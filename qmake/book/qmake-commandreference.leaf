\chapter qmake Command Reference

\section1 qmake Command Reference

\list
\i \link #About About This Reference \endlink
\i \link #Commands Command Line Options \endlink
\i \link #SystemVariables System Variables \endlink
\i \link #Functions Functions \endlink
\i \link #Properties Properties \endlink
\i \link #Environment Environment Variables and Configuration \endlink
\i \link #Extensions File Extensions \endlink
\i \link #Customizing Customizing Makefile Output \endlink
\endlist


\target About
\section1 About This Reference

This reference is a detailed index of all command line options,
configurations and internal variables used by the cross-platform
makefile generation utility \e qmake.

In addition to the variables and functions described in the following
sections, \e qmake project files may also include comments. 
Comments begin with the '#' symbol and run to the end of the line.

\target Commands
\section1 Command Line Options

\section2 Syntax

\code
qmake [options] files
\endcode

\section2 Options

The following options can be specified on the command line to \e qmake:

\list
\i \c -o file \BR
	\e qmake output will be directed to \e file. if this argument
	is not specified, then \e qmake will try to guess a suitable name.  If '-' is
	specified, output is directed to stdout. 
\i \c -unix \BR
	\e qmake will run in unix mode.  In this mode, Unix file
	naming and path conventions will be used, additionally testing for unix 
	(as a scope) will succeed. This is the default mode on all Unices. 
\i \c -macx \BR
	\e qmake will run in Mac OS X mode.  In this mode, Unix file
	naming and path conventions will be used, additionally testing for macx
	(as a scope) will succeed. This is the default mode on Mac OS X. 
\i \c -win32 \BR
	\e qmake will run in win32 mode.  In this mode, Windows file naming and path
	conventions will be used, additionally testing for win32 (as a scope) will succeed. 
	This is the default mode on Windows.
\i \c -d \BR
	\e qmake will output (hopefully) useful debugging information.
\i \c -t tmpl \BR
	\e qmake will override any set TEMPLATE variables with tmpl, but only
	\e after the .pro file has been processed.
\i \c -tp prefix \BR
	\e qmake will add the prefix to the TEMPLATE variable.
\i \c -help \BR
	\e qmake will go over these features and give some useful help.
\endlist

There are also warning options that can help to find problems in your
project file:

\list
\i \c -Wall \BR
      With this \e qmake will turn on all known warnings.
\i \c -Wnone \BR
      No warning information will be generated by \e qmake.
\i \c -Wparser \BR
      \e qmake will only generate parser warnings, this will alert
      you to common pitfalls, and potential problems in the parsing of your .pro
      files.
\i \c -Wlogic \BR
      Again \e qmake will warn of common pitfalls, and potential problems. This can
      include (but not limited to) checking if a file is placed into a list of files
      multiple times, if a file cannot be found, etc.
\endlist

\e qmake supports two different modes of operation. The first mode,
which is the default is makefile generation.  In this mode, \e qmake
will take a .pro file and turn it into a makefile.  Creating makefiles
is covered by this reference guide, there is another mode which
generates .pro files.

To toggle between these modes you must specify in the first argument
what mode you want to use.  If no mode is specified, \e qmake will
assume you want makefile mode.  The available modes are:

\list
\i \c -makefile \BR
	\e qmake output will be a makefile (\link #MakefileMode Makefile mode \endlink).
\i \c -project \BR
	\e qmake output will be a project file (\link #ProjectfileMode Project file mode \endlink).
\endlist

\target MakefileMode
\section3 Makefile Mode

In Makefile mode \e qmake will generate a makefile. Additionally you may
supply the following arguments in this mode:

\list
\i \c -after \BR
        \e qmake will process assignments given on the commandline after
        the specified files.
\i \c -nocache \BR
	\e qmake will ignore the .qmake.cache file.
\i \c -nodepend \BR
	\e qmake will not generate any dependency information.
\i \c -cache file \BR
	\e qmake will use \e file as the cache file, ignoring any other .qmake.cache file found
\i \c -spec spec \BR
	\e qmake will use \e spec as a path to platform-compiler information and QMAKESPEC will be ignored.
\endlist

The \c files argument can be a list of one or more project files, separated
by spaces. You may also pass qmake assignments on the command line here and
they will be processed before all files specified, for example:

qmake -makefile -unix -o Makefile "CONFIG+=test" test.pro 

If however you are certain you want your variables processed after the
the files specified, then you may pass the -after argument. When this
is specified all assignments on the commandline after the -after
option will be postponed until after the specified files are parsed.

This will generate a Makefile, from test.pro with Unix pathnames.  However
many of these arguments aren't necessary as they are the default.  Therefore
the line can be simplified on Unix to:

qmake "CONFIG+=test" test.pro 


\target ProjectfileMode
\section3 Projectfile Mode

In Projectfile mode \e qmake will generate a project file. Additionally, you may
supply the following arguments in this mode:

\list
\i \c -r \BR
        \e qmake will look through supplied directories recursively
\i \c -nopwd \BR
	\e qmake will not look in your current working directory for
	source code and only use the specified \c files
\endlist

The \c files argument can be a list of files or directories.  If a
directory is specified, then it will be included in the \link
#DEPENDPATH DEPENDPATH \endlink variable and relevant code from there
will be included in the generated project file, if a file is given it
will go into the correct variable depending on extension (i.e. .ui
files go into FORMS, .cpp files go into SOURCES, etc). Here too you
may pass assignments on the commandline, when doing so these
assignments will be placed last in the generated .pro file.

\target SystemVariables
\section1 System Variables

\list
\i \link #FrequentlyUsedSystemVariables Frequently Used System Variables \endlink
\i \link #RarelyUsedSystemVariables Rarely Used System Variables \endlink
\endlist


\target FrequentlyUsedSystemVariables
\section2 Frequently Used System Variables

The following variables are recognized by \e qmake and are used
most frequently when creating project files.


\target CONFIG
\section3 CONFIG

 The \c CONFIG variable specifies project configuration and
compiler options.  The values will be recognized internally by
\e qmake and have special meaning.  They are as follows.

These \c CONFIG values control compilation flags: 

\list
\i release - Compile with optimization enabled, ignored if
    "debug" is specified
\i debug - Compile with debug options enabled
\i warn_on - The compiler should emit more warnings than normally, ignored if
     "warn_off" is specified
\i warn_off - The compiler should only emit severe warnings.
\endlist

These options define the application/library type:

\list
\i qt - The target is a Qt application/library and requires the Qt header
     files/library.  The proper include and library paths for the Qt
     library will automatically be added to the project.
\i opengl - The target requires the OpenGL (or Mesa)
    headers/libraries. The proper include and library paths for
    these libraries will automatically be added to the project.
\i thread - The target is a multi-threaded application or library.  The
    proper defines and compiler flags will automatically be added to
    the project.
\i x11 - The target is a X11 application or library.  The proper
    include paths and libraries will automatically be added to the
    project.
\i windows - The target is a Win32 window application (app only). The
    proper include paths,compiler flags and libraries will
    automatically be added to the project.
\i console - The target is a Win32 console application (app only). The
    proper include paths, compiler flags and libraries will
    automatically be added to the
    project.
\i dll - The target is a shared object/DLL.The proper
    include paths, compiler flags and libraries will automatically be
    added to the project.
\i staticlib - The target is a static library (lib only).  The proper
    compiler flags will automatically be added to the project.
\i plugin - The target is a plugin (lib only). This enables dll as well.
\endlist

These options are used to set the compiler flags:

\list
\i exceptions - Exception support is enabled
\i rtti - RTTI support is enabled
\i stl - STL support is enabled
\endlist

These options define specific things depending on the platform and/or template:

\list
\i flat - When using the vcapp template this will put all the source files into the source group and 
	the header files into the header group regardless of what directory they reside in.  Turning this
	option off will group the files within the source/header group depending on the directory they 
	reside.  This is turned on by default.
\endlist

The \c CONFIG variable will also be checked when resolving
scopes.  You may assign anything to this variable.  

For example:

\code
CONFIG += qt console newstuff
...
newstuff {
	SOURCES += new.cpp
	HEADERS += new.h
}
\endcode


\target DEFINES
\section3 DEFINES

\e qmake adds the values of this variable as compiler C
preprocessor macros (-D option).  

For example:

\code 
DEFINES += USE_MY_STUFF QT_DLL
\endcode


\target DEF_FILE
\section3 DEF_FILE

\e {This is only used on Windows when using the 'app' template}.

Specifies a .def file to be included in the project.


\target DESTDIR
\section3 DESTDIR

Specifies where to put the \link #TARGET target \endlink file. 

For example:

\code 
  DESTDIR = ../../lib
\endcode

\target DLLDESTDIR
\section3 DLLDESTDIR

Specifies where to copy the \link #TARGET target \endlink dll.

\target HEADERS
\section3 HEADERS

Defines the header files for the project.  

\e qmake will generate dependency information (unless -nodepend
is specified on the \link #Commands command line \endlink) for the
specified headers.  \e qmake will also automatically detect if
\e moc is required by the classes in these headers, and add the
appropriate dependencies and files to the project for generating and
linking the moc files. 

For example:

\code
HEADERS	= myclass.h \
	  login.h \
	  mainwindow.h
\endcode

See also \link #SOURCES SOURCES \endlink.


\target INCLUDEPATH
\section3 INCLUDEPATH

This variable specifies the #include directories which should be
searched when compiling the project. Use ';' or a space as the
directory separator. 

For example:

\code
  INCLUDEPATH = c:\msdev\include d:\stl\include
\endcode


\target FORMS
\section3 FORMS

This variable specifies the .ui files (see \link
designer-manual.book Qt Designer \endlink) to be processed through \e uic
before compiling.  All dependencies, headers and source files required
to build these .ui files will automatically be added to the project.

For example:

\code
FORMS = mydialog.ui \
	mywidget.ui \
        myconfig.ui
\endcode

Note that forms should not be specified using the \c += operator because
this syntax is not fully supported by \QD.


\target LEXSOURCES
\section3 LEXSOURCES

This variable contains a list of lex source files.  All
dependencies, headers and source files will automatically be added to
the project for building these lex files.  

For example:

\code
LEXSOURCES = lexer.l
\endcode
 

\target LIBS
\section3 LIBS

This variable contains a list of libraries to be linked into the project.
If you are more comfortable with the Unix convension of -L/-l flags you are
free to use them in a cross-platform manner and qmake will do the correct
thing with these libraries on Windows (namely this means passing the full
path of the library to the linker). The only limitation to this is the
library must exist, for qmake to find which directory a -l lib lives in.

For example:

\code
unix:LIBS += -lmath -L/usr/local/lib
win32:LIBS += c:\mylibs\math.lib
\endcode


\target MOC_DIR
\section3 MOC_DIR

This variable specifies the directory where all intermediate moc
files should be placed.  

For example:

\code
unix:MOC_DIR = ../myproject/tmp
win32:MOC_DIR = c:\myproject\tmp
\endcode


\target OBJECTS_DIR
\section3 OBJECTS_DIR

This variable specifies the directory where all intermediate
objects should be placed.  

For example:

\code
unix:OBJECTS_DIR = ../myproject/tmp
win32:OBJECTS__DIR = c:\myproject\tmp
\endcode


\target UI_DIR
\section3 UI_DIR

This variable specifies the directory where all intermediate files from uic
should be placed. This variable overrides both UI_SOURCES_DIR and
UI_HEADERS_DIR.

For example:

\code
unix:UI_DIR = ../myproject/ui
win32:UI_DIR = c:\myproject\ui
\endcode

\target UI_HEADERS_DIR
\section3 UI_HEADERS_DIR

This variable specifies the directory where all declaration files (as
generated by uic) should be placed.

For example:

\code
unix:UI_HEADERS_DIR = ../myproject/ui/include
win32:UI_HEADERS_DIR = c:\myproject\ui\include
\endcode

\target UI_SOURCES_DIR
\section3 UI_SOURCES_DIR

This variable specifies the directory where all implementation files (as generated
by uic) should be placed.

For example:

\code
unix:UI_SOURCES_DIR = ../myproject/ui/src
win32:UI_SOURCES_DIR = c:\myproject\ui\src
\endcode


\target REQUIRES
\section3 REQUIRES

This is a special variable processed by \e qmake.  If the
contents of this variable do not appear in CONFIG by the time this
variable is assigned, then a minimal makefile will be generated that
states what dependencies (the values assigned to REQUIRES) are
missing.

This is mainly used in Qt's build system for building the examples.

\target SOURCES
\section3 SOURCES

This variable contains the name of all source files in the project.  

For example:

\code
SOURCES	= myclass.cpp \
	  login.cpp \
	  mainwindow.cpp

\endcode

See also \link #HEADERS HEADERS \endlink


\section3 SUBDIRS

This variable, when used with the 'subdirs'
\link #TEMPLATE TEMPLATE \endlink contains the names of all subdirectories
to look for a project file.

For example:

\code
SUBDIRS = kernel \
	  tools
\endcode


\target TARGET
\section3 TARGET

This specifies the name of the target file.

For example:

\code
TEMPLATE = app
TARGET = myapp
SOURCES = main.cpp
\endcode

The project file above would produce an executable named 'myapp' on
unix and 'myapp.exe' on windows.



\target TEMPLATE
\section3 TEMPLATE

This variable contains the name of the template to use when
generating the project.  The allowed values are:

\list
\i app - Creates a makefile for building applications (the default)
\i lib - Creates a makefile for building libraries
\i subdirs - Creates a makefile for building targets in subdirectories
\i vcapp - \e {win32 only}  Creates an application project file for
Visual Studio
\i vclib - \e {win32 only}  Creates a library project file for Visual
Studio

\endlist

For example:

\code
TEMPLATE = lib
SOURCES = main.cpp
TARGET = mylib
\endcode

The template can be overridden by specifying a new template type with the
\c -t command line option. This overrides the template type \e after the .pro
file has been processed. With .pro files that use the template type to
determine how the project is built, it is necessary to declare TEMPLATE on
the command line rather than use the \c -t option.



\section3 VERSION

This variable contains the version number of the library if the
'lib' \link #TEMPLATE TEMPLATE \endlink is specified.

For example:

\code
VERSION = 1.2.3
\endcode

\section3 DISTFILES

This variable contains a list of files to be included in the dist
target. This feature is supported by UnixMake specs only.

For example:

\code
DISTFILES += ../program.txt
\endcode


\target YACCSOURCES
\section3 YACCSOURCES

This variable contains a list of yacc source files to be included
in the project.  All dependencies, headers and source files will
automatically be included in the project.

For example:

\code
YACCSOURCES = moc.y
\endcode



\target RarelyUsedSystemVariables
\section2 Rarely Used System Variables

The following variables are also recognized by \e qmake but are
either internal or very rarely used.



\target DESTDIR_TARGET
\section3 DESTDIR_TARGET

This variable is set internally by \e qmake, which is basically the DESTDIR variable with
the TARGET variable appened at the end.  The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.


\target DSP_TEMPLATE
\section3 DSP_TEMPLATE

This variable is set internally by \e qmake, which specifies where the dsp template file for
basing generated dsp files is stored.  The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.


\target LEXIMPLS
\section3 LEXIMPLS

This variable contains a list of lex implementation files.  The value
of this variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely
needs to be modified.



\target LEXOBJECTS
\section3 LEXOBJECTS

This variable contains the names of intermediate lex object
files.The value of this variable is typically handled by
\e qmake and rarely needs to be modified.


\target LITERAL_HASH
\section3 LITERAL_HASH

This variable is used whenever a literal hash character (\c{#}) is needed in
a variable declaration, perhaps as part of a file name or in a string passed
to some external application.

For example:

\code
# To include a literal hash character, use the $$LITERAL_HASH variable:
urlPieces = http://doc.trolltech.com/3.3/qmake-manual-8.html LITERAL_HASH
message($$join(urlPieces, $$LITERAL_HASH))
\endcode

By using \c LITERAL_HASH in this way, the \c # character can be used
to construct a URL for the \c message() function to print to the console.


\target MAKEFILE
\section3 MAKEFILE

This variable specifies the name of the makefile which
\e qmake should use when outputting the dependency information
for building a project.  The value of this variable is typically
handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\target MAKEFILE_GENERATOR
\section3 MAKEFILE_GENERATOR

This variable contains the name of the makefile generator to use
when generating a makefile.  The value of this variable is typically
handled internally by \e qmake and rarely needs to be modified.


\target OBJECTS
\section3 OBJECTS

This variable is generated from the \link #SOURCES SOURCES
\endlink variable.  The extension of each source file will have been 
replaced by .o (Unix) or .obj (Win32).  The value of this variable is 
typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and
rarely needs to be modified.

\target OBJMOC
\section3 OBJMOC

This variable is set by \e qmake if files can be found that
contain the Q_OBJECT macro.  \c OBJMOC contains the
name of all intermediate moc object files. The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.

\target PRECOMPILED_HEADER
\section3 PRECOMPILED_HEADER

This variable indicates the header file for creating a precompiled
header file, to increase the compilation speed of a project.
Precompiled headers are currently only supported on some platforms
(Windows - all MSVC project types, Mac OS X - Xcode, Makefile,
UNIX - gcc 3.3 and up).

On other platforms, this variable has different meaning, as noted
below.

This variable contains a list of header files that require some
sort of pre-compilation step (such as with moc). The value of this
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.  

\target QMAKE
\section3 QMAKE

This variable contains the name of the \e qmake program
itself and is placed in generated makefiles.  The value of this
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.



\target QMAKESPEC_systemvariable
\section3 QMAKESPEC

This variable contains the name of the \e qmake
configuration to use when generating makefiles.  The value of this
variable is typically handled by \e qmake and rarely needs to be modified.
Use the \link #QMAKESPEC QMAKESPEC \endlink environment variable instead.




\target QMAKE_APP_FLAG
\section3 QMAKE_APP_FLAG

This variable is empty unless the 'app'
\link #TEMPLATE TEMPLATE \endlink is specified.  The value of this
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.  Use the following instead:

\code
app {
	#conditional code for 'app' template here
}
\endcode




\target QMAKE_APP_OR_DLL
\section3 QMAKE_APP_OR_DLL

This variable is empty unless the 'app' or 'dll'
\link #TEMPLATE TEMPLATE \endlink is specified.  The value of this
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.  



\target QMAKE_AR_CMD
\section3 QMAKE_AR_CMD

\e {This is used on Unix platforms only}

This variable contains the command for invoking the program which
creates, modifies and extracts archives. The value of this variable is
typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink 
and rarely needs to be modified.



\target QMAKE_CFLAGS_DEBUG
\section3 QMAKE_CFLAGS_DEBUG

This variable contains the flags for the C compiler in debug mode.The value of this variable is
typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink 
and rarely needs to be modified.




\target QMAKE_CFLAGS_MT
\section3 QMAKE_CFLAGS_MT

This variable contains the compiler flags for creating a
multi-threaded application or when the version of Qt that you link
against is a multi-threaded statically linked library.  The value of 
this variable is typically handled by \e qmake or 
\link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_CFLAGS_MT_DBG
\section3 QMAKE_CFLAGS_MT_DBG

This variable contains the compiler flags for creating a debuggable
multi-threaded application or when the version of Qt that you link
against is a debuggable multi-threaded statically linked library.  The 
value of this variable is typically handled by \e qmake or 
\link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_CFLAGS_MT_DLL
\section3 QMAKE_CFLAGS_MT_DLL

\e {This is used on Windows only}

This variable contains the compiler flags for creating a 
multi-threaded dll or when the version of Qt that you link
against is a multi-threaded dll.  The value of this variable is typically
handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and
rarely needs to be modified.




\target QMAKE_CFLAGS_MT_DLLDBG
\section3 QMAKE_CFLAGS_MT_DLLDBG

\e {This is used on Windows only}

This variable contains the compiler flags for creating a debuggable
multi-threaded dll or when the version of Qt that you link
against is a debuggable multi-threaded statically linked library. 
The value of this variable is typically handled by \e qmake or 
\link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_CFLAGS_RELEASE
\section3 QMAKE_CFLAGS_RELEASE

This variable contains the compiler flags for creating a non-debuggable
application.  The value of this variable is typically
handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and
rarely needs to be modified.




\target QMAKE_CFLAGS_SHLIB
\section3 QMAKE_CFLAGS_SHLIB

\e {This is used on Unix platforms only}

This variable contains the compiler flags for creating a shared
library. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CFLAGS_THREAD
\section3 QMAKE_CFLAGS_THREAD

This variable contains the compiler flags for creating a multi-threaded
application. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CFLAGS_WARN_OFF
\section3 QMAKE_CFLAGS_WARN_OFF

This variable is not empty if the warn_off
\link #TEMPLATE TEMPLATE \endlink option is specified.  The value of this 
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink 
and rarely needs to be modified.



\target QMAKE_CFLAGS_WARN_ON
\section3 QMAKE_CFLAGS_WARN_ON

This variable is not empty if the warn_on
\link #TEMPLATE TEMPLATE \endlink option is specified.
The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CLEAN
\section3 QMAKE_CLEAN

This variable contains any files which are not generated files (such as moc and uic 
generated files) and object files that should be removed when using "make clean".



\target QMAKE_CXXFLAGS_DEBUG
\section3 QMAKE_CXXFLAGS_DEBUG

This variable contains the C++ compiler flags for creating a debuggable
application. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.



\target QMAKE_CXXFLAGS_MT
\section3 QMAKE_CXXFLAGS_MT

This variable contains the C++ compiler flags for creating a multi-threaded
application. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_MT_DBG
\section3 QMAKE_CXXFLAGS_MT_DBG

This variable contains the C++ compiler flags for creating a debuggable multi-threaded
application. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_MT_DLL
\section3 QMAKE_CXXFLAGS_MT_DLL

\c {This is used on Windows only}

This variable contains the C++ compiler flags for creating a multi-threaded
dll. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_MT_DLLDBG
\section3 QMAKE_CXXFLAGS_MT_DLLDBG

\c {This is used on Windows only}

This variable contains the C++ compiler flags for creating a multi-threaded debuggable
dll. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_RELEASE
\section3 QMAKE_CXXFLAGS_RELEASE

This variable contains the C++ compiler flags for creating an 
application. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_SHLIB
\section3 QMAKE_CXXFLAGS_SHLIB

This variable contains the C++ compiler flags for creating a
shared library.  The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_THREAD
\section3 QMAKE_CXXFLAGS_THREAD

This variable contains the C++ compiler flags for creating a
multi-threaded application.  The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs
to be modified.




\target QMAKE_CXXFLAGS_WARN_OFF
\section3 QMAKE_CXXFLAGS_WARN_OFF

This variable contains the C++ compiler flags for suppressing compiler warnings.
 The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\target QMAKE_CXXFLAGS_WARN_ON
\section3 QMAKE_CXXFLAGS_WARN_ON

This variable contains C++ compiler flags for generating compiler warnings.
 The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_EXTENSION_SHLIB
\section3 QMAKE_EXTENSION_SHLIB

This variable contains the extention for shared libraries.  The value of this 
variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink 
and rarely needs to be modified.




\target QMAKE_FAILED_REQUIREMENTS
\section3 QMAKE_FAILED_REQUIREMENTS

This variable contains the list of requirements that were failed to be met when
\e qmake was used.  For example, the sql module is needed and wasn't compiled into Qt.  The 
value of this variable is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink 
and rarely needs to be modified.




\target QMAKE_FILETAGS
\section3 QMAKE_FILETAGS

This variable contains the file tags needed to be entered into the makefile, such as SOURCES
and HEADERS.  The value of this variable is typically handled by \e qmake or 
\link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_INCDIR
\section3 QMAKE_INCDIR

This variable contains the location of all known header files to be added to 
INCLUDEPATH when building an application.  The value of this variable is 
typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely 
needs to be modified.


\target POST_TARGETDEPS
\section3 POST_TARGETDEPS

All libraries that the \link #TARGET target \endlink depends on can be
listed in this variable. Some backends do not support this, these include
MSVC Dsp, and ProjectBuilder .pbproj files. Generally this is support
internally by these build tools, this is usefull for explicitly listing
dependant static libraries.

This list will go after all builtin (and \link #PRE_TARGETDEPS
$$PRE_TARGETDEPS \endlink) dependencies.


\target PRE_TARGETDEPS
\section3 PRE_TARGETDEPS

All libraries that the \link #TARGET target \endlink depends on can be
listed in this variable. Some backends do not support this, these include
MSVC Dsp, and ProjectBuilder .pbproj files. Generally this is support
internally by these build tools, this is usefull for explicitly listing
dependant static libraries.

This list will go before all builtin dependencies.


\target QMAKE_INCDIR_OPENGL
\section3 QMAKE_INCDIR_OPENGL

This variable contains the location of OpenGL header files to be added
to INCLUDEPATH when building an application with OpenGL support. The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\target QMAKE_INCDIR_QT
\section3 QMAKE_INCDIR_QT

This variable contains the location of all known header file
paths to be added to INCLUDEPATH when building a Qt application. The value 
of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_INCDIR_THREAD
\section3 QMAKE_INCDIR_THREAD

This variable contains the location of all known header file
paths to be added to INCLUDEPATH when building a multi-threaded application. 
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\target QMAKE_INCDIR_X11
\section3 QMAKE_INCDIR_X11

\e {This is used on Unix platforms only}

This variable contains the location of X11 header file paths to be
added to INCLUDEPATH when building a X11 application.  The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\target QMAKE_LFLAGS_CONSOLE
\section3 QMAKE_LFLAGS_CONSOLE

\e {This is used on Windows only}

This variable contains link flags when building console
programs.  The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_LFLAGS_CONSOLE_DLL

\e {This is used on Windows only}

This variable contains link flags when building console
dlls.  The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_DEBUG

This variable contains link flags when building debuggable applications.  The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_PLUGIN

This variable contains link flags when building plugins. The value
of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_QT_DLL

This variable contains link flags when building programs that
use the Qt library built as a dll. The value of this variable is
typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_RELEASE

This variable contains link flags when building applications for 
release. The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_SHAPP

This variable contains link flags when building applications which are using
the 'app' template.  The value of this variable is typically handled by
\e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_SHLIB

This variable contains link flags when building shared libraries
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_SONAME

This variable specifies the link flags to set the name of shared objects,
such as .so or .dll.  The value of this variable is typically handled by \e
qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\section3 QMAKE_LFLAGS_THREAD

This variable contains link flags when building multi-threaded projects.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LFLAGS_WINDOWS

\e {This is used on Windows only}

This variable contains link flags when building windows projects.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_LFLAGS_WINDOWS_DLL

\e {This is used on Windows only}

This variable contains link flags when building windows dll projects.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_LIBDIR

This variable contains the location of all known library
directories.The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBDIR_FLAGS

\e {This is used on Unix platforms only}

This variable contains the location of all library
directory with -L prefixed.  The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\section3 VPATH

This variable tells \e qmake where to search for files it cannot
open. With this you may tell \e qmake where it may look for things
like SOURCES, and if it finds an entry in SOURCES that cannot be
opened it will look through the entire VPATH list to see if it can
find the file on its own.

See also \link #DEPENDPATH DEPENDPATH \endlink.

\target DEPENDPATH
\section3 DEPENDPATH

This variable contains the list of all directories to look in to
resolve dependencies. This will be used when crawling through
'included' files.


\section3 QMAKE_LIBDIR_OPENGL

This variable contains the location of the OpenGL library
directory.The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBDIR_QT

This variable contains the location of the Qt library
directory.The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBDIR_X11

\e {This is used on Unix platforms only}

This variable contains the location of the X11 library
directory.The value of this variable is typically handled by
\e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.

\section3 QMAKE_LIBS

This variable contains all project libraries.  The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_LIBS_CONSOLE

\e {This is used on Windows only}

This variable contains all project libraries that should be linked against
when building a console application.  The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\section3 QMAKE_LIBS_OPENGL

This variable contains all OpenGL libraries.  The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_OPENGL_QT

This variable contains all OpenGL Qt libraries.The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_QT

This variable contains all Qt libraries.The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_QT_DLL

\e {This is used on Windows only}

This variable contains all Qt libraries when Qt is built as a dll.  The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_QT_OPENGL

This variable contains all the libraries needed to link against if 
OpenGL support is turned on. The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\section3 QMAKE_LIBS_QT_THREAD

This variable contains all the libraries needed to link against if 
thread support is turned on.  The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_RT

\e {This is used with Borland compilers only}

This variable contains the runtime library needed to link against when
building an application.  The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_RTMT

\e {This is used with Borland compilers only}

This variable contains the runtime library needed to link against when
building a multi-threaded application.  The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\section3 QMAKE_LIBS_THREAD

\e {This is used on Unix platforms only}

This variable contains all libraries that need to be linked against
when building a multi-threaded application.  The 
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_WINDOWS

\e {This is used on Windows only}

This variable contains all windows libraries.The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_X11

\e {This is used on Unix platforms only}

This variable contains all X11 libraries.The value of this
variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIBS_X11SM

\e {This is used on Unix platforms only}

This variable contains all X11 session management libraries.  The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_LIB_FLAG

This variable is not empty if the 'lib' template is specified.  The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\section3 QMAKE_LINK_SHLIB_CMD

This variable contains the command to execute when creating a
shared library. The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_POST_LINK

This variable contains the command to execute after linking the TARGET
together. This variable is normally empty and therefore nothing is
executed, additionally some backends will not support this - mostly only
Makefile backends.



\section3 QMAKE_PRE_LINK

This variable contains the command to execute before linking the TARGET
together. This variable is normally empty and therefore nothing is
executed, additionally some backends will not support this - mostly only
Makefile backends.



\section3 QMAKE_LN_SHLIB

This variable contains the command to execute when creating a link
to a shared library. The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_MAKEFILE

This variable contains the name of the makefile to create. The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.






\section3 QMAKE_MOC_SRC

This variable contains the names of all moc source files to
generate and include in the project. The value of this variable is
typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_QMAKE

This variable contains the location of qmake if it is not in the path.  
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 QMAKE_QT_DLL

This variable is not empty if Qt was built as a dll.  The
value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.

\section3 QMAKE_RUN_CC

This variable specifies the individual rule needed to build an object.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.

\section3 QMAKE_RUN_CC_IMP

This variable specifies the individual rule needed to build an object.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\section3 QMAKE_RUN_CXX

This variable specifies the individual rule needed to build an object.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\section3 QMAKE_RUN_CXX_IMP

This variable specifies the individual rule needed to build an object.
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.



\section3 QMAKE_TARGET

This variable contains the name of the project target.  The value of
this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 QMAKE_UIC

This variable contains the location of uic if it is not in the path.  
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.

It can be used to specify arguments to uic as well, such as additional plugin 
paths.  For example:

\code
	QMAKE_UIC = uic -L /path/to/plugin
\endcode



\section3 RC_FILE

This variable contains the name of the resource file for the application.  
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.





\section3 RES_FILE

This variable contains the name of the resource file for the application.  
The value of this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\section3 SRCMOC

This variable is set by \e qmake if files can be found that
contain the Q_OBJECT macro.  \c SRCMOC contains the
name of all the generated moc files. The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.

\section3 TARGET_EXT

This variable specifies the target's extension.  The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.



\section3 TARGET_x

This variable specifies the target's extension with a major version number.  The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.


\section3 TARGET_x.y.z

This variable specifies the target's extension with version number.  The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.


\section3 UICIMPLS

This variable contains a list of the generated implementation files by UIC.  
The value of this variable
is typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and rarely needs to be
modified.





\section3 UICOBJECTS

This variable is generated from the UICIMPLS variable.  The extension of each 
file will have been replaced by .o (Unix) or .obj (Win32).  The value of this variable is 
typically handled by \e qmake or \link #QMAKESPEC qmake.conf \endlink and
rarely needs to be modified.



\section3 VER_MAJ

This variable contains the major version number of the library, if the
'lib' \link #TEMPLATE template \endlink is specified.





\section3 VER_MIN

This variable contains the minor version number of the library, if the
'lib' \link #TEMPLATE template \endlink is specified.





\section3 VER_PAT

This variable contains the patch version number of the library, if the
'lib' \link #TEMPLATE template \endlink is specified.



\section3 QMAKE_EXT_MOC

This variable changes the extention used on included moc files. 

See also \link #Extensions File Extensions \endlink.



\section3 QMAKE_EXT_UI

This variable changes the extention used on /e Designer UI files. 

See also \link #Extensions File Extensions \endlink.



\section3 QMAKE_EXT_PRL

This variable changes the extention used on created PRL files. 

See also \link #Extensions File Extensions \endlink, 
         \link #LibDepend Library Dependencies \endlink.



\section3 QMAKE_EXT_LEX

This variable changes the extention used on files given to lex.

See also \link #Extensions File Extensions \endlink,
         \link #LEXSOURCES LEXSOURCES \endlink.



\section3 QMAKE_EXT_YACC
This variable changes the extention used on files given to yacc.

See also \link #Extensions File Extensions \endlink,
         \link #LEXSOURCES YACCSOURCES \endlink.



\section3 QMAKE_EXT_OBJ

This variable changes the extention used on generated object files. 

See also \link #Extensions File Extensions \endlink.


\section3 QMAKE_EXT_CPP

This variable changes the interpretation of all suffixes in this
list of values as files of type C++ source code.

See also \link #Extensions File Extensions \endlink.


\section3 QMAKE_EXT_H

This variable changes the interpretation of all suffixes in this
list of values as files of type C header files.

See also \link #Extensions File Extensions \endlink.


\section3 YACCIMPLS

This variable contains a list of yacc source files. The value of
this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.




\section3 YACCOBJECTS

This variable contains a list of yacc object files. The value of
this variable is typically handled by \e qmake or
 \link #QMAKESPEC qmake.conf \endlink and rarely needs to be modified.


\target Functions
\section1 Functions

\e qmake recognizes the following functions:



\section2 include( filename )

This function will include the contents of \e filename into the
current project at the point where was included.  The function succeeds
if \e filename was included, otherwise it fails. You can check the
return value of this function using a
scope.

For example:

\code
include( shared.pri )
OPTIONS = standard custom
!include( options.pri ) {
	message( "No custom build options specified" )
	OPTIONS -= custom
}
\endcode

\section2 exists( file )

This function will test if \e file exists.  If the file exists, then it will succeed; otherwise it will
fail. 
You can specify a regular expression in file and it will succeed if any file
matches the regular expression specified.

For example:
\code
exists( $(QTDIR)/lib/libqt-mt* ) {
      message( "Configuring for multi-threaded Qt..." )
      CONFIG += thread
}
\endcode

\section2 contains( variablename, value )

This function will succeed if the variable \e variablename
contains the value \e value.  You can check the return value of this
function using a scope.

For example:

\code
contains( drivers, network ) {
	# drivers contains 'network'
	message( "Configuring for network build..." )
	HEADERS += network.h
	SOURCES += network.cpp
}
\endcode

\section2 count( variablename, number )

This function will succeed if the variable \e variablename
contains \e number elements, otherwise it will fail.  You can check
the return value of this function using a
scope.

For example:

\code
MYVAR = one two three
count( MYVAR, 3 ) {
	# always true
}
\endcode

\section2 infile( filename, var, val )

This function will succeed if the file \e filename (when parsed
by qmake itself) contains the variable \e var with a value of 
\e val. You may also not pass in a third argument (\e val) and the
function will only test if \e var has been assigned to in the file.

\section2 isEmpty( variablename )

This function will succeed if the variable \e variablename is
empty (same as \c count(variable, 0)).

\section2 system( command )

This function will execute \c command in a secondary shell and will
succeed if the command exits with an exit status of 1.  You can check the
return value of this function using a scope.

For example:

\code
  system(ls /bin):HAS_BIN=FALSE
\endcode

\section2 message( string )

This function will always succeed, and will display the given
\e string to the user.

\section2 error( string )

This function will never return a value.  It will display the given \e
string to the user, and then exit \e qmake. This function should
only be used for very fatal configurations.

For example:

\code
  release:debug:error(You can't have release and debug at the same time!)
\endcode

\target Properties
\section1 Properties

\e qmake has a system of persistant information, this allows you to
'set' a variable in qmake once, and each time qmake is invoked this
value can be queried. Use the following to set a property in qmake:

\code
qmake -set VARIABLE VALUE
\endcode

To retrieve this information back from qmake you can do:

\code
qmake -query VARIABLE
qmake -query #queries all current VARIABLE/VALUE pairs..
\endcode

This information will be saved into a QSettings object (meaning it
will be stored in different places for different platforms). As
VARIABLE is versioned as well, you can set one value in an older
version of qmake, and newer versions will retrieve this value, however
if you -set VARIABLE into a newer version of qmake the older version
will not use this value. You can however query a specific version of a
variable if you prefix that version of qmake to VARIABLE, as in:

\code
qmake -query "1.06a/VARIABLE"
\endcode

qmake also has the notion of 'builtin' properties, for example you can
query the installation of Qt for this version of qmake with the
QT_INSTALL_PREFIX property:

\code
qmake -query "QT_INSTALL_PREFIX"
\endcode

These builtin properties cannot have a version prefixed to them as
they are not versioned and each qmake will have its own notion of
these values. The list below outlines the builtin properties:

\list
\i QT_INSTALL_PREFIX - Where the version of Qt this qmake is built for resides
\i QT_INSTALL_DATA - Where data for this version of Qt resides
\i QMAKE_VERSION - The current version of qmake
\endlist

Finally, these values can be queried in a project file with a special
notation such as:

\code
QMAKE_VERS = $$[QMAKE_VERSION]
\endcode

\target Environment
\section1 Environment Variables and Configuration

\target QMAKESPEC
\section2 QMAKESPEC

\e qmake requires a platform and compiler description file which
contains many default values used to generate appropriate makefiles.
The standard Qt distribution comes with many of these files, located
in the 'mkspecs' subdirectory of the Qt installation.

The QMAKESPEC environment variable can contain any of the following:

\list
\i A complete path to a directory containing a qmake.conf file.  In this case \e qmake will open the qmake.conf file from within that directory.  If the file does not exist, \e qmake will exit with an error.
\i The name of a platform-compiler combination.  In this case, \e qmake will search in the directory specified by the QTDIR environment variable.
\endlist

Note: the QMAKESPEC path will automatically be added to the
\link #INCLUDEPATH INCLUDEPATH \endlink system variable.

\target INSTALLS
\section2 INSTALLS

It is common on UNIX to be able to install from the same utility as
you build with (e.g make install). For this \e qmake has introduce the
concept of an install set. The notation for this is quite simple,
first you fill in an "object" in qmake for example:

\code
  documentation.path = /usr/local/program/doc
  documentation.files = docs/*
\endcode

In this way you are telling \e qmake several things about this
install, first that you plan to install to /usr/local/program/doc (the
path member), second that you plan to copy everything in the docs
directory. Once this is done you may insert it in the install list:

\code
  INSTALLS += documentation
\endcode

Now \e qmake will take over making sure the correct things are copied
to the specified places. If however you require greater control you
may use the 'extra' member of the object:

\code
  unix:documentation.extra = create_docs; mv master.doc toc.doc
\endcode

Then qmake will run the things in extra (this is of course platform
specific, so you may need to test for your platform first, this case
we test for unix). Then it will do the normal processings of the files
member. Finally if you appened a builtin install to INSTALLS \e qmake
(and do not specify a files or extra member) will decide what needs to
be copied for you, currently the only supported builtin is target:

\code
  target.path = /usr/local/myprogram
  INSTALLS += target
\endcode

With this \e qmake will know what you plan need copied, and do this
for you.

\target cache
\section2 Cache File

The cache file (mentioned above in the options) is a special file \e qmake
will read to find settings not specified in the \c qmake.conf file, the
.pro file, or the command line. If \c -nocache is not specified, \e qmake
will try to find a file called \c .qmake.cache in parent directories.  If
it fails to find this file, it will silently ignore this step of
processing.

\target LibDepend
\section2 Library Dependencies

Often when linking against a library \e qmake relies on the underlying
platform to know what other libraries this library links against, and
lets the platform pull them in. In many cases, however, this is not
sufficent. For example when statically linking a library there are no
libraries linked against, and therefore no dependencies to those
libraries are created - however an application that later links
against this library will need to know where to find the symbols that
the linked in library will require. To help with this situation \e
qmake will follow a library's dependencies when it feels appropriate,
however this behaviour must be enabled in \e qmake. To enable requires
two steps. First, you must enable it in the library - to do this you
must tell \e qmake to save information about this library:

\code
  CONFIG += create_prl
\endcode

This is only relevant to the lib template, and will be ignored for all
others. When this option is enabled \e qmake will create a file
(called a .prl file) which will save some meta information about the
library. This metafile is itself just a qmake project file, but with
all internal variables. You are free to view this file, and if deleted
\e qmake will know to recreate it when necesary (either when the .pro
file is later read, or if a dependent library (described below) has
changed). When installing this library (by using target in INSTALLS,
above) \e qmake will automatically copy the .prl file to your install
path.

The second step to enabling this processing is to turn on reading of
the meta information created above:

\code
  CONFIG += link_prl
\endcode

When this is turned on \e qmake will process all libraries linked to,
and find their meta information. With this meta information \e qmake
will figure out what is relevant to linking, specifically it will add
to your list of DEFINES as well as LIBS. Once \e qmake has processed
this file, it will then look through the newly introduced LIBS and
find their dependent .prl files, and continue until all libraries have
been resolved. At this point the makefile is created as usual, and the
libraries are linked explicity against your program.

The internals of the .prl file are left closed so they can easily
change later. It is not designed to be changed by hand however, and
should only be created by \e qmake - these .prl files should also not
be transfered from operating system to operating system as they may be
platform dependent (like a makefile).

\target Extensions
\section2 File Extensions

Under normal circumstances \e qmake will try to use appropriate file extensions
for your platform. There may be times, however, that you would like to override
the behavior of these extensions. To do this, you must modify builtin variables 
in your .pro file, which will in turn changes \e qmake's interpretation of these
files. You may do this as:

\code
  QMAKE_EXT_MOC = .mymoc
\endcode

The variables are as follows:

\list
\i QMAKE_EXT_MOC - This modifies the extension placed on included moc files.
\i QMAKE_EXT_UI - This modifies the extension used for designer UI files (usually in FORMS).
\i QMAKE_EXT_PRL - This modifies the extension placed on 
                   \link #LibDepend library dependency files \endlink.
\i QMAKE_EXT_LEX - This changes the suffix used in files (usually in LEXSOURCES).
\i QMAKE_EXT_YACC - This changes the suffix used in files (usually in YACCSOURCES).
\i QMAKE_EXT_OBJ - This changes the suffix used on generated object files.
\endlist

All the above accept just the first value, so you must assign to it one value that
will be used through your makefile. There are two variables that accept a list of values, 
they are:

\list
\i QMAKE_EXT_CPP - Changes interpretation all files with these suffixes to be
                   C++ source files. 
\i QMAKE_EXT_H - Changes interpretation all files with these suffixes to be
                   C header files. 
\endlist


\target Customizing
\section2 Customizing Makefile Output

qmake often tries to be all things to all build tools, this is often less
than ideal when you really need to run special platform dependent
commands. This can be achieved with specific instructions to the different
qmake backends (currently this is only supported by the UNIX \link
#MAKEFILE_GENERATOR generator \endlink). 

The interfaces to customizing the Makefile are done through "objects" as in
other places in qmake. The notation for this is quite simple, first you
fill in an "object" in qmake for example:

\code
  mytarget.target = .buildfile
  mytarget.commands = touch $$mytarget.target
  mytarget.depends = mytarget2

  mytarget2.commands = @echo Building $$mytarget.target
\endcode

The information above defines a qmake target called mytarget which contains
a Makefile target called .buildfile, .buildfile is generated by 'touch
.buildfile', and finally that this Makefile target depends on the qmake
target mytarget2. Additionally we've defined the qmake target mytarget2
which simply echo's something to stdout.

The final step to making use of the above is to instruct qmake that this is
actually an object used by the target building parts of qmake by:

\code
QMAKE_EXTRA_UNIX_TARGETS += mytarget mytarget2
\endcode

This is all you need to do to actually build custom targets in qmake, of
course you may want to tie one of these targets to actually building the
\link #TARGET qmake build target \endlink. To do this, you simply need to
include your Makefile target in the list of \link #PRE_TARGETDEPS PRE_TARGETDEPS
\endlink.

For convenience there is also a method of customizing (UNIX) projects
for generic new compilers (or even preprocessors).

\code
new_moc.output  = moc_${QMAKE_FILE_BASE}.cpp
new_moc.commands = moc ${QMAKE_FILE_NAME} -o ${QMAKE_FILE_OUT}
new_moc.depends = g++ -E -M ${QMAKE_FILE_NAME} | sed "s,^.*: ,,"
new_moc.input = NEW_HEADERS
QMAKE_EXTRA_UNIX_COMPILERS += new_moc
\endcode

With this you can create a new moc for qmake, the commands will be
executed over all arguments given to a NEW_HEADERS variable (from the
input variable), and write to output (and automatically hand this
filename to the compiler to be linked into your target). Additionally
qmake will execute depends to generate dependency information and
place this in the project as well.

These commands can easily be placed into a cache file, and subsequent
.pro files can give several arguments to NEW_HEADERS.
