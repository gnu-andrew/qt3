<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/opengl/qgl.cpp:95 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QGLFormat Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QGLFormat Class Reference<br><small>[<a href="opengl.html">OpenGL module</a>]</small></h1>

<p>The QGLFormat class specifies the display format of an OpenGL
rendering context.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qgl-h.html">qgl.h</a>&gt;</tt>
<p>Inherits <a href="qgl.html">QGL</a>.
<p><a href="qglformat-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QGLFormat"><b>QGLFormat</b></a> ()</li>
<li class=fn><a href="#QGLFormat-2"><b>QGLFormat</b></a> ( int&nbsp;options, int&nbsp;plane = 0 )</li>
<li class=fn>bool <a href="#doubleBuffer"><b>doubleBuffer</b></a> () const</li>
<li class=fn>void <a href="#setDoubleBuffer"><b>setDoubleBuffer</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#depth"><b>depth</b></a> () const</li>
<li class=fn>void <a href="#setDepth"><b>setDepth</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#rgba"><b>rgba</b></a> () const</li>
<li class=fn>void <a href="#setRgba"><b>setRgba</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#alpha"><b>alpha</b></a> () const</li>
<li class=fn>void <a href="#setAlpha"><b>setAlpha</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#accum"><b>accum</b></a> () const</li>
<li class=fn>void <a href="#setAccum"><b>setAccum</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#stencil"><b>stencil</b></a> () const</li>
<li class=fn>void <a href="#setStencil"><b>setStencil</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#stereo"><b>stereo</b></a> () const</li>
<li class=fn>void <a href="#setStereo"><b>setStereo</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#directRendering"><b>directRendering</b></a> () const</li>
<li class=fn>void <a href="#setDirectRendering"><b>setDirectRendering</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#hasOverlay"><b>hasOverlay</b></a> () const</li>
<li class=fn>void <a href="#setOverlay"><b>setOverlay</b></a> ( bool&nbsp;enable )</li>
<li class=fn>int <a href="#plane"><b>plane</b></a> () const</li>
<li class=fn>void <a href="#setPlane"><b>setPlane</b></a> ( int&nbsp;plane )</li>
<li class=fn>void <a href="#setOption"><b>setOption</b></a> ( FormatOption&nbsp;opt )</li>
<li class=fn>bool <a href="#testOption"><b>testOption</b></a> ( FormatOption&nbsp;opt ) const</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QGLFormat <a href="#defaultFormat"><b>defaultFormat</b></a> ()</li>
<li class=fn>void <a href="#setDefaultFormat"><b>setDefaultFormat</b></a> ( const&nbsp;QGLFormat&nbsp;&amp;&nbsp;f )</li>
<li class=fn>QGLFormat <a href="#defaultOverlayFormat"><b>defaultOverlayFormat</b></a> ()</li>
<li class=fn>void <a href="#setDefaultOverlayFormat"><b>setDefaultOverlayFormat</b></a> ( const&nbsp;QGLFormat&nbsp;&amp;&nbsp;f )</li>
<li class=fn>bool <a href="#hasOpenGL"><b>hasOpenGL</b></a> ()</li>
<li class=fn>bool <a href="#hasOpenGLOverlays"><b>hasOpenGLOverlays</b></a> ()</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QGLFormat class specifies the display format of an OpenGL
rendering context.

<p> 


<p> A display format has several characteristics:
<ul>
<li> <a href="#setDoubleBuffer">Double or single buffering.</a>
<li> <a href="#setDepth">Depth buffer.</a>
<li> <a href="#setRgba">RGBA or color index mode.</a>
<li> <a href="#setAlpha">Alpha channel.</a>
<li> <a href="#setAccum">Accumulation buffer.</a>
<li> <a href="#setStencil">Stencil buffer.</a>
<li> <a href="#setStereo">Stereo buffers.</a>
<li> <a href="#setDirectRendering">Direct rendering.</a>
<li> <a href="#setOverlay">Presence of an overlay.</a>
<li> <a href="#setPlane">The plane of an overlay format.</a>
</ul>
<p> You create and tell a QGLFormat object what rendering options you
want from an OpenGL<sup>*</sup> rendering context.
<p> OpenGL drivers or accelerated hardware may or may not support
advanced features such as alpha channel or stereographic viewing.
If you request some features that the driver/hardware does not
provide when you create a <a href="qglwidget.html">QGLWidget</a>, you will get a rendering
context with the nearest subset of features.
<p> There are different ways to define the display characteristics of
a rendering context. One is to create a QGLFormat and make it the
default for the entire application:
<pre>
    QGLFormat f;
    f.<a href="#setAlpha">setAlpha</a>( TRUE );
    f.<a href="#setStereo">setStereo</a>( TRUE );
    QGLFormat::<a href="#setDefaultFormat">setDefaultFormat</a>( f );
    </pre>
 
<p> Or you can specify the desired format when creating an object of
your QGLWidget subclass:
<pre>
    QGLFormat f;
    f.<a href="#setDoubleBuffer">setDoubleBuffer</a>( FALSE );                 // single buffer
    f.<a href="#setDirectRendering">setDirectRendering</a>( FALSE );              // software rendering
    MyGLWidget* myWidget = new MyGLWidget( f, ... );
    </pre>
 
<p> After the widget has been created, you can find out which of the
requested features the system was able to provide:
<pre>
    QGLFormat f;
    f.<a href="#setOverlay">setOverlay</a>( TRUE );
    f.<a href="#setStereo">setStereo</a>( TRUE );
    MyGLWidget* myWidget = new MyGLWidget( f, ... );
    if ( !w-&gt;format().stereo() ) {
        // ok, goggles off
        if ( !w-&gt;format().hasOverlay() ) {
            <a href="qapplication.html#qFatal">qFatal</a>( "Cool hardware required" );
        }
    }
    </pre>
 
<p> <sup>*</sup> OpenGL is a trademark of Silicon Graphics, Inc. in the
United States and other countries.
<p> <p>See also <a href="qglcontext.html">QGLContext</a>, <a href="qglwidget.html">QGLWidget</a>, <a href="graphics.html">Graphics Classes</a>, and <a href="images.html">Image Processing Classes</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QGLFormat"></a>QGLFormat::QGLFormat ()
</h3>
Constructs a QGLFormat object with the factory default settings:
<ul>
<li> <a href="#setDoubleBuffer">Double buffer:</a> Enabled.
<li> <a href="#setDepth">Depth buffer:</a> Enabled.
<li> <a href="#setRgba">RGBA:</a> Enabled (i.e., color index disabled).
<li> <a href="#setAlpha">Alpha channel:</a> Disabled.
<li> <a href="#setAccum">Accumulator buffer:</a> Disabled.
<li> <a href="#setStencil">Stencil buffer:</a> Disabled.
<li> <a href="#setStereo">Stereo:</a> Disabled.
<li> <a href="#setDirectRendering">Direct rendering:</a> Enabled.
<li> <a href="#setOverlay">Overlay:</a> Disabled.
<li> <a href="#setPlane">Plane:</a> 0 (i.e., normal plane).
</ul>

<h3 class=fn><a name="QGLFormat-2"></a>QGLFormat::QGLFormat ( int&nbsp;options, int&nbsp;plane = 0 )
</h3>
Creates a QGLFormat object that is a copy of the current <a href="#defaultFormat">application default format</a>.
<p> If <em>options</em> is not 0, this copy is modified by these format
options. The <em>options</em> parameter should be <a href="qgl.html#FormatOption-enum">FormatOption</a> values
OR'ed together.
<p> This constructor makes it easy to specify a certain desired format
in classes derived from <a href="qglwidget.html">QGLWidget</a>, for example:
<pre>
    // The rendering in MyGLWidget depends on using
    // stencil buffer and alpha channel
    MyGLWidget::MyGLWidget( <a href="qwidget.html">QWidget</a>* parent, const char* name )
        : <a href="qglwidget.html">QGLWidget</a>( <a href="#QGLFormat">QGLFormat</a>( StencilBuffer | AlphaChannel ), parent, name )
    {
        if ( !format().stencil() )
            <a href="qapplication.html#qWarning">qWarning</a>( "Could not get stencil buffer; results will be suboptimal" );
        if ( !format().alphaChannel() )
            <a href="qapplication.html#qWarning">qWarning</a>( "Could not get alpha channel; results will be suboptimal" );
        ...
    }
    </pre>
 
<p> Note that there are <a href="qgl.html#FormatOption-enum">FormatOption</a> values to turn format settings
both on and off, e.g. <a href="qgl.html#FormatOption-enum">DepthBuffer</a> and <a href="qgl.html#FormatOption-enum">NoDepthBuffer</a>,
<a href="qgl.html#FormatOption-enum">DirectRendering</a> and <a href="qgl.html#FormatOption-enum">IndirectRendering</a>, etc.
<p> The <em>plane</em> parameter defaults to 0 and is the plane which this
format should be associated with. Not all OpenGL implmentations
supports overlay/underlay rendering planes.
<p> <p>See also <a href="#defaultFormat">defaultFormat</a>() and <a href="#setOption">setOption</a>().

<h3 class=fn>bool <a name="accum"></a>QGLFormat::accum () const
</h3>

<p> Returns TRUE if the accumulation buffer is enabled; otherwise
returns FALSE. The accumulation buffer is disabled by default.
<p> <p>See also <a href="#setAccum">setAccum</a>().

<h3 class=fn>bool <a name="alpha"></a>QGLFormat::alpha () const
</h3>

<p> Returns TRUE if the alpha channel of the framebuffer is enabled;
otherwise returns FALSE. The alpha channel is disabled by default.
<p> <p>See also <a href="#setAlpha">setAlpha</a>().

<h3 class=fn><a href="qglformat.html">QGLFormat</a> <a name="defaultFormat"></a>QGLFormat::defaultFormat ()<tt> [static]</tt>
</h3>
Returns the default QGLFormat for the application. All QGLWidgets
that are created use this format unless another format is
specified, e.g. when they are constructed.
<p> If no special default format has been set using
<a href="#setDefaultFormat">setDefaultFormat</a>(), the default format is the same as that created
with QGLFormat().
<p> <p>See also <a href="#setDefaultFormat">setDefaultFormat</a>().

<h3 class=fn><a href="qglformat.html">QGLFormat</a> <a name="defaultOverlayFormat"></a>QGLFormat::defaultOverlayFormat ()<tt> [static]</tt>
</h3>
Returns the default QGLFormat for overlay contexts.
<p> The factory default overlay format is:
<ul>
<li> <a href="#setDoubleBuffer">Double buffer:</a> Disabled.
<li> <a href="#setDepth">Depth buffer:</a> Disabled.
<li> <a href="#setRgba">RGBA:</a> Disabled (i.e., color index enabled).
<li> <a href="#setAlpha">Alpha channel:</a> Disabled.
<li> <a href="#setAccum">Accumulator buffer:</a> Disabled.
<li> <a href="#setStencil">Stencil buffer:</a> Disabled.
<li> <a href="#setStereo">Stereo:</a> Disabled.
<li> <a href="#setDirectRendering">Direct rendering:</a> Enabled.
<li> <a href="#setOverlay">Overlay:</a> Disabled.
<li> <a href="#setPlane">Plane:</a> 1 (i.e., first overlay plane).
</ul>
<p> <p>See also <a href="#setDefaultFormat">setDefaultFormat</a>().

<h3 class=fn>bool <a name="depth"></a>QGLFormat::depth () const
</h3>

<p> Returns TRUE if the depth buffer is enabled; otherwise returns
FALSE. The depth buffer is enabled by default.
<p> <p>See also <a href="#setDepth">setDepth</a>().

<h3 class=fn>bool <a name="directRendering"></a>QGLFormat::directRendering () const
</h3>

<p> Returns TRUE if direct rendering is enabled; otherwise returns
FALSE.
<p> Direct rendering is enabled by default.
<p> <p>See also <a href="#setDirectRendering">setDirectRendering</a>().

<h3 class=fn>bool <a name="doubleBuffer"></a>QGLFormat::doubleBuffer () const
</h3>

<p> Returns TRUE if double buffering is enabled; otherwise returns
FALSE. Double buffering is enabled by default.
<p> <p>See also <a href="#setDoubleBuffer">setDoubleBuffer</a>().

<h3 class=fn>bool <a name="hasOpenGL"></a>QGLFormat::hasOpenGL ()<tt> [static]</tt>
</h3>

<p> Returns TRUE if the window system has any OpenGL support;
otherwise returns FALSE.
<p> <b>Warning:</b> This function must not be called until the <a href="qapplication.html">QApplication</a>
object has been created.

<h3 class=fn>bool <a name="hasOpenGLOverlays"></a>QGLFormat::hasOpenGLOverlays ()<tt> [static]</tt>
</h3>

<p> Returns TRUE if the window system supports OpenGL overlays;
otherwise returns FALSE.
<p> <b>Warning:</b> This function must not be called until the <a href="qapplication.html">QApplication</a>
object has been created.

<h3 class=fn>bool <a name="hasOverlay"></a>QGLFormat::hasOverlay () const
</h3>

<p> Returns TRUE if overlay plane is enabled; otherwise returns FALSE.
<p> Overlay is disabled by default.
<p> <p>See also <a href="#setOverlay">setOverlay</a>().

<h3 class=fn>int <a name="plane"></a>QGLFormat::plane () const
</h3>
Returns the plane of this format. The default for normal formats
is 0, which means the normal plane. The default for overlay
formats is 1, which is the first overlay plane.
<p> <p>See also <a href="#setPlane">setPlane</a>().

<h3 class=fn>bool <a name="rgba"></a>QGLFormat::rgba () const
</h3>

<p> Returns TRUE if RGBA color mode is set. Returns FALSE if color
index mode is set. The default color mode is RGBA.
<p> <p>See also <a href="#setRgba">setRgba</a>().

<h3 class=fn>void <a name="setAccum"></a>QGLFormat::setAccum ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables the accumulation buffer; otherwise
disables the accumulation buffer.
<p> The accumulation buffer is disabled by default.
<p> The accumulation buffer is used to create blur effects and
multiple exposures.
<p> <p>See also <a href="#accum">accum</a>().

<h3 class=fn>void <a name="setAlpha"></a>QGLFormat::setAlpha ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables the alpha channel; otherwise disables
the alpha channel.
<p> The alpha buffer is disabled by default.
<p> The alpha channel is typically used for implementing transparency
or translucency. The A in RGBA specifies the transparency of a
pixel.
<p> <p>See also <a href="#alpha">alpha</a>().

<h3 class=fn>void <a name="setDefaultFormat"></a>QGLFormat::setDefaultFormat ( const&nbsp;<a href="qglformat.html">QGLFormat</a>&nbsp;&amp;&nbsp;f )<tt> [static]</tt>
</h3>
Sets a new default QGLFormat for the application to <em>f</em>. For
example, to set single buffering as the default instead of double
buffering, your main() might contain code like this:
<pre>
    <a href="qapplication.html">QApplication</a> a(argc, argv);
    QGLFormat f;
    f.<a href="#setDoubleBuffer">setDoubleBuffer</a>( FALSE );
    QGLFormat::<a href="#setDefaultFormat">setDefaultFormat</a>( f );
    </pre>
 
<p> <p>See also <a href="#defaultFormat">defaultFormat</a>().

<h3 class=fn>void <a name="setDefaultOverlayFormat"></a>QGLFormat::setDefaultOverlayFormat ( const&nbsp;<a href="qglformat.html">QGLFormat</a>&nbsp;&amp;&nbsp;f )<tt> [static]</tt>
</h3>
Sets a new default QGLFormat for overlay contexts to <em>f</em>. This
format is used whenever a <a href="qglwidget.html">QGLWidget</a> is created with a format that
<a href="#hasOverlay">hasOverlay</a>() enabled.
<p> For example, to get a double buffered overlay context (if
available), use code like this:
<p> <pre>
    QGLFormat f = QGLFormat::<a href="#defaultOverlayFormat">defaultOverlayFormat</a>();
    f.<a href="#setDoubleBuffer">setDoubleBuffer</a>( TRUE );
    QGLFormat::<a href="#setDefaultOverlayFormat">setDefaultOverlayFormat</a>( f );
    </pre>
 
<p> As usual, you can find out after widget creation whether the
underlying OpenGL system was able to provide the requested
specification:
<p> <pre>
    // ...continued from above
    MyGLWidget* myWidget = new MyGLWidget( <a href="#QGLFormat">QGLFormat</a>( QGL::<a href="qgl.html#FormatOption-enum">HasOverlay</a> ), ... );
    if ( myWidget-&gt;format().hasOverlay() ) {
        // Yes, we got an overlay, let's check _its_ format:
        <a href="qglcontext.html">QGLContext</a>* olContext = myWidget-&gt;overlayContext();
        if ( olContext-&gt;<a href="qglcontext.html#format">format</a>().doubleBuffer() )
            ; // yes, we got a double buffered overlay
        else
            ; // no, only single buffered overlays are available
    }
    </pre>
 
<p> <p>See also <a href="#defaultOverlayFormat">defaultOverlayFormat</a>().

<h3 class=fn>void <a name="setDepth"></a>QGLFormat::setDepth ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables the depth buffer; otherwise disables
the depth buffer.
<p> The depth buffer is enabled by default.
<p> The purpose of a depth buffer (or Z-buffering) is to remove hidden
surfaces. Pixels are assigned Z values based on the distance to
the viewer. A pixel with a high Z value is closer to the viewer
than a pixel with a low Z value. This information is used to
decide whether to draw a pixel or not.
<p> <p>See also <a href="#depth">depth</a>().

<h3 class=fn>void <a name="setDirectRendering"></a>QGLFormat::setDirectRendering ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables direct rendering; otherwise disables
direct rendering.
<p> Direct rendering is enabled by default.
<p> Enabling this option will make OpenGL bypass the underlying window
system and render directly from hardware to the screen, if this is
supported by the system.
<p> <p>See also <a href="#directRendering">directRendering</a>().

<h3 class=fn>void <a name="setDoubleBuffer"></a>QGLFormat::setDoubleBuffer ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE sets double buffering; otherwise sets single
buffering.
<p> Double buffering is enabled by default.
<p> Double buffering is a technique where graphics are rendered on an
off-screen buffer and not directly to the screen. When the drawing
has been completed, the program calls a swapBuffers() function to
exchange the screen contents with the buffer. The result is
flicker-free drawing and often better performance.
<p> <p>See also <a href="#doubleBuffer">doubleBuffer</a>(), <a href="qglcontext.html#swapBuffers">QGLContext::swapBuffers</a>(), and <a href="qglwidget.html#swapBuffers">QGLWidget::swapBuffers</a>().

<h3 class=fn>void <a name="setOption"></a>QGLFormat::setOption ( <a href="qgl.html#FormatOption-enum">FormatOption</a>&nbsp;opt )
</h3>
Sets the format option to <em>opt</em>.
<p> <p>See also <a href="#testOption">testOption</a>().

<h3 class=fn>void <a name="setOverlay"></a>QGLFormat::setOverlay ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables an overlay plane; otherwise disables
the overlay plane.
<p> Enabling the overlay plane will cause <a href="qglwidget.html">QGLWidget</a> to create an
additional context in an overlay plane. See the QGLWidget
documentation for further information.
<p> <p>See also <a href="#hasOverlay">hasOverlay</a>().

<h3 class=fn>void <a name="setPlane"></a>QGLFormat::setPlane ( int&nbsp;plane )
</h3>
Sets the requested plane to <em>plane</em>. 0 is the normal plane, 1 is
the first overlay plane, 2 is the second overlay plane, etc.; -1,
-2, etc. are underlay planes.
<p> Note that in contrast to other format specifications, the plane
specifications will be matched exactly. This means that if you
specify a plane that the underlying OpenGL system cannot provide,
an <a href="qglwidget.html#isValid">invalid</a> <a href="qglwidget.html">QGLWidget</a> will be
created.
<p> <p>See also <a href="#plane">plane</a>().

<h3 class=fn>void <a name="setRgba"></a>QGLFormat::setRgba ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE sets RGBA mode. If <em>enable</em> is FALSE sets
color index mode.
<p> The default color mode is RGBA.
<p> RGBA is the preferred mode for most OpenGL applications. In RGBA
color mode you specify colors as red + green + blue + alpha
quadruplets.
<p> In color index mode you specify an index into a color lookup
table.
<p> <p>See also <a href="#rgba">rgba</a>().

<h3 class=fn>void <a name="setStencil"></a>QGLFormat::setStencil ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables the stencil buffer; otherwise
disables the stencil buffer.
<p> The stencil buffer is disabled by default.
<p> The stencil buffer masks certain parts of the drawing area so that
masked parts are not drawn on.
<p> <p>See also <a href="#stencil">stencil</a>().

<h3 class=fn>void <a name="setStereo"></a>QGLFormat::setStereo ( bool&nbsp;enable )
</h3>
If <em>enable</em> is TRUE enables stereo buffering; otherwise disables
stereo buffering.
<p> Stereo buffering is disabled by default.
<p> Stereo buffering provides extra color buffers to generate left-eye
and right-eye images.
<p> <p>See also <a href="#stereo">stereo</a>().

<h3 class=fn>bool <a name="stencil"></a>QGLFormat::stencil () const
</h3>

<p> Returns TRUE if the stencil buffer is enabled; otherwise returns
FALSE. The stencil buffer is disabled by default.
<p> <p>See also <a href="#setStencil">setStencil</a>().

<h3 class=fn>bool <a name="stereo"></a>QGLFormat::stereo () const
</h3>

<p> Returns TRUE if stereo buffering is enabled; otherwise returns
FALSE. Stereo buffering is disabled by default.
<p> <p>See also <a href="#setStereo">setStereo</a>().

<h3 class=fn>bool <a name="testOption"></a>QGLFormat::testOption ( <a href="qgl.html#FormatOption-enum">FormatOption</a>&nbsp;opt ) const
</h3>
Returns TRUE if format option <em>opt</em> is set; otherwise returns FALSE.
<p> <p>See also <a href="#setOption">setOption</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
