<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/network/qsocket.cpp:223 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QSocket Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QSocket Class Reference<br><small>[<a href="network.html">network module</a>]</small></h1>

<p>The QSocket class provides a buffered TCP connection.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qsocket-h.html">qsocket.h</a>&gt;</tt>
<p>Inherits <a href="qobject.html">QObject</a> and <a href="qiodevice.html">QIODevice</a>.
<p><a href="qsocket-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>enum <a href="#Error-enum"><b>Error</b></a> { ErrConnectionRefused, ErrHostNotFound, ErrSocketRead }</li>
<li class=fn><a href="#QSocket"><b>QSocket</b></a> ( QObject&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn>virtual <a href="#~QSocket"><b>~QSocket</b></a> ()</li>
<li class=fn>enum <a href="#State-enum"><b>State</b></a> { Idle, HostLookup, Connecting, Connected, Closing, Connection = Connected }</li>
<li class=fn>State <a href="#state"><b>state</b></a> () const</li>
<li class=fn>int <a href="#socket"><b>socket</b></a> () const</li>
<li class=fn>virtual void <a href="#setSocket"><b>setSocket</b></a> ( int&nbsp;socket )</li>
<li class=fn>QSocketDevice * <a href="#socketDevice"><b>socketDevice</b></a> ()</li>
<li class=fn>virtual void <a href="#setSocketDevice"><b>setSocketDevice</b></a> ( QSocketDevice&nbsp;*&nbsp;device )</li>
<li class=fn>virtual void <a href="#connectToHost"><b>connectToHost</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port )</li>
<li class=fn>QString <a href="#peerName"><b>peerName</b></a> () const</li>
<li class=fn>virtual bool <a href="#open"><b>open</b></a> ( int&nbsp;m )</li>
<li class=fn>virtual void <a href="#close"><b>close</b></a> ()</li>
<li class=fn>virtual void <a href="#flush"><b>flush</b></a> ()</li>
<li class=fn>virtual Offset <a href="#size"><b>size</b></a> () const</li>
<li class=fn>virtual Offset <a href="#at"><b>at</b></a> () const</li>
<li class=fn>virtual bool <a href="#at-2"><b>at</b></a> ( Offset&nbsp;index )</li>
<li class=fn>virtual bool <a href="#atEnd"><b>atEnd</b></a> () const</li>
<li class=fn>Q_ULONG <a href="#bytesAvailable"><b>bytesAvailable</b></a> () const</li>
<li class=fn>Q_ULONG <a href="#waitForMore"><b>waitForMore</b></a> ( int&nbsp;msecs, bool&nbsp;*&nbsp;timeout ) const</li>
<li class=fn>Q_ULONG <a href="#waitForMore-2"><b>waitForMore</b></a> ( int&nbsp;msecs ) const</li>
<li class=fn>Q_ULONG <a href="#bytesToWrite"><b>bytesToWrite</b></a> () const</li>
<li class=fn>void <a href="#clearPendingData"><b>clearPendingData</b></a> ()</li>
<li class=fn>virtual Q_LONG <a href="#readBlock"><b>readBlock</b></a> ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )</li>
<li class=fn>virtual Q_LONG <a href="#writeBlock"><b>writeBlock</b></a> ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len )</li>
<li class=fn>virtual int <a href="#getch"><b>getch</b></a> ()</li>
<li class=fn>virtual int <a href="#putch"><b>putch</b></a> ( int&nbsp;ch )</li>
<li class=fn>virtual int <a href="#ungetch"><b>ungetch</b></a> ( int&nbsp;ch )</li>
<li class=fn>bool <a href="#canReadLine"><b>canReadLine</b></a> () const</li>
<li class=fn>virtual QString <a href="#readLine"><b>readLine</b></a> ()</li>
<li class=fn>Q_UINT16 <a href="#port"><b>port</b></a> () const</li>
<li class=fn>Q_UINT16 <a href="#peerPort"><b>peerPort</b></a> () const</li>
<li class=fn>QHostAddress <a href="#address"><b>address</b></a> () const</li>
<li class=fn>QHostAddress <a href="#peerAddress"><b>peerAddress</b></a> () const</li>
<li class=fn>void <a href="#setReadBufferSize"><b>setReadBufferSize</b></a> ( Q_ULONG&nbsp;bufSize )</li>
<li class=fn>Q_ULONG <a href="#readBufferSize"><b>readBufferSize</b></a> () const</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#hostFound"><b>hostFound</b></a> ()</li>
<li class=fn>void <a href="#connected"><b>connected</b></a> ()</li>
<li class=fn>void <a href="#connectionClosed"><b>connectionClosed</b></a> ()</li>
<li class=fn>void <a href="#delayedCloseFinished"><b>delayedCloseFinished</b></a> ()</li>
<li class=fn>void <a href="#readyRead"><b>readyRead</b></a> ()</li>
<li class=fn>void <a href="#bytesWritten"><b>bytesWritten</b></a> ( int&nbsp;nbytes )</li>
<li class=fn>void <a href="#error"><b>error</b></a> ( int )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QSocket class provides a buffered TCP connection.

<p> 

<p> It provides a totally non-blocking <a href="qiodevice.html">QIODevice</a>, and modifies and
extends the API of QIODevice with socket-specific code.
<p> Note that a <a href="qapplication.html">QApplication</a> must have been constructed before this
class can be used.
<p> The functions you're likely to call most are <a href="#connectToHost">connectToHost</a>(),
<a href="#bytesAvailable">bytesAvailable</a>(), <a href="#canReadLine">canReadLine</a>() and the ones it inherits from
QIODevice.
<p> connectToHost() is the most-used function. As its name implies,
it opens a connection to a named host.
<p> Most network protocols are either packet-oriented or
line-oriented. canReadLine() indicates whether a connection
contains an entire unread line or not, and bytesAvailable()
returns the number of bytes available for reading.
<p> The signals <a href="#error">error</a>(), <a href="#connected">connected</a>(), <a href="#readyRead">readyRead</a>() and
<a href="#connectionClosed">connectionClosed</a>() inform you of the progress of the connection.
There are also some less commonly used signals. <a href="#hostFound">hostFound</a>() is
emitted when connectToHost() has finished its DNS lookup and is
starting its TCP connection. <a href="#delayedCloseFinished">delayedCloseFinished</a>() is emitted
when <a href="#close">close</a>() succeeds. <a href="#bytesWritten">bytesWritten</a>() is emitted when QSocket
moves data from its "to be written" queue into the TCP
implementation.
<p> There are several access functions for the socket: <a href="#state">state</a>() returns
whether the object is idle, is doing a DNS lookup, is connecting,
has an operational connection, etc. <a href="#address">address</a>() and <a href="#port">port</a>() return
the IP address and port used for the connection. The <a href="#peerAddress">peerAddress</a>()
and <a href="#peerPort">peerPort</a>() functions return the IP address and port used by
the peer, and <a href="#peerName">peerName</a>() returns the name of the peer (normally
the name that was passed to <a href="#connectToHost">connectToHost</a>()). <a href="#socketDevice">socketDevice</a>()
returns a pointer to the <a href="qsocketdevice.html">QSocketDevice</a> used for this socket.
<p> QSocket inherits <a href="qiodevice.html">QIODevice</a>, and reimplements some functions. In
general, you can treat it as a QIODevice for writing, and mostly
also for reading. The match isn't perfect, since the QIODevice
API is designed for devices that are controlled by the same
machine, and an asynchronous peer-to-peer network connection isn't
quite like that. For example, there is nothing that matches
<a href="qiodevice.html#size">QIODevice::size</a>() exactly. The documentation for <a href="#open">open</a>(), <a href="#close">close</a>(),
<a href="#flush">flush</a>(), <a href="#size">size</a>(), <a href="#at">at</a>(), <a href="#atEnd">atEnd</a>(), <a href="#readBlock">readBlock</a>(), <a href="#writeBlock">writeBlock</a>(),
<a href="#getch">getch</a>(), <a href="#putch">putch</a>(), <a href="#ungetch">ungetch</a>() and <a href="#readLine">readLine</a>() describes the
differences in detail.
<p> <b>Warning:</b> QSocket is not suitable for use in threads. If you need
to uses sockets in threads use the lower-level <a href="qsocketdevice.html">QSocketDevice</a> class.
<p> <b>Warning:</b> Because Qt doesn't use the native socketstream
implementation on Mac OS X, QSocket has an implicit transfer
latency of 100ms. You can achieve lower latency on Mac OS X by
using QSocketDevice instead.
<p> <p>See also <a href="qsocketdevice.html">QSocketDevice</a>, <a href="qhostaddress.html">QHostAddress</a>, <a href="qsocketnotifier.html">QSocketNotifier</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Error-enum"></a>QSocket::Error</h3>

<p> This enum specifies the possible errors:
<ul>
<li><tt>QSocket::ErrConnectionRefused</tt> - if the connection was refused
<li><tt>QSocket::ErrHostNotFound</tt> - if the host was not found
<li><tt>QSocket::ErrSocketRead</tt> - if a read from the socket failed
</ul>
<h3 class=fn><a name="State-enum"></a>QSocket::State</h3>

<p> This enum defines the connection states:
<ul>
<li><tt>QSocket::Idle</tt> - if there is no connection
<li><tt>QSocket::HostLookup</tt> - during a DNS lookup
<li><tt>QSocket::Connecting</tt> - during TCP connection establishment
<li><tt>QSocket::Connected</tt> - when there is an operational connection
<li><tt>QSocket::Closing</tt> - if the socket is closing down, but is not yet closed.
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QSocket"></a>QSocket::QSocket ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Creates a QSocket object in <a href="#State-enum">QSocket::Idle</a> state.
<p> The <em>parent</em> and <em>name</em> arguments are passed on to the <a href="qobject.html">QObject</a>
constructor.
<p> Note that a <a href="qapplication.html">QApplication</a> must have been constructed before sockets
can be used.

<h3 class=fn><a name="~QSocket"></a>QSocket::~QSocket ()<tt> [virtual]</tt>
</h3>
Destroys the socket. Closes the connection if necessary.
<p> <p>See also <a href="#close">close</a>().

<h3 class=fn><a href="qhostaddress.html">QHostAddress</a> <a name="address"></a>QSocket::address () const
</h3>
Returns the host address of this socket. (This is normally the
main IP address of the host, but can be e.g. 127.0.0.1 for
connections to localhost.)

<h3 class=fn><a href="qiodevice.html#Offset">Offset</a> <a name="at"></a>QSocket::at () const<tt> [virtual]</tt>
</h3>
Returns the current read index. Since QSocket is a sequential
device, the current read index is always zero.

<p>Reimplemented from <a href="qiodevice.html#at">QIODevice</a>.
<h3 class=fn>bool <a name="at-2"></a>QSocket::at ( <a href="qiodevice.html#Offset">Offset</a>&nbsp;index )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Moves the read index forward to <em>index</em> and returns TRUE if the
operation was successful; otherwise returns FALSE. Moving the
index forward means skipping incoming data.

<p>Reimplemented from <a href="qiodevice.html#at-2">QIODevice</a>.
<h3 class=fn>bool <a name="atEnd"></a>QSocket::atEnd () const<tt> [virtual]</tt>
</h3>
Returns TRUE if there is no more data to read; otherwise returns FALSE.

<p>Reimplemented from <a href="qiodevice.html#atEnd">QIODevice</a>.
<h3 class=fn>Q_ULONG <a name="bytesAvailable"></a>QSocket::bytesAvailable () const
</h3>
Returns the number of incoming bytes that can be read, i.e. the
size of the input buffer. Equivalent to <a href="#size">size</a>().
<p> This function can trigger the <a href="#readyRead">readyRead</a>() signal, if more data has
arrived on the socket.
<p> <p>See also <a href="#bytesToWrite">bytesToWrite</a>().

<p>Example: <a href="networkprotocol-example.html#x677">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>Q_ULONG <a name="bytesToWrite"></a>QSocket::bytesToWrite () const
</h3>
Returns the number of bytes that are waiting to be written, i.e.
the size of the output buffer.
<p> <p>See also <a href="#bytesAvailable">bytesAvailable</a>() and <a href="#clearPendingData">clearPendingData</a>().

<h3 class=fn>void <a name="bytesWritten"></a>QSocket::bytesWritten ( int&nbsp;nbytes )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when data has been written to the network.
The <em>nbytes</em> parameter specifies how many bytes were written.
<p> The <a href="#bytesToWrite">bytesToWrite</a>() function is often used in the same context; it
indicates how many buffered bytes there are left to write.
<p> <p>See also <a href="#writeBlock">writeBlock</a>() and <a href="#bytesToWrite">bytesToWrite</a>().

<h3 class=fn>bool <a name="canReadLine"></a>QSocket::canReadLine () const
</h3>
Returns TRUE if it's possible to read an entire line of text from
this socket at this time; otherwise returns FALSE.
<p> Note that if the peer closes the connection unexpectedly, this
function returns FALSE. This means that loops such as this won't
work:
<p> <pre>
        while( !socket-&gt;canReadLine() ) // WRONG
            ;
    </pre>
 
<p> <p>See also <a href="#readLine">readLine</a>().

<p>Examples: <a href="clientserver-example.html#x795">network/clientserver/client/client.cpp</a>, <a href="httpd-example.html#x727">network/httpd/httpd.cpp</a>, <a href="mail-example.html#x709">network/mail/smtp.cpp</a>, and <a href="networkprotocol-example.html#x678">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="clearPendingData"></a>QSocket::clearPendingData ()
</h3>
Deletes the data that is waiting to be written. This is useful if you want
to close the socket without waiting for all the data to be written.
<p> <p>See also <a href="#bytesToWrite">bytesToWrite</a>(), <a href="#close">close</a>(), and <a href="#delayedCloseFinished">delayedCloseFinished</a>().

<h3 class=fn>void <a name="close"></a>QSocket::close ()<tt> [virtual]</tt>
</h3>
Closes the socket.
<p> The read buffer is cleared.
<p> If the output buffer is empty, the state is set to <a href="#State-enum">QSocket::Idle</a> and the connection is terminated immediately. If the
output buffer still contains data to be written, QSocket goes into
the <a href="#State-enum">QSocket::Closing</a> state and the rest of the data will be
written. When all of the outgoing data have been written, the
state is set to <a href="#State-enum">QSocket::Idle</a> and the connection is terminated.
At this point, the <a href="#delayedCloseFinished">delayedCloseFinished</a>() signal is emitted.
<p> If you don't want that the data of the output buffer is written, call
<a href="#clearPendingData">clearPendingData</a>() before you call <a href="#close">close</a>().
<p> <p>See also <a href="#state">state</a>(), <a href="#bytesToWrite">bytesToWrite</a>(), and <a href="#clearPendingData">clearPendingData</a>().

<p>Examples: <a href="clientserver-example.html#x796">network/clientserver/client/client.cpp</a>, <a href="httpd-example.html#x728">network/httpd/httpd.cpp</a>, and <a href="networkprotocol-example.html#x679">network/networkprotocol/nntp.cpp</a>.
<p>Reimplemented from <a href="qiodevice.html#close">QIODevice</a>.
<h3 class=fn>void <a name="connectToHost"></a>QSocket::connectToHost ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port )<tt> [virtual]</tt>
</h3>
Attempts to make a connection to <em>host</em> on the specified <em>port</em>
and return immediately.
<p> Any connection or pending connection is closed immediately, and
QSocket goes into the <a href="#State-enum">HostLookup</a> state. When the lookup
succeeds, it emits <a href="#hostFound">hostFound</a>(), starts a TCP connection and goes
into the <a href="#State-enum">Connecting</a> state. Finally, when the connection
succeeds, it emits <a href="#connected">connected</a>() and goes into the <a href="#State-enum">Connected</a>
state. If there is an error at any point, it emits <a href="#error">error</a>().
<p> <em>host</em> may be an IP address in string form, or it may be a DNS
name. QSocket will do a normal DNS lookup if required. Note that
<em>port</em> is in native byte order, unlike some other libraries.
<p> <p>See also <a href="#state">state</a>().

<p>Examples: <a href="clientserver-example.html#x797">network/clientserver/client/client.cpp</a>, <a href="mail-example.html#x710">network/mail/smtp.cpp</a>, and <a href="networkprotocol-example.html#x680">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="connected"></a>QSocket::connected ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted after <a href="#connectToHost">connectToHost</a>() has been called and a
connection has been successfully established.
<p> <p>See also <a href="#connectToHost">connectToHost</a>() and <a href="#connectionClosed">connectionClosed</a>().

<p>Examples: <a href="clientserver-example.html#x798">network/clientserver/client/client.cpp</a>, <a href="mail-example.html#x711">network/mail/smtp.cpp</a>, and <a href="networkprotocol-example.html#x681">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="connectionClosed"></a>QSocket::connectionClosed ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the other end has closed the
connection. The read buffers may contain buffered input data which
you can read after the connection was closed.
<p> <p>See also <a href="#connectToHost">connectToHost</a>() and <a href="#close">close</a>().

<p>Examples: <a href="clientserver-example.html#x799">network/clientserver/client/client.cpp</a>, <a href="clientserver-example.html#x785">network/clientserver/server/server.cpp</a>, and <a href="networkprotocol-example.html#x682">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="delayedCloseFinished"></a>QSocket::delayedCloseFinished ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted when a delayed close is finished.
<p> If you call <a href="#close">close</a>() and there is buffered output data to be
written, QSocket goes into the <a href="#State-enum">QSocket::Closing</a> state and
returns immediately. It will then keep writing to the socket until
all the data has been written. Then, the <a href="#delayedCloseFinished">delayedCloseFinished</a>()
signal is emitted.
<p> <p>See also <a href="#close">close</a>().

<p>Examples: <a href="clientserver-example.html#x800">network/clientserver/client/client.cpp</a> and <a href="httpd-example.html#x729">network/httpd/httpd.cpp</a>.
<h3 class=fn>void <a name="error"></a>QSocket::error ( int )<tt> [signal]</tt>
</h3>

<p> This signal is emitted after an error occurred. The parameter is
the <a href="#Error-enum">Error</a> value.

<p>Examples: <a href="clientserver-example.html#x801">network/clientserver/client/client.cpp</a> and <a href="networkprotocol-example.html#x683">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="flush"></a>QSocket::flush ()<tt> [virtual]</tt>
</h3>
Implementation of the abstract virtual <a href="qiodevice.html#flush">QIODevice::flush</a>() function.

<p>Reimplemented from <a href="qiodevice.html#flush">QIODevice</a>.
<h3 class=fn>int <a name="getch"></a>QSocket::getch ()<tt> [virtual]</tt>
</h3>
Reads a single byte/character from the internal read buffer.
Returns the byte/character read, or -1 if there is nothing to be
read.
<p> <p>See also <a href="#bytesAvailable">bytesAvailable</a>() and <a href="#putch">putch</a>().

<p>Reimplemented from <a href="qiodevice.html#getch">QIODevice</a>.
<h3 class=fn>void <a name="hostFound"></a>QSocket::hostFound ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted after <a href="#connectToHost">connectToHost</a>() has been called and
the host lookup has succeeded.
<p> <p>See also <a href="#connected">connected</a>().

<p>Example: <a href="networkprotocol-example.html#x684">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>bool <a name="open"></a>QSocket::open ( int&nbsp;m )<tt> [virtual]</tt>
</h3>
Opens the socket using the specified <a href="qiodevice.html">QIODevice</a> file mode <em>m</em>.
This function is called automatically when needed and you should
not call it yourself.
<p> <p>See also <a href="#close">close</a>().

<p>Reimplemented from <a href="qiodevice.html#open">QIODevice</a>.
<h3 class=fn><a href="qhostaddress.html">QHostAddress</a> <a name="peerAddress"></a>QSocket::peerAddress () const
</h3>
Returns the address of the connected peer if the socket is in
Connected state; otherwise an empty <a href="qhostaddress.html">QHostAddress</a> is returned.

<h3 class=fn><a href="qstring.html">QString</a> <a name="peerName"></a>QSocket::peerName () const
</h3>
Returns the host name as specified to the <a href="#connectToHost">connectToHost</a>()
function. An empty string is returned if none has been set.

<p>Example: <a href="mail-example.html#x712">network/mail/smtp.cpp</a>.
<h3 class=fn>Q_UINT16 <a name="peerPort"></a>QSocket::peerPort () const
</h3>
Returns the peer's host port number, normally as specified to the
<a href="#connectToHost">connectToHost</a>() function. If none has been set, this function
returns 0.
<p> Note that Qt always uses native byte order, i.e. 67 is 67 in Qt;
there is no need to call htons().

<h3 class=fn>Q_UINT16 <a name="port"></a>QSocket::port () const
</h3>
Returns the host port number of this socket, in native byte order.

<h3 class=fn>int <a name="putch"></a>QSocket::putch ( int&nbsp;ch )<tt> [virtual]</tt>
</h3>
Writes the character <em>ch</em> to the output buffer.
<p> Returns <em>ch</em>, or -1 if an error occurred.
<p> <p>See also <a href="#getch">getch</a>().

<p>Reimplemented from <a href="qiodevice.html#putch">QIODevice</a>.
<h3 class=fn>Q_LONG <a name="readBlock"></a>QSocket::readBlock ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )<tt> [virtual]</tt>
</h3>
Reads <em>maxlen</em> bytes from the socket into <em>data</em> and returns the
number of bytes read. Returns -1 if an error occurred.

<p>Example: <a href="networkprotocol-example.html#x685">network/networkprotocol/nntp.cpp</a>.
<p>Reimplemented from <a href="qiodevice.html#readBlock">QIODevice</a>.
<h3 class=fn>Q_ULONG <a name="readBufferSize"></a>QSocket::readBufferSize () const
</h3>
Returns the size of the read buffer.
<p> <p>See also <a href="#setReadBufferSize">setReadBufferSize</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="readLine"></a>QSocket::readLine ()<tt> [virtual]</tt>
</h3>
Returns a line of text including a terminating newline character
(\n). Returns "" if <a href="#canReadLine">canReadLine</a>() returns FALSE.
<p> <p>See also <a href="#canReadLine">canReadLine</a>().

<p>Examples: <a href="clientserver-example.html#x802">network/clientserver/client/client.cpp</a>, <a href="httpd-example.html#x730">network/httpd/httpd.cpp</a>, <a href="mail-example.html#x713">network/mail/smtp.cpp</a>, and <a href="networkprotocol-example.html#x686">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="readyRead"></a>QSocket::readyRead ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted every time there is new incoming data.
<p> Bear in mind that new incoming data is only reported once; if you do not
read all the data, this class buffers the data and you can read it later,
but no signal is emitted unless new data arrives. A good practice is to
read all data in the slot connected to this signal unless you are sure that
you need to receive more data to be able to process it.
<p> <p>See also <a href="#readBlock">readBlock</a>(), <a href="#readLine">readLine</a>(), and <a href="#bytesAvailable">bytesAvailable</a>().

<p>Examples: <a href="clientserver-example.html#x803">network/clientserver/client/client.cpp</a>, <a href="httpd-example.html#x731">network/httpd/httpd.cpp</a>, <a href="mail-example.html#x714">network/mail/smtp.cpp</a>, and <a href="networkprotocol-example.html#x687">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="setReadBufferSize"></a>QSocket::setReadBufferSize ( Q_ULONG&nbsp;bufSize )
</h3>
Sets the size of the QSocket's internal read buffer to <em>bufSize</em>.
<p> Usually QSocket reads all data that is available from the operating
system's socket. If the buffer size is limited to a certain size, this
means that the QSocket class doesn't buffer more than this size of data.
<p> If the size of the read buffer is 0, the read buffer is unlimited and all
incoming data is buffered. This is the default.
<p> If you read the data in the <a href="#readyRead">readyRead</a>() signal, you shouldn't use this
option since it might slow down your program unnecessary. This option is
useful if you only need to read the data at certain points in time, like in
a realtime streaming application.
<p> <p>See also <a href="#readBufferSize">readBufferSize</a>().

<h3 class=fn>void <a name="setSocket"></a>QSocket::setSocket ( int&nbsp;socket )<tt> [virtual]</tt>
</h3>
Sets the socket to use <em>socket</em> and the <a href="#state">state</a>() to <a href="#State-enum">Connected</a>.
The socket must already be connected.
<p> This allows us to use the QSocket class as a wrapper for other
socket types (e.g. Unix Domain Sockets).

<p>Example: <a href="httpd-example.html#x732">network/httpd/httpd.cpp</a>.
<h3 class=fn>void <a name="setSocketDevice"></a>QSocket::setSocketDevice ( <a href="qsocketdevice.html">QSocketDevice</a>&nbsp;*&nbsp;device )<tt> [virtual]</tt>
</h3>
Sets the internal socket device to <em>device</em>. Passing a <em>device</em>
of 0 will cause the internal socket device to be used. Any
existing connection will be disconnected before using the new <em>device</em>.
<p> The new device should not be connected before being associated
with a QSocket; after setting the socket call <a href="#connectToHost">connectToHost</a>() to
make the connection.
<p> This function is useful if you need to subclass <a href="qsocketdevice.html">QSocketDevice</a> and
want to use the QSocket API, for example, to implement Unix domain
sockets.

<h3 class=fn><a href="qiodevice.html#Offset">Offset</a> <a name="size"></a>QSocket::size () const<tt> [virtual]</tt>
</h3>
Returns the number of incoming bytes that can be read right now
(like <a href="#bytesAvailable">bytesAvailable</a>()).

<p>Reimplemented from <a href="qiodevice.html#size">QIODevice</a>.
<h3 class=fn>int <a name="socket"></a>QSocket::socket () const
</h3>
Returns the socket number, or -1 if there is no socket at the moment.

<h3 class=fn><a href="qsocketdevice.html">QSocketDevice</a>&nbsp;* <a name="socketDevice"></a>QSocket::socketDevice ()
</h3>
Returns a pointer to the internal socket device.
<p> There is normally no need to manipulate the socket device directly
since this class does the necessary setup for most applications.

<h3 class=fn><a href="qsocket.html#State-enum">State</a> <a name="state"></a>QSocket::state () const
</h3>
Returns the current state of the socket connection.
<p> <p>See also <a href="#State-enum">QSocket::State</a>.

<p>Examples: <a href="clientserver-example.html#x804">network/clientserver/client/client.cpp</a> and <a href="networkprotocol-example.html#x688">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>int <a name="ungetch"></a>QSocket::ungetch ( int&nbsp;ch )<tt> [virtual]</tt>
</h3>
This implementation of the virtual function <a href="qiodevice.html#ungetch">QIODevice::ungetch</a>()
prepends the character <em>ch</em> to the read buffer so that the next
read returns this character as the first character of the output.

<p>Reimplemented from <a href="qiodevice.html#ungetch">QIODevice</a>.
<h3 class=fn>Q_ULONG <a name="waitForMore"></a>QSocket::waitForMore ( int&nbsp;msecs, bool&nbsp;*&nbsp;timeout ) const
</h3>
Wait up to <em>msecs</em> milliseconds for more data to be available.
<p> If <em>msecs</em> is -1 the call will block indefinitely.
<p> Returns the number of bytes available.
<p> If <em>timeout</em> is non-null and no error occurred (i.e. it does not
return -1): this function sets <em>*timeout</em> to TRUE, if the reason
for returning was that the timeout was reached; otherwise it sets
<em>*timeout</em> to FALSE. This is useful to find out if the peer
closed the connection.
<p> <b>Warning:</b> This is a blocking call and should be avoided in event
driven applications.
<p> <p>See also <a href="#bytesAvailable">bytesAvailable</a>().

<h3 class=fn>Q_ULONG <a name="waitForMore-2"></a>QSocket::waitForMore ( int&nbsp;msecs ) const
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn>Q_LONG <a name="writeBlock"></a>QSocket::writeBlock ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len )<tt> [virtual]</tt>
</h3>
Writes <em>len</em> bytes to the socket from <em>data</em> and returns the
number of bytes written. Returns -1 if an error occurred.

<p>Example: <a href="networkprotocol-example.html#x689">network/networkprotocol/nntp.cpp</a>.
<p>Reimplemented from <a href="qiodevice.html#writeBlock">QIODevice</a>.
<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
