<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/tools/qiodevice.cpp:40 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QIODevice Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QIODevice Class Reference</h1>

<p>The QIODevice class is the base class of I/O devices.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qiodevice-h.html">qiodevice.h</a>&gt;</tt>
<p>Inherited by <a href="qbuffer.html">QBuffer</a>, <a href="qfile.html">QFile</a>, <a href="qsocket.html">QSocket</a>, and <a href="qsocketdevice.html">QSocketDevice</a>.
<p><a href="qiodevice-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>typedef Q_ULONG&nbsp;<a href="#Offset"><b>Offset</b></a></li>
<li class=fn><a href="#QIODevice"><b>QIODevice</b></a> ()</li>
<li class=fn>virtual <a href="#~QIODevice"><b>~QIODevice</b></a> ()</li>
<li class=fn>int <a href="#flags"><b>flags</b></a> () const</li>
<li class=fn>int <a href="#mode"><b>mode</b></a> () const</li>
<li class=fn>int <a href="#state"><b>state</b></a> () const</li>
<li class=fn>bool <a href="#isDirectAccess"><b>isDirectAccess</b></a> () const</li>
<li class=fn>bool <a href="#isSequentialAccess"><b>isSequentialAccess</b></a> () const</li>
<li class=fn>bool <a href="#isCombinedAccess"><b>isCombinedAccess</b></a> () const</li>
<li class=fn>bool <a href="#isBuffered"><b>isBuffered</b></a> () const</li>
<li class=fn>bool <a href="#isRaw"><b>isRaw</b></a> () const</li>
<li class=fn>bool <a href="#isSynchronous"><b>isSynchronous</b></a> () const</li>
<li class=fn>bool <a href="#isAsynchronous"><b>isAsynchronous</b></a> () const</li>
<li class=fn>bool <a href="#isTranslated"><b>isTranslated</b></a> () const</li>
<li class=fn>bool <a href="#isReadable"><b>isReadable</b></a> () const</li>
<li class=fn>bool <a href="#isWritable"><b>isWritable</b></a> () const</li>
<li class=fn>bool <a href="#isReadWrite"><b>isReadWrite</b></a> () const</li>
<li class=fn>bool <a href="#isInactive"><b>isInactive</b></a> () const</li>
<li class=fn>bool <a href="#isOpen"><b>isOpen</b></a> () const</li>
<li class=fn>int <a href="#status"><b>status</b></a> () const</li>
<li class=fn>void <a href="#resetStatus"><b>resetStatus</b></a> ()</li>
<li class=fn>virtual bool <a href="#open"><b>open</b></a> ( int&nbsp;mode ) = 0</li>
<li class=fn>virtual void <a href="#close"><b>close</b></a> () = 0</li>
<li class=fn>virtual void <a href="#flush"><b>flush</b></a> () = 0</li>
<li class=fn>virtual Offset <a href="#size"><b>size</b></a> () const = 0</li>
<li class=fn>virtual Offset <a href="#at"><b>at</b></a> () const</li>
<li class=fn>virtual bool <a href="#at-2"><b>at</b></a> ( Offset&nbsp;pos )</li>
<li class=fn>virtual bool <a href="#atEnd"><b>atEnd</b></a> () const</li>
<li class=fn>bool <a href="#reset"><b>reset</b></a> ()</li>
<li class=fn>virtual Q_LONG <a href="#readBlock"><b>readBlock</b></a> ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen ) = 0</li>
<li class=fn>virtual Q_LONG <a href="#writeBlock"><b>writeBlock</b></a> ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len ) = 0</li>
<li class=fn>virtual Q_LONG <a href="#readLine"><b>readLine</b></a> ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )</li>
<li class=fn>Q_LONG <a href="#writeBlock-2"><b>writeBlock</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;data )</li>
<li class=fn>virtual QByteArray <a href="#readAll"><b>readAll</b></a> ()</li>
<li class=fn>virtual int <a href="#getch"><b>getch</b></a> () = 0</li>
<li class=fn>virtual int <a href="#putch"><b>putch</b></a> ( int&nbsp;ch ) = 0</li>
<li class=fn>virtual int <a href="#ungetch"><b>ungetch</b></a> ( int&nbsp;ch ) = 0</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>void <a href="#setFlags"><b>setFlags</b></a> ( int&nbsp;flags )</li>
<li class=fn>void <a href="#setType"><b>setType</b></a> ( int&nbsp;type )</li>
<li class=fn>void <a href="#setMode"><b>setMode</b></a> ( int&nbsp;mode )</li>
<li class=fn>void <a href="#setState"><b>setState</b></a> ( int&nbsp;state )</li>
<li class=fn>void <a href="#setStatus"><b>setStatus</b></a> ( int&nbsp;s )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



<p> The QIODevice class is the base class of I/O devices.
<p> 
<p> An I/O device represents a medium that one can read bytes from
and/or write bytes to. The QIODevice class is the abstract
superclass of all such devices; classes such as <a href="qfile.html">QFile</a>, <a href="qbuffer.html">QBuffer</a> and
<a href="qsocket.html">QSocket</a> inherit QIODevice and implement virtual functions such as
write() appropriately.
<p> Although applications sometimes use QIODevice directly, it is
usually better to use <a href="qtextstream.html">QTextStream</a> and <a href="qdatastream.html">QDataStream</a>, which provide
stream operations on any QIODevice subclass. QTextStream provides
text-oriented stream functionality (for human-readable ASCII
files, for example), whereas QDataStream deals with binary data in
a totally platform-independent manner.
<p> The public member functions in QIODevice roughly fall into two
groups: the action functions and the state access functions. The
most important action functions are:
<p> <ul>
<p> <li>  <a href="#open">open</a>() opens a device for reading and/or writing, depending on
the mode argument.
<p> <li>  <a href="#close">close</a>() closes the device and tidies up (e.g. flushes buffered
data)
<p> <li>  <a href="#readBlock">readBlock</a>() reads a block of data from the device.
<p> <li>  <a href="#writeBlock">writeBlock</a>() writes a block of data to the device.
<p> <li>  <a href="#readLine">readLine</a>() reads a line (of text, usually) from the device.
<p> <li>  <a href="#flush">flush</a>() ensures that all buffered data are written to the real device.
<p> </ul>
<p> There are also some other, less used, action functions:
<p> <ul>
<p> <li>  <a href="#getch">getch</a>() reads a single character.
<p> <li>  <a href="#ungetch">ungetch</a>() forgets the last call to getch(), if possible.
<p> <li>  <a href="#putch">putch</a>() writes a single character.
<p> <li>  <a href="#size">size</a>() returns the size of the device, if there is one.
<p> <li>  <a href="#at">at</a>() returns the current read/write pointer's position, if there
is one for this device, or it moves the pointer if given an offset.
<p> <li>  <a href="#atEnd">atEnd</a>() indicates whether there is more to read, if this is
meaningful for this device.
<p> <li>  <a href="#reset">reset</a>() moves the read/write pointer to the start of the
device, if that is possible for this device.
<p> </ul>
<p> The state access are all "get" functions. The QIODevice subclass
calls <a href="#setState">setState</a>() to update the state, and simple access functions
tell the user of the device what the device's state is. Here are
the settings, and their associated access functions:
<p> <ul>
<p> <li>  Access type. Some devices are direct access (it is possible
to read/write anywhere), whereas others are sequential. QIODevice
provides the access functions (<a href="#isDirectAccess">isDirectAccess</a>(),
<a href="#isSequentialAccess">isSequentialAccess</a>(), and <a href="#isCombinedAccess">isCombinedAccess</a>()) to tell users what a
given I/O device supports.
<p> <li>  Buffering. Some devices are accessed in raw mode, whereas
others are buffered. Buffering usually provides greater
efficiency, particularly for small read/write operations.
<a href="#isBuffered">isBuffered</a>() tells the user whether a given device is buffered.
(This can often be set by the application in the call to <a href="#open">open</a>().)
<p> <li>  Synchronicity. Synchronous devices work immediately (for
example, files). When you read from a file, the file delivers its
data straight away. Other kinds of device, such as a socket
connected to a HTTP server, may not deliver the data until seconds
after you ask to read it. <a href="#isSynchronous">isSynchronous</a>() and <a href="#isAsynchronous">isAsynchronous</a>()
tell the user how this device operates.
<p> <li>  CR/LF translation. For simplicity, applications often like to
see just a single CR/LF style, and QIODevice subclasses can
provide this. <a href="#isTranslated">isTranslated</a>() returns TRUE if this object
translates CR/LF to just LF. (This can often be set by the
application in the call to open().)
<p> <li>  Permissions. Some files cannot be written. For example,
<a href="#isReadable">isReadable</a>(), <a href="#isWritable">isWritable</a>() and <a href="#isReadWrite">isReadWrite</a>() tell the application
whether it can read from and write to a given device. (This can
often be set by the application in the call to <a href="#open">open</a>().)
<p> <li>  Finally, <a href="#isOpen">isOpen</a>() returns TRUE if the device is open, i.e.
after an open() call.
<p> </ul>
<p> QIODevice provides numerous pure virtual functions that you need
to implement when subclassing it. Here is a skeleton subclass with
all the members you are sure to need and some that you will
probably need:
<p> <pre>
    class MyDevice : public QIODevice
    {
    public:
        MyDevice();
        ~MyDevice();

        bool open( int mode );
        void close();
        void flush();

        uint size() const;
        int  at() const;        // non-pure virtual
        bool at( int );         // non-pure virtual
        bool atEnd() const;     // non-pure virtual

        int readBlock( char *data, uint maxlen );
        int writeBlock( const char *data, uint len );
        int readLine( char *data, uint maxlen );

        int getch();
        int putch( int );
        int ungetch( int );
    };
    </pre>
 
<p> The three non-pure virtual functions need not be reimplemented for
sequential devices.
<p> <p>See also <a href="qdatastream.html">QDataStream</a>, <a href="qtextstream.html">QTextStream</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Offset"></a>QIODevice::Offset</h3>

<p> The offset within the device.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QIODevice"></a>QIODevice::QIODevice ()
</h3>
Constructs an I/O device.

<h3 class=fn><a name="~QIODevice"></a>QIODevice::~QIODevice ()<tt> [virtual]</tt>
</h3>
Destroys the I/O device.

<h3 class=fn><a href="qiodevice.html#Offset">Offset</a> <a name="at"></a>QIODevice::at () const<tt> [virtual]</tt>
</h3>
Virtual function that returns the current I/O device position.
<p> This is the position of the data read/write head of the I/O
device.
<p> <p>See also <a href="#size">size</a>().

<p>Example: <a href="distributor-example.html#x2666">distributor/distributor.ui.h</a>.
<p>Reimplemented in <a href="qsocket.html#at">QSocket</a>.
<h3 class=fn>bool <a name="at-2"></a>QIODevice::at ( <a href="qiodevice.html#Offset">Offset</a>&nbsp;pos )<tt> [virtual]</tt>
</h3>
Virtual function that sets the I/O device position to <em>pos</em>.
Returns TRUE if the position was successfully set, i.e. <em>pos</em> is
within range and the seek was successful; otherwise returns FALSE.
<p> <p>See also <a href="#size">size</a>().

<p>Reimplemented in <a href="qsocket.html#at-2">QSocket</a>.
<h3 class=fn>bool <a name="atEnd"></a>QIODevice::atEnd () const<tt> [virtual]</tt>
</h3>
Virtual function that returns TRUE if the I/O device position is
at the end of the input; otherwise returns FALSE.

<p>Reimplemented in <a href="qfile.html#atEnd">QFile</a> and <a href="qsocket.html#atEnd">QSocket</a>.
<h3 class=fn>void <a name="close"></a>QIODevice::close ()<tt> [pure virtual]</tt>
</h3>

<p> Closes the I/O device.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#open">open</a>().

<p>Example: <a href="grapher-nsplugin-example.html#x2742">grapher/grapher.cpp</a>.
<p>Reimplemented in <a href="qfile.html#close">QFile</a> and <a href="qsocket.html#close">QSocket</a>.
<h3 class=fn>int <a name="flags"></a>QIODevice::flags () const
</h3>

<p> Returns the current I/O device flags setting.
<p> Flags consists of mode flags and state flags.
<p> <p>See also <a href="#mode">mode</a>() and <a href="#state">state</a>().

<h3 class=fn>void <a name="flush"></a>QIODevice::flush ()<tt> [pure virtual]</tt>
</h3>

<p> Flushes an open I/O device.
<p> This virtual function must be reimplemented by all subclasses.

<p>Reimplemented in <a href="qfile.html#flush">QFile</a> and <a href="qsocket.html#flush">QSocket</a>.
<h3 class=fn>int <a name="getch"></a>QIODevice::getch ()<tt> [pure virtual]</tt>
</h3>

<p> Reads a single byte/character from the I/O device.
<p> Returns the byte/character read, or -1 if the end of the I/O
device has been reached.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#putch">putch</a>() and <a href="#ungetch">ungetch</a>().

<p>Reimplemented in <a href="qfile.html#getch">QFile</a> and <a href="qsocket.html#getch">QSocket</a>.
<h3 class=fn>bool <a name="isAsynchronous"></a>QIODevice::isAsynchronous () const
</h3>

<p> Returns TRUE if the device is an asynchronous device; otherwise
returns FALSE, i.e. if the device is a synchronous device.
<p> This mode is currently not in use.
<p> <p>See also <a href="#isSynchronous">isSynchronous</a>().

<h3 class=fn>bool <a name="isBuffered"></a>QIODevice::isBuffered () const
</h3>

<p> Returns TRUE if the I/O device is a buffered device; otherwise
returns FALSE, i.e. the device is a raw device.
<p> <p>See also <a href="#isRaw">isRaw</a>().

<h3 class=fn>bool <a name="isCombinedAccess"></a>QIODevice::isCombinedAccess () const
</h3>

<p> Returns TRUE if the I/O device is a combined access (both direct
and sequential) device; otherwise returns FALSE.
<p> This access method is currently not in use.

<h3 class=fn>bool <a name="isDirectAccess"></a>QIODevice::isDirectAccess () const
</h3>

<p> Returns TRUE if the I/O device is a direct access device;
otherwise returns FALSE, i.e. if the device is a sequential access
device.
<p> <p>See also <a href="#isSequentialAccess">isSequentialAccess</a>().

<h3 class=fn>bool <a name="isInactive"></a>QIODevice::isInactive () const
</h3>

<p> Returns TRUE if the I/O device state is 0, i.e. the device is not
open; otherwise returns FALSE.
<p> <p>See also <a href="#isOpen">isOpen</a>().

<h3 class=fn>bool <a name="isOpen"></a>QIODevice::isOpen () const
</h3>

<p> Returns TRUE if the I/O device has been opened; otherwise returns
FALSE.
<p> <p>See also <a href="#isInactive">isInactive</a>().

<p>Example: <a href="networkprotocol-example.html#x670">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>bool <a name="isRaw"></a>QIODevice::isRaw () const
</h3>

<p> Returns TRUE if the device is a raw device; otherwise returns
FALSE, i.e. if the device is a buffered device.
<p> <p>See also <a href="#isBuffered">isBuffered</a>().

<h3 class=fn>bool <a name="isReadWrite"></a>QIODevice::isReadWrite () const
</h3>

<p> Returns TRUE if the I/O device was opened using <a href="qfile.html#open">IO_ReadWrite</a>
mode; otherwise returns FALSE.
<p> <p>See also <a href="#isReadable">isReadable</a>() and <a href="#isWritable">isWritable</a>().

<h3 class=fn>bool <a name="isReadable"></a>QIODevice::isReadable () const
</h3>

<p> Returns TRUE if the I/O device was opened using <a href="qfile.html#open">IO_ReadOnly</a> or
<a href="qfile.html#open">IO_ReadWrite</a> mode; otherwise returns FALSE.
<p> <p>See also <a href="#isWritable">isWritable</a>() and <a href="#isReadWrite">isReadWrite</a>().

<h3 class=fn>bool <a name="isSequentialAccess"></a>QIODevice::isSequentialAccess () const
</h3>

<p> Returns TRUE if the device is a sequential access device;
otherwise returns FALSE, i.e. if the device is a direct access
device.
<p> Operations involving <a href="#size">size</a>() and <a href="#at">at</a>(int) are not valid on
sequential devices.
<p> <p>See also <a href="#isDirectAccess">isDirectAccess</a>().

<h3 class=fn>bool <a name="isSynchronous"></a>QIODevice::isSynchronous () const
</h3>

<p> Returns TRUE if the I/O device is a synchronous device; otherwise
returns FALSE, i.e. the device is an asynchronous device.
<p> <p>See also <a href="#isAsynchronous">isAsynchronous</a>().

<h3 class=fn>bool <a name="isTranslated"></a>QIODevice::isTranslated () const
</h3>

<p> Returns TRUE if the I/O device translates carriage-return and
linefeed characters; otherwise returns FALSE.
<p> A <a href="qfile.html">QFile</a> is translated if it is opened with the <a href="qfile.html#open">IO_Translate</a>
mode flag.

<h3 class=fn>bool <a name="isWritable"></a>QIODevice::isWritable () const
</h3>

<p> Returns TRUE if the I/O device was opened using <a href="qfile.html#open">IO_WriteOnly</a> or
<a href="qfile.html#open">IO_ReadWrite</a> mode; otherwise returns FALSE.
<p> <p>See also <a href="#isReadable">isReadable</a>() and <a href="#isReadWrite">isReadWrite</a>().

<h3 class=fn>int <a name="mode"></a>QIODevice::mode () const
</h3>

<p> Returns bits OR'ed together that specify the current operation
mode.
<p> These are the flags that were given to the <a href="#open">open</a>() function.
<p> The flags are <a href="qfile.html#open">IO_ReadOnly</a>, <a href="qfile.html#open">IO_WriteOnly</a>, <a href="qfile.html#open">IO_ReadWrite</a>,
<a href="qfile.html#open">IO_Append</a>, <a href="qfile.html#open">IO_Truncate</a> and <a href="qfile.html#open">IO_Translate</a>.

<h3 class=fn>bool <a name="open"></a>QIODevice::open ( int&nbsp;mode )<tt> [pure virtual]</tt>
</h3>

<p> Opens the I/O device using the specified <em>mode</em>. Returns TRUE if
the device was successfully opened; otherwise returns FALSE.
<p> The mode parameter <em>mode</em> must be an OR'ed combination of the
following flags.
<center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Mode flags <th valign="top">Meaning
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qfile.html#open">IO_Raw</a> <td valign="top">specifies raw (unbuffered) file access.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qfile.html#open">IO_ReadOnly</a> <td valign="top">opens a file in read-only mode.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qfile.html#open">IO_WriteOnly</a> <td valign="top">opens a file in write-only mode.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qfile.html#open">IO_ReadWrite</a> <td valign="top">opens a file in read/write mode.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qfile.html#open">IO_Append</a> <td valign="top">sets the file index to the end of the file.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qfile.html#open">IO_Truncate</a> <td valign="top">truncates the file.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qfile.html#open">IO_Translate</a> <td valign="top">enables carriage returns and linefeed
translation for text files under MS-DOS, Windows and Macintosh. On
Unix systems this flag has no effect. Use with caution as it will
also transform every linefeed written to the file into a CRLF
pair. This is likely to corrupt your file if you write write
binary data. Cannot be combined with <a href="qfile.html#open">IO_Raw</a>.
</table></center>
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#close">close</a>().

<p>Example: <a href="grapher-nsplugin-example.html#x2743">grapher/grapher.cpp</a>.
<p>Reimplemented in <a href="qfile.html#open">QFile</a> and <a href="qsocket.html#open">QSocket</a>.
<h3 class=fn>int <a name="putch"></a>QIODevice::putch ( int&nbsp;ch )<tt> [pure virtual]</tt>
</h3>

<p> Writes the character <em>ch</em> to the I/O device.
<p> Returns <em>ch</em>, or -1 if an error occurred.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#getch">getch</a>() and <a href="#ungetch">ungetch</a>().

<p>Example: <a href="grapher-nsplugin-example.html#x2744">grapher/grapher.cpp</a>.
<p>Reimplemented in <a href="qfile.html#putch">QFile</a> and <a href="qsocket.html#putch">QSocket</a>.
<h3 class=fn><a href="qbytearray.html">QByteArray</a> <a name="readAll"></a>QIODevice::readAll ()<tt> [virtual]</tt>
</h3>
This convenience function returns all of the remaining data in the
device.

<h3 class=fn>Q_LONG <a name="readBlock"></a>QIODevice::readBlock ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )<tt> [pure virtual]</tt>
</h3>

<p> Reads at most <em>maxlen</em> bytes from the I/O device into <em>data</em> and
returns the number of bytes actually read.
<p> This function should return -1 if a fatal error occurs and should
return 0 if there are no bytes to read.
<p> The device must be opened for reading, and <em>data</em> must not be 0.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#writeBlock">writeBlock</a>(), <a href="#isOpen">isOpen</a>(), and <a href="#isReadable">isReadable</a>().

<p>Example: <a href="distributor-example.html#x2667">distributor/distributor.ui.h</a>.
<p>Reimplemented in <a href="qsocket.html#readBlock">QSocket</a> and <a href="qsocketdevice.html#readBlock">QSocketDevice</a>.
<h3 class=fn>Q_LONG <a name="readLine"></a>QIODevice::readLine ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )<tt> [virtual]</tt>
</h3>
Reads a line of text, (or up to <em>maxlen</em> bytes if a newline isn't
encountered) plus a terminating '&#92;0' into <em>data</em>. If there is a
newline at the end if the line, it is not stripped.
<p> Returns the number of bytes read including the terminating '&#92;0',
or -1 if an error occurred.
<p> This virtual function can be reimplemented much more efficiently
by the most subclasses.
<p> <p>See also <a href="#readBlock">readBlock</a>() and <a href="qtextstream.html#readLine">QTextStream::readLine</a>().

<p>Reimplemented in <a href="qfile.html#readLine">QFile</a>.
<h3 class=fn>bool <a name="reset"></a>QIODevice::reset ()
</h3>

<p> Sets the device index position to 0.
<p> <p>See also <a href="#at">at</a>().

<h3 class=fn>void <a name="resetStatus"></a>QIODevice::resetStatus ()
</h3>

<p> Sets the I/O device status to <a href="qiodevice.html#status">IO_Ok</a>.
<p> <p>See also <a href="#status">status</a>().

<h3 class=fn>void <a name="setFlags"></a>QIODevice::setFlags ( int&nbsp;flags )<tt> [protected]</tt>
</h3>

<p> Used by subclasses to set the device flags to the <em>flags</em> specified.

<h3 class=fn>void <a name="setMode"></a>QIODevice::setMode ( int&nbsp;mode )<tt> [protected]</tt>
</h3>

<p> Used by subclasses to set the device mode to the <em>mode</em> specified.

<h3 class=fn>void <a name="setState"></a>QIODevice::setState ( int&nbsp;state )<tt> [protected]</tt>
</h3>

<p> Used by subclasses to set the device state to the <em>state</em> specified.

<h3 class=fn>void <a name="setStatus"></a>QIODevice::setStatus ( int&nbsp;s )<tt> [protected]</tt>
</h3>
Used by subclasses to set the device status (not state) to <em>s</em>.

<h3 class=fn>void <a name="setType"></a>QIODevice::setType ( int&nbsp;type )<tt> [protected]</tt>
</h3>

<p> Used by subclasses to set the device type to the <em>type</em> specified.

<h3 class=fn><a href="qiodevice.html#Offset">Offset</a> <a name="size"></a>QIODevice::size () const<tt> [pure virtual]</tt>
</h3>

<p> Virtual function that returns the size of the I/O device.
<p> <p>See also <a href="#at">at</a>().

<p>Reimplemented in <a href="qfile.html#size">QFile</a> and <a href="qsocket.html#size">QSocket</a>.
<h3 class=fn>int <a name="state"></a>QIODevice::state () const
</h3>

<p> Returns bits OR'ed together that specify the current state.
<p> The flags are: <tt>IO_Open</tt>.
<p> Subclasses may define additional flags.

<h3 class=fn>int <a name="status"></a>QIODevice::status () const
</h3>

<p> Returns the I/O device status.
<p> The I/O device status returns an error code. If <a href="#open">open</a>() returns
FALSE or <a href="#readBlock">readBlock</a>() or <a href="#writeBlock">writeBlock</a>() return -1, this function can
be called to find out the reason why the operation failed.
<p> <!-- index IO_Ok --><!-- index IO_ReadError --><!-- index IO_WriteError --><!-- index IO_FatalError --><!-- index IO_OpenError --><!-- index IO_ConnectError --><!-- index IO_AbortError --><!-- index IO_TimeOutError --><!-- index IO_UnspecifiedError -->
<p> The status codes are:
<center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Status code <th valign="top">Meaning
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qiodevice.html#status">IO_Ok</a> <td valign="top">The operation was successful.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qiodevice.html#status">IO_ReadError</a> <td valign="top">Could not read from the device.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qiodevice.html#status">IO_WriteError</a> <td valign="top">Could not write to the device.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qiodevice.html#status">IO_FatalError</a> <td valign="top">A fatal unrecoverable error occurred.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qiodevice.html#status">IO_OpenError</a> <td valign="top">Could not open the device.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qiodevice.html#status">IO_ConnectError</a> <td valign="top">Could not connect to the device.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qiodevice.html#status">IO_AbortError</a> <td valign="top">The operation was unexpectedly aborted.
<tr bgcolor="#d0d0d0"> <td valign="top"><a href="qiodevice.html#status">IO_TimeOutError</a> <td valign="top">The operation timed out.
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="qiodevice.html#status">IO_UnspecifiedError</a> <td valign="top">An unspecified error happened on close.
</table></center>
<p> <p>See also <a href="#resetStatus">resetStatus</a>().

<h3 class=fn>int <a name="ungetch"></a>QIODevice::ungetch ( int&nbsp;ch )<tt> [pure virtual]</tt>
</h3>

<p> Puts the character <em>ch</em> back into the I/O device and decrements
the index position if it is not zero.
<p> This function is normally called to "undo" a <a href="#getch">getch</a>() operation.
<p> Returns <em>ch</em>, or -1 if an error occurred.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#getch">getch</a>() and <a href="#putch">putch</a>().

<p>Reimplemented in <a href="qfile.html#ungetch">QFile</a> and <a href="qsocket.html#ungetch">QSocket</a>.
<h3 class=fn>Q_LONG <a name="writeBlock"></a>QIODevice::writeBlock ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len )<tt> [pure virtual]</tt>
</h3>

<p> Writes <em>len</em> bytes from <em>data</em> to the I/O device and returns the
number of bytes actually written.
<p> This function should return -1 if a fatal error occurs.
<p> This virtual function must be reimplemented by all subclasses.
<p> <p>See also <a href="#readBlock">readBlock</a>().

<p>Example: <a href="distributor-example.html#x2668">distributor/distributor.ui.h</a>.
<p>Reimplemented in <a href="qbuffer.html#writeBlock">QBuffer</a>, <a href="qsocket.html#writeBlock">QSocket</a>, and <a href="qsocketdevice.html#writeBlock">QSocketDevice</a>.
<h3 class=fn>Q_LONG <a name="writeBlock-2"></a>QIODevice::writeBlock ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;data )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This convenience function is the same as calling <a href="#writeBlock">writeBlock</a>(
data.data(), data.<a href="#size">size</a>() ).

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
