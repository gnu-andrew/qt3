<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/network/qsocketdevice.cpp:59 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QSocketDevice Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QSocketDevice Class Reference<br><small>[<a href="network.html">network module</a>]</small></h1>

<p>The QSocketDevice class provides a platform-independent low-level socket API.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qsocketdevice-h.html">qsocketdevice.h</a>&gt;</tt>
<p>Inherits <a href="qiodevice.html">QIODevice</a>.
<p><a href="qsocketdevice-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>enum <a href="#Type-enum"><b>Type</b></a> { Stream, Datagram }</li>
<li class=fn>enum <a href="#Protocol-enum"><b>Protocol</b></a> { IPv4, IPv6, Unknown }</li>
<li class=fn><a href="#QSocketDevice"><b>QSocketDevice</b></a> ( Type&nbsp;type = Stream )</li>
<li class=fn><a href="#QSocketDevice-2"><b>QSocketDevice</b></a> ( Type&nbsp;type, Protocol&nbsp;protocol, int&nbsp;dummy )</li>
<li class=fn><a href="#QSocketDevice-3"><b>QSocketDevice</b></a> ( int&nbsp;socket, Type&nbsp;type )</li>
<li class=fn>virtual <a href="#~QSocketDevice"><b>~QSocketDevice</b></a> ()</li>
<li class=fn>bool <a href="#isValid"><b>isValid</b></a> () const</li>
<li class=fn>Type <a href="#type"><b>type</b></a> () const</li>
<li class=fn>Protocol <a href="#protocol"><b>protocol</b></a> () const</li>
<li class=fn>int <a href="#socket"><b>socket</b></a> () const</li>
<li class=fn>virtual void <a href="#setSocket"><b>setSocket</b></a> ( int&nbsp;socket, Type&nbsp;type )</li>
<li class=fn>bool <a href="#blocking"><b>blocking</b></a> () const</li>
<li class=fn>virtual void <a href="#setBlocking"><b>setBlocking</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#addressReusable"><b>addressReusable</b></a> () const</li>
<li class=fn>virtual void <a href="#setAddressReusable"><b>setAddressReusable</b></a> ( bool&nbsp;enable )</li>
<li class=fn>int <a href="#receiveBufferSize"><b>receiveBufferSize</b></a> () const</li>
<li class=fn>virtual void <a href="#setReceiveBufferSize"><b>setReceiveBufferSize</b></a> ( uint&nbsp;size )</li>
<li class=fn>int <a href="#sendBufferSize"><b>sendBufferSize</b></a> () const</li>
<li class=fn>virtual void <a href="#setSendBufferSize"><b>setSendBufferSize</b></a> ( uint&nbsp;size )</li>
<li class=fn>virtual bool <a href="#connect"><b>connect</b></a> ( const&nbsp;QHostAddress&nbsp;&amp;&nbsp;addr, Q_UINT16&nbsp;port )</li>
<li class=fn>virtual bool <a href="#bind"><b>bind</b></a> ( const&nbsp;QHostAddress&nbsp;&amp;&nbsp;address, Q_UINT16&nbsp;port )</li>
<li class=fn>virtual bool <a href="#listen"><b>listen</b></a> ( int&nbsp;backlog )</li>
<li class=fn>virtual int <a href="#accept"><b>accept</b></a> ()</li>
<li class=fn>Q_LONG <a href="#bytesAvailable"><b>bytesAvailable</b></a> () const</li>
<li class=fn>Q_LONG <a href="#waitForMore"><b>waitForMore</b></a> ( int&nbsp;msecs, bool&nbsp;*&nbsp;timeout = 0 ) const</li>
<li class=fn>virtual Q_LONG <a href="#readBlock"><b>readBlock</b></a> ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )</li>
<li class=fn>virtual Q_LONG <a href="#writeBlock"><b>writeBlock</b></a> ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len )</li>
<li class=fn>virtual Q_LONG <a href="#writeBlock-2"><b>writeBlock</b></a> ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len, const&nbsp;QHostAddress&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port )</li>
<li class=fn>Q_UINT16 <a href="#port"><b>port</b></a> () const</li>
<li class=fn>Q_UINT16 <a href="#peerPort"><b>peerPort</b></a> () const</li>
<li class=fn>QHostAddress <a href="#address"><b>address</b></a> () const</li>
<li class=fn>QHostAddress <a href="#peerAddress"><b>peerAddress</b></a> () const</li>
<li class=fn>enum <a href="#Error-enum"><b>Error</b></a> { NoError, AlreadyBound, Inaccessible, NoResources, InternalError, Bug = InternalError, Impossible, NoFiles, ConnectionRefused, NetworkFailure, UnknownError }</li>
<li class=fn>Error <a href="#error"><b>error</b></a> () const</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>void <a href="#setError"><b>setError</b></a> ( Error&nbsp;err )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QSocketDevice class provides a platform-independent low-level socket API.

<p> 

<p> This class provides a low level API for working with sockets.  Users of
this class are assumed to have networking experience. For most users the
<a href="qsocket.html">QSocket</a> class provides a much easier and high level alternative, but
certain things (like UDP) can't be done with QSocket and if you need a
platform-independent API for those, QSocketDevice is the right choice.
<p> The essential purpose of the class is to provide a <a href="qiodevice.html">QIODevice</a> that
works on sockets, wrapped in a platform-independent API.
<p> When calling <a href="#connect">connect</a>() or <a href="#bind">bind</a>(), QSocketDevice detects the
protocol family (IPv4, IPv6) automatically. Passing the protocol
family to QSocketDevice's constructor or to <a href="#setSocket">setSocket</a>() forces
creation of a socket device of a specific protocol. If not set, the
protocol will be detected at the first call to connect() or bind().
<p> <p>See also <a href="qsocket.html">QSocket</a>, <a href="qsocketnotifier.html">QSocketNotifier</a>, <a href="qhostaddress.html">QHostAddress</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Error-enum"></a>QSocketDevice::Error</h3>

<p> This enum type describes the error states of QSocketDevice.
<ul>
<li><tt>QSocketDevice::NoError</tt> - No error has occurred.
<li><tt>QSocketDevice::AlreadyBound</tt> - The device is already bound, according to <a href="#bind">bind</a>().
<li><tt>QSocketDevice::Inaccessible</tt> - The operating system or firewall prohibited
the action.
<li><tt>QSocketDevice::NoResources</tt> - The operating system ran out of a resource.
<li><tt>QSocketDevice::InternalError</tt> - An internal error occurred in QSocketDevice.
<li><tt>QSocketDevice::Impossible</tt> - An attempt was made to do something which makes
no sense. For example:
<pre>
    ::close( sd-&gt;socket() );
    sd-&gt;writeBlock( someData, 42 );
    </pre>
 
The libc ::close() closes the socket, but QSocketDevice is not aware
of this. So when you call <a href="#writeBlock">writeBlock</a>(), the impossible happens.
<li><tt>QSocketDevice::NoFiles</tt> - The operating system will not let QSocketDevice open
another file.
<li><tt>QSocketDevice::ConnectionRefused</tt> - A connection attempt was rejected by the
peer.
<li><tt>QSocketDevice::NetworkFailure</tt> - There is a network failure.
<li><tt>QSocketDevice::UnknownError</tt> - The operating system did something
unexpected.
</ul>
<h3 class=fn><a name="Protocol-enum"></a>QSocketDevice::Protocol</h3>

<p> This enum type describes the protocol family of the socket. Possible values
are:
<ul>
<li><tt>QSocketDevice::IPv4</tt> - The socket is an IPv4 socket.
<li><tt>QSocketDevice::IPv6</tt> - The socket is an IPv6 socket.
<li><tt>QSocketDevice::Unknown</tt> - The protocol family of the socket is not known. This can
happen if you use QSocketDevice with an already existing socket; it
tries to determine the protocol family, but this can fail if the
protocol family is not known to QSocketDevice.
</ul><p> <p>See also <a href="#protocol">protocol</a>() and <a href="#setSocket">setSocket</a>().

<h3 class=fn><a name="Type-enum"></a>QSocketDevice::Type</h3>

<p> This enum type describes the type of the socket:
<ul>
<li><tt>QSocketDevice::Stream</tt> - a stream socket (TCP, usually)
<li><tt>QSocketDevice::Datagram</tt> - a datagram socket (UDP, usually)
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QSocketDevice"></a>QSocketDevice::QSocketDevice ( <a href="qsocketdevice.html#Type-enum">Type</a>&nbsp;type = Stream )
</h3>
Creates a QSocketDevice object for a stream or datagram socket.
<p> The <em>type</em> argument must be either <a href="#Type-enum">QSocketDevice::Stream</a> for a
reliable, connection-oriented TCP socket, or <a href="#Type-enum">QSocketDevice::Datagram</a> for an unreliable UDP socket.
<p> The socket is created as an IPv4 socket.
<p> <p>See also <a href="#blocking">blocking</a>() and <a href="#protocol">protocol</a>().

<h3 class=fn><a name="QSocketDevice-2"></a>QSocketDevice::QSocketDevice ( <a href="qsocketdevice.html#Type-enum">Type</a>&nbsp;type, <a href="qsocketdevice.html#Protocol-enum">Protocol</a>&nbsp;protocol, int&nbsp;dummy )
</h3>
Creates a QSocketDevice object for a stream or datagram socket.
<p> The <em>type</em> argument must be either <a href="#Type-enum">QSocketDevice::Stream</a> for a
reliable, connection-oriented TCP socket, or <a href="#Type-enum">QSocketDevice::Datagram</a> for an unreliable UDP socket.
<p> The <em>protocol</em> indicates whether the socket should be of type IPv4
or IPv6. Passing <a href="#Protocol-enum">Unknown</a> is not meaningful in this context and you
should avoid using (it creates an IPv4 socket, but your code is not easily
readable).
<p> The argument <em>dummy</em> is necessary for compatibility with some
compilers.
<p> <p>See also <a href="#blocking">blocking</a>() and <a href="#protocol">protocol</a>().

<h3 class=fn><a name="QSocketDevice-3"></a>QSocketDevice::QSocketDevice ( int&nbsp;socket, <a href="qsocketdevice.html#Type-enum">Type</a>&nbsp;type )
</h3>
Creates a QSocketDevice object for the existing socket <em>socket</em>.
<p> The <em>type</em> argument must match the actual socket type; use <a href="#Type-enum">QSocketDevice::Stream</a> for a reliable, connection-oriented TCP
socket, or <a href="#Type-enum">QSocketDevice::Datagram</a> for an unreliable,
connectionless UDP socket.

<h3 class=fn><a name="~QSocketDevice"></a>QSocketDevice::~QSocketDevice ()<tt> [virtual]</tt>
</h3>
Destroys the socket device and closes the socket if it is open.

<h3 class=fn>int <a name="accept"></a>QSocketDevice::accept ()<tt> [virtual]</tt>
</h3>
Extracts the first connection from the queue of pending
connections for this socket and returns a new socket identifier.
Returns -1 if the operation failed.
<p> <p>See also <a href="#bind">bind</a>() and <a href="#listen">listen</a>().

<h3 class=fn><a href="qhostaddress.html">QHostAddress</a> <a name="address"></a>QSocketDevice::address () const
</h3>
Returns the address of this socket device. This may be 0.0.0.0 for
a while, but is set to something sensible as soon as a sensible
value is available.

<h3 class=fn>bool <a name="addressReusable"></a>QSocketDevice::addressReusable () const
</h3>
Returns TRUE if the address of this socket can be used by other
sockets at the same time, and FALSE if this socket claims
exclusive ownership.
<p> <p>See also <a href="#setAddressReusable">setAddressReusable</a>().

<h3 class=fn>bool <a name="bind"></a>QSocketDevice::bind ( const&nbsp;<a href="qhostaddress.html">QHostAddress</a>&nbsp;&amp;&nbsp;address, Q_UINT16&nbsp;port )<tt> [virtual]</tt>
</h3>
Assigns a name to an unnamed socket. The name is the host address
<em>address</em> and the port number <em>port</em>. If the operation succeeds,
<a href="#bind">bind</a>() returns TRUE; otherwise it returns FALSE without changing
what <a href="#port">port</a>() and <a href="#address">address</a>() return.
<p> bind() is used by servers for setting up incoming connections.
Call bind() before <a href="#listen">listen</a>().

<h3 class=fn>bool <a name="blocking"></a>QSocketDevice::blocking () const
</h3>
Returns TRUE if the socket is valid and in blocking mode;
otherwise returns FALSE.
<p> Note that this function does not set <a href="#error">error</a>().
<p> <b>Warning:</b> On Windows, this function always returns TRUE since the
ioctlsocket() function is broken.
<p> <p>See also <a href="#setBlocking">setBlocking</a>() and <a href="#isValid">isValid</a>().

<h3 class=fn>Q_LONG <a name="bytesAvailable"></a>QSocketDevice::bytesAvailable () const
</h3>
Returns the number of bytes available for reading, or -1 if an
error occurred.
<p> <b>Warning:</b> On Microsoft Windows, we use the ioctlsocket() function
to determine the number of bytes queued on the socket. According
to Microsoft (KB Q125486), ioctlsocket() sometimes returns an
incorrect number. The only safe way to determine the amount of
data on the socket is to read it using <a href="#readBlock">readBlock</a>(). <a href="qsocket.html">QSocket</a> has
workarounds to deal with this problem.

<h3 class=fn>bool <a name="connect"></a>QSocketDevice::connect ( const&nbsp;<a href="qhostaddress.html">QHostAddress</a>&nbsp;&amp;&nbsp;addr, Q_UINT16&nbsp;port )<tt> [virtual]</tt>
</h3>
Connects to the IP address and port specified by <em>addr</em> and <em>port</em>. Returns TRUE if it establishes a connection; otherwise returns FALSE.
If it returns FALSE, <a href="#error">error</a>() explains why.
<p> Note that error() commonly returns NoError for non-blocking
sockets; this just means that you can call <a href="#connect">connect</a>() again in a
little while and it'll probably succeed.

<h3 class=fn><a href="qsocketdevice.html#Error-enum">Error</a> <a name="error"></a>QSocketDevice::error () const
</h3>
Returns the first error seen.

<h3 class=fn>bool <a name="isValid"></a>QSocketDevice::isValid () const
</h3>
Returns TRUE if this is a valid socket; otherwise returns FALSE.
<p> <p>See also <a href="#socket">socket</a>().

<h3 class=fn>bool <a name="listen"></a>QSocketDevice::listen ( int&nbsp;backlog )<tt> [virtual]</tt>
</h3>
Specifies how many pending connections a server socket can have.
Returns TRUE if the operation was successful; otherwise returns
FALSE. A <em>backlog</em> value of 50 is quite common.
<p> The <a href="#listen">listen</a>() call only applies to sockets where <a href="#type">type</a>() is <a href="#Type-enum">Stream</a>, i.e. not to <a href="#Type-enum">Datagram</a> sockets. listen() must not be
called before <a href="#bind">bind</a>() or after <a href="#accept">accept</a>().
<p> <p>See also <a href="#bind">bind</a>() and <a href="#accept">accept</a>().

<h3 class=fn><a href="qhostaddress.html">QHostAddress</a> <a name="peerAddress"></a>QSocketDevice::peerAddress () const
</h3>
Returns the address of the port this socket device is connected
to. This may be 0.0.0.0 for a while, but is set to something
sensible as soon as a sensible value is available.
<p> Note that for Datagram sockets, this is the source port of the
last packet received.

<h3 class=fn>Q_UINT16 <a name="peerPort"></a>QSocketDevice::peerPort () const
</h3>
Returns the port number of the port this socket device is
connected to. This may be 0 for a while, but is set to something
sensible as soon as a sensible value is available.
<p> Note that for Datagram sockets, this is the source port of the
last packet received, and that it is in native byte order.

<h3 class=fn>Q_UINT16 <a name="port"></a>QSocketDevice::port () const
</h3>
Returns the port number of this socket device. This may be 0 for a
while, but is set to something sensible as soon as a sensible
value is available.
<p> Note that Qt always uses native byte order, i.e. 67 is 67 in Qt;
there is no need to call htons().

<h3 class=fn><a href="qsocketdevice.html#Protocol-enum">Protocol</a> <a name="protocol"></a>QSocketDevice::protocol () const
</h3>
Returns the socket's protocol family, which is one of <a href="#Protocol-enum">Unknown</a>, <a href="#Protocol-enum">IPv4</a>,
or <a href="#Protocol-enum">IPv6</a>.
<p> QSocketDevice either creates a socket with a well known protocol family or
it uses an already existing socket. In the first case, this function
returns the protocol family it was constructed with. In the second case, it
tries to determine the protocol family of the socket; if this fails, it
returns <a href="#Protocol-enum">Unknown</a>.
<p> <p>See also <a href="#Protocol-enum">Protocol</a> and <a href="#setSocket">setSocket</a>().

<h3 class=fn>Q_LONG <a name="readBlock"></a>QSocketDevice::readBlock ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )<tt> [virtual]</tt>
</h3>
Reads <em>maxlen</em> bytes from the socket into <em>data</em> and returns the
number of bytes read. Returns -1 if an error occurred. Returning 0
is not an error. For Stream sockets, 0 is returned when the remote
host closes the connection. For Datagram sockets, 0 is a valid
datagram size.

<p>Reimplemented from <a href="qiodevice.html#readBlock">QIODevice</a>.
<h3 class=fn>int <a name="receiveBufferSize"></a>QSocketDevice::receiveBufferSize () const
</h3>
Returns the size of the operating system receive buffer.
<p> <p>See also <a href="#setReceiveBufferSize">setReceiveBufferSize</a>().

<h3 class=fn>int <a name="sendBufferSize"></a>QSocketDevice::sendBufferSize () const
</h3>
Returns the size of the operating system send buffer.
<p> <p>See also <a href="#setSendBufferSize">setSendBufferSize</a>().

<h3 class=fn>void <a name="setAddressReusable"></a>QSocketDevice::setAddressReusable ( bool&nbsp;enable )<tt> [virtual]</tt>
</h3>
Sets the address of this socket to be usable by other sockets too
if <em>enable</em> is TRUE, and to be used exclusively by this socket if
<em>enable</em> is FALSE.
<p> When a socket is reusable, other sockets can use the same port
number (and IP address), which is generally useful. Of course
other sockets cannot use the same
(address,port,peer-address,peer-port) 4-tuple as this socket, so
there is no risk of confusing the two TCP connections.
<p> <p>See also <a href="#addressReusable">addressReusable</a>().

<h3 class=fn>void <a name="setBlocking"></a>QSocketDevice::setBlocking ( bool&nbsp;enable )<tt> [virtual]</tt>
</h3>
Makes the socket blocking if <em>enable</em> is TRUE or nonblocking if
<em>enable</em> is FALSE.
<p> Sockets are blocking by default, but we recommend using
nonblocking socket operations, especially for GUI programs that
need to be responsive.
<p> <b>Warning:</b> On Windows, this function should be used with care since
whenever you use a <a href="qsocketnotifier.html">QSocketNotifier</a> on Windows, the socket is
immediately made nonblocking.
<p> <p>See also <a href="#blocking">blocking</a>() and <a href="#isValid">isValid</a>().

<h3 class=fn>void <a name="setError"></a>QSocketDevice::setError ( <a href="qsocketdevice.html#Error-enum">Error</a>&nbsp;err )<tt> [protected]</tt>
</h3>
Allows subclasses to set the error state to <em>err</em>.

<h3 class=fn>void <a name="setReceiveBufferSize"></a>QSocketDevice::setReceiveBufferSize ( uint&nbsp;size )<tt> [virtual]</tt>
</h3>
Sets the size of the operating system receive buffer to <em>size</em>.
<p> The operating system receive buffer size effectively limits two
things: how much data can be in transit at any one moment, and how
much data can be received in one iteration of the main event loop.
<p> The default is operating system-dependent. A socket that receives
large amounts of data is probably best with a buffer size of
49152.

<h3 class=fn>void <a name="setSendBufferSize"></a>QSocketDevice::setSendBufferSize ( uint&nbsp;size )<tt> [virtual]</tt>
</h3>
Sets the size of the operating system send buffer to <em>size</em>.
<p> The operating system send buffer size effectively limits how much
data can be in transit at any one moment.
<p> The default is operating system-dependent. A socket that sends
large amounts of data is probably best with a buffer size of
49152.

<h3 class=fn>void <a name="setSocket"></a>QSocketDevice::setSocket ( int&nbsp;socket, <a href="qsocketdevice.html#Type-enum">Type</a>&nbsp;type )<tt> [virtual]</tt>
</h3>
Sets the socket device to operate on the existing socket <em>socket</em>.
<p> The <em>type</em> argument must match the actual socket type; use <a href="#Type-enum">QSocketDevice::Stream</a> for a reliable, connection-oriented TCP
socket, or <a href="#Type-enum">QSocketDevice::Datagram</a> for an unreliable,
connectionless UDP socket.
<p> Any existing socket is closed.
<p> <p>See also <a href="#isValid">isValid</a>() and <a href="qiodevice.html#close">close</a>().

<h3 class=fn>int <a name="socket"></a>QSocketDevice::socket () const
</h3>
Returns the socket number, or -1 if it is an invalid socket.
<p> <p>See also <a href="#isValid">isValid</a>() and <a href="#type">type</a>().

<h3 class=fn><a href="qsocketdevice.html#Type-enum">Type</a> <a name="type"></a>QSocketDevice::type () const
</h3>

<p> Returns the socket type which is either <a href="#Type-enum">QSocketDevice::Stream</a>
or <a href="#Type-enum">QSocketDevice::Datagram</a>.
<p> <p>See also <a href="#socket">socket</a>().

<h3 class=fn>Q_LONG <a name="waitForMore"></a>QSocketDevice::waitForMore ( int&nbsp;msecs, bool&nbsp;*&nbsp;timeout = 0 ) const
</h3>
Wait up to <em>msecs</em> milliseconds for more data to be available. If
<em>msecs</em> is -1 the call will block indefinitely.
<p> Returns the number of bytes available for reading, or -1 if an
error occurred.
<p> If <em>timeout</em> is non-null and no error occurred (i.e. it does not
return -1): this function sets <em>*timeout</em> to TRUE, if the reason
for returning was that the timeout was reached; otherwise it sets
<em>*timeout</em> to FALSE. This is useful to find out if the peer
closed the connection.
<p> <b>Warning:</b> This is a blocking call and should be avoided in event
driven applications.
<p> <p>See also <a href="#bytesAvailable">bytesAvailable</a>().

<h3 class=fn>Q_LONG <a name="writeBlock"></a>QSocketDevice::writeBlock ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len )<tt> [virtual]</tt>
</h3>
Writes <em>len</em> bytes to the socket from <em>data</em> and returns the
number of bytes written. Returns -1 if an error occurred.
<p> This is used for <a href="#Type-enum">QSocketDevice::Stream</a> sockets.

<p>Reimplemented from <a href="qiodevice.html#writeBlock">QIODevice</a>.
<h3 class=fn>Q_LONG <a name="writeBlock-2"></a>QSocketDevice::writeBlock ( const&nbsp;char&nbsp;*&nbsp;data, Q_ULONG&nbsp;len, const&nbsp;<a href="qhostaddress.html">QHostAddress</a>&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes <em>len</em> bytes to the socket from <em>data</em> and returns the
number of bytes written. Returns -1 if an error occurred.
<p> This is used for <a href="#Type-enum">QSocketDevice::Datagram</a> sockets. You must
specify the <em>host</em> and <em>port</em> of the destination of the data.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
