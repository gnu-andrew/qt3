<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/tools/qstring.cpp:1228 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QString Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QString Class Reference</h1>

<p>The QString class provides an abstraction of Unicode text
and the classic C '&#92;0'-terminated char array.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qstring-h.html">qstring.h</a>&gt;</tt>
<p><a href="qstring-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QString"><b>QString</b></a> ()</li>
<li class=fn><a href="#QString-2"><b>QString</b></a> ( QChar&nbsp;ch )</li>
<li class=fn><a href="#QString-3"><b>QString</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn><a href="#QString-4"><b>QString</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;ba )</li>
<li class=fn><a href="#QString-5"><b>QString</b></a> ( const&nbsp;QChar&nbsp;*&nbsp;unicode, uint&nbsp;length )</li>
<li class=fn><a href="#QString-6"><b>QString</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn><a href="#QString-7"><b>QString</b></a> ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )</li>
<li class=fn><a href="#~QString"><b>~QString</b></a> ()</li>
<li class=fn>QString &amp; <a href="#operator-eq-2"><b>operator=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#operator-eq-3"><b>operator=</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#operator-eq-4"><b>operator=</b></a> ( const&nbsp;std::string&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#operator-eq-5"><b>operator=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;cstr )</li>
<li class=fn>QString &amp; <a href="#operator-eq"><b>operator=</b></a> ( QChar&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#operator-eq-6"><b>operator=</b></a> ( char&nbsp;c )</li>
<li class=fn>bool <a href="#isNull"><b>isNull</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>uint <a href="#length"><b>length</b></a> () const</li>
<li class=fn>void <a href="#truncate"><b>truncate</b></a> ( uint&nbsp;newLen )</li>
<li class=fn>QString &amp; <a href="#fill"><b>fill</b></a> ( QChar&nbsp;c, int&nbsp;len = -1 )</li>
<li class=fn>QString copy () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>QString <a href="#arg-2"><b>arg</b></a> ( long&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-3"><b>arg</b></a> ( ulong&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-4"><b>arg</b></a> ( Q_LLONG&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-5"><b>arg</b></a> ( Q_ULLONG&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-6"><b>arg</b></a> ( int&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-7"><b>arg</b></a> ( uint&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-8"><b>arg</b></a> ( short&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-9"><b>arg</b></a> ( ushort&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>QString <a href="#arg-a"><b>arg</b></a> ( double&nbsp;a, int&nbsp;fieldWidth = 0, char&nbsp;fmt = 'g', int&nbsp;prec = -1 ) const</li>
<li class=fn>QString <a href="#arg-b"><b>arg</b></a> ( char&nbsp;a, int&nbsp;fieldWidth = 0 ) const</li>
<li class=fn>QString <a href="#arg-c"><b>arg</b></a> ( QChar&nbsp;a, int&nbsp;fieldWidth = 0 ) const</li>
<li class=fn>QString <a href="#arg"><b>arg</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;a, int&nbsp;fieldWidth = 0 ) const</li>
<li class=fn>QString <a href="#arg-d"><b>arg</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;a1, const&nbsp;QString&nbsp;&amp;&nbsp;a2 ) const</li>
<li class=fn>QString <a href="#arg-e"><b>arg</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;a1, const&nbsp;QString&nbsp;&amp;&nbsp;a2, const&nbsp;QString&nbsp;&amp;&nbsp;a3 ) const</li>
<li class=fn>QString <a href="#arg-f"><b>arg</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;a1, const&nbsp;QString&nbsp;&amp;&nbsp;a2, const&nbsp;QString&nbsp;&amp;&nbsp;a3, const&nbsp;QString&nbsp;&amp;&nbsp;a4 ) const</li>
<li class=fn>QString &amp; <a href="#sprintf"><b>sprintf</b></a> ( const&nbsp;char&nbsp;*&nbsp;cformat, ... )</li>
<li class=fn>int <a href="#find-2"><b>find</b></a> ( QChar&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#find-3"><b>find</b></a> ( char&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#find-4"><b>find</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#find"><b>find</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, int&nbsp;index = 0 ) const</li>
<li class=fn>int <a href="#find-5"><b>find</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = 0 ) const</li>
<li class=fn>int <a href="#findRev-2"><b>findRev</b></a> ( QChar&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#findRev-3"><b>findRev</b></a> ( char&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#findRev-4"><b>findRev</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#findRev-5"><b>findRev</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, int&nbsp;index = -1 ) const</li>
<li class=fn>int <a href="#findRev"><b>findRev</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = -1 ) const</li>
<li class=fn>int <a href="#contains"><b>contains</b></a> ( QChar&nbsp;c, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-2"><b>contains</b></a> ( char&nbsp;c, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-3"><b>contains</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-4"><b>contains</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-5"><b>contains</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx ) const</li>
<li class=fn>enum <a href="#SectionFlags-enum"><b>SectionFlags</b></a> { SectionDefault = 0x00, SectionSkipEmpty = 0x01, SectionIncludeLeadingSep = 0x02, SectionIncludeTrailingSep = 0x04, SectionCaseInsensitiveSeps = 0x08 }</li>
<li class=fn>QString <a href="#section"><b>section</b></a> ( QChar&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const</li>
<li class=fn>QString <a href="#section-2"><b>section</b></a> ( char&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const</li>
<li class=fn>QString <a href="#section-3"><b>section</b></a> ( const&nbsp;char&nbsp;*&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const</li>
<li class=fn>QString <a href="#section-4"><b>section</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const</li>
<li class=fn>QString <a href="#section-5"><b>section</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;reg, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const</li>
<li class=fn>QString <a href="#left"><b>left</b></a> ( uint&nbsp;len ) const</li>
<li class=fn>QString <a href="#right"><b>right</b></a> ( uint&nbsp;len ) const</li>
<li class=fn>QString <a href="#mid"><b>mid</b></a> ( uint&nbsp;index, uint&nbsp;len = 0xffffffff ) const</li>
<li class=fn>QString <a href="#leftJustify"><b>leftJustify</b></a> ( uint&nbsp;width, QChar&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const</li>
<li class=fn>QString <a href="#rightJustify"><b>rightJustify</b></a> ( uint&nbsp;width, QChar&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const</li>
<li class=fn>QString <a href="#lower"><b>lower</b></a> () const</li>
<li class=fn>QString <a href="#upper"><b>upper</b></a> () const</li>
<li class=fn>QString <a href="#stripWhiteSpace"><b>stripWhiteSpace</b></a> () const</li>
<li class=fn>QString <a href="#simplifyWhiteSpace"><b>simplifyWhiteSpace</b></a> () const</li>
<li class=fn>QString &amp; <a href="#insert"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#insert-2"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;QByteArray&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#insert-3"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;char&nbsp;*&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#insert-4"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;QChar&nbsp;*&nbsp;s, uint&nbsp;len )</li>
<li class=fn>QString &amp; <a href="#insert-5"><b>insert</b></a> ( uint&nbsp;index, QChar&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#insert-6"><b>insert</b></a> ( uint&nbsp;index, char&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#append-2"><b>append</b></a> ( char&nbsp;ch )</li>
<li class=fn>QString &amp; <a href="#append-3"><b>append</b></a> ( QChar&nbsp;ch )</li>
<li class=fn>QString &amp; <a href="#append"><b>append</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#append-4"><b>append</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#append-5"><b>append</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#append-6"><b>append</b></a> ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#prepend-2"><b>prepend</b></a> ( char&nbsp;ch )</li>
<li class=fn>QString &amp; <a href="#prepend-3"><b>prepend</b></a> ( QChar&nbsp;ch )</li>
<li class=fn>QString &amp; <a href="#prepend"><b>prepend</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#prepend-4"><b>prepend</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#prepend-5"><b>prepend</b></a> ( const&nbsp;char&nbsp;*&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#prepend-6"><b>prepend</b></a> ( const&nbsp;std::string&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#remove"><b>remove</b></a> ( uint&nbsp;index, uint&nbsp;len )</li>
<li class=fn>QString &amp; <a href="#remove-2"><b>remove</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str, bool&nbsp;cs = TRUE )</li>
<li class=fn>QString &amp; <a href="#remove-3"><b>remove</b></a> ( QChar&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#remove-4"><b>remove</b></a> ( char&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#remove-5"><b>remove</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#remove-6"><b>remove</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx )</li>
<li class=fn>QString &amp; <a href="#replace"><b>replace</b></a> ( uint&nbsp;index, uint&nbsp;len, const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QString &amp; <a href="#replace-2"><b>replace</b></a> ( uint&nbsp;index, uint&nbsp;len, const&nbsp;QChar&nbsp;*&nbsp;s, uint&nbsp;slen )</li>
<li class=fn>QString &amp; <a href="#replace-3"><b>replace</b></a> ( uint&nbsp;index, uint&nbsp;len, QChar&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#replace-4"><b>replace</b></a> ( uint&nbsp;index, uint&nbsp;len, char&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#replace-5"><b>replace</b></a> ( QChar&nbsp;c, const&nbsp;QString&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )</li>
<li class=fn>QString &amp; <a href="#replace-6"><b>replace</b></a> ( char&nbsp;c, const&nbsp;QString&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )</li>
<li class=fn>QString &amp; <a href="#replace-7"><b>replace</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;before, const&nbsp;QString&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )</li>
<li class=fn>QString &amp; <a href="#replace-8"><b>replace</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, const&nbsp;QString&nbsp;&amp;&nbsp;after )</li>
<li class=fn>QString &amp; <a href="#replace-9"><b>replace</b></a> ( QChar&nbsp;c1, QChar&nbsp;c2 )</li>
<li class=fn>short <a href="#toShort"><b>toShort</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>ushort <a href="#toUShort"><b>toUShort</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>int <a href="#toInt"><b>toInt</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>uint <a href="#toUInt"><b>toUInt</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>long <a href="#toLong"><b>toLong</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>ulong <a href="#toULong"><b>toULong</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>Q_LLONG <a href="#toLongLong"><b>toLongLong</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>Q_ULLONG <a href="#toULongLong"><b>toULongLong</b></a> ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const</li>
<li class=fn>float <a href="#toFloat"><b>toFloat</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>double <a href="#toDouble"><b>toDouble</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>QString &amp; <a href="#setNum-2"><b>setNum</b></a> ( short&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-3"><b>setNum</b></a> ( ushort&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-4"><b>setNum</b></a> ( int&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-5"><b>setNum</b></a> ( uint&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-6"><b>setNum</b></a> ( long&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-7"><b>setNum</b></a> ( ulong&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum"><b>setNum</b></a> ( Q_LLONG&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-8"><b>setNum</b></a> ( Q_ULLONG&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString &amp; <a href="#setNum-9"><b>setNum</b></a> ( float&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )</li>
<li class=fn>QString &amp; <a href="#setNum-a"><b>setNum</b></a> ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )</li>
<li class=fn>void setExpand ( uint&nbsp;index, QChar&nbsp;c ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>QString &amp; <a href="#operator+-eq"><b>operator+=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#operator+-eq-2"><b>operator+=</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#operator+-eq-3"><b>operator+=</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#operator+-eq-4"><b>operator+=</b></a> ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QString &amp; <a href="#operator+-eq-5"><b>operator+=</b></a> ( QChar&nbsp;c )</li>
<li class=fn>QString &amp; <a href="#operator+-eq-6"><b>operator+=</b></a> ( char&nbsp;c )</li>
<li class=fn>QChar <a href="#at"><b>at</b></a> ( uint&nbsp;i ) const</li>
<li class=fn>QChar <a href="#operator[]"><b>operator[]</b></a> ( int&nbsp;i ) const</li>
<li class=fn>QCharRef <a href="#at-2"><b>at</b></a> ( uint&nbsp;i )</li>
<li class=fn>QCharRef <a href="#operator[]-2"><b>operator[]</b></a> ( int&nbsp;i )</li>
<li class=fn>QChar <a href="#constref"><b>constref</b></a> ( uint&nbsp;i ) const</li>
<li class=fn>QChar &amp; <a href="#ref"><b>ref</b></a> ( uint&nbsp;i )</li>
<li class=fn>const QChar * <a href="#unicode"><b>unicode</b></a> () const</li>
<li class=fn>const char * <a href="#ascii"><b>ascii</b></a> () const</li>
<li class=fn>const char * <a href="#latin1"><b>latin1</b></a> () const</li>
<li class=fn>QCString <a href="#utf8"><b>utf8</b></a> () const</li>
<li class=fn>QCString <a href="#local8Bit"><b>local8Bit</b></a> () const</li>
<li class=fn>bool <a href="#operator!"><b>operator!</b></a> () const</li>
<li class=fn><a href="#operator-const-char-*"><b>operator const char *</b></a> () const</li>
<li class=fn><a href="#operator-std::string"><b>operator std::string</b></a> () const</li>
<li class=fn>const unsigned short * <a href="#ucs2"><b>ucs2</b></a> () const</li>
<li class=fn>QString &amp; <a href="#setUnicode"><b>setUnicode</b></a> ( const&nbsp;QChar&nbsp;*&nbsp;unicode, uint&nbsp;len )</li>
<li class=fn>QString &amp; <a href="#setUnicodeCodes"><b>setUnicodeCodes</b></a> ( const&nbsp;ushort&nbsp;*&nbsp;unicode_as_ushorts, uint&nbsp;len )</li>
<li class=fn>QString &amp; <a href="#setAscii"><b>setAscii</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;len = -1 )</li>
<li class=fn>QString &amp; <a href="#setLatin1"><b>setLatin1</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;len = -1 )</li>
<li class=fn>int <a href="#compare-2"><b>compare</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s ) const</li>
<li class=fn>int <a href="#localeAwareCompare-2"><b>localeAwareCompare</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s ) const</li>
<li class=fn>void <a href="#compose"><b>compose</b></a> ()</li>
<li class=fn>const char * data () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool <a href="#startsWith"><b>startsWith</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>bool <a href="#endsWith"><b>endsWith</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>void <a href="#setLength"><b>setLength</b></a> ( uint&nbsp;newLen )</li>
<li class=fn>uint <a href="#capacity"><b>capacity</b></a> () const</li>
<li class=fn>void <a href="#reserve"><b>reserve</b></a> ( uint&nbsp;minCapacity )</li>
<li class=fn>void <a href="#squeeze"><b>squeeze</b></a> ()</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QString <a href="#number"><b>number</b></a> ( long&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-2"><b>number</b></a> ( ulong&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-3"><b>number</b></a> ( Q_LLONG&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-4"><b>number</b></a> ( Q_ULLONG&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-5"><b>number</b></a> ( int&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-6"><b>number</b></a> ( uint&nbsp;n, int&nbsp;base = 10 )</li>
<li class=fn>QString <a href="#number-7"><b>number</b></a> ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )</li>
<li class=fn>QString <a href="#fromAscii"><b>fromAscii</b></a> ( const&nbsp;char&nbsp;*&nbsp;ascii, int&nbsp;len = -1 )</li>
<li class=fn>QString <a href="#fromLatin1"><b>fromLatin1</b></a> ( const&nbsp;char&nbsp;*&nbsp;chars, int&nbsp;len = -1 )</li>
<li class=fn>QString <a href="#fromUtf8"><b>fromUtf8</b></a> ( const&nbsp;char&nbsp;*&nbsp;utf8, int&nbsp;len = -1 )</li>
<li class=fn>QString <a href="#fromLocal8Bit"><b>fromLocal8Bit</b></a> ( const&nbsp;char&nbsp;*&nbsp;local8Bit, int&nbsp;len = -1 )</li>
<li class=fn>QString <a href="#fromUcs2"><b>fromUcs2</b></a> ( const&nbsp;unsigned&nbsp;short&nbsp;*&nbsp;str )</li>
<li class=fn>int <a href="#compare"><b>compare</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>int <a href="#localeAwareCompare"><b>localeAwareCompare</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-eq-eq-2"><b>operator==</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-eq-eq-3"><b>operator==</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq-2"><b>operator!=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq-3"><b>operator!=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt"><b>operator&lt;</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-2"><b>operator&lt;</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-eq"><b>operator&lt;=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-eq-2"><b>operator&lt;=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt"><b>operator&gt;</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-2"><b>operator&gt;</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-eq"><b>operator&gt;=</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-eq-2"><b>operator&gt;=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QString <a href="#operator+"><b>operator+</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QString <a href="#operator+-2"><b>operator+</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>const QString <a href="#operator+-3"><b>operator+</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QString <a href="#operator+-4"><b>operator+</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;s, char&nbsp;c )</li>
<li class=fn>const QString <a href="#operator+-5"><b>operator+</b></a> ( char&nbsp;c, const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QString&nbsp;&amp;&nbsp;str )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



<p> The QString class provides an abstraction of Unicode text
and the classic C '&#92;0'-terminated char array.
<p> 



<p> QString uses <a href="shclass.html">implicit sharing</a>, which
makes it very efficient and easy to use.
<p> In all of the QString methods that take <tt>const char *</tt>
parameters, the <tt>const char *</tt> is interpreted as a classic
C-style '&#92;0'-terminated ASCII string. It is legal for the <tt>const char *</tt> parameter to be 0. If the <tt>const char *</tt> is not
'&#92;0'-terminated, the results are undefined. Functions that copy
classic C strings into a QString will not copy the terminating
'&#92;0' character. The <a href="qchar.html">QChar</a> array of the QString (as returned by
<a href="#unicode">unicode</a>()) is generally not terminated by a '&#92;0'. If you need to
pass a QString to a function that requires a C '&#92;0'-terminated
string use <a href="#latin1">latin1</a>().
<p> <!-- index QString::null --><a name="QString-null"></a>A QString that has not been assigned to anything is <em>null</em>, i.e.
both the length and data pointer is 0. A QString that references
the empty string ("", a single '&#92;0' char) is <em>empty</em>. Both null
and empty QStrings are legal parameters to the methods. Assigning
<tt>(const char *) 0</tt> to QString gives a null QString. For
convenience, <a href="qstring.html#QString-null">QString::null</a> is a null QString. When sorting,
empty strings come first, followed by non-empty strings, followed
by null strings. We recommend using <tt>if ( !str.isNull() )</tt> to
check for a non-null string rather than <tt>if ( !str )</tt>; see <a href="#operator!">operator!</a>() for an explanation.
<p> Note that if you find that you are mixing usage of <a href="qcstring.html">QCString</a>,
QString, and <a href="qbytearray.html">QByteArray</a>, this causes lots of unnecessary
copying and might indicate that the true nature of the data you
are dealing with is uncertain. If the data is '&#92;0'-terminated 8-bit
data, use <a href="qcstring.html">QCString</a>; if it is unterminated (i.e. contains '&#92;0's)
8-bit data, use <a href="qbytearray.html">QByteArray</a>; if it is text, use QString.
<p> Lists of strings are handled by the <a href="qstringlist.html">QStringList</a> class. You can
split a string into a list of strings using <a href="qstringlist.html#split">QStringList::split</a>(),
and join a list of strings into a single string with an optional
separator using <a href="qstringlist.html#join">QStringList::join</a>(). You can obtain a list of
strings from a string list that contain a particular substring or
that match a particular <a href="qregexp.html">regex</a> using
<a href="qstringlist.html#grep">QStringList::grep</a>().
<p> <b>Note for C programmers</b>
<p> Due to C++'s type system and the fact that QString is <a href="shclass.html#implicitly-shared">implicitly shared</a>, QStrings can be treated like ints or other simple base
types. For example:
<p> <pre>
    QString boolToString( bool b )
    {
        QString result;
        if ( b )
            result = "True";
        else
            result = "False";
        return result;
    }
    </pre>
 
<p> The variable, result, is an auto variable allocated on the stack.
When return is called, because we're returning by value, The copy
constructor is called and a copy of the string is returned. (No
actual copying takes place thanks to the <a href="shclass.html#implicit-sharing">implicit sharing</a>, see
below.)
<p> Throughout Qt's source code you will encounter QString usages like
this:
<pre>
    QString func( const QString&amp; input )
    {
        QString output = input;
        // process output
        return output;
    }
    </pre>
 
<p> The 'copying' of input to output is almost as fast as copying a
pointer because behind the scenes copying is achieved by
incrementing a reference count. QString (like all Qt's implicitly
shared classes) operates on a copy-on-write basis, only copying if
an instance is actually changed.
<p> If you wish to create a <a href="shclass.html#deep-copy">deep copy</a> of a QString without losing any
Unicode information then you should use <a href="qdeepcopy.html">QDeepCopy</a>.
<p> <p>See also <a href="qchar.html">QChar</a>, <a href="qcstring.html">QCString</a>, <a href="qbytearray.html">QByteArray</a>, <a href="qconststring.html">QConstString</a>, <a href="shared.html">Implicitly and Explicitly Shared Classes</a>, <a href="text.html">Text Related Classes</a>, and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="SectionFlags-enum"></a>QString::SectionFlags</h3>

<ul>
<li><tt>QString::SectionDefault</tt> - Empty fields are counted, leading and
trailing separators are not included, and the separator is
compared case sensitively.
<li><tt>QString::SectionSkipEmpty</tt> - Treat empty fields as if they don't exist,
i.e. they are not considered as far as <em>start</em> and <em>end</em> are
concerned.
<li><tt>QString::SectionIncludeLeadingSep</tt> - Include the leading separator (if
any) in the result string.
<li><tt>QString::SectionIncludeTrailingSep</tt> - Include the trailing separator
(if any) in the result string.
<li><tt>QString::SectionCaseInsensitiveSeps</tt> - Compare the separator
case-insensitively.
</ul><p> Any of the last four values can be OR-ed together to form a flag.
<p> <p>See also <a href="#section">section</a>().

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QString"></a>QString::QString ()
</h3>

<p> Constructs a null string, i.e. both the length and data pointer
are 0.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QString-2"></a>QString::QString ( <a href="qchar.html">QChar</a>&nbsp;ch )
</h3>
Constructs a string of length one, containing the character <em>ch</em>.

<h3 class=fn><a name="QString-3"></a>QString::QString ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>
Constructs an <a href="shclass.html#implicitly-shared">implicitly shared</a> copy of <em>s</em>. This is very fast
since it only involves incrementing a reference count.

<h3 class=fn><a name="QString-4"></a>QString::QString ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;ba )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>ba</em> interpreted as a
classic C string.

<h3 class=fn><a name="QString-5"></a>QString::QString ( const&nbsp;<a href="qchar.html">QChar</a>&nbsp;*&nbsp;unicode, uint&nbsp;length )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of the first <em>length</em>
characters in the <a href="qchar.html">QChar</a> array.
<p> If <em>unicode</em> and <em>length</em> are 0, then a null string is created.
<p> If only <em>unicode</em> is 0, the string is empty but has <em>length</em>
characters of space preallocated: QString expands automatically
anyway, but this may speed up some cases a little. We recommend
using the plain constructor and <a href="#setLength">setLength</a>() for this purpose since
it will result in more readable code.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#setLength">setLength</a>().

<h3 class=fn><a name="QString-6"></a>QString::QString ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>, interpreted as
a classic C string. The encoding is assumed to be Latin-1, unless
you change it using <a href="qtextcodec.html#setCodecForCStrings">QTextCodec::setCodecForCStrings</a>().
<p> If <em>str</em> is 0, then a null string is created.
<p> This is a cast constructor, but it is perfectly safe: converting a
Latin-1 <tt>const char *</tt> to QString preserves all the information. You
can disable this constructor by defining <tt>QT_NO_CAST_ASCII</tt> when
you compile your applications. You can also make QString objects
by using <a href="#setLatin1">setLatin1</a>(), <a href="#fromLatin1">fromLatin1</a>(), <a href="#fromLocal8Bit">fromLocal8Bit</a>(), and
<a href="#fromUtf8">fromUtf8</a>(). Or whatever encoding is appropriate for the 8-bit data
you have.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#fromAscii">fromAscii</a>().

<h3 class=fn><a name="QString-7"></a>QString::QString ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>.
<p> This is the same as <a href="#fromAscii">fromAscii</a>(<em>str</em>).

<h3 class=fn><a name="~QString"></a>QString::~QString ()
</h3>

<p> Destroys the string and frees the string's data if this is the
last reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append"></a>QString::append ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>

<p> Appends <em>str</em> to the string and returns a reference to the
result.
<p> <pre>
        string = "Test";
        string.append( "ing" );        // string == "Testing"
    </pre>
 
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<p>Example: <a href="dirview-example.html#x1701">dirview/dirview.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append-2"></a>QString::append ( char&nbsp;ch )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends character <em>ch</em> to the string and returns a reference to
the result.
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append-3"></a>QString::append ( <a href="qchar.html">QChar</a>&nbsp;ch )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends character <em>ch</em> to the string and returns a reference to
the result.
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append-4"></a>QString::append ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;str )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the result.
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append-5"></a>QString::append ( const&nbsp;char&nbsp;*&nbsp;str )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the result.
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="append-6"></a>QString::append ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the result.
<p> Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg"></a>QString::arg ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a, int&nbsp;fieldWidth = 0 ) const
</h3>
This function will return a string that replaces the lowest
numbered occurrence of <tt>%1</tt>, <tt>%2</tt>, ..., <tt>%9</tt> with <em>a</em>.
<p> The <em>fieldWidth</em> value specifies the minimum amount of space that
<em>a</em> is padded to. A positive value will produce right-aligned
text, whereas a negative value will produce left-aligned text.
<p> The following example shows how we could create a 'status' string
when processing a list of files:
<pre>
    QString status = <a href="#QString">QString</a>( "Processing file %1 of %2: %3" )
                        .arg( i )         // current file's number
                        .arg( total )     // number of files to process
                        .arg( fileName ); // current file's name
    </pre>
 
<p> It is generally fine to use filenames and numbers as we have done
in the example above. But note that using <a href="#arg">arg</a>() to construct
natural language sentences does not usually translate well into
other languages because sentence structure and word order often
differ between languages.
<p> If there is no place marker (<tt>%1</tt>, <tt>%2</tt>, etc.), a warning
message (<a href="qapplication.html#qWarning">qWarning</a>()) is output and the result is undefined.
<p> <b>Warning:</b> If any placeholder occurs more than once, the result is undefined.
<p> 
<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-2"></a>QString::arg ( long&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> The <em>fieldWidth</em> value specifies the minimum amount of space that
<em>a</em> is padded to. A positive value will produce a right-aligned
number, whereas a negative value will produce a left-aligned
number.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36.
<p> The '%' can be followed by an 'L', in which case the sequence is
replaced with a localized representation of <em>a</em>. The conversion
uses the default locale. The default locale is determined from the
system's locale settings at application startup. It can be changed
using <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). The 'L' flag is ignored if <em>base</em> is
not 10.
<p> <pre>
        QString str;
        str = <a href="#QString">QString</a>( "Decimal 63 is %1 in hexadecimal" )
                .arg( 63, 0, 16 );
        // str == "Decimal 63 is 3f in hexadecimal"

        QLocale::<a href="qlocale.html#setDefault">setDefault</a>(QLocale::English, QLocale::UnitedStates);
        str = <a href="#QString">QString</a>( "%1 %L2 %L3" )
                .arg( 12345 )
                .arg( 12345 )
                .arg( 12345, 0, 16 );
        // str == "12345 12,345 3039"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-3"></a>QString::arg ( ulong&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-4"></a>QString::arg ( Q_LLONG&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-5"></a>QString::arg ( Q_ULLONG&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-6"></a>QString::arg ( int&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-7"></a>QString::arg ( uint&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-8"></a>QString::arg ( short&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-9"></a>QString::arg ( ushort&nbsp;a, int&nbsp;fieldWidth = 0, int&nbsp;base = 10 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is expressed in base <em>base</em>, which is 10 by default and must
be between 2 and 36. If <em>base</em> is 10, the '%L' syntax can be used
to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-a"></a>QString::arg ( double&nbsp;a, int&nbsp;fieldWidth = 0, char&nbsp;fmt = 'g', int&nbsp;prec = -1 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <a name="arg-formats"></a>
<p> Argument <em>a</em> is formatted according to the <em>fmt</em> format specified,
which is 'g' by default and can be any of the following:
<p> <center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Format <th valign="top">Meaning
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>e</tt> <td valign="top">format as [-]9.9e[+|-]999
<tr bgcolor="#d0d0d0"> <td valign="top"><tt>E</tt> <td valign="top">format as [-]9.9E[+|-]999
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>f</tt> <td valign="top">format as [-]9.9
<tr bgcolor="#d0d0d0"> <td valign="top"><tt>g</tt> <td valign="top">use <tt>e</tt> or <tt>f</tt> format, whichever is the most concise
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>G</tt> <td valign="top">use <tt>E</tt> or <tt>f</tt> format, whichever is the most concise
</table></center>
<p> With 'e', 'E', and 'f', <em>prec</em> is the number of digits after the
decimal point. With 'g' and 'G', <em>prec</em> is the maximum number of
significant digits (trailing zeroes are omitted).
<p> <pre>
        double d = 12.34;
        QString ds = <a href="#QString">QString</a>( "'E' format, precision 3, gives %1" )
                        .arg( d, 0, 'E', 3 );
        // ds == "'E' format, precision 3, gives 1.234E+01"
    </pre>
 
<p> The '%L' syntax can be used to produce localized strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-b"></a>QString::arg ( char&nbsp;a, int&nbsp;fieldWidth = 0 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>a</em> is assumed to be in the Latin-1 character set.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-c"></a>QString::arg ( <a href="qchar.html">QChar</a>&nbsp;a, int&nbsp;fieldWidth = 0 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-d"></a>QString::arg ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a2 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This is the same as str.<a href="#arg">arg</a>(<em>a1</em>).arg(<em>a2</em>), except that
the strings are replaced in one pass. This can make a difference
if <em>a1</em> contains e.g. <tt>%1</tt>:
<p> <pre>
    QString str( "%1 %2" );
    str.<a href="#arg">arg</a>( "Hello", "world" );        // returns "Hello world"
    str.<a href="#arg">arg</a>( "Hello" ).arg( "world" );  // returns "Hello world"

    str.<a href="#arg">arg</a>( "(%1)", "Hello" );           // returns "(%1) Hello"
    str.<a href="#arg">arg</a>( "(%1)" ).arg( "Hello" );     // returns "(Hello) %2"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-e"></a>QString::arg ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a2, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a3 ) const
</h3>

This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This is the same as calling str.<a href="#arg">arg</a>(<em>a1</em>).arg(<em>a2</em>).arg(<em>a3</em>),
except that the strings are replaced in one pass.

<h3 class=fn><a href="qstring.html">QString</a> <a name="arg-f"></a>QString::arg ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a2, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a3, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;a4 ) const
</h3>

This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This is the same as calling
str.<a href="#arg">arg</a>(<em>a1</em>).arg(<em>a2</em>).arg(<em>a3</em>).arg(<em>a4</em>),
except that the strings are replaced in one pass.

<h3 class=fn>const char * <a name="ascii"></a>QString::ascii () const
</h3>
Returns an 8-bit ASCII representation of the string.
<p> If a codec has been set using <a href="qtextcodec.html#codecForCStrings">QTextCodec::codecForCStrings</a>(),
it is used to convert Unicode to 8-bit char. Otherwise, this function
does the same as <a href="#latin1">latin1</a>().
<p> <p>See also <a href="#fromAscii">fromAscii</a>(), <a href="#latin1">latin1</a>(), <a href="#utf8">utf8</a>(), and <a href="#local8Bit">local8Bit</a>().

<p>Example: <a href="networkprotocol-example.html#x690">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qchar.html">QChar</a> <a name="at"></a>QString::at ( uint&nbsp;i ) const
</h3>

<p> Returns the character at index <em>i</em>, or 0 if <em>i</em> is beyond the
length of the string.
<p> <pre>
        const QString string( "abcdefgh" );
        <a href="qchar.html">QChar</a> ch = string.<a href="#at">at</a>( 4 );
        // ch == 'e'
    </pre>
 
<p> If the QString is not const (i.e. const QString) or const& (i.e.
const QString &), then the non-const overload of <a href="#at">at</a>() will be used
instead.

<h3 class=fn><a href="qcharref.html">QCharRef</a> <a name="at-2"></a>QString::at ( uint&nbsp;i )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> The function returns a reference to the character at index <em>i</em>.
The resulting reference can then be assigned to, or used
immediately, but it will become invalid once further modifications
are made to the original string.
<p> If <em>i</em> is beyond the length of the string then the string is
expanded with QChar::null.

<h3 class=fn>uint <a name="capacity"></a>QString::capacity () const
</h3>

<p> Returns the number of characters this string can hold
in the allocated memory.
<p> <p>See also <a href="#reserve">reserve</a>() and <a href="#squeeze">squeeze</a>().

<h3 class=fn>int <a name="compare"></a>QString::compare ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )<tt> [static]</tt>
</h3>

<p> Lexically compares <em>s1</em> with <em>s2</em> and returns an integer less
than, equal to, or greater than zero if <em>s1</em> is less than, equal
to, or greater than <em>s2</em>.
<p> The comparison is based exclusively on the numeric Unicode values
of the characters and is very fast, but is not what a human would
expect. Consider sorting user-interface strings with
<a href="#localeAwareCompare">QString::localeAwareCompare</a>().
<p> <pre>
        int a = QString::<a href="#compare">compare</a>( "def", "abc" );   // a &gt; 0
        int b = QString::<a href="#compare">compare</a>( "abc", "def" );   // b &lt; 0
        int c = QString::<a href="#compare">compare</a>( "abc", "abc" );   // c == 0
    </pre>
 

<h3 class=fn>int <a name="compare-2"></a>QString::compare ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Lexically compares this string with <em>s</em> and returns an integer
less than, equal to, or greater than zero if it is less than, equal
to, or greater than <em>s</em>.

<h3 class=fn>void <a name="compose"></a>QString::compose ()
</h3>
<b>Warning:</b> This function is not supported in Qt 3.x. It is provided
for experimental and illustrative purposes only. It is mainly of
interest to those experimenting with Arabic and other
composition-rich texts.
<p> Applies possible ligatures to a QString. Useful when
composition-rich text requires rendering with glyph-poor fonts,
but it also makes compositions such as <a href="qchar.html">QChar</a>(0x0041) ('A') and
QChar(0x0308) (Unicode accent diaresis), giving QChar(0x00c4)
(German A Umlaut).

<h3 class=fn><a href="qchar.html">QChar</a> <a name="constref"></a>QString::constref ( uint&nbsp;i ) const
</h3>

<p> Returns the <a href="qchar.html">QChar</a> at index <em>i</em> by value.
<p> Equivalent to <a href="#at">at</a>(<em>i</em>).
<p> <p>See also <a href="#ref">ref</a>().

<h3 class=fn>int <a name="contains"></a>QString::contains ( <a href="qchar.html">QChar</a>&nbsp;c, bool&nbsp;cs = TRUE ) const
</h3>
Returns the number of times the character <em>c</em> occurs in the
string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> <pre>
    QString string( "Trolltech and Qt" );
    int n = string.<a href="#contains">contains</a>( 't', FALSE );
    // n == 3
    </pre>
 

<p>Examples: <a href="fileiconview-example.html#x867">fileiconview/qfileiconview.cpp</a> and <a href="mdi-example.html#x2064">mdi/application.cpp</a>.
<h3 class=fn>int <a name="contains-2"></a>QString::contains ( char&nbsp;c, bool&nbsp;cs = TRUE ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn>int <a name="contains-3"></a>QString::contains ( const&nbsp;char&nbsp;*&nbsp;str, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the number of times the string <em>str</em> occurs in the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.

<h3 class=fn>int <a name="contains-4"></a>QString::contains ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the number of times <em>str</em> occurs in the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> This function counts overlapping strings, so in the example below,
there are two instances of "ana" in "bananas".
<p> <pre>
    QString str( "bananas" );
    int i = str.<a href="#contains">contains</a>( "ana" );  // i == 2
    </pre>
 
<p> <p>See also <a href="#findRev">findRev</a>().

<h3 class=fn>int <a name="contains-5"></a>QString::contains ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the number of times the regexp, <em>rx</em>, matches in the
string.
<p> This function counts overlapping matches, so in the example below,
there are four instances of "ana" or "ama".
<p> <pre>
        QString str = "banana and panama";
        <a href="qregexp.html">QRegExp</a> rxp = QRegExp( "a[nm]a", TRUE, FALSE );
        int i = str.<a href="#contains">contains</a>( rxp );    // i == 4
    </pre>
 
<p> <p>See also <a href="#find">find</a>() and <a href="#findRev">findRev</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="copy"></a>QString::copy () const
</h3>

<p> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> In Qt 2.0 and later, all calls to this function are needless. Just
remove them.

<h3 class=fn>const char * <a name="data"></a>QString::data () const
</h3>

<p> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns a pointer to a '&#92;0'-terminated classic C string.
<p> In Qt 1.x, this returned a char* allowing direct manipulation of the
string as a sequence of bytes. In Qt 2.x where QString is a Unicode
string, char* conversion constructs a temporary string, and hence
direct character operations are meaningless.

<h3 class=fn>bool <a name="endsWith"></a>QString::endsWith ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s, bool&nbsp;cs = TRUE ) const
</h3>
Returns TRUE if the string ends with <em>s</em>; otherwise returns
FALSE.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> <pre>
        QString str( "Bananas" );
        str.<a href="#endsWith">endsWith</a>( "anas" );         // returns TRUE
        str.<a href="#endsWith">endsWith</a>( "pple" );         // returns FALSE
    </pre>
 
<p> <p>See also <a href="#startsWith">startsWith</a>().

<p>Example: <a href="tutorial2-04.html#x2561">chart/main.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="fill"></a>QString::fill ( <a href="qchar.html">QChar</a>&nbsp;c, int&nbsp;len = -1 )
</h3>
Fills the string with <em>len</em> characters of value <em>c</em>, and returns
a reference to the string.
<p> If <em>len</em> is negative (the default), the current string length is
used.
<p> <pre>
        QString str;
        str.<a href="#fill">fill</a>( 'g', 5 );      // string == "ggggg"
    </pre>
 

<h3 class=fn>int <a name="find"></a>QString::find ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, int&nbsp;index = 0 ) const
</h3>
Finds the first match of the <a href="qregexp.html#regular-expression">regular expression</a> <em>rx</em>, starting
from position <em>index</em>. If <em>index</em> is -1, the search starts at
the last character; if -2, at the next to last character and so
on. (See <a href="#findRev">findRev</a>() for searching backwards.)
<p> Returns the position of the first match of <em>rx</em> or -1 if no match
was found.
<p> <pre>
        QString string( "bananas" );
        int i = string.<a href="#find">find</a>( QRegExp("an"), 0 );    // i == 1
    </pre>
 
<p> <p>See also <a href="#findRev">findRev</a>(), <a href="#replace">replace</a>(), and <a href="#contains">contains</a>().

<p>Example: <a href="mail-example.html#x715">network/mail/smtp.cpp</a>.
<h3 class=fn>int <a name="find-2"></a>QString::find ( <a href="qchar.html">QChar</a>&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the character <em>c</em>, starting at
position <em>index</em>. If <em>index</em> is -1, the search starts at the
last character; if -2, at the next to last character and so on.
(See <a href="#findRev">findRev</a>() for searching backwards.)
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> Returns the position of <em>c</em> or -1 if <em>c</em> could not be found.

<h3 class=fn>int <a name="find-3"></a>QString::find ( char&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Find character <em>c</em> starting from position <em>index</em>.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.

<h3 class=fn>int <a name="find-4"></a>QString::find ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the string <em>str</em>, starting at
position <em>index</em>. If <em>index</em> is -1, the search starts at the
last character, if it is -2, at the next to last character and so
on. (See <a href="#findRev">findRev</a>() for searching backwards.)
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> Returns the position of <em>str</em> or -1 if <em>str</em> could not be found.

<h3 class=fn>int <a name="find-5"></a>QString::find ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = 0 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Equivalent to <a href="#find">find</a>(QString(<em>str</em>), <em>index</em>).

<h3 class=fn>int <a name="findRev"></a>QString::findRev ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = -1 ) const
</h3>

<p> Equivalent to <a href="#findRev">findRev</a>(QString(<em>str</em>), <em>index</em>).

<h3 class=fn>int <a name="findRev-2"></a>QString::findRev ( <a href="qchar.html">QChar</a>&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the character <em>c</em>, starting at
position <em>index</em> and searching backwards. If the index is -1, the
search starts at the last character, if it is -2, at the next to
last character and so on.
<p> Returns the position of <em>c</em> or -1 if <em>c</em> could not be found.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> <pre>
        QString string( "bananas" );
        int i = string.<a href="#findRev">findRev</a>( 'a' );      // i == 5
    </pre>
 

<h3 class=fn>int <a name="findRev-3"></a>QString::findRev ( char&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Find character <em>c</em> starting from position <em>index</em> and working
backwards.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.

<h3 class=fn>int <a name="findRev-4"></a>QString::findRev ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the string <em>str</em>, starting at
position <em>index</em> and searching backwards. If the index is -1, the
search starts at the last character, if it is -2, at the next to
last character and so on.
<p> Returns the position of <em>str</em> or -1 if <em>str</em> could not be found.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> <pre>
    QString string("bananas");
    int i = string.<a href="#findRev">findRev</a>( "ana" );      // i == 3
    </pre>
 

<h3 class=fn>int <a name="findRev-5"></a>QString::findRev ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, int&nbsp;index = -1 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first match of the regexp <em>rx</em>, starting at position <em>index</em> and searching backwards. If the index is -1, the search
starts at the last character, if it is -2, at the next to last
character and so on. (See <a href="#findRev">findRev</a>() for searching backwards.)
<p> Returns the position of the match or -1 if no match was found.
<p> <pre>
        QString string( "bananas" );
        int i = string.<a href="#findRev">findRev</a>( QRegExp("an") );      // i == 3
    </pre>
 
<p> <p>See also <a href="#find">find</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="fromAscii"></a>QString::fromAscii ( const&nbsp;char&nbsp;*&nbsp;ascii, int&nbsp;len = -1 )<tt> [static]</tt>
</h3>
Returns the Unicode string decoded from the first <em>len</em>
bytes of <em>ascii</em>, ignoring the rest of <em>ascii</em>. If <em>len</em>
is -1 then the length of <em>ascii</em> is used. If <em>len</em> is bigger
than the length of <em>ascii</em> then it will use the length of <em>ascii</em>.
<p> If a codec has been set using <a href="qtextcodec.html#codecForCStrings">QTextCodec::codecForCStrings</a>(),
it is used to convert the string from 8-bit characters to Unicode.
Otherwise, this function does the same as <a href="#fromLatin1">fromLatin1</a>().
<p> This is the same as the QString(const char*) constructor, but you
can make that constructor invisible if you compile with the define
<tt>QT_NO_CAST_ASCII</tt>, in which case you can explicitly create a
QString from 8-bit ASCII text using this function.
<p> <pre>
        QString str = QString::<a href="#fromAscii">fromAscii</a>( "123456789", 5 );
        // str == "12345"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a> <a name="fromLatin1"></a>QString::fromLatin1 ( const&nbsp;char&nbsp;*&nbsp;chars, int&nbsp;len = -1 )<tt> [static]</tt>
</h3>
Returns the Unicode string decoded from the first <em>len</em>
bytes of <em>chars</em>, ignoring the rest of <em>chars</em>. If <em>len</em>
is -1 then the length of <em>chars</em> is used. If <em>len</em> is bigger
than the length of <em>chars</em> then it will use the length of <em>chars</em>.
<p> <p>See also <a href="#fromAscii">fromAscii</a>().

<p>Examples: <a href="listbox-example.html#x1446">listbox/listbox.cpp</a> and <a href="mail-example.html#x716">network/mail/smtp.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="fromLocal8Bit"></a>QString::fromLocal8Bit ( const&nbsp;char&nbsp;*&nbsp;local8Bit, int&nbsp;len = -1 )<tt> [static]</tt>
</h3>
Returns the Unicode string decoded from the first <em>len</em>
bytes of <em>local8Bit</em>, ignoring the rest of <em>local8Bit</em>. If
<em>len</em> is -1 then the length of <em>local8Bit</em> is used. If <em>len</em> is
bigger than the length of <em>local8Bit</em> then it will use the length
of <em>local8Bit</em>.
<p> <pre>
        QString str = QString::<a href="#fromLocal8Bit">fromLocal8Bit</a>( "123456789", 5 );
        // str == "12345"
    </pre>
 
<p> <em>local8Bit</em> is assumed to be encoded in a locale-specific format.
<p> See <a href="qtextcodec.html">QTextCodec</a> for more diverse coding/decoding of Unicode strings.

<h3 class=fn><a href="qstring.html">QString</a> <a name="fromUcs2"></a>QString::fromUcs2 ( const&nbsp;unsigned&nbsp;short&nbsp;*&nbsp;str )<tt> [static]</tt>
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>, interpreted as a
UCS2 encoded, zero terminated, Unicode string.
<p> If <em>str</em> is 0, then a null string is created.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="fromUtf8"></a>QString::fromUtf8 ( const&nbsp;char&nbsp;*&nbsp;utf8, int&nbsp;len = -1 )<tt> [static]</tt>
</h3>
Returns the Unicode string decoded from the first <em>len</em>
bytes of <em>utf8</em>, ignoring the rest of <em>utf8</em>. If <em>len</em> is
-1 then the length of <em>utf8</em> is used. If <em>len</em> is bigger than
the length of <em>utf8</em> then it will use the length of <em>utf8</em>.
<p> <pre>
        QString str = QString::<a href="#fromUtf8">fromUtf8</a>( "123456789", 5 );
        // str == "12345"
    </pre>
 
<p> See <a href="qtextcodec.html">QTextCodec</a> for more diverse coding/decoding of Unicode strings.

<p>Example: <a href="simple-font-demo-example.html#x2850">fonts/simple-qfont-demo/viewer.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert"></a>QString::insert ( uint&nbsp;index, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>
Inserts <em>s</em> into the string at position <em>index</em>.
<p> If <em>index</em> is beyond the end of the string, the string is
extended with spaces to length <em>index</em> and <em>s</em> is then appended
and returns a reference to the string.
<p> <pre>
        QString string( "I like fish" );
        str = string.<a href="#insert">insert</a>( 2, "don't " );
        // str == "I don't like fish"
    </pre>
 
<p> <p>See also <a href="#remove">remove</a>() and <a href="#replace">replace</a>().

<p>Examples: <a href="themes-example.html#x337">themes/themes.cpp</a> and <a href="xform-example.html#x1264">xform/xform.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert-2"></a>QString::insert ( uint&nbsp;index, const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;s )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>s</em> into the string at position <em>index</em> and returns
a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert-3"></a>QString::insert ( uint&nbsp;index, const&nbsp;char&nbsp;*&nbsp;s )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>s</em> into the string at position <em>index</em> and returns
a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert-4"></a>QString::insert ( uint&nbsp;index, const&nbsp;<a href="qchar.html">QChar</a>&nbsp;*&nbsp;s, uint&nbsp;len )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts the first <em>len</em> characters in <em>s</em> into the string at
position <em>index</em> and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert-5"></a>QString::insert ( uint&nbsp;index, <a href="qchar.html">QChar</a>&nbsp;c )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Insert <em>c</em> into the string at position <em>index</em> and returns a
reference to the string.
<p> If <em>index</em> is beyond the end of the string, the string is
extended with spaces (ASCII 32) to length <em>index</em> and <em>c</em> is
then appended.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="insert-6"></a>QString::insert ( uint&nbsp;index, char&nbsp;c )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Insert character <em>c</em> at position <em>index</em>.

<h3 class=fn>bool <a name="isEmpty"></a>QString::isEmpty () const
</h3>

<p> Returns TRUE if the string is empty, i.e. if <a href="#length">length</a>() == 0;
otherwise returns FALSE. Null strings are also empty.
<p> <pre>
        QString a( "" );
        a.<a href="#isEmpty">isEmpty</a>();        // TRUE
        a.<a href="#isNull">isNull</a>();         // FALSE

        QString b;
        b.<a href="#isEmpty">isEmpty</a>();        // TRUE
        b.<a href="#isNull">isNull</a>();         // TRUE
    </pre>
 
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#length">length</a>().

<p>Examples: <a href="addressbook-example.html#x571">addressbook/mainwindow.cpp</a>, <a href="canvas-chart-example.html#x2892">chart/chartform.cpp</a>, <a href="tutorial2-06.html#x2576">chart/chartform_canvas.cpp</a>, <a href="networkprotocol-example.html#x691">network/networkprotocol/nntp.cpp</a>, <a href="qmag-example.html#x1792">qmag/qmag.cpp</a>, and <a href="qwerty-example.html#x390">qwerty/qwerty.cpp</a>.
<h3 class=fn>bool <a name="isNull"></a>QString::isNull () const
</h3>

<p> Returns TRUE if the string is null; otherwise returns FALSE. A
null string is always empty.
<p> <pre>
        QString a;          // a.<a href="#unicode">unicode</a>() == 0, a.<a href="#length">length</a>() == 0
        a.<a href="#isNull">isNull</a>();         // TRUE, because a.<a href="#unicode">unicode</a>() == 0
        a.<a href="#isEmpty">isEmpty</a>();        // TRUE, because a.<a href="#length">length</a>() == 0
    </pre>
 
<p> <p>See also <a href="#isEmpty">isEmpty</a>() and <a href="#length">length</a>().

<p>Examples: <a href="i18n-example.html#x1948">i18n/main.cpp</a>, <a href="ftpclient-example.html#x771">network/ftpclient/ftpmainwindow.ui.h</a>, and <a href="qdir-example.html#x1842">qdir/qdir.cpp</a>.
<h3 class=fn>const char * <a name="latin1"></a>QString::latin1 () const
</h3>
Returns a Latin-1 representation of the string. The
returned value is undefined if the string contains non-Latin-1
characters. If you want to convert strings into formats other than
Unicode, see the <a href="qtextcodec.html">QTextCodec</a> classes.
<p> This function is mainly useful for boot-strapping legacy code to
use Unicode.
<p> The result remains valid so long as one unmodified copy of the
source string exists.
<p> <p>See also <a href="#fromLatin1">fromLatin1</a>(), <a href="#ascii">ascii</a>(), <a href="#utf8">utf8</a>(), and <a href="#local8Bit">local8Bit</a>().

<p>Examples: <a href="fileiconview-example.html#x869">fileiconview/qfileiconview.cpp</a> and <a href="networkprotocol-example.html#x692">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="left"></a>QString::left ( uint&nbsp;len ) const
</h3>
Returns a substring that contains the <em>len</em> leftmost characters
of the string.
<p> The whole string is returned if <em>len</em> exceeds the length of the
string.
<p> <pre>
        QString s = "Pineapple";
        QString t = s.<a href="#left">left</a>( 4 );    // t == "Pine"
    </pre>
 
<p> <p>See also <a href="#right">right</a>(), <a href="#mid">mid</a>(), and <a href="#isEmpty">isEmpty</a>().

<p>Example: <a href="themes-example.html#x338">themes/themes.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="leftJustify"></a>QString::leftJustify ( uint&nbsp;width, <a href="qchar.html">QChar</a>&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const
</h3>
Returns a string of length <em>width</em> that contains this string
padded by the <em>fill</em> character.
<p> If <em>truncate</em> is FALSE and the length of the string is more than
<em>width</em>, then the returned string is a copy of the string.
<p> If <em>truncate</em> is TRUE and the length of the string is more than
<em>width</em>, then any characters in a copy of the string after length
<em>width</em> are removed, and the copy is returned.
<p> <pre>
        QString s( "apple" );
        QString t = s.<a href="#leftJustify">leftJustify</a>( 8, '.' );        // t == "apple..."
    </pre>
 
<p> <p>See also <a href="#rightJustify">rightJustify</a>().

<h3 class=fn>uint <a name="length"></a>QString::length () const
</h3>

<p> Returns the length of the string.
<p> Null strings and empty strings have zero length.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<p>Examples: <a href="dirview-example.html#x1702">dirview/dirview.cpp</a>, <a href="fileiconview-example.html#x870">fileiconview/qfileiconview.cpp</a>, <a href="networkprotocol-example.html#x693">network/networkprotocol/nntp.cpp</a>, <a href="rot-example.html#x1372">rot13/rot13.cpp</a>, and <a href="themes-example.html#x339">themes/themes.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="local8Bit"></a>QString::local8Bit () const
</h3>
Returns the string encoded in a locale-specific format. On X11,
this is the <a href="qtextcodec.html#codecForLocale">QTextCodec::codecForLocale</a>(). On Windows, it is a
system-defined encoding. On Mac OS X, this always uses UTF-8 as
the encoding.
<p> See <a href="qtextcodec.html">QTextCodec</a> for more diverse coding/decoding of Unicode
strings.
<p> <p>See also <a href="#fromLocal8Bit">fromLocal8Bit</a>(), <a href="#ascii">ascii</a>(), <a href="#latin1">latin1</a>(), and <a href="#utf8">utf8</a>().

<h3 class=fn>int <a name="localeAwareCompare"></a>QString::localeAwareCompare ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )<tt> [static]</tt>
</h3>

<p> Compares <em>s1</em> with <em>s2</em> and returns an integer less than, equal
to, or greater than zero if <em>s1</em> is less than, equal to, or
greater than <em>s2</em>.
<p> The comparison is performed in a locale- and also
platform-dependent manner. Use this function to present sorted
lists of strings to the user.
<p> <p>See also <a href="#compare">QString::compare</a>() and <a href="qtextcodec.html#locale">QTextCodec::locale</a>().

<h3 class=fn>int <a name="localeAwareCompare-2"></a>QString::localeAwareCompare ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Compares this string with <em>s</em>.

<h3 class=fn><a href="qstring.html">QString</a> <a name="lower"></a>QString::lower () const
</h3>
Returns a lowercase copy of the string.
<p> <pre>
        QString string( "TROlltECH" );
        str = string.<a href="#lower">lower</a>();   // str == "trolltech"
    </pre>
 
<p> <p>See also <a href="#upper">upper</a>().

<p>Example: <a href="scribble-example.html#x941">scribble/scribble.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="mid"></a>QString::mid ( uint&nbsp;index, uint&nbsp;len = 0xffffffff ) const
</h3>
Returns a string that contains the <em>len</em> characters of this
string, starting at position <em>index</em>.
<p> Returns a null string if the string is empty or <em>index</em> is out of
range. Returns the whole string from <em>index</em> if <em>index</em> + <em>len</em>
exceeds the length of the string.
<p> <pre>
        QString s( "Five pineapples" );
        QString t = s.<a href="#mid">mid</a>( 5, 4 );                  // t == "pine"
    </pre>
 
<p> <p>See also <a href="#left">left</a>() and <a href="#right">right</a>().

<p>Examples: <a href="mail-example.html#x717">network/mail/smtp.cpp</a>, <a href="qmag-example.html#x1793">qmag/qmag.cpp</a>, and <a href="themes-example.html#x340">themes/themes.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="number"></a>QString::number ( long&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
A convenience function that returns a string equivalent of the
number <em>n</em> to base <em>base</em>, which is 10 by default and must be
between 2 and 36. The returned string is in "C" locale.
<p> <pre>
        long a = 63;
        QString str = QString::<a href="#number">number</a>( a, 16 );             // str == "3f"
        QString str = QString::<a href="#number">number</a>( a, 16 ).upper();     // str == "3F"
    </pre>
 
<p> <p>See also <a href="#setNum">setNum</a>().

<p>Examples: <a href="simple-application-example.html#x1580">application/application.cpp</a>, <a href="canvas-chart-example.html#x2893">chart/chartform.cpp</a>, <a href="simple-font-demo-example.html#x2851">fonts/simple-qfont-demo/viewer.cpp</a>, <a href="helpviewer-example.html#x1018">helpviewer/helpwindow.cpp</a>, <a href="mdi-example.html#x2066">mdi/application.cpp</a>, <a href="regexptester-example.html#x2496">regexptester/regexptester.cpp</a>, and <a href="sql.html#x2193">sql/overview/extract/main.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="number-2"></a>QString::number ( ulong&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="number-3"></a>QString::number ( Q_LLONG&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="number-4"></a>QString::number ( Q_ULLONG&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="number-5"></a>QString::number ( int&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="number-6"></a>QString::number ( uint&nbsp;n, int&nbsp;base = 10 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> A convenience factory function that returns a string
representation of the number <em>n</em> to the base <em>base</em>, which is 10
by default and must be between 2 and 36.
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="number-7"></a>QString::number ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Argument <em>n</em> is formatted according to the <em>f</em> format specified,
which is <tt>g</tt> by default, and can be any of the following:
<p> <center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Format <th valign="top">Meaning
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>e</tt> <td valign="top">format as [-]9.9e[+|-]999
<tr bgcolor="#d0d0d0"> <td valign="top"><tt>E</tt> <td valign="top">format as [-]9.9E[+|-]999
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>f</tt> <td valign="top">format as [-]9.9
<tr bgcolor="#d0d0d0"> <td valign="top"><tt>g</tt> <td valign="top">use <tt>e</tt> or <tt>f</tt> format, whichever is the most concise
<tr bgcolor="#f0f0f0"> <td valign="top"><tt>G</tt> <td valign="top">use <tt>E</tt> or <tt>f</tt> format, whichever is the most concise
</table></center>
<p> With 'e', 'E', and 'f', <em>prec</em> is the number of digits after the
decimal point. With 'g' and 'G', <em>prec</em> is the maximum number of
significant digits (trailing zeroes are omitted).
<p> <pre>
    double d = 12.34;
    QString ds = <a href="#QString">QString</a>( "'E' format, precision 3, gives %1" )
                    .arg( d, 0, 'E', 3 );
    // ds == "1.234E+001"
    </pre>
 
<p> <p>See also <a href="#setNum">setNum</a>().

<h3 class=fn><a name="operator-const-char-*"></a>QString::operator const char * () const
</h3>

<p> Returns <a href="#ascii">ascii</a>(). Be sure to see the warnings documented in the
ascii() function. Note that for new code which you wish to be
strictly Unicode-clean, you can define the macro <tt>QT_NO_ASCII_CAST</tt> when compiling your code to hide this function so
that automatic casts are not done. This has the added advantage
that you catch the programming error described in <a href="#operator!">operator!</a>().

<h3 class=fn><a name="operator-std::string"></a>QString::operator std::string () const
</h3>

<p> Returns <a href="#ascii">ascii</a>() as a std::string. 
<p> <b>Warning:</b> The function may cause an application to crash if a static C run-time is in use. 
This can happen in Microsoft Visual C++ if Qt is configured as single-threaded. A safe   
alternative is to call ascii() directly and construct a std::string manually.    

<h3 class=fn>bool <a name="operator!"></a>QString::operator! () const
</h3>

<p> Returns TRUE if this is a null string; otherwise returns FALSE.
<p> <pre>
        QString name = getName();
        if ( !name )
            name = "Rodney";
    </pre>
 
<p> Note that if you say
<p> <pre>
        QString name = getName();
        if ( name )
            doSomethingWith(name);
    </pre>
 
<p> It will call "operator const char*()", which is inefficent; you
may wish to define the macro <tt>QT_NO_ASCII_CAST</tt> when writing code
which you wish to remain Unicode-clean.
<p> When you want the above semantics, use:
<p> <pre>
        QString name = getName();
        if ( !name.<a href="#isNull">isNull</a>() )
            doSomethingWith(name);
    </pre>
 
<p> <p>See also <a href="#isEmpty">isEmpty</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq"></a>QString::operator+= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>
Appends <em>str</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq-2"></a>QString::operator+= ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;str )
</h3>

This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq-3"></a>QString::operator+= ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq-4"></a>QString::operator+= ( const&nbsp;std::string&nbsp;&amp;&nbsp;str )
</h3>

This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>str</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq-5"></a>QString::operator+= ( <a href="qchar.html">QChar</a>&nbsp;c )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>c</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator+-eq-6"></a>QString::operator+= ( char&nbsp;c )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends <em>c</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq"></a>QString::operator= ( <a href="qchar.html">QChar</a>&nbsp;c )
</h3>

<p> Sets the string to contain just the single character <em>c</em>.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq-2"></a>QString::operator= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns a <a href="shclass.html#shallow-copy">shallow copy</a> of <em>s</em> to this string and returns a
reference to this string. This is very fast because the string
isn't actually copied.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq-3"></a>QString::operator= ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>, interpreted as a classic C string
to this string and returns a reference to this string.
<p> If <em>str</em> is 0, then a null string is created.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq-4"></a>QString::operator= ( const&nbsp;std::string&nbsp;&amp;&nbsp;s )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Makes a <a href="shclass.html#deep-copy">deep copy</a> of <em>s</em> and returns a reference to the deep
copy.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq-5"></a>QString::operator= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;cstr )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns a <a href="shclass.html#deep-copy">deep copy</a> of <em>cstr</em>, interpreted as a classic C
string, to this string. Returns a reference to this string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="operator-eq-6"></a>QString::operator= ( char&nbsp;c )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to contain just the single character <em>c</em>.

<h3 class=fn><a href="qchar.html">QChar</a> <a name="operator[]"></a>QString::operator[] ( int&nbsp;i ) const
</h3>

<p> Returns the character at index <em>i</em>, or QChar::null if <em>i</em> is
beyond the length of the string.
<p> If the QString is not const (i.e., const QString) or const&amp;
(i.e., const QString&amp;), then the non-const overload of operator[]
will be used instead.

<h3 class=fn><a href="qcharref.html">QCharRef</a> <a name="operator[]-2"></a>QString::operator[] ( int&nbsp;i )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> The function returns a reference to the character at index <em>i</em>.
The resulting reference can then be assigned to, or used
immediately, but it will become invalid once further modifications
are made to the original string.
<p> If <em>i</em> is beyond the length of the string then the string is
expanded with QChar::nulls, so that the <a href="qcharref.html">QCharRef</a> references a
valid (null) character in the string.
<p> The QCharRef internal class can be used much like a constant
<a href="qchar.html">QChar</a>, but if you assign to it, you change the original string
(which will detach itself because of QString's copy-on-write
semantics). You will get compilation errors if you try to use the
result as anything but a QChar.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend"></a>QString::prepend ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>

<p> Inserts <em>s</em> at the beginning of the string and returns a
reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>s</em>).
<p> <pre>
        QString string = "42";
        string.<a href="#prepend">prepend</a>( "The answer is " );
        // string == "The answer is 42"
    </pre>
 
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend-2"></a>QString::prepend ( char&nbsp;ch )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>ch</em> at the beginning of the string and returns a
reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>ch</em>).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend-3"></a>QString::prepend ( <a href="qchar.html">QChar</a>&nbsp;ch )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>ch</em> at the beginning of the string and returns a
reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>ch</em>).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend-4"></a>QString::prepend ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;s )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>s</em> at the beginning of the string and returns a reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>s</em>).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend-5"></a>QString::prepend ( const&nbsp;char&nbsp;*&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>s</em> at the beginning of the string and returns a reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>s</em>).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="prepend-6"></a>QString::prepend ( const&nbsp;std::string&nbsp;&amp;&nbsp;s )
</h3> 
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>s</em> at the beginning of the string and returns a reference to the string.
<p> Equivalent to <a href="#insert">insert</a>(0, <em>s</em>).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qchar.html">QChar</a>&nbsp;&amp; <a name="ref"></a>QString::ref ( uint&nbsp;i )
</h3>

<p> Returns the <a href="qchar.html">QChar</a> at index <em>i</em> by reference, expanding the string
with QChar::null if necessary. The resulting reference can be
assigned to, or otherwise used immediately, but becomes invalid
once furher modifications are made to the string.
<p> <pre>
        QString string("ABCDEF");
        <a href="qchar.html">QChar</a> ch = string.<a href="#ref">ref</a>( 3 );         // ch == 'D'
    </pre>
 
<p> <p>See also <a href="#constref">constref</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove"></a>QString::remove ( uint&nbsp;index, uint&nbsp;len )
</h3>
Removes <em>len</em> characters from the string starting at position <em>index</em>, and returns a reference to the string.
<p> If <em>index</em> is beyond the length of the string, nothing happens.
If <em>index</em> is within the string, but <em>index</em> + <em>len</em> is beyond
the end of the string, the string is truncated at position <em>index</em>.
<p> <pre>
        QString string( "Montreal" );
        string.<a href="#remove">remove</a>( 1, 4 );      // string == "Meal"
    </pre>
 
<p> <p>See also <a href="#insert">insert</a>() and <a href="#replace">replace</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove-2"></a>QString::remove ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, bool&nbsp;cs = TRUE )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes every occurrence of <em>str</em> in the string. Returns a
reference to the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> This is the same as <a href="#replace">replace</a>(<em>str</em>, "", <em>cs</em>).

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove-3"></a>QString::remove ( <a href="qchar.html">QChar</a>&nbsp;c )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes every occurrence of the character <em>c</em> in the string.
Returns a reference to the string.
<p> This is the same as <a href="#replace">replace</a>(<em>c</em>, "").

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove-4"></a>QString::remove ( char&nbsp;c )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Removes every occurrence of the character <em>c</em> in the string.
Returns a reference to the string.
<p> This is the same as <a href="#replace">replace</a>(<em>c</em>, "").

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove-5"></a>QString::remove ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes every occurrence of <em>str</em> in the string. Returns a
reference to the string.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="remove-6"></a>QString::remove ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes every occurrence of the <a href="qregexp.html#regular-expression">regular expression</a> <em>rx</em> in the
string. Returns a reference to the string.
<p> This is the same as <a href="#replace">replace</a>(<em>rx</em>, "").

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace"></a>QString::replace ( uint&nbsp;index, uint&nbsp;len, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>
Replaces <em>len</em> characters from the string with <em>s</em>, starting at
position <em>index</em>, and returns a reference to the string.
<p> If <em>index</em> is beyond the length of the string, nothing is deleted
and <em>s</em> is appended at the end of the string. If <em>index</em> is
valid, but <em>index</em> + <em>len</em> is beyond the end of the string,
the string is truncated at position <em>index</em>, then <em>s</em> is
appended at the end.
<p> <pre>
        QString string( "Say yes!" );
        string = string.<a href="#replace">replace</a>( 4, 3, "NO" );
        // string == "Say NO!"
    </pre>
 
<p> <b>Warning:</b> Qt 3.3.3 and earlier had different semantics for the
case <em>index</em> >= <a href="#length">length</a>(), which contradicted the documentation.
To avoid portability problems between Qt 3 versions and with Qt
4, we recommend that you never call the function with <em>index</em> >=
length().
<p> <p>See also <a href="#insert">insert</a>() and <a href="#remove">remove</a>().

<p>Examples: <a href="listviews-example.html#x162">listviews/listviews.cpp</a>, <a href="networkprotocol-example.html#x694">network/networkprotocol/nntp.cpp</a>, <a href="qmag-example.html#x1794">qmag/qmag.cpp</a>, and <a href="regexptester-example.html#x2497">regexptester/regexptester.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-2"></a>QString::replace ( uint&nbsp;index, uint&nbsp;len, const&nbsp;<a href="qchar.html">QChar</a>&nbsp;*&nbsp;s, uint&nbsp;slen )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces <em>len</em> characters with <em>slen</em> characters of <a href="qchar.html">QChar</a> data
from <em>s</em>, starting at position <em>index</em>, and returns a reference
to the string.
<p> <p>See also <a href="#insert">insert</a>() and <a href="#remove">remove</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-3"></a>QString::replace ( uint&nbsp;index, uint&nbsp;len, <a href="qchar.html">QChar</a>&nbsp;c )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This is the same as <a href="#replace">replace</a>(<em>index</em>, <em>len</em>, QString(<em>c</em>)).

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-4"></a>QString::replace ( uint&nbsp;index, uint&nbsp;len, char&nbsp;c )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> This is the same as <a href="#replace">replace</a>(<em>index</em>, <em>len</em>, <a href="qchar.html">QChar</a>(<em>c</em>)).

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-5"></a>QString::replace ( <a href="qchar.html">QChar</a>&nbsp;c, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of the character <em>c</em> in the string
with <em>after</em>. Returns a reference to the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> Example:
<pre>
    QString s = "a,b,c";
    s.<a href="#replace">replace</a>( QChar(','), " or " );
    // s == "a or b or c"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-6"></a>QString::replace ( char&nbsp;c, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Replaces every occurrence of the character <em>c</em> in the string
with <em>after</em>. Returns a reference to the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-7"></a>QString::replace ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;before, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;after, bool&nbsp;cs = TRUE )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of the string <em>before</em> in the string
with the string <em>after</em>. Returns a reference to the string.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> Example:
<pre>
    QString s = "Greek is Greek";
    s.<a href="#replace">replace</a>( "Greek", "English" );
    // s == "English is English"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-8"></a>QString::replace ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;after )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of the regexp <em>rx</em> in the string with
<em>after</em>. Returns a reference to the string. For example:
<pre>
    QString s = "banana";
    s.<a href="#replace">replace</a>( QRegExp("an"), "" );
    // s == "ba"
  </pre>
 
<p> For regexps containing <a href="qregexp.html#capturing-text">capturing
  parentheses</a>, occurrences of <b>&#92;1</b>, <b>&#92;2</b>, ...,
in <em>after</em> are replaced with <em>rx</em>.cap(1), cap(2), ...
<p> <pre>
    QString t = "A &lt;i&gt;bon mot&lt;/i&gt;.";
    t.<a href="#replace">replace</a>( QRegExp("&lt;i&gt;([^&lt;]*)&lt;/i&gt;"), "\\emph{\\1}" );
    // t == "A \\emph{bon mot}."
  </pre>
 
<p> <p>See also <a href="#find">find</a>(), <a href="#findRev">findRev</a>(), and <a href="qregexp.html#cap">QRegExp::cap</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="replace-9"></a>QString::replace ( <a href="qchar.html">QChar</a>&nbsp;c1, <a href="qchar.html">QChar</a>&nbsp;c2 )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of <em>c1</em> with the char <em>c2</em>. Returns a
reference to the string.

<h3 class=fn>void <a name="reserve"></a>QString::reserve ( uint&nbsp;minCapacity )
</h3>
Ensures that at least <em>minCapacity</em> characters are allocated to
the string.
<p> This function is useful for code that needs to build up a long
string and wants to avoid repeated reallocation. In this example,
we want to add to the string until some condition is true, and
we're fairly sure that size is big enough:
<pre>
        QString result;
        int len = 0;
        result.<a href="#reserve">reserve</a>(maxLen);
        while (...) {
            result[len++] = ...         // fill part of the space
        }
        result.<a href="#squeeze">squeeze</a>();
    </pre>
 
<p> If <em>maxLen</em> is an underestimate, the worst that will happen is
that the loop will slow down.
<p> If it is not possible to allocate enough memory, the string
remains unchanged.
<p> <p>See also <a href="#capacity">capacity</a>(), <a href="#squeeze">squeeze</a>(), and <a href="#setLength">setLength</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="right"></a>QString::right ( uint&nbsp;len ) const
</h3>
Returns a string that contains the <em>len</em> rightmost characters of
the string.
<p> If <em>len</em> is greater than the length of the string then the whole
string is returned.
<p> <pre>
        QString string( "Pineapple" );
        QString t = string.<a href="#right">right</a>( 5 );   // t == "apple"
    </pre>
 
<p> <p>See also <a href="#left">left</a>(), <a href="#mid">mid</a>(), and <a href="#isEmpty">isEmpty</a>().

<p>Example: <a href="fileiconview-example.html#x871">fileiconview/qfileiconview.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="rightJustify"></a>QString::rightJustify ( uint&nbsp;width, <a href="qchar.html">QChar</a>&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const
</h3>
Returns a string of length <em>width</em> that contains the <em>fill</em>
character followed by the string.
<p> If <em>truncate</em> is FALSE and the length of the string is more than
<em>width</em>, then the returned string is a copy of the string.
<p> If <em>truncate</em> is TRUE and the length of the string is more than
<em>width</em>, then the resulting string is truncated at position <em>width</em>.
<p> <pre>
        QString string( "apple" );
        QString t = string.<a href="#rightJustify">rightJustify</a>( 8, '.' );  // t == "...apple"
    </pre>
 
<p> <p>See also <a href="#leftJustify">leftJustify</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="section"></a>QString::section ( <a href="qchar.html">QChar</a>&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const
</h3>

<p> This function returns a section of the string.
<p> This string is treated as a sequence of fields separated by the
character, <em>sep</em>. The returned string consists of the fields from
position <em>start</em> to position <em>end</em> inclusive. If <em>end</em> is not
specified, all fields from position <em>start</em> to the end of the
string are included. Fields are numbered 0, 1, 2, etc., counting
from the left, and -1, -2, etc., counting from right to left.
<p> The <em>flags</em> argument can be used to affect some aspects of the
function's behaviour, e.g. whether to be case sensitive, whether
to skip empty fields and how to deal with leading and trailing
separators; see <a href="#SectionFlags-enum">SectionFlags</a>.
<p> <pre>
    QString csv( "forename,middlename,surname,phone" );
    QString s = csv.<a href="#section">section</a>( ',', 2, 2 );   // s == "surname"

    QString path( "/usr/local/bin/myapp" ); // First field is empty
    QString s = path.<a href="#section">section</a>( '/', 3, 4 );  // s == "bin/myapp"
    QString s = path.<a href="#section">section</a>( '/', 3, 3, SectionSkipEmpty ); // s == "myapp"
    </pre>
 
<p> If <em>start</em> or <em>end</em> is negative, we count fields from the right
of the string, the right-most field being -1, the one from
right-most field being -2, and so on.
<p> <pre>
    QString csv( "forename,middlename,surname,phone" );
    QString s = csv.<a href="#section">section</a>( ',', -3, -2 );  // s == "middlename,surname"

    QString path( "/usr/local/bin/myapp" ); // First field is empty
    QString s = path.<a href="#section">section</a>( '/', -1 ); // s == "myapp"
    </pre>
 
<p> <p>See also <a href="qstringlist.html#split">QStringList::split</a>().

<p>Examples: <a href="tutorial2-03.html#x2551">chart/element.cpp</a> and <a href="ftpclient-example.html#x772">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="section-2"></a>QString::section ( char&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qstring.html">QString</a> <a name="section-3"></a>QString::section ( const&nbsp;char&nbsp;*&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qstring.html">QString</a> <a name="section-4"></a>QString::section ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;sep, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This function returns a section of the string.
<p> This string is treated as a sequence of fields separated by the
string, <em>sep</em>. The returned string consists of the fields from
position <em>start</em> to position <em>end</em> inclusive. If <em>end</em> is not
specified, all fields from position <em>start</em> to the end of the
string are included. Fields are numbered 0, 1, 2, etc., counting
from the left, and -1, -2, etc., counting from right to left.
<p> The <em>flags</em> argument can be used to affect some aspects of the
function's behaviour, e.g. whether to be case sensitive, whether
to skip empty fields and how to deal with leading and trailing
separators; see <a href="#SectionFlags-enum">SectionFlags</a>.
<p> <pre>
    QString data( "forename**middlename**surname**phone" );
    QString s = data.<a href="#section">section</a>( "**", 2, 2 ); // s == "surname"
    </pre>
 
<p> If <em>start</em> or <em>end</em> is negative, we count fields from the right
of the string, the right-most field being -1, the one from
right-most field being -2, and so on.
<p> <pre>
    QString data( "forename**middlename**surname**phone" );
    QString s = data.<a href="#section">section</a>( "**", -3, -2 ); // s == "middlename**surname"
    </pre>
 
<p> <p>See also <a href="qstringlist.html#split">QStringList::split</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="section-5"></a>QString::section ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;reg, int&nbsp;start, int&nbsp;end = 0xffffffff, int&nbsp;flags = SectionDefault ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This function returns a section of the string.
<p> This string is treated as a sequence of fields separated by the
<a href="qregexp.html#regular-expression">regular expression</a>, <em>reg</em>. The returned string consists of the
fields from position <em>start</em> to position <em>end</em> inclusive. If <em>end</em> is not specified, all fields from position <em>start</em> to the end
of the string are included. Fields are numbered 0, 1, 2, etc., counting
from the left, and -1, -2, etc., counting from right to left.
<p> The <em>flags</em> argument can be used to affect some aspects of the
function's behaviour, e.g. whether to be case sensitive, whether
to skip empty fields and how to deal with leading and trailing
separators; see <a href="#SectionFlags-enum">SectionFlags</a>.
<p> <pre>
    QString line( "forename\tmiddlename  surname \t \t phone" );
    <a href="qregexp.html">QRegExp</a> sep( "\s+" );
    QString s = line.<a href="#section">section</a>( sep, 2, 2 ); // s == "surname"
    </pre>
 
<p> If <em>start</em> or <em>end</em> is negative, we count fields from the right
of the string, the right-most field being -1, the one from
right-most field being -2, and so on.
<p> <pre>
    QString line( "forename\tmiddlename  surname \t \t phone" );
    <a href="qregexp.html">QRegExp</a> sep( "\\s+" );
    QString s = line.<a href="#section">section</a>( sep, -3, -2 ); // s == "middlename  surname"
    </pre>
 
<p> <b>Warning:</b> Using this <a href="qregexp.html">QRegExp</a> version is much more expensive than
the overloaded string and character versions.
<p> <p>See also <a href="qstringlist.html#split">QStringList::split</a>() and <a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setAscii"></a>QString::setAscii ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;len = -1 )
</h3>
Sets this string to <em>str</em>, interpreted as a classic 8-bit ASCII C
string. If <em>len</em> is -1 (the default), then it is set to
strlen(str).
<p> If <em>str</em> is 0 a null string is created. If <em>str</em> is "", an empty
string is created.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>void <a name="setExpand"></a>QString::setExpand ( uint&nbsp;index, <a href="qchar.html">QChar</a>&nbsp;c )
</h3> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Sets the character at position <em>index</em> to <em>c</em> and expands the
string if necessary, filling with spaces.
<p> This method is redundant in Qt 3.x, because operator[] will expand
the string as necessary.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setLatin1"></a>QString::setLatin1 ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;len = -1 )
</h3>
Sets this string to <em>str</em>, interpreted as a classic Latin-1 C
string. If <em>len</em> is -1 (the default), then it is set to
strlen(str).
<p> If <em>str</em> is 0 a null string is created. If <em>str</em> is "", an empty
string is created.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>void <a name="setLength"></a>QString::setLength ( uint&nbsp;newLen )
</h3>
Ensures that at least <em>newLen</em> characters are allocated to the
string, and sets the length of the string to <em>newLen</em>. Any new
space allocated contains arbitrary data.
<p> <p>See also <a href="#reserve">reserve</a>() and <a href="#truncate">truncate</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum"></a>QString::setNum ( Q_LLONG&nbsp;n, int&nbsp;base = 10 )
</h3>
Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string. The returned string is in "C" locale.
<p> The base is 10 by default and must be between 2 and 36.
<p> <pre>
        QString string;
        string = string.<a href="#setNum">setNum</a>( 1234 );     // string == "1234"
    </pre>
 

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-2"></a>QString::setNum ( short&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string.
<p> The base is 10 by default and must be between 2 and 36.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-3"></a>QString::setNum ( ushort&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string.
<p> The base is 10 by default and must be between 2 and 36.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-4"></a>QString::setNum ( int&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string.
<p> The base is 10 by default and must be between 2 and 36.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-5"></a>QString::setNum ( uint&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string.
<p> The base is 10 by default and must be between 2 and 36.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-6"></a>QString::setNum ( long&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-7"></a>QString::setNum ( ulong&nbsp;n, int&nbsp;base = 10 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-8"></a>QString::setNum ( Q_ULLONG&nbsp;n, int&nbsp;base = 10 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em> in base <em>base</em> and
returns a reference to the string.
<p> The base is 10 by default and must be between 2 and 36.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-9"></a>QString::setNum ( float&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em>, formatted in format
<em>f</em> with precision <em>prec</em>, and returns a reference to the
string.
<p> The format <em>f</em> can be 'f', 'F', 'e', 'E', 'g' or 'G'. See <a href="#arg-formats">arg</a>() for an explanation of the formats.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setNum-a"></a>QString::setNum ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the printed value of <em>n</em>, formatted in format
<em>f</em> with precision <em>prec</em>, and returns a reference to the
string.
<p> The format <em>f</em> can be 'f', 'F', 'e', 'E', 'g' or 'G'. See <a href="#arg-formats">arg</a>() for an explanation of the formats.

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setUnicode"></a>QString::setUnicode ( const&nbsp;<a href="qchar.html">QChar</a>&nbsp;*&nbsp;unicode, uint&nbsp;len )
</h3>
Resizes the string to <em>len</em> characters and copies <em>unicode</em> into
the string. If <em>unicode</em> is 0, nothing is copied, but the
string is still resized to <em>len</em>. If <em>len</em> is zero, then the
string becomes a <a href="#isNull">null</a> string.
<p> <p>See also <a href="#setLatin1">setLatin1</a>() and <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="setUnicodeCodes"></a>QString::setUnicodeCodes ( const&nbsp;ushort&nbsp;*&nbsp;unicode_as_ushorts, uint&nbsp;len )
</h3>
Resizes the string to <em>len</em> characters and copies <em>unicode_as_ushorts</em> into the string (on some X11 client platforms
this will involve a byte-swapping pass).
<p> If <em>unicode_as_ushorts</em> is 0, nothing is copied, but the string
is still resized to <em>len</em>. If <em>len</em> is zero, the string becomes
a <a href="#isNull">null</a> string.
<p> <p>See also <a href="#setLatin1">setLatin1</a>() and <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="simplifyWhiteSpace"></a>QString::simplifyWhiteSpace () const
</h3>
Returns a string that has whitespace removed from the start and
the end, and which has each sequence of internal whitespace
replaced with a single space.
<p> Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns
TRUE. This includes Unicode characters with decimal values 9
(TAB), 10 (LF), 11 (VT), 12 (FF), 13 (CR), and 32 (Space).
<p> <pre>
        QString string = "  lots\t of\nwhite    space ";
        QString t = string.<a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>();
        // t == "lots of white space"
    </pre>
 
<p> <p>See also <a href="#stripWhiteSpace">stripWhiteSpace</a>().

<h3 class=fn><a href="qstring.html">QString</a>&nbsp;&amp; <a name="sprintf"></a>QString::sprintf ( const&nbsp;char&nbsp;*&nbsp;cformat, ... )
</h3>
Safely builds a formatted string from the format string <em>cformat</em>
and an arbitrary list of arguments. The format string supports all
the escape sequences of printf() in the standard C library.
<p> The %s escape sequence expects a <a href="#utf8">utf8</a>() encoded string. The format
string <em>cformat</em> is expected to be in latin1. If you need a
Unicode format string, use <a href="#arg">arg</a>() instead. For typesafe string
building, with full Unicode support, you can use <a href="qtextostream.html">QTextOStream</a> like
this:
<p> <pre>
        QString str;
        QString s = ...;
        int x = ...;
        QTextOStream( &amp;str ) &lt;&lt; s &lt;&lt; " : " &lt;&lt; x;
    </pre>
 
<p> For <a href="qobject.html#tr">translations,</a> especially if the
strings contains more than one escape sequence, you should
consider using the arg() function instead. This allows the order
of the replacements to be controlled by the translator, and has
Unicode support.
<p> The %lc escape sequence expects a unicode character of type ushort
(as returned by <a href="qchar.html#unicode">QChar::unicode</a>()).
The %ls escape sequence expects a pointer to a zero-terminated
array of unicode characters of type ushort (as returned by
<a href="#ucs2">QString::ucs2</a>()).
<p> <p>See also <a href="#arg">arg</a>().

<p>Examples: <a href="dclock-example.html#x1103">dclock/dclock.cpp</a>, <a href="forever-example.html#x1052">forever/forever.cpp</a>, <a href="layout-example.html#x542">layout/layout.cpp</a>, <a href="qmag-example.html#x1795">qmag/qmag.cpp</a>, <a href="scrollview-example.html#x656">scrollview/scrollview.cpp</a>, <a href="tooltip-example.html#x449">tooltip/tooltip.cpp</a>, and <a href="xform-example.html#x1265">xform/xform.cpp</a>.
<h3 class=fn>void <a name="squeeze"></a>QString::squeeze ()
</h3>
Squeezes the string's capacity to the current content.
<p> <p>See also <a href="#capacity">capacity</a>() and <a href="#reserve">reserve</a>().

<h3 class=fn>bool <a name="startsWith"></a>QString::startsWith ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s, bool&nbsp;cs = TRUE ) const
</h3>
Returns TRUE if the string starts with <em>s</em>; otherwise returns
FALSE.
<p> If <em>cs</em> is TRUE (the default), the search is case sensitive;
otherwise the search is case insensitive.
<p> <pre>
        QString str( "Bananas" );
        str.<a href="#startsWith">startsWith</a>( "Ban" );     // returns TRUE
        str.<a href="#startsWith">startsWith</a>( "Car" );     // returns FALSE
    </pre>
 
<p> <p>See also <a href="#endsWith">endsWith</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="stripWhiteSpace"></a>QString::stripWhiteSpace () const
</h3>
Returns a string that has whitespace removed from the start and
the end.
<p> Whitespace means any character for which <a href="qchar.html#isSpace">QChar::isSpace</a>() returns
TRUE. This includes Unicode characters with decimal values 9
(TAB), 10 (LF), 11 (VT), 12 (FF), 13 (CR) and 32 (Space), and may
also include other Unicode characters.
<p> <pre>
        QString string = "   white space   ";
        QString s = string.<a href="#stripWhiteSpace">stripWhiteSpace</a>();       // s == "white space"
    </pre>
 
<p> <p>See also <a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>().

<h3 class=fn>double <a name="toDouble"></a>QString::toDouble ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>double</tt> value.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> <pre>
        QString string( "1234.56" );
        double a = string.<a href="#toDouble">toDouble</a>();   // a == 1234.56
    </pre>
 
<p> The string-to-number functions:
<ul>
<li> <a href="#toShort">toShort</a>()
<li> <a href="#toUShort">toUShort</a>()
<li> <a href="#toInt">toInt</a>()
<li> <a href="#toUInt">toUInt</a>()
<li> <a href="#toLong">toLong</a>()
<li> <a href="#toULong">toULong</a>()
<li> <a href="#toLongLong">toLongLong</a>()
<li> <a href="#toULongLong">toULongLong</a>()
<li> <a href="#toFloat">toFloat</a>()
<li> <a href="#toDouble">toDouble</a>()
</ul>
can handle numbers
represented in various locales. These representations may use different
characters for the decimal point, thousands group sepearator
and even individual digits. QString's functions try to interpret
the string according to the current locale. The current locale is
determined from the system at application startup and can be changed
by calling <a href="qlocale.html#setDefault">QLocale::setDefault</a>(). If the string cannot be interpreted
according to the current locale, this function falls back
on the "C" locale.
<p> <pre>
        bool ok;
        double d;

        QLocale::<a href="qlocale.html#setDefault">setDefault</a>(QLocale::C);
        d = <a href="#QString">QString</a>( "1234,56" ).toDouble(&amp;ok); // ok == false
        d = <a href="#QString">QString</a>( "1234.56" ).toDouble(&amp;ok); // ok == true, d == 1234.56

        QLocale::<a href="qlocale.html#setDefault">setDefault</a>(QLocale::German);
        d = <a href="#QString">QString</a>( "1234,56" ).toDouble(&amp;ok); // ok == true, d == 1234.56
        d = <a href="#QString">QString</a>( "1234.56" ).toDouble(&amp;ok); // ok == true, d == 1234.56
    </pre>
 
<p> Due to the ambiguity between the decimal point and thousands group
separator in various locales, these functions do not handle
thousands group separators. If you need to convert such numbers,
use the corresponding function in <a href="qlocale.html">QLocale</a>.
<p> <pre>
        bool ok;
        QLocale::<a href="qlocale.html#setDefault">setDefault</a>(QLocale::C);
        double d = <a href="#QString">QString</a>( "1,234,567.89" ).toDouble(&amp;ok); // ok == false
    </pre>
 
<p> <b>Warning:</b> If the string contains trailing whitespace this function
will fail, and set <em>*ok</em> to false if <em>ok</em> is not 0. Leading
whitespace is ignored.
<p> <p>See also <a href="#number">number</a>(), <a href="qlocale.html#setDefault">QLocale::setDefault</a>(), <a href="qlocale.html#toDouble">QLocale::toDouble</a>(), and <a href="#stripWhiteSpace">stripWhiteSpace</a>().

<h3 class=fn>float <a name="toFloat"></a>QString::toFloat ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>float</tt> value.
<p> Returns 0.0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <b>Warning:</b> If the string contains trailing whitespace this function
will fail, settings <em>*ok</em> to false if <em>ok</em> is not 0.
Leading whitespace is ignored.
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>int <a name="toInt"></a>QString::toInt ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to an <tt>int</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> <pre>
        QString str( "FF" );
        bool ok;
        int hex = str.<a href="#toInt">toInt</a>( &amp;ok, 16 );     // hex == 255, ok == TRUE
        int dec = str.<a href="#toInt">toInt</a>( &amp;ok, 10 );     // dec == 0, ok == FALSE
    </pre>
 
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>long <a name="toLong"></a>QString::toLong ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to a <tt>long</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>Q_LLONG <a name="toLongLong"></a>QString::toLongLong ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to a <tt>long long</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>short <a name="toShort"></a>QString::toShort ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to a <tt>short</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>uint <a name="toUInt"></a>QString::toUInt ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to an <tt>unsigned int</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>ulong <a name="toULong"></a>QString::toULong ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to an <tt>unsigned long</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>Q_ULLONG <a name="toULongLong"></a>QString::toULongLong ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to an <tt>unsigned long long</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>ushort <a name="toUShort"></a>QString::toUShort ( bool&nbsp;*&nbsp;ok = 0, int&nbsp;base = 10 ) const
</h3>
Returns the string converted to an <tt>unsigned short</tt> using base <em>base</em>, which is 10 by default and must be between 2 and 36 or 0. If
<em>base</em> is 0, the base is determined automatically using the
following rules:
<ul>
<li>If the string begins with "0x", it is assumed to
be hexadecimal;
<li>If it begins with "0", it is assumed to be octal;
<li>Otherwise it is assumed to be decimal.
</ul>
<p> Returns 0 if the conversion fails.
<p> If <em>ok</em> is not 0: if a conversion error occurs, <em>*ok</em> is set to
FALSE; otherwise <em>*ok</em> is set to TRUE.
<p> Leading and trailing whitespace is ignored by this function.
<p> For information on how string-to-number functions in QString handle
localized input, see <a href="#toDouble">toDouble</a>().
<p> <p>See also <a href="#number">number</a>().

<h3 class=fn>void <a name="truncate"></a>QString::truncate ( uint&nbsp;newLen )
</h3>
If <em>newLen</em> is less than the length of the string, then the
string is truncated at position <em>newLen</em>. Otherwise nothing
happens.
<p> <pre>
        QString s = "truncate me";
        s.<a href="#truncate">truncate</a>( 5 );            // s == "trunc"
    </pre>
 
<p> <p>See also <a href="#setLength">setLength</a>().

<p>Example: <a href="mail-example.html#x718">network/mail/smtp.cpp</a>.
<h3 class=fn>const unsigned short * <a name="ucs2"></a>QString::ucs2 () const
</h3>
Returns the QString as a zero terminated array of unsigned shorts
if the string is not null; otherwise returns zero.
<p> The result remains valid so long as one unmodified
copy of the source string exists.

<p>Example: <a href="activeqt-dotnet.html#x2467">dotnet/wrapper/lib/tools.cpp</a>.
<h3 class=fn>const&nbsp;<a href="qchar.html">QChar</a>&nbsp;* <a name="unicode"></a>QString::unicode () const
</h3>

<p> Returns the Unicode representation of the string. The result
remains valid until the string is modified.

<h3 class=fn><a href="qstring.html">QString</a> <a name="upper"></a>QString::upper () const
</h3>
Returns an uppercase copy of the string.
<p> <pre>
        QString string( "TeXt" );
        str = string.<a href="#upper">upper</a>();     // t == "TEXT"
    </pre>
 
<p> <p>See also <a href="#lower">lower</a>().

<p>Examples: <a href="scribble-example.html#x942">scribble/scribble.cpp</a> and <a href="sql.html#x2240">sql/overview/custom1/main.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="utf8"></a>QString::utf8 () const
</h3>
Returns the string encoded in UTF-8 format.
<p> See <a href="qtextcodec.html">QTextCodec</a> for more diverse coding/decoding of Unicode strings.
<p> <p>See also <a href="#fromUtf8">fromUtf8</a>(), <a href="#ascii">ascii</a>(), <a href="#latin1">latin1</a>(), and <a href="#local8Bit">local8Bit</a>().

<p>Example: <a href="archivesearch-example.html#x483">network/archivesearch/archivedialog.ui.h</a>.
<hr><h2>Related Functions</h2>
<h3 class=fn>bool <a name="operator!-eq"></a>operator!= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is not equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) != 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator!-eq-2"></a>operator!= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is not equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) != 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator!-eq-3"></a>operator!= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is not equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) != 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>const&nbsp;<a href="qstring.html">QString</a> <a name="operator+"></a>operator+ ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns a string which is the result of concatenating the string
<em>s1</em> and the string <em>s2</em>.
<p> Equivalent to <em>s1</em>.<a href="#append">append</a>(<em>s2</em>).

<h3 class=fn>const&nbsp;<a href="qstring.html">QString</a> <a name="operator+-2"></a>operator+ ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which is the result of concatenating the string
<em>s1</em> and character <em>s2</em>.
<p> Equivalent to <em>s1</em>.<a href="#append">append</a>(<em>s2</em>).

<h3 class=fn>const&nbsp;<a href="qstring.html">QString</a> <a name="operator+-3"></a>operator+ ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which is the result of concatenating the
character <em>s1</em> and string <em>s2</em>.

<h3 class=fn>const&nbsp;<a href="qstring.html">QString</a> <a name="operator+-4"></a>operator+ ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s, char&nbsp;c )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which is the result of concatenating the string
<em>s</em> and character <em>c</em>.
<p> Equivalent to <em>s</em>.<a href="#append">append</a>(<em>c</em>).

<h3 class=fn>const&nbsp;<a href="qstring.html">QString</a> <a name="operator+-5"></a>operator+ ( char&nbsp;c, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which is the result of concatenating the
character <em>c</em> and string <em>s</em>.
<p> Equivalent to <em>s</em>.<a href="#prepend">prepend</a>(<em>c</em>).

<h3 class=fn>bool <a name="operator-lt"></a>operator&lt; ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is lexically less than <em>s2</em>; otherwise returns FALSE.
The comparison is case sensitive.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &lt; 0.

<h3 class=fn>bool <a name="operator-lt-2"></a>operator&lt; ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is lexically less than <em>s2</em>; otherwise returns FALSE.
The comparison is case sensitive.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &lt; 0.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt"></a>operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>

<p> Writes the string <em>str</em> to the stream <em>s</em>.
<p> See also <a href="datastreamformat.html">Format of the QDataStream operators</a>

<h3 class=fn>bool <a name="operator-lt-eq"></a>operator&lt;= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is lexically less than or equal to <em>s2</em>;
otherwise returns FALSE.
The comparison is case sensitive.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>,<em>s2</em>) &lt;= 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-lt-eq-2"></a>operator&lt;= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is lexically less than or equal to <em>s2</em>;
otherwise returns FALSE.
The comparison is case sensitive.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &lt;= 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-eq-eq"></a>operator== ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) == 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-eq-eq-2"></a>operator== ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) == 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-eq-eq-3"></a>operator== ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is equal to <em>s2</em>; otherwise returns FALSE.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) == 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-gt"></a>operator&gt; ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is lexically greater than <em>s2</em>; otherwise
returns FALSE.
The comparison is case sensitive.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &gt; 0.

<h3 class=fn>bool <a name="operator-gt-2"></a>operator&gt; ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is lexically greater than <em>s2</em>; otherwise
returns FALSE.
The comparison is case sensitive.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &gt; 0.

<h3 class=fn>bool <a name="operator-gt-eq"></a>operator&gt;= ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is lexically greater than or equal to <em>s2</em>;
otherwise returns FALSE.
The comparison is case sensitive.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &gt;= 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="operator-gt-eq-2"></a>operator&gt;= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is lexically greater than or equal to <em>s2</em>;
otherwise returns FALSE.
The comparison is case sensitive.
Note that a null string is not equal to a not-null empty string.
<p> Equivalent to <a href="#compare">compare</a>(<em>s1</em>, <em>s2</em>) &gt;= 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#isEmpty">isEmpty</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>

<p> Reads a string from the stream <em>s</em> into string <em>str</em>.
<p> See also <a href="datastreamformat.html">Format of the QDataStream operators</a>

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
