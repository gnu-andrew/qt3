<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/doc/qvaluelist.doc:41 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QValueList Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QValueList Class Reference</h1>

<p>The QValueList class is a value-based template class that
provides lists.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qvaluelist-h.html">qvaluelist.h</a>&gt;</tt>
<p>Inherited by <a href="qcanvasitemlist.html">QCanvasItemList</a>, <a href="qstringlist.html">QStringList</a>, and <a href="qvaluestack.html">QValueStack</a>.
<p><a href="qvaluelist-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>typedef QValueListIterator&lt;T&gt;&nbsp;<a href="#iterator"><b>iterator</b></a></li>
<li class=fn>typedef QValueListConstIterator&lt;T&gt;&nbsp;<a href="#const_iterator"><b>const_iterator</b></a></li>
<li class=fn>typedef T&nbsp;<a href="#value_type"><b>value_type</b></a></li>
<li class=fn>typedef value_type&nbsp;*&nbsp;<a href="#pointer"><b>pointer</b></a></li>
<li class=fn>typedef const&nbsp;value_type&nbsp;*&nbsp;<a href="#const_pointer"><b>const_pointer</b></a></li>
<li class=fn>typedef value_type&nbsp;&amp;&nbsp;<a href="#reference"><b>reference</b></a></li>
<li class=fn>typedef const&nbsp;value_type&nbsp;&amp;&nbsp;<a href="#const_reference"><b>const_reference</b></a></li>
<li class=fn>typedef size_t&nbsp;<a href="#size_type"><b>size_type</b></a></li>
<li class=fn><a href="#QValueList"><b>QValueList</b></a> ()</li>
<li class=fn><a href="#QValueList-2"><b>QValueList</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn><a href="#QValueList-3"><b>QValueList</b></a> ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn><a href="#~QValueList"><b>~QValueList</b></a> ()</li>
<li class=fn>QValueList&lt;T&gt; &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn>QValueList&lt;T&gt; &amp; <a href="#operator-eq-2"><b>operator=</b></a> ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn>bool <a href="#operator-eq-eq-2"><b>operator==</b></a> ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l ) const</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l ) const</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l ) const</li>
<li class=fn>iterator <a href="#begin-2"><b>begin</b></a> ()</li>
<li class=fn>const_iterator <a href="#begin"><b>begin</b></a> () const</li>
<li class=fn>const_iterator <a href="#constBegin"><b>constBegin</b></a> () const</li>
<li class=fn>iterator <a href="#end"><b>end</b></a> ()</li>
<li class=fn>const_iterator <a href="#end-2"><b>end</b></a> () const</li>
<li class=fn>const_iterator <a href="#constEnd"><b>constEnd</b></a> () const</li>
<li class=fn>iterator <a href="#insert"><b>insert</b></a> ( iterator&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>uint <a href="#remove-2"><b>remove</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>void <a href="#clear"><b>clear</b></a> ()</li>
<li class=fn>QValueList&lt;T&gt; &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>size_type <a href="#size"><b>size</b></a> () const</li>
<li class=fn>bool <a href="#empty"><b>empty</b></a> () const</li>
<li class=fn>void <a href="#push_front"><b>push_front</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>void <a href="#push_back"><b>push_back</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>iterator <a href="#erase"><b>erase</b></a> ( iterator&nbsp;it )</li>
<li class=fn>iterator <a href="#erase-2"><b>erase</b></a> ( iterator&nbsp;first, iterator&nbsp;last )</li>
<li class=fn>reference <a href="#front"><b>front</b></a> ()</li>
<li class=fn>const_reference <a href="#front-2"><b>front</b></a> () const</li>
<li class=fn>reference <a href="#back"><b>back</b></a> ()</li>
<li class=fn>const_reference <a href="#back-2"><b>back</b></a> () const</li>
<li class=fn>void <a href="#pop_front"><b>pop_front</b></a> ()</li>
<li class=fn>void <a href="#pop_back"><b>pop_back</b></a> ()</li>
<li class=fn>void <a href="#insert-2"><b>insert</b></a> ( iterator&nbsp;pos, size_type&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>QValueList&lt;T&gt; <a href="#operator+"><b>operator+</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l ) const</li>
<li class=fn>QValueList&lt;T&gt; &amp; <a href="#operator+-eq"><b>operator+=</b></a> ( const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn>iterator <a href="#fromLast-2"><b>fromLast</b></a> ()</li>
<li class=fn>const_iterator <a href="#fromLast"><b>fromLast</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>iterator <a href="#append"><b>append</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>iterator <a href="#prepend"><b>prepend</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>iterator <a href="#remove"><b>remove</b></a> ( iterator&nbsp;it )</li>
<li class=fn>T &amp; <a href="#first"><b>first</b></a> ()</li>
<li class=fn>const T &amp; <a href="#first-2"><b>first</b></a> () const</li>
<li class=fn>T &amp; <a href="#last"><b>last</b></a> ()</li>
<li class=fn>const T &amp; <a href="#last-2"><b>last</b></a> () const</li>
<li class=fn>T &amp; <a href="#operator[]-2"><b>operator[]</b></a> ( size_type&nbsp;i )</li>
<li class=fn>const T &amp; <a href="#operator[]"><b>operator[]</b></a> ( size_type&nbsp;i ) const</li>
<li class=fn>iterator <a href="#at-2"><b>at</b></a> ( size_type&nbsp;i )</li>
<li class=fn>const_iterator <a href="#at"><b>at</b></a> ( size_type&nbsp;i ) const</li>
<li class=fn>iterator <a href="#find"><b>find</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>const_iterator <a href="#find-2"><b>find</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const</li>
<li class=fn>iterator <a href="#find-3"><b>find</b></a> ( iterator&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>const_iterator <a href="#find-4"><b>find</b></a> ( const_iterator&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x ) const</li>
<li class=fn>int <a href="#findIndex"><b>findIndex</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const</li>
<li class=fn>size_type <a href="#contains"><b>contains</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const</li>
<li class=fn>size_type <a href="#count"><b>count</b></a> () const</li>
<li class=fn>QValueList&lt;T&gt; &amp; <a href="#operator+-eq-2"><b>operator+=</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>typedef QValueListIterator&lt;T&gt;&nbsp;<a href="#Iterator"><b>Iterator</b></a></li>
<li class=fn>typedef QValueListConstIterator&lt;T&gt;&nbsp;<a href="#ConstIterator"><b>ConstIterator</b></a></li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-2"><b>operator&lt;&lt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, const&nbsp;QValueList&lt;T&gt;&nbsp;&amp;&nbsp;l )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QValueList class is a value-based template class that
provides lists.
<p> 




<p> QValueList is a Qt implementation of an STL-like list container.
It can be used in your application if the standard <tt>list</tt> is not
available for your target platform(s). QValueList is part of the
<a href="qtl.html">Qt Template Library</a>.
<p> QValueList&lt;T&gt; defines a template instance to create a list of
values that all have the class T. Note that QValueList does not
store pointers to the members of the list; it holds a copy of
every member. This is why these kinds of classes are called "value
based"; <a href="qptrlist.html">QPtrList</a> and <a href="qdict.html">QDict</a> are "pointer based".
<p> QValueList contains and manages a collection of objects of type T
and provides iterators that allow the contained objects to be
addressed. QValueList owns the contained items. For more relaxed
ownership semantics, see <a href="qptrcollection.html">QPtrCollection</a> and friends which are
pointer-based containers.
<p> Some classes cannot be used within a QValueList, for example, all
classes derived from <a href="qobject.html">QObject</a> and thus all classes that implement
widgets. Only values can be used in a QValueList. To qualify as a
value the class must provide:
<ul>
<li> a copy constructor;
<li> an assignment operator;
<li> a default constructor, i.e. a constructor that does not take any arguments.
</ul>
<p> Note that C++ defaults to field-by-field assignment operators and
copy constructors if no explicit version is supplied. In many
cases this is sufficient.
<p> In addition, some compilers (e.g. Sun CC) might require that the
class provides an equality operator (<a href="#operator-eq-eq">operator==</a>()).
<p> QValueList's function naming is consistent with the other Qt
classes (e.g. <a href="#count">count</a>(), <a href="#isEmpty">isEmpty</a>()). QValueList also provides extra
functions for compatibility with STL algorithms, such as <a href="#size">size</a>()
and <a href="#empty">empty</a>(). Programmers already familiar with the STL <tt>list</tt> may
prefer to use the STL-compatible functions.
<p> Example:
<pre>
    class Employee
    {
    public:
        Employee(): sn(0) {}
        Employee( const <a href="qstring.html">QString</a>&amp; forename, const <a href="qstring.html">QString</a>&amp; surname, int salary )
            : fn(forename), sn(surname), sal(salary)
        {}

        <a href="qstring.html">QString</a> forename() const { return fn; }
        <a href="qstring.html">QString</a> surname() const { return sn; }
        int salary() const { return sal; }
        void setSalary( int salary ) { sal = salary; }

    private:
        <a href="qstring.html">QString</a> fn;
        <a href="qstring.html">QString</a> sn;
        int sal;
    };

    typedef QValueList&lt;Employee&gt; EmployeeList;
    EmployeeList list;

    list.append( Employee("John", "Doe", 50000) );
    list.append( Employee("Jane", "Williams", 80000) );
    list.append( Employee("Tom", "Jones", 60000) );

    Employee mary( "Mary", "Hawthorne", 90000 );
    list.append( mary );
    mary.setSalary( 100000 );

    EmployeeList::<a href="#iterator">iterator</a> it;
    for ( it = list.begin(); it != list.end(); ++it )
        cout &lt;&lt; (*it).surname().latin1() &lt;&lt; ", " &lt;&lt;
                (*it).forename().latin1() &lt;&lt; " earns " &lt;&lt;
                (*it).salary() &lt;&lt; endl;

    // Output:
    // Doe, John earns 50000
    // Williams, Jane earns 80000
    // Hawthorne, Mary earns 90000
    // Jones, Tom earns 60000
    </pre>
 
<p> Notice that the latest changes to Mary's salary did not affect the
value in the list because the list created a copy of Mary's entry.
<p> There are several ways to find items in the list. The <a href="#begin">begin</a>() and
<a href="#end">end</a>() functions return iterators to the beginning and end of the
list. The advantage of getting an iterator is that you can move
forward or backward from this position by
incrementing/decrementing the iterator. The iterator returned by
end() points to the item which is one <em>past</em> the last item in the
container. The past-the-end iterator is still associated with the
list it belongs to, however it is <em>not</em> dereferenceable;
<a href="qsize.html#operator*-4">operator*</a>() will not return a well-defined value. If the list is
<a href="#empty">empty</a>(), the iterator returned by begin() will equal the iterator
returned by end().
<p> Another way to find an item in the list is by using the <a href="qtl.html#qFind">qFind()</a> algorithm. For example:
<p> <pre>
    QValueList&lt;int&gt; list;
    ...
    QValueList&lt;int&gt;::<a href="#iterator">iterator</a> it = qFind( list.<a href="#begin">begin</a>(), list.<a href="#end">end</a>(), 3 );
    if ( it != list.<a href="#end">end</a>() )
        // it points to the found item
    </pre>
 
<p> It is safe to have multiple iterators a the list at the same
time. If some member of the list is removed, only iterators
pointing to the removed member become invalid. Inserting into the
list does not invalidate any iterator. For convenience, the
function <a href="#last">last</a>() returns a reference to the last item in the list,
and <a href="#first">first</a>() returns a reference to the the first item. If the
list is empty(), both last() and first() have undefined behavior
(your application will crash or do unpredictable things). Use
last() and first() with caution, for example:
<p> <pre>
    QValueList&lt;int&gt; list;
    list.<a href="#append">append</a>( 1 );
    list.<a href="#append">append</a>( 2 );
    list.<a href="#append">append</a>( 3 );
    ...
    if ( !list.<a href="#empty">empty</a>() ) {
        // OK, modify the first item
        int&amp; i = list.<a href="#first">first</a>();
        i = 18;
    }
    ...
    QValueList&lt;double&gt; dlist;
    double d = dlist.<a href="#last">last</a>(); // undefined
    </pre>
 
<p> Because QValueList is value-based there is no need to be careful
about deleting items in the list. The list holds its own copies
and will free them if the corresponding member or the list itself
is deleted. You can force the list to free all of its items with
<a href="#clear">clear</a>().
<p> QValueList is <a href="shclass.html#shared-implicitly">shared implicitly</a>, which means it can be copied in
constant time, i.e. O(1). If multiple QValueList instances share
the same data and one needs to modify its contents, this modifying
instance makes a copy and modifies its private copy; therefore it
does not affect the other instances; this takes O(n) time. This is
often called "copy on write". If a QValueList is being used in a
multi-threaded program, you must protect all access to the list.
See <a href="qmutex.html">QMutex</a>.
<p> There are several ways to insert items into the list. The
<a href="#prepend">prepend</a>() and <a href="#append">append</a>() functions insert items at the beginning and
the end of the list respectively. The <a href="#insert">insert</a>() function comes in
several flavors and can be used to add one or more items at
specific positions within the list.
<p> Items can also be removed from the list in several ways. There
are several variants of the <a href="#remove">remove</a>() function, which removes a
specific item from the list. The remove() function will find and
remove items according to a specific item value.
<p> Lists can also be sorted using the <a href="qtl.html">Qt Template
    Library</a>. For example with qHeapSort():
<p> Example:
<pre>
    QValueList&lt;int&gt; list;
    list.<a href="#append">append</a>( 5 );
    list.<a href="#append">append</a>( 8 );
    list.<a href="#append">append</a>( 3 );
    list.<a href="#append">append</a>( 4 );
    qHeapSort( list );
    </pre>
 
<p> <p>See also <a href="qvaluelistiterator.html">QValueListIterator</a>, <a href="qtl.html">Qt Template Library Classes</a>, <a href="shared.html">Implicitly and Explicitly Shared Classes</a>, and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ConstIterator"></a>QValueList::ConstIterator</h3>

<p> This iterator is an instantiation of <a href="qvaluelistconstiterator.html">QValueListConstIterator</a> for
the same type as this QValueList. In other words, if you
instantiate QValueList<int>, ConstIterator is a
QValueListConstIterator<int>. Several member function use it, such
as <a href="#begin">QValueList::begin</a>(), which returns an iterator pointing to the
first item in the list.
<p> Functionally, this is almost the same as Iterator. The only
difference is you cannot use ConstIterator for non-const
operations, and that the compiler can often generate better code
if you use ConstIterator.
<p> <p>See also <a href="qvaluelistiterator.html">QValueListIterator</a> and <a href="#Iterator">Iterator</a>.

<h3 class=fn><a name="Iterator"></a>QValueList::Iterator</h3>

<p> This iterator is an instantiation of <a href="qvaluelistiterator.html">QValueListIterator</a> for the
same type as this QValueList. In other words, if you instantiate
QValueList<int>, Iterator is a QValueListIterator<int>. Several
member function use it, such as <a href="#begin">QValueList::begin</a>(), which returns
an iterator pointing to the first item in the list.
<p> Functionally, this is almost the same as ConstIterator. The only
difference is that you cannot use ConstIterator for non-const
operations, and that the compiler can often generate better code
if you use ConstIterator.
<p> <p>See also <a href="qvaluelistiterator.html">QValueListIterator</a> and <a href="#ConstIterator">ConstIterator</a>.

<h3 class=fn><a name="const_iterator"></a>QValueList::const_iterator</h3> 
The list's const iterator type, <a href="qvaluelistconstiterator.html">QValueListConstIterator</a>. 
<h3 class=fn><a name="const_pointer"></a>QValueList::const_pointer</h3> 
The const pointer to T type. 
<h3 class=fn><a name="const_reference"></a>QValueList::const_reference</h3> 
The const reference to T type. 
<h3 class=fn><a name="iterator"></a>QValueList::iterator</h3> 
The list's iterator type, <a href="qvaluelistiterator.html">QValueListIterator</a>. 
<h3 class=fn><a name="pointer"></a>QValueList::pointer</h3> 
The pointer to T type. 
<h3 class=fn><a name="reference"></a>QValueList::reference</h3> 
The reference to T type. 
<h3 class=fn><a name="size_type"></a>QValueList::size_type</h3> 
An unsigned integral type, used to represent various sizes. 
<h3 class=fn><a name="value_type"></a>QValueList::value_type</h3> 
The type of the object stored in the list, T. 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QValueList"></a>QValueList::QValueList ()
</h3>

<p> Constructs an empty list.

<h3 class=fn><a name="QValueList-2"></a>QValueList::QValueList ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> Constructs a copy of <em>l</em>.
<p> This operation takes O(1) time because QValueList is <a href="shclass.html#implicitly-shared">implicitly shared</a>.
<p> The first modification to a list will take O(n) time.

<h3 class=fn><a name="QValueList-3"></a>QValueList::QValueList ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> Contructs a copy of <em>l</em>.
<p> This constructor is provided for compatibility with STL
containers.

<h3 class=fn><a name="~QValueList"></a>QValueList::~QValueList ()
</h3>

<p> Destroys the list. References to the values in the list and all
iterators of this list become invalidated. Note that it is
impossible for an iterator to check whether or not it is valid:
QValueList is highly tuned for performance, not for error
checking.

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="append"></a>QValueList::append ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts <em>x</em> at the end of the list.
<p> <p>See also <a href="#insert">insert</a>() and <a href="#prepend">prepend</a>().

<p>Examples: <a href="checklists-example.html#x434">checklists/checklists.cpp</a> and <a href="simple-font-demo-example.html#x2853">fonts/simple-qfont-demo/viewer.cpp</a>.
<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="at"></a>QValueList::at ( <a href="qvaluelist.html#size_type">size_type</a>&nbsp;i ) const
</h3>

<p> Returns an iterator pointing to the item at position <em>i</em> in the
list, or an undefined value if the index is out of range.
<p> <b>Warning:</b> This function uses a linear search and can be extremely
slow for large lists. QValueList is not optimized for random item
access. If you need random access use a different container, such
as <a href="qvaluevector.html">QValueVector</a>.

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="at-2"></a>QValueList::at ( <a href="qvaluelist.html#size_type">size_type</a>&nbsp;i )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns an iterator pointing to the item at position <em>i</em> in the
list, or an undefined value if the index is out of range.
<p> 
<h3 class=fn><a href="qvaluelist.html#reference">reference</a> <a name="back"></a>QValueList::back ()
</h3>

<p> Returns a reference to the last item. If the list contains no last
item (i.e. <a href="#empty">empty</a>() returns TRUE), the return value is undefined.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#last">last</a>().
<p> <p>See also <a href="#front">front</a>().

<h3 class=fn><a href="qvaluelist.html#const_reference">const_reference</a> <a name="back-2"></a>QValueList::back () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="begin"></a>QValueList::begin () const
</h3>

<p> Returns an iterator pointing to the first item in the list. This
iterator equals <a href="#end">end</a>() if the list is empty.
<p> <p>See also <a href="#first">first</a>(), <a href="#end">end</a>(), and <a href="#constBegin">constBegin</a>().

<p>Examples: <a href="canvas-example.html#x2952">canvas/canvas.cpp</a>, <a href="tutorial2-06.html#x2588">chart/canvasview.cpp</a>, <a href="tutorial2-03.html#x2554">chart/element.cpp</a>, <a href="checklists-example.html#x435">checklists/checklists.cpp</a>, <a href="sql.html#x2197">sql/overview/insert/main.cpp</a>, <a href="statistics-example.html#x2789">table/statistics/statistics.cpp</a>, and <a href="themes-example.html#x344">themes/themes.cpp</a>.
<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="begin-2"></a>QValueList::begin ()
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns an iterator pointing to the first item in the list. This
iterator equals <a href="#end">end</a>() if the list is empty.
<p> <p>See also <a href="#first">first</a>() and <a href="#end">end</a>().

<h3 class=fn>void <a name="clear"></a>QValueList::clear ()
</h3>

<p> Removes all items from the list.
<p> <p>See also <a href="#remove">remove</a>().

<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="constBegin"></a>QValueList::constBegin () const
</h3>

<p> Returns an iterator pointing to the first item in the list. This
iterator equals <a href="#constEnd">constEnd</a>() if the list is empty.
<p> <p>See also <a href="#begin">begin</a>().

<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="constEnd"></a>QValueList::constEnd () const
</h3>

<p> Returns an iterator pointing <em>past</em> the last item in the list.
This iterator equals <a href="#constBegin">constBegin</a>() if the list is empty.
<p> <p>See also <a href="#end">end</a>().

<h3 class=fn><a href="qvaluelist.html#size_type">size_type</a> <a name="contains"></a>QValueList::contains ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const
</h3>

<p> Returns the number of occurrences of the value <em>x</em> in the list.

<h3 class=fn><a href="qvaluelist.html#size_type">size_type</a> <a name="count"></a>QValueList::count () const
</h3>

<p> Returns the number of items in the list.
<p> <p>See also <a href="#isEmpty">isEmpty</a>().

<p>Examples: <a href="tutorial2-03.html#x2555">chart/element.cpp</a>, <a href="fileiconview-example.html#x874">fileiconview/qfileiconview.cpp</a>, and <a href="statistics-example.html#x2790">table/statistics/statistics.cpp</a>.
<h3 class=fn>bool <a name="empty"></a>QValueList::empty () const
</h3>

<p> Returns TRUE if the list contains no items; otherwise returns
FALSE.
<p> <p>See also <a href="#size">size</a>().

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="end"></a>QValueList::end ()
</h3>

<p> Returns an iterator pointing <em>past</em> the last item in the list.
This iterator equals <a href="#begin">begin</a>() if the list is empty.
<p> <p>See also <a href="#last">last</a>(), <a href="#begin">begin</a>(), and <a href="#constEnd">constEnd</a>().

<p>Examples: <a href="canvas-example.html#x2953">canvas/canvas.cpp</a>, <a href="tutorial2-06.html#x2589">chart/canvasview.cpp</a>, <a href="tutorial2-03.html#x2556">chart/element.cpp</a>, <a href="checklists-example.html#x436">checklists/checklists.cpp</a>, <a href="sql.html#x2198">sql/overview/insert/main.cpp</a>, <a href="statistics-example.html#x2791">table/statistics/statistics.cpp</a>, and <a href="themes-example.html#x345">themes/themes.cpp</a>.
<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="end-2"></a>QValueList::end () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns an iterator pointing <em>past</em> the last item in the list.
This iterator equals <a href="#begin">begin</a>() if the list is empty.
<p> <p>See also <a href="#last">last</a>() and <a href="#begin">begin</a>().

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="erase"></a>QValueList::erase ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;it )
</h3>

<p> Removes the item pointed to by <em>it</em> from the list. No iterators
other than <em>it</em> or other iterators pointing at the same item as
<em>it</em> are invalidated. Returns an iterator to the next item after
<em>it</em>, or <a href="#end">end</a>() if there is no such item.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#remove">remove</a>().

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="erase-2"></a>QValueList::erase ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;first, <a href="qvaluelist.html#iterator">iterator</a>&nbsp;last )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Deletes all items from <em>first</em> to <em>last</em> (not including <em>last</em>). No iterators are invalidated, except those pointing to the
removed items themselves. Returns <em>last</em>.

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="find"></a>QValueList::find ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Returns an iterator pointing to the first occurrence of <em>x</em> in
the list.
<p> Returns <a href="#end">end</a>() is no item matched.

<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="find-2"></a>QValueList::find ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns an iterator pointing to the first occurrence of <em>x</em> in
the list.
<p> Returns <a href="#end">end</a>() if no item matched.

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="find-3"></a>QValueList::find ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of <em>x</em> in the list starting at the
position given by <em>it</em>.
<p> Returns <a href="#end">end</a>() if no item matched.

<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="find-4"></a>QValueList::find ( <a href="qvaluelist.html#const_iterator">const_iterator</a>&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of <em>x</em> in the list starting at the
position given by <em>it</em>.
<p> Returns <a href="#end">end</a>() if no item matched.

<h3 class=fn>int <a name="findIndex"></a>QValueList::findIndex ( const&nbsp;T&nbsp;&amp;&nbsp;x ) const
</h3>

<p> Returns the index of the first occurrence of the value <em>x</em>.
Returns -1 if no item matched.

<h3 class=fn>T &amp; <a name="first"></a>QValueList::first ()
</h3>

<p> Returns a reference to the first item. If the list contains no
first item (i.e. <a href="#isEmpty">isEmpty</a>() returns TRUE), the return value is
undefined.
<p> <p>See also <a href="#last">last</a>().

<p>Example: <a href="mail-example.html#x719">network/mail/smtp.cpp</a>.
<h3 class=fn>const T &amp; <a name="first-2"></a>QValueList::first () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qvaluelist.html#const_iterator">const_iterator</a> <a name="fromLast"></a>QValueList::fromLast () const
</h3>

<p> Returns an iterator to the last item in the list, or <a href="#end">end</a>() if
there is no last item.
<p> Use the end() function instead. For example:
<p> <pre>
    QValueList&lt;int&gt; l;
    ...
    QValueList&lt;int&gt;::<a href="#iterator">iterator</a> it = l.<a href="#end">end</a>();
    --it;
    if ( it != <a href="#end">end</a>() )
        // ...
    </pre>
 
<p> 
<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="fromLast-2"></a>QValueList::fromLast ()
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns an iterator to the last item in the list, or <a href="#end">end</a>() if
there is no last item.
<p> Use the end() function instead. For example:
<p> <pre>
    QValueList&lt;int&gt; l;
    ...
    QValueList&lt;int&gt;::<a href="#iterator">iterator</a> it = l.<a href="#end">end</a>();
    --it;
    if ( it != <a href="#end">end</a>() )
        // ...
    </pre>
 
<p> 
<h3 class=fn><a href="qvaluelist.html#reference">reference</a> <a name="front"></a>QValueList::front ()
</h3>

<p> Returns a reference to the first item. If the list contains no
first item (i.e. <a href="#empty">empty</a>() returns TRUE), the return value is
undefined.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#first">first</a>().
<p> <p>See also <a href="#back">back</a>().

<h3 class=fn><a href="qvaluelist.html#const_reference">const_reference</a> <a name="front-2"></a>QValueList::front () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="insert"></a>QValueList::insert ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;it, const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts the value <em>x</em> in front of the item pointed to by the
iterator, <em>it</em>.
<p> Returns an iterator pointing at the inserted item.
<p> <p>See also <a href="#append">append</a>() and <a href="#prepend">prepend</a>().

<p>Example: <a href="themes-example.html#x346">themes/themes.cpp</a>.
<h3 class=fn>void <a name="insert-2"></a>QValueList::insert ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;pos, <a href="qvaluelist.html#size_type">size_type</a>&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>n</em> copies of <em>x</em> before position <em>pos</em>.

<h3 class=fn>bool <a name="isEmpty"></a>QValueList::isEmpty () const
</h3>

<p> Returns TRUE if the list contains no items; otherwise returns
FALSE.
<p> <p>See also <a href="#count">count</a>().

<p>Examples: <a href="simple-font-demo-example.html#x2856">fonts/simple-qfont-demo/viewer.cpp</a> and <a href="mail-example.html#x720">network/mail/smtp.cpp</a>.
<h3 class=fn>T &amp; <a name="last"></a>QValueList::last ()
</h3>

<p> Returns a reference to the last item. If the list contains no last
item (i.e. <a href="#empty">empty</a>() returns TRUE), the return value is undefined.

<h3 class=fn>const T &amp; <a name="last-2"></a>QValueList::last () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn>bool <a name="operator!-eq"></a>QValueList::operator!= ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l ) const
</h3>

<p> Compares both lists.
<p> Returns TRUE if this list and <em>l</em> are unequal; otherwise returns
FALSE.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt; <a name="operator+"></a>QValueList::operator+ ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l ) const
</h3>

<p> Creates a new list and fills it with the items of this list. Then
the items of <em>l</em> are appended. Returns the new list.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp; <a name="operator+-eq"></a>QValueList::operator+= ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> Appends the items of <em>l</em> to this list. Returns a reference to
this list.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp; <a name="operator+-eq-2"></a>QValueList::operator+= ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends the value <em>x</em> to the list. Returns a reference to the
list.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp; <a name="operator-lt-lt"></a>QValueList::operator&lt;&lt; ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Adds the value <em>x</em> to the end of the list.
<p> Returns a reference to the list.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp; <a name="operator-eq"></a>QValueList::operator= ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> Assigns <em>l</em> to this list and returns a reference to this list.
<p> All iterators of the current list become invalidated by this
operation. The cost of such an assignment is O(1) since QValueList
is <a href="shclass.html#implicitly-shared">implicitly shared</a>.

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp; <a name="operator-eq-2"></a>QValueList::operator= ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns the contents of <em>l</em> to the list.
<p> All iterators of the current list become invalidated by this
operation.

<h3 class=fn>bool <a name="operator-eq-eq"></a>QValueList::operator== ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l ) const
</h3>

<p> Compares both lists.
<p> Returns TRUE if this list and <em>l</em> are equal; otherwise returns
FALSE.

<h3 class=fn>bool <a name="operator-eq-eq-2"></a>QValueList::operator== ( const&nbsp;std::list&lt;T&gt;&nbsp;&amp;&nbsp;l ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns TRUE if this list and <em>l</em> are equal; otherwise returns
FALSE.
<p> This operator is provided for compatibility with STL containers.

<h3 class=fn>const T &amp; <a name="operator[]"></a>QValueList::operator[] ( <a href="qvaluelist.html#size_type">size_type</a>&nbsp;i ) const
</h3>

<p> Returns a const reference to the item with index <em>i</em> in the list.
It is up to you to check whether this item really exists. You can
do that easily with the <a href="#count">count</a>() function. However this operator
does not check whether <em>i</em> is in range and will deliver undefined
results if it does not exist.
<p> <b>Warning:</b> This function uses a linear search and can be extremely
slow for large lists. QValueList is not optimized for random item
access. If you need random access use a different container, such
as <a href="qvaluevector.html">QValueVector</a>.

<h3 class=fn>T &amp; <a name="operator[]-2"></a>QValueList::operator[] ( <a href="qvaluelist.html#size_type">size_type</a>&nbsp;i )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a non-const reference to the item with index <em>i</em>.

<h3 class=fn>void <a name="pop_back"></a>QValueList::pop_back ()
</h3>

<p> Removes the last item. If there is no last item, this operation is
undefined.
<p> This function is provided for STL compatibility.

<h3 class=fn>void <a name="pop_front"></a>QValueList::pop_front ()
</h3>

<p> Removes the first item. If there is no first item, this operation
is undefined.
<p> This function is provided for STL compatibility.

<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="prepend"></a>QValueList::prepend ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts <em>x</em> at the beginning of the list.
<p> <p>See also <a href="#insert">insert</a>() and <a href="#append">append</a>().

<h3 class=fn>void <a name="push_back"></a>QValueList::push_back ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts <em>x</em> at the end of the list.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#append">append</a>().

<h3 class=fn>void <a name="push_front"></a>QValueList::push_front ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts <em>x</em> at the beginning of the list.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#prepend">prepend</a>().

<p>Example: <a href="toplevel-example.html#x2534">toplevel/options.ui.h</a>.
<h3 class=fn><a href="qvaluelist.html#iterator">iterator</a> <a name="remove"></a>QValueList::remove ( <a href="qvaluelist.html#iterator">iterator</a>&nbsp;it )
</h3>

<p> Removes the item pointed to by <em>it</em> from the list. No iterators
other than <em>it</em> or other iterators pointing at the same item as
<em>it</em> are invalidated. Returns an iterator to the next item after
<em>it</em>, or <a href="#end">end</a>() if there is no such item.
<p> <p>See also <a href="#clear">clear</a>().

<h3 class=fn>uint <a name="remove-2"></a>QValueList::remove ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes all items that have value <em>x</em> and returns the number of
removed items.

<h3 class=fn><a href="qvaluelist.html#size_type">size_type</a> <a name="size"></a>QValueList::size () const
</h3>

<p> Returns the number of items in the list.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#count">count</a>().
<p> <p>See also <a href="#empty">empty</a>().

<hr><h2>Related Functions</h2>
<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-2"></a>operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Writes a list, <em>l</em>, to the stream <em>s</em>. The type T stored in the
list must implement the streaming operator.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qvaluelist.html">QValueList</a>&lt;T&gt;&nbsp;&amp;&nbsp;l )
</h3>

<p> 
<p> Reads a list, <em>l</em>, from the stream <em>s</em>. The type T stored in the
list must implement the streaming operator.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
