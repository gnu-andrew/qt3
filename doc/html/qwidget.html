<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qwidget.cpp:69 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QWidget Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QWidget Class Reference</h1>

<p>The QWidget class is the base class of all user interface objects.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qwidget-h.html">qwidget.h</a>&gt;</tt>
<p>Inherits <a href="qobject.html">QObject</a> and <a href="qpaintdevice.html">QPaintDevice</a>.
<p>Inherited by <a href="qaxwidget.html">QAxWidget</a>, <a href="qbutton.html">QButton</a>, <a href="qframe.html">QFrame</a>, <a href="qdialog.html">QDialog</a>, <a href="qcombobox.html">QComboBox</a>, <a href="qdatabrowser.html">QDataBrowser</a>, <a href="qdataview.html">QDataView</a>, <a href="qdatetimeeditbase.html">QDateTimeEditBase</a>, <a href="qdatetimeedit.html">QDateTimeEdit</a>, <a href="qdesktopwidget.html">QDesktopWidget</a>, <a href="qdial.html">QDial</a>, <a href="qdockarea.html">QDockArea</a>, <a href="qglwidget.html">QGLWidget</a>, <a href="qheader.html">QHeader</a>, <a href="qmainwindow.html">QMainWindow</a>, <a href="qmotifwidget.html">QMotifWidget</a>, <a href="qnpwidget.html">QNPWidget</a>, <a href="qscrollbar.html">QScrollBar</a>, <a href="qsizegrip.html">QSizeGrip</a>, <a href="qslider.html">QSlider</a>, <a href="qspinbox.html">QSpinBox</a>, <a href="qsplashscreen.html">QSplashScreen</a>, <a href="qstatusbar.html">QStatusBar</a>, <a href="qtabbar.html">QTabBar</a>, <a href="qtabwidget.html">QTabWidget</a>, <a href="qworkspace.html">QWorkspace</a>, and <a href="qxtwidget.html">QXtWidget</a>.
<p><a href="qwidget-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>explicit <a href="#QWidget"><b>QWidget</b></a> ( QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, WFlags&nbsp;f = 0 )</li>
<li class=fn><a href="#~QWidget"><b>~QWidget</b></a> ()</li>
<li class=fn>WId <a href="#winId"><b>winId</b></a> () const</li>
<li class=fn>QStyle &amp; <a href="#style"><b>style</b></a> () const</li>
<li class=fn>void <a href="#setStyle"><b>setStyle</b></a> ( QStyle&nbsp;*&nbsp;style )</li>
<li class=fn>QStyle * <a href="#setStyle-2"><b>setStyle</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;style )</li>
<li class=fn>bool <a href="#isTopLevel"><b>isTopLevel</b></a> () const</li>
<li class=fn>bool <a href="#isDialog"><b>isDialog</b></a> () const</li>
<li class=fn>bool <a href="#isPopup"><b>isPopup</b></a> () const</li>
<li class=fn>bool <a href="#isDesktop"><b>isDesktop</b></a> () const</li>
<li class=fn>bool <a href="#isModal"><b>isModal</b></a> () const</li>
<li class=fn>bool <a href="#isEnabled"><b>isEnabled</b></a> () const</li>
<li class=fn>bool <a href="#isEnabledTo"><b>isEnabledTo</b></a> ( QWidget&nbsp;*&nbsp;ancestor ) const</li>
<li class=fn>bool isEnabledToTLW () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>QRect <a href="#frameGeometry"><b>frameGeometry</b></a> () const</li>
<li class=fn>const QRect &amp; <a href="#geometry"><b>geometry</b></a> () const</li>
<li class=fn>int <a href="#x"><b>x</b></a> () const</li>
<li class=fn>int <a href="#y"><b>y</b></a> () const</li>
<li class=fn>QPoint <a href="#pos"><b>pos</b></a> () const</li>
<li class=fn>QSize <a href="#frameSize"><b>frameSize</b></a> () const</li>
<li class=fn>QSize <a href="#size"><b>size</b></a> () const</li>
<li class=fn>int <a href="#width"><b>width</b></a> () const</li>
<li class=fn>int <a href="#height"><b>height</b></a> () const</li>
<li class=fn>QRect <a href="#rect"><b>rect</b></a> () const</li>
<li class=fn>QRect <a href="#childrenRect"><b>childrenRect</b></a> () const</li>
<li class=fn>QRegion <a href="#childrenRegion"><b>childrenRegion</b></a> () const</li>
<li class=fn>QSize <a href="#minimumSize"><b>minimumSize</b></a> () const</li>
<li class=fn>QSize <a href="#maximumSize"><b>maximumSize</b></a> () const</li>
<li class=fn>int <a href="#minimumWidth"><b>minimumWidth</b></a> () const</li>
<li class=fn>int <a href="#minimumHeight"><b>minimumHeight</b></a> () const</li>
<li class=fn>int <a href="#maximumWidth"><b>maximumWidth</b></a> () const</li>
<li class=fn>int <a href="#maximumHeight"><b>maximumHeight</b></a> () const</li>
<li class=fn>void <a href="#setMinimumSize"><b>setMinimumSize</b></a> ( const QSize &amp; )</li>
<li class=fn>virtual void <a href="#setMinimumSize-2"><b>setMinimumSize</b></a> ( int&nbsp;minw, int&nbsp;minh )</li>
<li class=fn>void <a href="#setMaximumSize"><b>setMaximumSize</b></a> ( const QSize &amp; )</li>
<li class=fn>virtual void <a href="#setMaximumSize-2"><b>setMaximumSize</b></a> ( int&nbsp;maxw, int&nbsp;maxh )</li>
<li class=fn>void <a href="#setMinimumWidth"><b>setMinimumWidth</b></a> ( int&nbsp;minw )</li>
<li class=fn>void <a href="#setMinimumHeight"><b>setMinimumHeight</b></a> ( int&nbsp;minh )</li>
<li class=fn>void <a href="#setMaximumWidth"><b>setMaximumWidth</b></a> ( int&nbsp;maxw )</li>
<li class=fn>void <a href="#setMaximumHeight"><b>setMaximumHeight</b></a> ( int&nbsp;maxh )</li>
<li class=fn>QSize <a href="#sizeIncrement"><b>sizeIncrement</b></a> () const</li>
<li class=fn>void <a href="#setSizeIncrement"><b>setSizeIncrement</b></a> ( const QSize &amp; )</li>
<li class=fn>virtual void <a href="#setSizeIncrement-2"><b>setSizeIncrement</b></a> ( int&nbsp;w, int&nbsp;h )</li>
<li class=fn>QSize <a href="#baseSize"><b>baseSize</b></a> () const</li>
<li class=fn>void <a href="#setBaseSize"><b>setBaseSize</b></a> ( const QSize &amp; )</li>
<li class=fn>void <a href="#setBaseSize-2"><b>setBaseSize</b></a> ( int&nbsp;basew, int&nbsp;baseh )</li>
<li class=fn>void <a href="#setFixedSize"><b>setFixedSize</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;s )</li>
<li class=fn>void <a href="#setFixedSize-2"><b>setFixedSize</b></a> ( int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#setFixedWidth"><b>setFixedWidth</b></a> ( int&nbsp;w )</li>
<li class=fn>void <a href="#setFixedHeight"><b>setFixedHeight</b></a> ( int&nbsp;h )</li>
<li class=fn>QPoint <a href="#mapToGlobal"><b>mapToGlobal</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QPoint <a href="#mapFromGlobal"><b>mapFromGlobal</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QPoint <a href="#mapToParent"><b>mapToParent</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QPoint <a href="#mapFromParent"><b>mapFromParent</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QPoint <a href="#mapTo"><b>mapTo</b></a> ( QWidget&nbsp;*&nbsp;parent, const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QPoint <a href="#mapFrom"><b>mapFrom</b></a> ( QWidget&nbsp;*&nbsp;parent, const&nbsp;QPoint&nbsp;&amp;&nbsp;pos ) const</li>
<li class=fn>QWidget * <a href="#topLevelWidget"><b>topLevelWidget</b></a> () const</li>
<li class=fn>BackgroundMode <a href="#backgroundMode"><b>backgroundMode</b></a> () const</li>
<li class=fn>virtual void <a href="#setBackgroundMode"><b>setBackgroundMode</b></a> ( BackgroundMode )</li>
<li class=fn>void <a href="#setBackgroundMode-2"><b>setBackgroundMode</b></a> ( BackgroundMode&nbsp;m, BackgroundMode&nbsp;visual )</li>
<li class=fn>const QColor &amp; <a href="#foregroundColor"><b>foregroundColor</b></a> () const</li>
<li class=fn>const QColor &amp; <a href="#eraseColor"><b>eraseColor</b></a> () const</li>
<li class=fn>virtual void <a href="#setEraseColor"><b>setEraseColor</b></a> ( const&nbsp;QColor&nbsp;&amp;&nbsp;color )</li>
<li class=fn>const QPixmap * <a href="#erasePixmap"><b>erasePixmap</b></a> () const</li>
<li class=fn>virtual void <a href="#setErasePixmap"><b>setErasePixmap</b></a> ( const&nbsp;QPixmap&nbsp;&amp;&nbsp;pixmap )</li>
<li class=fn>const QColorGroup &amp; <a href="#colorGroup"><b>colorGroup</b></a> () const</li>
<li class=fn>const QPalette &amp; <a href="#palette"><b>palette</b></a> () const</li>
<li class=fn>bool <a href="#ownPalette"><b>ownPalette</b></a> () const</li>
<li class=fn>virtual void <a href="#setPalette"><b>setPalette</b></a> ( const QPalette &amp; )</li>
<li class=fn>void <a href="#unsetPalette"><b>unsetPalette</b></a> ()</li>
<li class=fn>const QColor &amp; <a href="#paletteForegroundColor"><b>paletteForegroundColor</b></a> () const</li>
<li class=fn>void <a href="#setPaletteForegroundColor"><b>setPaletteForegroundColor</b></a> ( const QColor &amp; )</li>
<li class=fn>const QColor &amp; <a href="#paletteBackgroundColor"><b>paletteBackgroundColor</b></a> () const</li>
<li class=fn>virtual void <a href="#setPaletteBackgroundColor"><b>setPaletteBackgroundColor</b></a> ( const QColor &amp; )</li>
<li class=fn>const QPixmap * <a href="#paletteBackgroundPixmap"><b>paletteBackgroundPixmap</b></a> () const</li>
<li class=fn>virtual void <a href="#setPaletteBackgroundPixmap"><b>setPaletteBackgroundPixmap</b></a> ( const QPixmap &amp; )</li>
<li class=fn>const QBrush &amp; <a href="#backgroundBrush"><b>backgroundBrush</b></a> () const</li>
<li class=fn>QFont <a href="#font"><b>font</b></a> () const</li>
<li class=fn>bool <a href="#ownFont"><b>ownFont</b></a> () const</li>
<li class=fn>virtual void <a href="#setFont"><b>setFont</b></a> ( const QFont &amp; )</li>
<li class=fn>void <a href="#unsetFont"><b>unsetFont</b></a> ()</li>
<li class=fn>QFontMetrics <a href="#fontMetrics"><b>fontMetrics</b></a> () const</li>
<li class=fn>QFontInfo <a href="#fontInfo"><b>fontInfo</b></a> () const</li>
<li class=fn>const QCursor &amp; <a href="#cursor"><b>cursor</b></a> () const</li>
<li class=fn>bool <a href="#ownCursor"><b>ownCursor</b></a> () const</li>
<li class=fn>virtual void <a href="#setCursor"><b>setCursor</b></a> ( const QCursor &amp; )</li>
<li class=fn>virtual void <a href="#unsetCursor"><b>unsetCursor</b></a> ()</li>
<li class=fn>QString <a href="#caption"><b>caption</b></a> () const</li>
<li class=fn>const QPixmap * <a href="#icon"><b>icon</b></a> () const</li>
<li class=fn>QString <a href="#iconText"><b>iconText</b></a> () const</li>
<li class=fn>bool <a href="#hasMouseTracking"><b>hasMouseTracking</b></a> () const</li>
<li class=fn>bool <a href="#hasMouse"><b>hasMouse</b></a> () const</li>
<li class=fn>virtual void <a href="#setMask"><b>setMask</b></a> ( const&nbsp;QBitmap&nbsp;&amp;&nbsp;bitmap )</li>
<li class=fn>virtual void <a href="#setMask-2"><b>setMask</b></a> ( const&nbsp;QRegion&nbsp;&amp;&nbsp;region )</li>
<li class=fn>void <a href="#clearMask"><b>clearMask</b></a> ()</li>
<li class=fn>const QColor &amp; backgroundColor () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>virtual void setBackgroundColor ( const&nbsp;QColor&nbsp;&amp;&nbsp;c ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>const QPixmap * backgroundPixmap () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>virtual void setBackgroundPixmap ( const&nbsp;QPixmap&nbsp;&amp;&nbsp;pm ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>enum <a href="#FocusPolicy-enum"><b>FocusPolicy</b></a> { NoFocus = 0, TabFocus = 0x1, ClickFocus = 0x2, StrongFocus = TabFocus | ClickFocus | 0x8, WheelFocus = StrongFocus | 0x4 }</li>
<li class=fn>bool <a href="#isActiveWindow"><b>isActiveWindow</b></a> () const</li>
<li class=fn>virtual void <a href="#setActiveWindow"><b>setActiveWindow</b></a> ()</li>
<li class=fn>bool <a href="#isFocusEnabled"><b>isFocusEnabled</b></a> () const</li>
<li class=fn>FocusPolicy <a href="#focusPolicy"><b>focusPolicy</b></a> () const</li>
<li class=fn>virtual void <a href="#setFocusPolicy"><b>setFocusPolicy</b></a> ( FocusPolicy )</li>
<li class=fn>bool <a href="#hasFocus"><b>hasFocus</b></a> () const</li>
<li class=fn>virtual void <a href="#setFocusProxy"><b>setFocusProxy</b></a> ( QWidget&nbsp;*&nbsp;w )</li>
<li class=fn>QWidget * <a href="#focusProxy"><b>focusProxy</b></a> () const</li>
<li class=fn>void <a href="#setInputMethodEnabled"><b>setInputMethodEnabled</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#isInputMethodEnabled"><b>isInputMethodEnabled</b></a> () const</li>
<li class=fn>void <a href="#grabMouse"><b>grabMouse</b></a> ()</li>
<li class=fn>void <a href="#grabMouse-2"><b>grabMouse</b></a> ( const&nbsp;QCursor&nbsp;&amp;&nbsp;cursor )</li>
<li class=fn>void <a href="#releaseMouse"><b>releaseMouse</b></a> ()</li>
<li class=fn>void <a href="#grabKeyboard"><b>grabKeyboard</b></a> ()</li>
<li class=fn>void <a href="#releaseKeyboard"><b>releaseKeyboard</b></a> ()</li>
<li class=fn>bool <a href="#isUpdatesEnabled"><b>isUpdatesEnabled</b></a> () const</li>
<li class=fn>virtual bool <a href="#close-2"><b>close</b></a> ( bool&nbsp;alsoDelete )</li>
<li class=fn>bool <a href="#isVisible"><b>isVisible</b></a> () const</li>
<li class=fn>bool <a href="#isVisibleTo"><b>isVisibleTo</b></a> ( QWidget&nbsp;*&nbsp;ancestor ) const</li>
<li class=fn>bool isVisibleToTLW () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>QRect visibleRect () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool <a href="#isHidden"><b>isHidden</b></a> () const</li>
<li class=fn>bool <a href="#isShown"><b>isShown</b></a> () const</li>
<li class=fn>bool <a href="#isMinimized"><b>isMinimized</b></a> () const</li>
<li class=fn>bool <a href="#isMaximized"><b>isMaximized</b></a> () const</li>
<li class=fn>bool <a href="#isFullScreen"><b>isFullScreen</b></a> () const</li>
<li class=fn>uint <a href="#windowState"><b>windowState</b></a> () const</li>
<li class=fn>void <a href="#setWindowState"><b>setWindowState</b></a> ( uint&nbsp;windowState )</li>
<li class=fn>virtual QSize <a href="#sizeHint"><b>sizeHint</b></a> () const</li>
<li class=fn>virtual QSize <a href="#minimumSizeHint"><b>minimumSizeHint</b></a> () const</li>
<li class=fn>virtual QSizePolicy <a href="#sizePolicy"><b>sizePolicy</b></a> () const</li>
<li class=fn>virtual void <a href="#setSizePolicy"><b>setSizePolicy</b></a> ( QSizePolicy )</li>
<li class=fn>void <a href="#setSizePolicy-2"><b>setSizePolicy</b></a> ( QSizePolicy::SizeType&nbsp;hor, QSizePolicy::SizeType&nbsp;ver, bool&nbsp;hfw = FALSE )</li>
<li class=fn>virtual int <a href="#heightForWidth"><b>heightForWidth</b></a> ( int&nbsp;w ) const</li>
<li class=fn>QRegion <a href="#clipRegion"><b>clipRegion</b></a> () const</li>
<li class=fn>QLayout * <a href="#layout"><b>layout</b></a> () const</li>
<li class=fn>void <a href="#updateGeometry"><b>updateGeometry</b></a> ()</li>
<li class=fn>virtual void <a href="#reparent"><b>reparent</b></a> ( QWidget&nbsp;*&nbsp;parent, WFlags&nbsp;f, const&nbsp;QPoint&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE )</li>
<li class=fn>void <a href="#reparent-2"><b>reparent</b></a> ( QWidget&nbsp;*&nbsp;parent, const&nbsp;QPoint&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE )</li>
<li class=fn>void recreate ( QWidget&nbsp;*&nbsp;parent, WFlags&nbsp;f, const&nbsp;QPoint&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>void <a href="#erase-2"><b>erase</b></a> ()</li>
<li class=fn>void <a href="#erase"><b>erase</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#erase-3"><b>erase</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r )</li>
<li class=fn>void <a href="#erase-4"><b>erase</b></a> ( const&nbsp;QRegion&nbsp;&amp;&nbsp;reg )</li>
<li class=fn>void <a href="#scroll"><b>scroll</b></a> ( int&nbsp;dx, int&nbsp;dy )</li>
<li class=fn>void <a href="#scroll-2"><b>scroll</b></a> ( int&nbsp;dx, int&nbsp;dy, const&nbsp;QRect&nbsp;&amp;&nbsp;r )</li>
<li class=fn>void <a href="#drawText"><b>drawText</b></a> ( int&nbsp;x, int&nbsp;y, const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>void <a href="#drawText-2"><b>drawText</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos, const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QWidget * <a href="#focusWidget"><b>focusWidget</b></a> () const</li>
<li class=fn>QRect <a href="#microFocusHint"><b>microFocusHint</b></a> () const</li>
<li class=fn>bool <a href="#acceptDrops"><b>acceptDrops</b></a> () const</li>
<li class=fn>virtual void <a href="#setAcceptDrops"><b>setAcceptDrops</b></a> ( bool&nbsp;on )</li>
<li class=fn>virtual void <a href="#setAutoMask"><b>setAutoMask</b></a> ( bool )</li>
<li class=fn>bool <a href="#autoMask"><b>autoMask</b></a> () const</li>
<li class=fn>enum <a href="#BackgroundOrigin-enum"><b>BackgroundOrigin</b></a> { WidgetOrigin, ParentOrigin, WindowOrigin, AncestorOrigin }</li>
<li class=fn>virtual void <a href="#setBackgroundOrigin"><b>setBackgroundOrigin</b></a> ( BackgroundOrigin )</li>
<li class=fn>BackgroundOrigin <a href="#backgroundOrigin"><b>backgroundOrigin</b></a> () const</li>
<li class=fn>virtual bool <a href="#customWhatsThis"><b>customWhatsThis</b></a> () const</li>
<li class=fn>QWidget * <a href="#parentWidget"><b>parentWidget</b></a> ( bool&nbsp;sameWindow = FALSE ) const</li>
<li class=fn>WFlags <a href="#testWFlags"><b>testWFlags</b></a> ( WFlags&nbsp;f ) const</li>
<li class=fn>QWidget * <a href="#childAt"><b>childAt</b></a> ( int&nbsp;x, int&nbsp;y, bool&nbsp;includeThis = FALSE ) const</li>
<li class=fn>QWidget * <a href="#childAt-2"><b>childAt</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;p, bool&nbsp;includeThis = FALSE ) const</li>
<li class=fn>void <a href="#setWindowOpacity"><b>setWindowOpacity</b></a> ( double&nbsp;level )</li>
<li class=fn>double <a href="#windowOpacity"><b>windowOpacity</b></a> () const</li>
<li class=fn>void setPalette ( const&nbsp;QPalette&nbsp;&amp;&nbsp;p, bool ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>void setFont ( const&nbsp;QFont&nbsp;&amp;&nbsp;f, bool ) &nbsp;<em>(obsolete)</em></li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>virtual void <a href="#setEnabled"><b>setEnabled</b></a> ( bool )</li>
<li class=fn>void <a href="#setDisabled"><b>setDisabled</b></a> ( bool&nbsp;disable )</li>
<li class=fn>virtual void <a href="#setCaption"><b>setCaption</b></a> ( const QString &amp; )</li>
<li class=fn>virtual void <a href="#setIcon"><b>setIcon</b></a> ( const QPixmap &amp; )</li>
<li class=fn>virtual void <a href="#setIconText"><b>setIconText</b></a> ( const QString &amp; )</li>
<li class=fn>virtual void <a href="#setMouseTracking"><b>setMouseTracking</b></a> ( bool&nbsp;enable )</li>
<li class=fn>virtual void <a href="#setFocus"><b>setFocus</b></a> ()</li>
<li class=fn>void <a href="#clearFocus"><b>clearFocus</b></a> ()</li>
<li class=fn>virtual void <a href="#setUpdatesEnabled"><b>setUpdatesEnabled</b></a> ( bool&nbsp;enable )</li>
<li class=fn>void <a href="#update"><b>update</b></a> ()</li>
<li class=fn>void <a href="#update-2"><b>update</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#update-3"><b>update</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r )</li>
<li class=fn>void <a href="#repaint-2"><b>repaint</b></a> ()</li>
<li class=fn>void <a href="#repaint-3"><b>repaint</b></a> ( bool&nbsp;erase )</li>
<li class=fn>void <a href="#repaint"><b>repaint</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, bool&nbsp;erase = TRUE )</li>
<li class=fn>void <a href="#repaint-4"><b>repaint</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r, bool&nbsp;erase = TRUE )</li>
<li class=fn>void <a href="#repaint-5"><b>repaint</b></a> ( const&nbsp;QRegion&nbsp;&amp;&nbsp;reg, bool&nbsp;erase = TRUE )</li>
<li class=fn>virtual void <a href="#show"><b>show</b></a> ()</li>
<li class=fn>virtual void <a href="#hide"><b>hide</b></a> ()</li>
<li class=fn>void <a href="#setShown"><b>setShown</b></a> ( bool&nbsp;show )</li>
<li class=fn>void <a href="#setHidden"><b>setHidden</b></a> ( bool&nbsp;hide )</li>
<li class=fn>void iconify () &nbsp;<em>(obsolete)</em></li>
<li class=fn>virtual void <a href="#showMinimized"><b>showMinimized</b></a> ()</li>
<li class=fn>virtual void <a href="#showMaximized"><b>showMaximized</b></a> ()</li>
<li class=fn>void <a href="#showFullScreen"><b>showFullScreen</b></a> ()</li>
<li class=fn>virtual void <a href="#showNormal"><b>showNormal</b></a> ()</li>
<li class=fn>virtual void <a href="#polish"><b>polish</b></a> ()</li>
<li class=fn>void <a href="#constPolish"><b>constPolish</b></a> () const</li>
<li class=fn>bool <a href="#close"><b>close</b></a> ()</li>
<li class=fn>void <a href="#raise"><b>raise</b></a> ()</li>
<li class=fn>void <a href="#lower"><b>lower</b></a> ()</li>
<li class=fn>void <a href="#stackUnder"><b>stackUnder</b></a> ( QWidget&nbsp;*&nbsp;w )</li>
<li class=fn>virtual void <a href="#move-2"><b>move</b></a> ( int&nbsp;x, int&nbsp;y )</li>
<li class=fn>void <a href="#move"><b>move</b></a> ( const QPoint &amp; )</li>
<li class=fn>virtual void <a href="#resize-2"><b>resize</b></a> ( int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#resize"><b>resize</b></a> ( const QSize &amp; )</li>
<li class=fn>virtual void <a href="#setGeometry-2"><b>setGeometry</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>virtual void <a href="#setGeometry"><b>setGeometry</b></a> ( const QRect &amp; )</li>
<li class=fn>virtual void <a href="#adjustSize"><b>adjustSize</b></a> ()</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>void <a href="#setTabOrder"><b>setTabOrder</b></a> ( QWidget&nbsp;*&nbsp;first, QWidget&nbsp;*&nbsp;second )</li>
<li class=fn>QWidget * <a href="#mouseGrabber"><b>mouseGrabber</b></a> ()</li>
<li class=fn>QWidget * <a href="#keyboardGrabber"><b>keyboardGrabber</b></a> ()</li>
<li class=fn>QWidget * <a href="#find"><b>find</b></a> ( WId&nbsp;id )</li>
</ul>
<h2>Properties</h2>
<ul>
<li class=fn>bool <a href="#acceptDrops-prop"><b>acceptDrops</b></a>&nbsp;- whether drop events are enabled for this widget</li>
<li class=fn>bool <a href="#autoMask-prop"><b>autoMask</b></a>&nbsp;- whether the auto mask feature is enabled for the widget</li>
<li class=fn>QBrush <a href="#backgroundBrush-prop"><b>backgroundBrush</b></a>&nbsp;- the widget's background brush &nbsp;<em>(read only)</em></li>
<li class=fn>BackgroundMode <a href="#backgroundMode-prop"><b>backgroundMode</b></a>&nbsp;- the color role used for painting the background of the widget</li>
<li class=fn>BackgroundOrigin <a href="#backgroundOrigin-prop"><b>backgroundOrigin</b></a>&nbsp;- the origin of the widget's background</li>
<li class=fn>QSize <a href="#baseSize-prop"><b>baseSize</b></a>&nbsp;- the base size of the widget</li>
<li class=fn>QString <a href="#caption-prop"><b>caption</b></a>&nbsp;- the window caption (title)</li>
<li class=fn>QRect <a href="#childrenRect-prop"><b>childrenRect</b></a>&nbsp;- the bounding rectangle of the widget's children &nbsp;<em>(read only)</em></li>
<li class=fn>QRegion <a href="#childrenRegion-prop"><b>childrenRegion</b></a>&nbsp;- the combined region occupied by the widget's children &nbsp;<em>(read only)</em></li>
<li class=fn>QColorGroup <a href="#colorGroup-prop"><b>colorGroup</b></a>&nbsp;- the current color group of the widget palette &nbsp;<em>(read only)</em></li>
<li class=fn>QCursor <a href="#cursor-prop"><b>cursor</b></a>&nbsp;- the cursor shape for this widget</li>
<li class=fn>bool <a href="#customWhatsThis-prop"><b>customWhatsThis</b></a>&nbsp;- whether the widget wants to handle What's This help manually &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#enabled-prop"><b>enabled</b></a>&nbsp;- whether the widget is enabled</li>
<li class=fn>bool <a href="#focus-prop"><b>focus</b></a>&nbsp;- whether this widget (or its focus proxy) has the keyboard input focus &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#focusEnabled-prop"><b>focusEnabled</b></a>&nbsp;- whether the widget accepts keyboard focus &nbsp;<em>(read only)</em></li>
<li class=fn>FocusPolicy <a href="#focusPolicy-prop"><b>focusPolicy</b></a>&nbsp;- the way the widget accepts keyboard focus</li>
<li class=fn>QFont <a href="#font-prop"><b>font</b></a>&nbsp;- the font currently set for the widget</li>
<li class=fn>QRect <a href="#frameGeometry-prop"><b>frameGeometry</b></a>&nbsp;- geometry of the widget relative to its parent including any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>QSize <a href="#frameSize-prop"><b>frameSize</b></a>&nbsp;- the size of the widget including any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#fullScreen-prop"><b>fullScreen</b></a>&nbsp;- whether the widget is full screen &nbsp;<em>(read only)</em></li>
<li class=fn>QRect <a href="#geometry-prop"><b>geometry</b></a>&nbsp;- the geometry of the widget relative to its parent and excluding the window frame</li>
<li class=fn>int <a href="#height-prop"><b>height</b></a>&nbsp;- the height of the widget excluding any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#hidden-prop"><b>hidden</b></a>&nbsp;- whether the widget is explicitly hidden</li>
<li class=fn>QPixmap <a href="#icon-prop"><b>icon</b></a>&nbsp;- the widget's icon</li>
<li class=fn>QString <a href="#iconText-prop"><b>iconText</b></a>&nbsp;- the widget's icon text</li>
<li class=fn>bool <a href="#inputMethodEnabled-prop"><b>inputMethodEnabled</b></a>&nbsp;- enables or disables the use of input methods for this widget</li>
<li class=fn>bool <a href="#isActiveWindow-prop"><b>isActiveWindow</b></a>&nbsp;- whether this widget is the active window &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#isDesktop-prop"><b>isDesktop</b></a>&nbsp;- whether the widget is a desktop widget, i.e. represents the desktop &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#isDialog-prop"><b>isDialog</b></a>&nbsp;- whether the widget is a dialog widget &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#isModal-prop"><b>isModal</b></a>&nbsp;- whether the widget is a modal widget &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#isPopup-prop"><b>isPopup</b></a>&nbsp;- whether the widget is a popup widget &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#isTopLevel-prop"><b>isTopLevel</b></a>&nbsp;- whether the widget is a top-level widget &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#maximized-prop"><b>maximized</b></a>&nbsp;- whether this widget is maximized &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#maximumHeight-prop"><b>maximumHeight</b></a>&nbsp;- the widget's maximum height</li>
<li class=fn>QSize <a href="#maximumSize-prop"><b>maximumSize</b></a>&nbsp;- the widget's maximum size</li>
<li class=fn>int <a href="#maximumWidth-prop"><b>maximumWidth</b></a>&nbsp;- the widget's maximum width</li>
<li class=fn>QRect <a href="#microFocusHint-prop"><b>microFocusHint</b></a>&nbsp;- the currently set micro focus hint for this widget &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#minimized-prop"><b>minimized</b></a>&nbsp;- whether this widget is minimized (iconified) &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#minimumHeight-prop"><b>minimumHeight</b></a>&nbsp;- the widget's minimum height</li>
<li class=fn>QSize <a href="#minimumSize-prop"><b>minimumSize</b></a>&nbsp;- the widget's minimum size</li>
<li class=fn>QSize <a href="#minimumSizeHint-prop"><b>minimumSizeHint</b></a>&nbsp;- the recommended minimum size for the widget &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#minimumWidth-prop"><b>minimumWidth</b></a>&nbsp;- the widget's minimum width</li>
<li class=fn>bool <a href="#mouseTracking-prop"><b>mouseTracking</b></a>&nbsp;- whether mouse tracking is enabled for the widget</li>
<li class=fn>bool <a href="#ownCursor-prop"><b>ownCursor</b></a>&nbsp;- whether the widget uses its own cursor &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#ownFont-prop"><b>ownFont</b></a>&nbsp;- whether the widget uses its own font &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#ownPalette-prop"><b>ownPalette</b></a>&nbsp;- whether the widget uses its own palette &nbsp;<em>(read only)</em></li>
<li class=fn>QPalette <a href="#palette-prop"><b>palette</b></a>&nbsp;- the widget's palette</li>
<li class=fn>QColor <a href="#paletteBackgroundColor-prop"><b>paletteBackgroundColor</b></a>&nbsp;- the background color of the widget</li>
<li class=fn>QPixmap <a href="#paletteBackgroundPixmap-prop"><b>paletteBackgroundPixmap</b></a>&nbsp;- the background pixmap of the widget</li>
<li class=fn>QColor <a href="#paletteForegroundColor-prop"><b>paletteForegroundColor</b></a>&nbsp;- the foreground color of the widget</li>
<li class=fn>QPoint <a href="#pos-prop"><b>pos</b></a>&nbsp;- the position of the widget within its parent widget</li>
<li class=fn>QRect <a href="#rect-prop"><b>rect</b></a>&nbsp;- the internal geometry of the widget excluding any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#shown-prop"><b>shown</b></a>&nbsp;- whether the widget is shown</li>
<li class=fn>QSize <a href="#size-prop"><b>size</b></a>&nbsp;- the size of the widget excluding any window frame</li>
<li class=fn>QSize <a href="#sizeHint-prop"><b>sizeHint</b></a>&nbsp;- the recommended size for the widget &nbsp;<em>(read only)</em></li>
<li class=fn>QSize <a href="#sizeIncrement-prop"><b>sizeIncrement</b></a>&nbsp;- the size increment of the widget</li>
<li class=fn>QSizePolicy <a href="#sizePolicy-prop"><b>sizePolicy</b></a>&nbsp;- the default layout behavior of the widget</li>
<li class=fn>bool <a href="#underMouse-prop"><b>underMouse</b></a>&nbsp;- whether the widget is under the mouse cursor &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#updatesEnabled-prop"><b>updatesEnabled</b></a>&nbsp;- whether updates are enabled</li>
<li class=fn>bool <a href="#visible-prop"><b>visible</b></a>&nbsp;- whether the widget is visible &nbsp;<em>(read only)</em></li>
<li class=fn>QRect visibleRect&nbsp;- the visible rectangle &nbsp;<em>(read only)</em> &nbsp;<em>(obsolete)</em></li>
<li class=fn>int <a href="#width-prop"><b>width</b></a>&nbsp;- the width of the widget excluding any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>double <a href="#windowOpacity-prop"><b>windowOpacity</b></a>&nbsp;- the level of opacity for the window</li>
<li class=fn>int <a href="#x-prop"><b>x</b></a>&nbsp;- the x coordinate of the widget relative to its parent including any window frame &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#y-prop"><b>y</b></a>&nbsp;- the y coordinate of the widget relative to its parent and including any window frame &nbsp;<em>(read only)</em></li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>virtual bool <a href="#event"><b>event</b></a> ( QEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#mousePressEvent"><b>mousePressEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#mouseReleaseEvent"><b>mouseReleaseEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#mouseDoubleClickEvent"><b>mouseDoubleClickEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#mouseMoveEvent"><b>mouseMoveEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#wheelEvent"><b>wheelEvent</b></a> ( QWheelEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#keyPressEvent"><b>keyPressEvent</b></a> ( QKeyEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#keyReleaseEvent"><b>keyReleaseEvent</b></a> ( QKeyEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#focusInEvent"><b>focusInEvent</b></a> ( QFocusEvent * )</li>
<li class=fn>virtual void <a href="#focusOutEvent"><b>focusOutEvent</b></a> ( QFocusEvent * )</li>
<li class=fn>virtual void <a href="#enterEvent"><b>enterEvent</b></a> ( QEvent * )</li>
<li class=fn>virtual void <a href="#leaveEvent"><b>leaveEvent</b></a> ( QEvent * )</li>
<li class=fn>virtual void <a href="#paintEvent"><b>paintEvent</b></a> ( QPaintEvent * )</li>
<li class=fn>virtual void <a href="#moveEvent"><b>moveEvent</b></a> ( QMoveEvent * )</li>
<li class=fn>virtual void <a href="#resizeEvent"><b>resizeEvent</b></a> ( QResizeEvent * )</li>
<li class=fn>virtual void <a href="#closeEvent"><b>closeEvent</b></a> ( QCloseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contextMenuEvent"><b>contextMenuEvent</b></a> ( QContextMenuEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#imStartEvent"><b>imStartEvent</b></a> ( QIMEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#imComposeEvent"><b>imComposeEvent</b></a> ( QIMEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#imEndEvent"><b>imEndEvent</b></a> ( QIMEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#tabletEvent"><b>tabletEvent</b></a> ( QTabletEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#dragEnterEvent"><b>dragEnterEvent</b></a> ( QDragEnterEvent * )</li>
<li class=fn>virtual void <a href="#dragMoveEvent"><b>dragMoveEvent</b></a> ( QDragMoveEvent * )</li>
<li class=fn>virtual void <a href="#dragLeaveEvent"><b>dragLeaveEvent</b></a> ( QDragLeaveEvent * )</li>
<li class=fn>virtual void <a href="#dropEvent"><b>dropEvent</b></a> ( QDropEvent * )</li>
<li class=fn>virtual void <a href="#showEvent"><b>showEvent</b></a> ( QShowEvent * )</li>
<li class=fn>virtual void <a href="#hideEvent"><b>hideEvent</b></a> ( QHideEvent * )</li>
<li class=fn>virtual bool <a href="#macEvent"><b>macEvent</b></a> ( MSG * )</li>
<li class=fn>virtual bool <a href="#winEvent"><b>winEvent</b></a> ( MSG * )</li>
<li class=fn>virtual bool <a href="#x11Event"><b>x11Event</b></a> ( XEvent * )</li>
<li class=fn>virtual bool <a href="#qwsEvent"><b>qwsEvent</b></a> ( QWSEvent * )</li>
<li class=fn>virtual void <a href="#updateMask"><b>updateMask</b></a> ()</li>
<li class=fn>virtual void <a href="#styleChange"><b>styleChange</b></a> ( QStyle&nbsp;&amp;&nbsp;oldStyle )</li>
<li class=fn>virtual void <a href="#enabledChange"><b>enabledChange</b></a> ( bool&nbsp;oldEnabled )</li>
<li class=fn>virtual void <a href="#paletteChange"><b>paletteChange</b></a> ( const&nbsp;QPalette&nbsp;&amp;&nbsp;oldPalette )</li>
<li class=fn>virtual void <a href="#fontChange"><b>fontChange</b></a> ( const&nbsp;QFont&nbsp;&amp;&nbsp;oldFont )</li>
<li class=fn>virtual void <a href="#windowActivationChange"><b>windowActivationChange</b></a> ( bool&nbsp;oldActive )</li>
<li class=fn>virtual int <a href="#metric"><b>metric</b></a> ( int&nbsp;m ) const</li>
<li class=fn>void <a href="#resetInputContext"><b>resetInputContext</b></a> ()</li>
<li class=fn>virtual void <a href="#create"><b>create</b></a> ( WId&nbsp;window = 0, bool&nbsp;initializeWindow = TRUE, bool&nbsp;destroyOldWindow = TRUE )</li>
<li class=fn>virtual void <a href="#destroy"><b>destroy</b></a> ( bool&nbsp;destroyWindow = TRUE, bool&nbsp;destroySubWindows = TRUE )</li>
<li class=fn>WFlags <a href="#getWFlags"><b>getWFlags</b></a> () const</li>
<li class=fn>virtual void <a href="#setWFlags"><b>setWFlags</b></a> ( WFlags&nbsp;f )</li>
<li class=fn>void <a href="#clearWFlags"><b>clearWFlags</b></a> ( WFlags&nbsp;f )</li>
<li class=fn>virtual bool <a href="#focusNextPrevChild"><b>focusNextPrevChild</b></a> ( bool&nbsp;next )</li>
<li class=fn>QFocusData * <a href="#focusData"><b>focusData</b></a> ()</li>
<li class=fn>virtual void <a href="#setKeyCompression"><b>setKeyCompression</b></a> ( bool&nbsp;compress )</li>
<li class=fn>virtual void <a href="#setMicroFocusHint"><b>setMicroFocusHint</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;width, int&nbsp;height, bool&nbsp;text = TRUE, QFont&nbsp;*&nbsp;f = 0 )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QWidget class is the base class of all user interface objects.
<p> 

<p> The widget is the atom of the user interface: it receives mouse,
keyboard and other events from the window system, and paints a
representation of itself on the screen. Every widget is
rectangular, and they are sorted in a Z-order. A widget is
clipped by its parent and by the widgets in front of it.
<p> A widget that isn't embedded in a parent widget is called a
top-level widget. Usually, top-level widgets are windows with a
frame and a title bar (although it is also possible to create
top-level widgets without such decoration if suitable widget flags
are used). In Qt, <a href="qmainwindow.html">QMainWindow</a> and the various subclasses of
<a href="qdialog.html">QDialog</a> are the most common top-level windows.
<p> A widget without a parent widget is always a top-level widget.
<p> Non-top-level widgets are child widgets. These are child windows
in their parent widgets. You cannot usually distinguish a child
widget from its parent visually. Most other widgets in Qt are
useful only as child widgets. (It is possible to make, say, a
button into a top-level widget, but most people prefer to put
their buttons inside other widgets, e.g. QDialog.)
<p> If you want to use a QWidget to hold child widgets you will
probably want to add a layout to the parent QWidget. (See <a href="layout.html">Layouts</a>.)
<p> QWidget has many member functions, but some of them have little
direct functionality: for example, QWidget has a font property,
but never uses this itself. There are many subclasses which
provide real functionality, such as <a href="qpushbutton.html">QPushButton</a>, <a href="qlistbox.html">QListBox</a> and
<a href="qtabdialog.html">QTabDialog</a>, etc.
<p> <h3> Groups of functions:
</h3>
<a name="1"></a><p> <center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Context <th valign="top">Functions
<tr bgcolor="#f0f0f0"> <td valign="top">Window functions <td valign="top">
<a href="#show">show</a>(),
<a href="#hide">hide</a>(),
<a href="#raise">raise</a>(),
<a href="#lower">lower</a>(),
<a href="#close">close</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">Top level windows <td valign="top">
<a href="#caption">caption</a>(),
<a href="#setCaption">setCaption</a>(),
<a href="#icon">icon</a>(),
<a href="#setIcon">setIcon</a>(),
<a href="#iconText">iconText</a>(),
<a href="#setIconText">setIconText</a>(),
<a href="#isActiveWindow">isActiveWindow</a>(),
<a href="#setActiveWindow">setActiveWindow</a>(),
<a href="#showMinimized">showMinimized</a>().
<a href="#showMaximized">showMaximized</a>(),
<a href="#showFullScreen">showFullScreen</a>(),
<a href="#showNormal">showNormal</a>().
<tr bgcolor="#f0f0f0"> <td valign="top">Window contents <td valign="top">
<a href="#update">update</a>(),
<a href="#repaint">repaint</a>(),
<a href="#erase">erase</a>(),
<a href="#scroll">scroll</a>(),
<a href="#updateMask">updateMask</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">Geometry <td valign="top">
<a href="#pos">pos</a>(),
<a href="#size">size</a>(),
<a href="#rect">rect</a>(),
<a href="#x">x</a>(),
<a href="#y">y</a>(),
<a href="#width">width</a>(),
<a href="#height">height</a>(),
<a href="#sizePolicy">sizePolicy</a>(),
<a href="#setSizePolicy">setSizePolicy</a>(),
<a href="#sizeHint">sizeHint</a>(),
<a href="#updateGeometry">updateGeometry</a>(),
<a href="#layout">layout</a>(),
<a href="#move">move</a>(),
<a href="#resize">resize</a>(),
<a href="#setGeometry">setGeometry</a>(),
<a href="#frameGeometry">frameGeometry</a>(),
<a href="#geometry">geometry</a>(),
<a href="#childrenRect">childrenRect</a>(),
<a href="#adjustSize">adjustSize</a>(),
<a href="#mapFromGlobal">mapFromGlobal</a>(),
<a href="#mapFromParent">mapFromParent</a>()
<a href="#mapToGlobal">mapToGlobal</a>(),
<a href="#mapToParent">mapToParent</a>(),
<a href="#maximumSize">maximumSize</a>(),
<a href="#minimumSize">minimumSize</a>(),
<a href="#sizeIncrement">sizeIncrement</a>(),
<a href="#setMaximumSize">setMaximumSize</a>(),
<a href="#setMinimumSize">setMinimumSize</a>(),
<a href="#setSizeIncrement">setSizeIncrement</a>(),
<a href="#setBaseSize">setBaseSize</a>(),
<a href="#setFixedSize">setFixedSize</a>()
<tr bgcolor="#f0f0f0"> <td valign="top">Mode <td valign="top">
<a href="#isVisible">isVisible</a>(),
<a href="#isVisibleTo">isVisibleTo</a>(),
<a href="#isMinimized">isMinimized</a>(),
<a href="#isDesktop">isDesktop</a>(),
<a href="#isEnabled">isEnabled</a>(),
<a href="#isEnabledTo">isEnabledTo</a>(),
<a href="#isModal">isModal</a>(),
<a href="#isPopup">isPopup</a>(),
<a href="#isTopLevel">isTopLevel</a>(),
<a href="#setEnabled">setEnabled</a>(),
<a href="#hasMouseTracking">hasMouseTracking</a>(),
<a href="#setMouseTracking">setMouseTracking</a>(),
<a href="#isUpdatesEnabled">isUpdatesEnabled</a>(),
<a href="#setUpdatesEnabled">setUpdatesEnabled</a>(),
<a href="#clipRegion">clipRegion</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">Look and feel <td valign="top">
<a href="#style">style</a>(),
<a href="#setStyle">setStyle</a>(),
<a href="#cursor">cursor</a>(),
<a href="#setCursor">setCursor</a>()
<a href="#font">font</a>(),
<a href="#setFont">setFont</a>(),
<a href="#palette">palette</a>(),
<a href="#setPalette">setPalette</a>(),
<a href="#backgroundMode">backgroundMode</a>(),
<a href="#setBackgroundMode">setBackgroundMode</a>(),
<a href="#colorGroup">colorGroup</a>(),
<a href="#fontMetrics">fontMetrics</a>(),
<a href="#fontInfo">fontInfo</a>().
<tr bgcolor="#f0f0f0"> <td valign="top"><a href="focus.html#keyboard-focus">Keyboard focus</a><br>functions <td valign="top">
<a href="#isFocusEnabled">isFocusEnabled</a>(),
<a href="#setFocusPolicy">setFocusPolicy</a>(),
<a href="#focusPolicy">focusPolicy</a>(),
<a href="#hasFocus">hasFocus</a>(),
<a href="#setFocus">setFocus</a>(),
<a href="#clearFocus">clearFocus</a>(),
<a href="#setTabOrder">setTabOrder</a>(),
<a href="#setFocusProxy">setFocusProxy</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">Mouse and<br>keyboard grabbing <td valign="top">
<a href="#grabMouse">grabMouse</a>(),
<a href="#releaseMouse">releaseMouse</a>(),
<a href="#grabKeyboard">grabKeyboard</a>(),
<a href="#releaseKeyboard">releaseKeyboard</a>(),
<a href="#mouseGrabber">mouseGrabber</a>(),
<a href="#keyboardGrabber">keyboardGrabber</a>().
<tr bgcolor="#f0f0f0"> <td valign="top">Event handlers <td valign="top">
<a href="#event">event</a>(),
<a href="#mousePressEvent">mousePressEvent</a>(),
<a href="#mouseReleaseEvent">mouseReleaseEvent</a>(),
<a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(),
<a href="#mouseMoveEvent">mouseMoveEvent</a>(),
<a href="#keyPressEvent">keyPressEvent</a>(),
<a href="#keyReleaseEvent">keyReleaseEvent</a>(),
<a href="#focusInEvent">focusInEvent</a>(),
<a href="#focusOutEvent">focusOutEvent</a>(),
<a href="#wheelEvent">wheelEvent</a>(),
<a href="#enterEvent">enterEvent</a>(),
<a href="#leaveEvent">leaveEvent</a>(),
<a href="#paintEvent">paintEvent</a>(),
<a href="#moveEvent">moveEvent</a>(),
<a href="#resizeEvent">resizeEvent</a>(),
<a href="#closeEvent">closeEvent</a>(),
<a href="#dragEnterEvent">dragEnterEvent</a>(),
<a href="#dragMoveEvent">dragMoveEvent</a>(),
<a href="#dragLeaveEvent">dragLeaveEvent</a>(),
<a href="#dropEvent">dropEvent</a>(),
<a href="qobject.html#childEvent">childEvent</a>(),
<a href="#showEvent">showEvent</a>(),
<a href="#hideEvent">hideEvent</a>(),
<a href="qobject.html#customEvent">customEvent</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">Change handlers <td valign="top">
<a href="#enabledChange">enabledChange</a>(),
<a href="#fontChange">fontChange</a>(),
<a href="#paletteChange">paletteChange</a>(),
<a href="#styleChange">styleChange</a>(),
<a href="#windowActivationChange">windowActivationChange</a>().
<tr bgcolor="#f0f0f0"> <td valign="top">System functions <td valign="top">
<a href="#parentWidget">parentWidget</a>(),
<a href="#topLevelWidget">topLevelWidget</a>(),
<a href="#reparent">reparent</a>(),
<a href="#polish">polish</a>(),
<a href="#winId">winId</a>(),
<a href="#find">find</a>(),
<a href="#metric">metric</a>().
<tr bgcolor="#d0d0d0"> <td valign="top">What's this help <td valign="top">
<a href="#customWhatsThis">customWhatsThis</a>()
<tr bgcolor="#f0f0f0"> <td valign="top">Internal kernel<br>functions <td valign="top">
<a href="#focusNextPrevChild">focusNextPrevChild</a>(),
wmapper(),
<a href="#clearWFlags">clearWFlags</a>(),
<a href="#getWFlags">getWFlags</a>(),
<a href="#setWFlags">setWFlags</a>(),
<a href="#testWFlags">testWFlags</a>().
<p> </table></center>
<p> Every widget's constructor accepts two or three standard arguments:
<ol type=1>
<li> <tt>QWidget *parent = 0</tt> is the parent of the new widget.
If it is 0 (the default), the new widget will be a top-level window.
If not, it will be a child of <em>parent</em>, and be constrained by <em>parent</em>'s geometry (unless you specify <a href="qt.html#WidgetFlags-enum">WType_TopLevel</a> as
<a href="qt.html#WidgetFlags">widget flag</a>).
<li> <tt>const char *name = 0</tt> is the widget name of the new
widget. You can access it using <a href="qobject.html#name">name</a>(). The widget name is little
used by programmers but is quite useful with GUI builders such as
<em>Qt Designer</em> (you can name a widget in <em>Qt Designer</em>, and
<a href="qobject.html#connect">connect</a>() to it using the name in your code). The <a href="qobject.html#dumpObjectTree">dumpObjectTree</a>()
debugging function also uses it.
<li> <tt>WFlags f = 0</tt> (where available) sets the widget flags; the
default is suitable for almost all widgets, but to get, for
example, a top-level widget without a window system frame, you
must use special flags.
</ol>
<p> The tictac/tictac.cpp example program is good example of a simple
widget. It contains a few event handlers (as all widgets must), a
few custom routines that are specific to it (as all useful widgets
do), and has a few children and connections. Everything it does
is done in response to an event: this is by far the most common way
to design GUI applications.
<p> You will need to supply the content for your widgets yourself, but
here is a brief run-down of the events, starting with the most common
ones:
<p> <ul>
<p> <li> <a href="#paintEvent">paintEvent</a>() - called whenever the widget needs to be
repainted. Every widget which displays output must implement it,
and it is wise <em>not</em> to paint on the screen outside
paintEvent().
<p> <li> <a href="#resizeEvent">resizeEvent</a>() - called when the widget has been resized.
<p> <li> <a href="#mousePressEvent">mousePressEvent</a>() - called when a mouse button is pressed.
There are six mouse-related events, but the mouse press and mouse
release events are by far the most important. A widget receives
mouse press events when the mouse is inside it, or when it has
grabbed the mouse using <a href="#grabMouse">grabMouse</a>().
<p> <li> <a href="#mouseReleaseEvent">mouseReleaseEvent</a>() - called when a mouse button is released.
A widget receives mouse release events when it has received the
corresponding mouse press event. This means that if the user
presses the mouse inside <em>your</em> widget, then drags the mouse to
somewhere else, then releases, <em>your</em> widget receives the release
event. There is one exception: if a popup menu appears while the
mouse button is held down, this popup immediately steals the mouse
events.
<p> <li> <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>() - not quite as obvious as it might seem.
If the user double-clicks, the widget receives a mouse press event
(perhaps a mouse move event or two if they don't hold the mouse
quite steady), a mouse release event and finally this event. It is
<em>not possible</em> to distinguish a click from a double click until you've
seen whether the second click arrives. (This is one reason why most GUI
books recommend that double clicks be an extension of single clicks,
rather than trigger a different action.)
<p> </ul>
<p> If your widget only contains child widgets, you probably do not need to
implement any event handlers. If you want to detect a mouse click in
a child widget call the child's <a href="#hasMouse">hasMouse</a>() function inside the
parent widget's <a href="#mousePressEvent">mousePressEvent</a>().
<p> Widgets that accept keyboard input need to reimplement a few more
event handlers:
<p> <ul>
<p> <li> <a href="#keyPressEvent">keyPressEvent</a>() - called whenever a key is pressed, and again
when a key has been held down long enough for it to auto-repeat.
Note that the Tab and Shift+Tab keys are only passed to the widget
if they are not used by the focus-change mechanisms. To force those
keys to be processed by your widget, you must reimplement
<a href="#event">QWidget::event</a>().
<p> <li> <a href="#focusInEvent">focusInEvent</a>() - called when the widget gains keyboard focus
(assuming you have called <a href="#setFocusPolicy">setFocusPolicy</a>()). Well written widgets
indicate that they own the keyboard focus in a clear but discreet
way.
<p> <li> <a href="#focusOutEvent">focusOutEvent</a>() - called when the widget loses keyboard focus.
<p> </ul>
<p> Some widgets will also need to reimplement some of the less common
event handlers:
<p> <ul>
<p> <li> <a href="#mouseMoveEvent">mouseMoveEvent</a>() - called whenever the mouse moves while a
button is held down. This is useful for, for example, dragging. If
you call <a href="#setMouseTracking">setMouseTracking</a>(TRUE), you get mouse move events even
when no buttons are held down. (Note that applications which make
use of mouse tracking are often not very useful on low-bandwidth X
connections.) (See also the <a href="dnd.html">drag and drop</a>
information.)
<p> <li> <a href="#keyReleaseEvent">keyReleaseEvent</a>() - called whenever a key is released, and also
while it is held down if the key is auto-repeating. In that case
the widget receives a key release event and immediately a key press
event for every repeat. Note that the Tab and Shift+Tab keys are
only passed to the widget if they are not used by the focus-change
mechanisms. To force those keys to be processed by your widget, you
must reimplement <a href="#event">QWidget::event</a>().
<p> <li> <a href="#wheelEvent">wheelEvent</a>() -- called whenever the user turns the mouse wheel
while the widget has the focus.
<p> <li> <a href="#enterEvent">enterEvent</a>() - called when the mouse enters the widget's screen
space. (This excludes screen space owned by any children of the
widget.)
<p> <li> <a href="#leaveEvent">leaveEvent</a>() - called when the mouse leaves the widget's screen
space.
<p> <li> <a href="#moveEvent">moveEvent</a>() - called when the widget has been moved relative to its
parent.
<p> <li> <a href="#closeEvent">closeEvent</a>() - called when the user closes the widget (or when
<a href="#close">close</a>() is called).
<p> </ul>
<p> There are also some rather obscure events. They are listed in
<a href="qevent-h.html">qevent.h</a> and you need to reimplement <a href="#event">event</a>() to handle them.
The default implementation of event() handles Tab and Shift+Tab
(to move the keyboard focus), and passes on most other events to
one of the more specialized handlers above.
<p> When implementing a widget, there are a few more things to
consider.
<p> <ul>
<p> <li> In the constructor, be sure to set up your member variables
early on, before there's any chance that you might receive an event.
<p> <li> It is almost always useful to reimplement <a href="#sizeHint">sizeHint</a>() and to set
the correct size policy with <a href="#setSizePolicy">setSizePolicy</a>(), so users of your class
can set up layout management more easily. A size policy lets you
supply good defaults for the layout management handling, so that
other widgets can contain and manage yours easily. sizeHint()
indicates a "good" size for the widget.
<p> <li> If your widget is a top-level window, <a href="#setCaption">setCaption</a>() and <a href="#setIcon">setIcon</a>() set
the title bar and icon respectively.
<p> </ul>
<p> <p>See also <a href="qevent.html">QEvent</a>, <a href="qpainter.html">QPainter</a>, <a href="qgridlayout.html">QGridLayout</a>, <a href="qboxlayout.html">QBoxLayout</a>, and <a href="abstractwidgets.html">Abstract Widget Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="BackgroundOrigin-enum"></a>QWidget::BackgroundOrigin</h3>

<p> This enum defines the origin used to draw a widget's background
pixmap.
<p> The pixmap is drawn using the:
<ul>
<li><tt>QWidget::WidgetOrigin</tt> - widget's coordinate system.
<li><tt>QWidget::ParentOrigin</tt> - parent's coordinate system.
<li><tt>QWidget::WindowOrigin</tt> - top-level window's coordinate system.
<li><tt>QWidget::AncestorOrigin</tt> - same origin as the parent uses.
</ul>
<h3 class=fn><a name="FocusPolicy-enum"></a>QWidget::FocusPolicy</h3>

<p> This enum type defines the various policies a widget can have with
respect to acquiring <a href="focus.html#keyboard-focus">keyboard focus</a>.
<ul>
<li><tt>QWidget::TabFocus</tt> - the widget accepts focus by tabbing.
<li><tt>QWidget::ClickFocus</tt> - the widget accepts focus by clicking.
<li><tt>QWidget::StrongFocus</tt> - the widget accepts focus by both tabbing
and clicking. On Mac OS X this will also
be indicate that the widget accepts tab focus
when in 'Text/List focus mode'.
<li><tt>QWidget::WheelFocus</tt> - like StrongFocus plus the widget accepts
focus by using the mouse wheel.
<li><tt>QWidget::NoFocus</tt> - the widget does not accept focus.
</ul><p> 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn>explicit <a name="QWidget"></a>QWidget::QWidget ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, WFlags&nbsp;f = 0 )
</h3>
Constructs a widget which is a child of <em>parent</em>, with the name
<em>name</em> and widget flags set to <em>f</em>.
<p> If <em>parent</em> is 0, the new widget becomes a top-level window. If
<em>parent</em> is another widget, this widget becomes a child window
inside <em>parent</em>. The new widget is deleted when its <em>parent</em> is
deleted.
<p> The <em>name</em> is sent to the <a href="qobject.html">QObject</a> constructor.
<p> The widget flags argument, <em>f</em>, is normally 0, but it can be set
to customize the window frame of a top-level widget (i.e. <em>parent</em> must be 0). To customize the frame, set the <a href="qt.html#WidgetFlags-enum">WStyle_Customize</a> flag OR'ed with any of the <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.
<p> If you add a child widget to an already visible widget you must
explicitly show the child to make it visible.
<p> Note that the X11 version of Qt may not be able to deliver all
combinations of style flags on all systems. This is because on
X11, Qt can only ask the window manager, and the window manager
can override the application's settings. On Windows, Qt can set
whatever flags you want.
<p> Example:
<pre>
    <a href="qlabel.html">QLabel</a> *splashScreen = new <a href="qlabel.html">QLabel</a>( 0, "mySplashScreen",
                                WStyle_Customize | WStyle_Splash );
    </pre>
 

<h3 class=fn><a name="~QWidget"></a>QWidget::~QWidget ()
</h3>
Destroys the widget.
<p> All this widget's children are deleted first. The application
exits if this widget is the main widget.

<h3 class=fn>bool <a name="acceptDrops"></a>QWidget::acceptDrops () const
</h3><p>Returns TRUE if drop events are enabled for this widget; otherwise returns FALSE.
See the <a href="qwidget.html#acceptDrops-prop">"acceptDrops"</a> property for details.
<h3 class=fn>void <a name="adjustSize"></a>QWidget::adjustSize ()<tt> [virtual slot]</tt>
</h3>
Adjusts the size of the widget to fit the contents.
<p> Uses <a href="#sizeHint">sizeHint</a>() if valid (i.e if the size hint's width and height
are &gt;= 0), otherwise sets the size to the children rectangle (the
union of all child widget geometries).
<p> <p>See also <a href="#sizeHint-prop">sizeHint</a> and <a href="#childrenRect-prop">childrenRect</a>.

<p>Example: <a href="xform-example.html#x1266">xform/xform.cpp</a>.
<p>Reimplemented in <a href="qmessagebox.html#adjustSize">QMessageBox</a>.
<h3 class=fn>bool <a name="autoMask"></a>QWidget::autoMask () const
</h3><p>Returns TRUE if the auto mask feature is enabled for the widget; otherwise returns FALSE.
See the <a href="qwidget.html#autoMask-prop">"autoMask"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qbrush.html">QBrush</a>&nbsp;&amp; <a name="backgroundBrush"></a>QWidget::backgroundBrush () const
</h3><p>Returns the widget's background brush.
See the <a href="qwidget.html#backgroundBrush-prop">"backgroundBrush"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="backgroundColor"></a>QWidget::backgroundColor () const
</h3><b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
Use <a href="#paletteBackgroundColor">paletteBackgroundColor</a>() or <a href="#eraseColor">eraseColor</a>() instead. 
<h3 class=fn><a href="qt.html#BackgroundMode-enum">BackgroundMode</a> <a name="backgroundMode"></a>QWidget::backgroundMode () const
</h3><p>Returns the color role used for painting the background of the widget.
See the <a href="qwidget.html#backgroundMode-prop">"backgroundMode"</a> property for details.
<h3 class=fn><a href="qwidget.html#BackgroundOrigin-enum">BackgroundOrigin</a> <a name="backgroundOrigin"></a>QWidget::backgroundOrigin () const
</h3><p>Returns the origin of the widget's background.
See the <a href="qwidget.html#backgroundOrigin-prop">"backgroundOrigin"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;* <a name="backgroundPixmap"></a>QWidget::backgroundPixmap () const
</h3><b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
Use <a href="#paletteBackgroundPixmap">paletteBackgroundPixmap</a>()  or <a href="#erasePixmap">erasePixmap</a>() instead. 
<p>Examples: <a href="themes-example.html#x305">themes/metal.cpp</a> and <a href="themes-example.html#x250">themes/wood.cpp</a>.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="baseSize"></a>QWidget::baseSize () const
</h3><p>Returns the base size of the widget.
See the <a href="qwidget.html#baseSize-prop">"baseSize"</a> property for details.
<h3 class=fn><a href="qstring.html">QString</a> <a name="caption"></a>QWidget::caption () const
</h3><p>Returns the window caption (title).
See the <a href="qwidget.html#caption-prop">"caption"</a> property for details.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="childAt"></a>QWidget::childAt ( int&nbsp;x, int&nbsp;y, bool&nbsp;includeThis = FALSE ) const
</h3>
Returns the visible child widget at pixel position <em>(x, y)</em> in
the widget's own coordinate system.
<p> If <em>includeThis</em> is TRUE, and there is no child visible at <em>(x, y)</em>, the widget itself is returned.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="childAt-2"></a>QWidget::childAt ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p, bool&nbsp;includeThis = FALSE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the visible child widget at point <em>p</em> in the widget's own
coordinate system.
<p> If <em>includeThis</em> is TRUE, and there is no child visible at <em>p</em>,
the widget itself is returned.
<p> 
<h3 class=fn><a href="qrect.html">QRect</a> <a name="childrenRect"></a>QWidget::childrenRect () const
</h3><p>Returns the bounding rectangle of the widget's children.
See the <a href="qwidget.html#childrenRect-prop">"childrenRect"</a> property for details.
<h3 class=fn><a href="qregion.html">QRegion</a> <a name="childrenRegion"></a>QWidget::childrenRegion () const
</h3><p>Returns the combined region occupied by the widget's children.
See the <a href="qwidget.html#childrenRegion-prop">"childrenRegion"</a> property for details.
<h3 class=fn>void <a name="clearFocus"></a>QWidget::clearFocus ()<tt> [slot]</tt>
</h3>
Takes keyboard input focus from the widget.
<p> If the widget has active focus, a <a href="#focusOutEvent">focus out
    event</a> is sent to this widget to tell it that it is about
to lose the focus.
<p> This widget must enable focus setting in order to get the keyboard
input focus, i.e. it must call <a href="#setFocusPolicy">setFocusPolicy</a>().
<p> <p>See also <a href="#focus-prop">focus</a>, <a href="#setFocus">setFocus</a>(), <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, and <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>().

<h3 class=fn>void <a name="clearMask"></a>QWidget::clearMask ()
</h3>
Removes any mask set by <a href="#setMask">setMask</a>().
<p> <p>See also <a href="#setMask">setMask</a>().

<h3 class=fn>void <a name="clearWFlags"></a>QWidget::clearWFlags ( WFlags&nbsp;f )<tt> [protected]</tt>
</h3>

<p> Clears the widget flags <em>f</em>.
<p> Widget flags are a combination of <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.
<p> <p>See also <a href="#testWFlags">testWFlags</a>(), <a href="#getWFlags">getWFlags</a>(), and <a href="#setWFlags">setWFlags</a>().

<h3 class=fn><a href="qregion.html">QRegion</a> <a name="clipRegion"></a>QWidget::clipRegion () const
</h3>
Returns the unobscured region where paint events can occur.
<p> For visible widgets, this is an approximation of the area not
covered by other widgets; otherwise, this is an empty region.
<p> The <a href="#repaint">repaint</a>() function calls this function if necessary, so in
general you do not need to call it.
<p> 
<h3 class=fn>bool <a name="close"></a>QWidget::close ()<tt> [slot]</tt>
</h3>

<p> Closes this widget. Returns TRUE if the widget was closed;
otherwise returns FALSE.
<p> First it sends the widget a <a href="qcloseevent.html">QCloseEvent</a>. The widget is <a href="#hide">hidden</a> if it <a href="qcloseevent.html#accept">accepts</a> the close event. The default implementation of
<a href="#closeEvent">QWidget::closeEvent</a>() accepts the close event.
<p> The <a href="qapplication.html#lastWindowClosed">QApplication::lastWindowClosed</a>() signal is emitted when the
last visible top level widget is closed.
<p> 
<p>Examples: <a href="motif-dialog-example.html#x2708">dialog/mainwindow.cpp</a>, <a href="mdi-example.html#x2076">mdi/application.cpp</a>, <a href="popup-example.html#x1616">popup/popup.cpp</a>, and <a href="toplevel-example.html#x2535">toplevel/options.ui.h</a>.
<h3 class=fn>bool <a name="close-2"></a>QWidget::close ( bool&nbsp;alsoDelete )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Closes this widget. Returns TRUE if the widget was closed;
otherwise returns FALSE.
<p> If <em>alsoDelete</em> is TRUE or the widget has the <a href="qt.html#WidgetFlags-enum">WDestructiveClose</a> widget flag, the widget is also deleted. The
widget can prevent itself from being closed by rejecting the
<a href="qcloseevent.html">QCloseEvent</a> it gets. A close events is delivered to the widget
no matter if the widget is visible or not.
<p> The <a href="qapplication.html#lastWindowClosed">QApplication::lastWindowClosed</a>() signal is emitted when the
last visible top level widget is closed.
<p> Note that closing the <a href="qapplication.html#mainWidget">QApplication::mainWidget</a>() terminates the
application.
<p> <p>See also <a href="#closeEvent">closeEvent</a>(), <a href="qcloseevent.html">QCloseEvent</a>, <a href="#hide">hide</a>(), <a href="qapplication.html#quit">QApplication::quit</a>(), <a href="qapplication.html#setMainWidget">QApplication::setMainWidget</a>(), and <a href="qapplication.html#lastWindowClosed">QApplication::lastWindowClosed</a>().

<h3 class=fn>void <a name="closeEvent"></a>QWidget::closeEvent ( <a href="qcloseevent.html">QCloseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive widget close events.
<p> The default implementation calls e->accept(), which hides this
widget. See the <a href="qcloseevent.html">QCloseEvent</a> documentation for more details.
<p> <p>See also <a href="#event">event</a>(), <a href="#hide">hide</a>(), <a href="#close">close</a>(), and <a href="qcloseevent.html">QCloseEvent</a>.

<p>Examples: <a href="qaction-application-example.html#x1173">action/application.cpp</a>, <a href="simple-application-example.html#x1592">application/application.cpp</a>, <a href="canvas-chart-example.html#x2896">chart/chartform.cpp</a>, <a href="i18n-example.html#x1927">i18n/mywidget.cpp</a>, <a href="mdi-example.html#x2077">mdi/application.cpp</a>, <a href="popup-example.html#x1617">popup/popup.cpp</a>, and <a href="qwerty-example.html#x404">qwerty/qwerty.cpp</a>.
<h3 class=fn>const&nbsp;<a href="qcolorgroup.html">QColorGroup</a>&nbsp;&amp; <a name="colorGroup"></a>QWidget::colorGroup () const
</h3><p>Returns the current color group of the widget palette.
See the <a href="qwidget.html#colorGroup-prop">"colorGroup"</a> property for details.
<h3 class=fn>void <a name="constPolish"></a>QWidget::constPolish () const<tt> [slot]</tt>
</h3>

<p> Ensures that the widget is properly initialized by calling
<a href="#polish">polish</a>().
<p> Call <a href="#constPolish">constPolish</a>() from functions like <a href="#sizeHint">sizeHint</a>() that depends on
the widget being initialized, and that may be called before
<a href="#show">show</a>().
<p> <b>Warning:</b> Do not call constPolish() on a widget from inside that
widget's constructor.
<p> <p>See also <a href="#polish">polish</a>().

<h3 class=fn>void <a name="contextMenuEvent"></a>QWidget::contextMenuEvent ( <a href="qcontextmenuevent.html">QContextMenuEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive widget context menu events.
<p> The default implementation calls e->ignore(), which rejects the
context event. See the <a href="qcontextmenuevent.html">QContextMenuEvent</a> documentation for
more details.
<p> <p>See also <a href="#event">event</a>() and <a href="qcontextmenuevent.html">QContextMenuEvent</a>.

<p>Example: <a href="menu-example.html#x1881">menu/menu.cpp</a>.
<h3 class=fn>void <a name="create"></a>QWidget::create ( WId&nbsp;window = 0, bool&nbsp;initializeWindow = TRUE, bool&nbsp;destroyOldWindow = TRUE )<tt> [virtual protected]</tt>
</h3>
Creates a new widget window if <em>window</em> is 0, otherwise sets the
widget's window to <em>window</em>.
<p> Initializes the window (sets the geometry etc.) if <em>initializeWindow</em> is TRUE. If <em>initializeWindow</em> is FALSE, no
initialization is performed. This parameter only makes sense if <em>window</em> is a valid window.
<p> Destroys the old window if <em>destroyOldWindow</em> is TRUE. If <em>destroyOldWindow</em> is FALSE, you are responsible for destroying the
window yourself (using platform native code).
<p> The QWidget constructor calls <a href="#create">create</a>(0,TRUE,TRUE) to create a
window for this widget.

<h3 class=fn>const&nbsp;<a href="qcursor.html">QCursor</a>&nbsp;&amp; <a name="cursor"></a>QWidget::cursor () const
</h3><p>Returns the cursor shape for this widget.
See the <a href="qwidget.html#cursor-prop">"cursor"</a> property for details.
<h3 class=fn>bool <a name="customWhatsThis"></a>QWidget::customWhatsThis () const<tt> [virtual]</tt>
</h3><p>Returns TRUE if the widget wants to handle What's This help manually; otherwise returns FALSE.
See the <a href="qwidget.html#customWhatsThis-prop">"customWhatsThis"</a> property for details.
<h3 class=fn>void <a name="destroy"></a>QWidget::destroy ( bool&nbsp;destroyWindow = TRUE, bool&nbsp;destroySubWindows = TRUE )<tt> [virtual protected]</tt>
</h3>
Frees up window system resources. Destroys the widget window if <em>destroyWindow</em> is TRUE.
<p> <a href="#destroy">destroy</a>() calls itself recursively for all the child widgets,
passing <em>destroySubWindows</em> for the <em>destroyWindow</em> parameter.
To have more control over destruction of subwidgets, destroy
subwidgets selectively first.
<p> This function is usually called from the QWidget destructor.

<h3 class=fn>void <a name="dragEnterEvent"></a>QWidget::dragEnterEvent ( <a href="qdragenterevent.html">QDragEnterEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called when a drag is in progress and the
mouse enters this widget.
<p> See the <a href="dnd.html">Drag-and-drop documentation</a> for an
overview of how to provide drag-and-drop in your application.
<p> <p>See also <a href="qtextdrag.html">QTextDrag</a>, <a href="qimagedrag.html">QImageDrag</a>, and <a href="qdragenterevent.html">QDragEnterEvent</a>.

<p>Example: <a href="simple_dd-example.html#x2829">iconview/simple_dd/main.cpp</a>.
<h3 class=fn>void <a name="dragLeaveEvent"></a>QWidget::dragLeaveEvent ( <a href="qdragleaveevent.html">QDragLeaveEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called when a drag is in progress and the
mouse leaves this widget.
<p> See the <a href="dnd.html">Drag-and-drop documentation</a> for an
overview of how to provide drag-and-drop in your application.
<p> <p>See also <a href="qtextdrag.html">QTextDrag</a>, <a href="qimagedrag.html">QImageDrag</a>, and <a href="qdragleaveevent.html">QDragLeaveEvent</a>.

<h3 class=fn>void <a name="dragMoveEvent"></a>QWidget::dragMoveEvent ( <a href="qdragmoveevent.html">QDragMoveEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called when a drag is in progress and the
mouse enters this widget, and whenever it moves within the widget.
<p> See the <a href="dnd.html">Drag-and-drop documentation</a> for an
overview of how to provide drag-and-drop in your application.
<p> <p>See also <a href="qtextdrag.html">QTextDrag</a>, <a href="qimagedrag.html">QImageDrag</a>, and <a href="qdragmoveevent.html">QDragMoveEvent</a>.

<h3 class=fn>void <a name="drawText"></a>QWidget::drawText ( int&nbsp;x, int&nbsp;y, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>
Draws the string <em>str</em> at position <em>(x, y)</em>.
<p> The <em>y</em> position is the base line position of the text. The text
is drawn using the default font and the default foreground color.
<p> This function is provided for convenience. You will generally get
more flexible results and often higher speed by using a a <a href="qpainter.html">painter</a> instead.
<p> <p>See also <a href="#font-prop">font</a>, <a href="#foregroundColor">foregroundColor</a>(), and <a href="qpainter.html#drawText">QPainter::drawText</a>().

<h3 class=fn>void <a name="drawText-2"></a>QWidget::drawText ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Draws the string <em>str</em> at position <em>pos</em>.

<h3 class=fn>void <a name="dropEvent"></a>QWidget::dropEvent ( <a href="qdropevent.html">QDropEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called when the drag is dropped on this
widget.
<p> See the <a href="dnd.html">Drag-and-drop documentation</a> for an
overview of how to provide drag-and-drop in your application.
<p> <p>See also <a href="qtextdrag.html">QTextDrag</a>, <a href="qimagedrag.html">QImageDrag</a>, and <a href="qdropevent.html">QDropEvent</a>.

<p>Example: <a href="simple_dd-example.html#x2830">iconview/simple_dd/main.cpp</a>.
<h3 class=fn>void <a name="enabledChange"></a>QWidget::enabledChange ( bool&nbsp;oldEnabled )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called from <a href="#setEnabled">setEnabled</a>(). <em>oldEnabled</em>
is the previous setting; you can get the new setting from
<a href="#isEnabled">isEnabled</a>().
<p> Reimplement this function if your widget needs to know when it
becomes enabled or disabled. You will almost certainly need to
update the widget using <a href="#update">update</a>().
<p> The default implementation repaints the visible part of the
widget.
<p> <p>See also <a href="#enabled-prop">enabled</a>, <a href="#enabled-prop">enabled</a>, <a href="#repaint">repaint</a>(), <a href="#update">update</a>(), and <a href="#clipRegion">clipRegion</a>().

<h3 class=fn>void <a name="enterEvent"></a>QWidget::enterEvent ( <a href="qevent.html">QEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget enter events.
<p> An event is sent to the widget when the mouse cursor enters the
widget.
<p> <p>See also <a href="#leaveEvent">leaveEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="#event">event</a>().

<h3 class=fn>void <a name="erase"></a>QWidget::erase ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )
</h3>
Erases the specified area <em>(x, y, w, h)</em> in the widget without
generating a <a href="#paintEvent">paint event</a>.
<p> If <em>w</em> is negative, it is replaced with <tt>width() - x</tt>. If <em>h</em>
is negative, it is replaced width <tt>height() - y</tt>.
<p> Child widgets are not affected.
<p> <p>See also <a href="#repaint">repaint</a>().

<h3 class=fn>void <a name="erase-2"></a>QWidget::erase ()
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This version erases the entire widget.

<h3 class=fn>void <a name="erase-3"></a>QWidget::erase ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Erases the specified area <em>r</em> in the widget without generating a
<a href="#paintEvent">paint event</a>.

<h3 class=fn>void <a name="erase-4"></a>QWidget::erase ( const&nbsp;<a href="qregion.html">QRegion</a>&nbsp;&amp;&nbsp;reg )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Erases the area defined by <em>reg</em>, without generating a <a href="#paintEvent">paint event</a>.
<p> Child widgets are not affected.

<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="eraseColor"></a>QWidget::eraseColor () const
</h3>

<p> Returns the erase color of the widget.
<p> <p>See also <a href="#setEraseColor">setEraseColor</a>(), <a href="#setErasePixmap">setErasePixmap</a>(), and <a href="#backgroundColor">backgroundColor</a>().

<h3 class=fn>const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;* <a name="erasePixmap"></a>QWidget::erasePixmap () const
</h3>
Returns the widget's erase pixmap.
<p> <p>See also <a href="#setErasePixmap">setErasePixmap</a>() and <a href="#eraseColor">eraseColor</a>().

<h3 class=fn>bool <a name="event"></a>QWidget::event ( <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This is the main event handler; it handles event <em>e</em>. You can
reimplement this function in a subclass, but we recommend using
one of the specialized event handlers instead.
<p> The main event handler first passes an event through all <a href="qobject.html#installEventFilter">event filters</a> that have been
installed. If none of the filters intercept the event, it calls
one of the specialized event handlers.
<p> Key press and release events are treated differently from other
events. <a href="#event">event</a>() checks for Tab and Shift+Tab and tries to move the
focus appropriately. If there is no widget to move the focus to
(or the key press is not Tab or Shift+Tab), event() calls
<a href="#keyPressEvent">keyPressEvent</a>().
<p> This function returns TRUE if it is able to pass the event over to
someone (i.e. someone wanted the event); otherwise returns FALSE.
<p> <p>See also <a href="#closeEvent">closeEvent</a>(), <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#enterEvent">enterEvent</a>(), <a href="#keyPressEvent">keyPressEvent</a>(), <a href="#keyReleaseEvent">keyReleaseEvent</a>(), <a href="#leaveEvent">leaveEvent</a>(), <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), <a href="#mousePressEvent">mousePressEvent</a>(), <a href="#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="#moveEvent">moveEvent</a>(), <a href="#paintEvent">paintEvent</a>(), <a href="#resizeEvent">resizeEvent</a>(), <a href="qobject.html#event">QObject::event</a>(), and <a href="qobject.html#timerEvent">QObject::timerEvent</a>().

<p>Reimplemented from <a href="qobject.html#event">QObject</a>.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="find"></a>QWidget::find ( WId&nbsp;id )<tt> [static]</tt>
</h3>
Returns a pointer to the widget with window identifer/handle <em>id</em>.
<p> The window identifier type depends on the underlying window
system, see <a href="qwindowdefs-h.html">qwindowdefs.h</a> for the actual definition. If there
is no widget with this identifier, 0 is returned.

<h3 class=fn><a href="qfocusdata.html">QFocusData</a>&nbsp;* <a name="focusData"></a>QWidget::focusData ()<tt> [protected]</tt>
</h3>
Returns the focus data for this widget's top-level widget.
<p> Focus data always belongs to the top-level widget. The focus data
list contains all the widgets in this top-level widget that can
accept focus, in tab order. An iterator points to the current
focus widget (<a href="#focusWidget">focusWidget</a>() returns a pointer to this widget).
<p> This information is useful for implementing advanced versions of
<a href="#focusNextPrevChild">focusNextPrevChild</a>().

<h3 class=fn>void <a name="focusInEvent"></a>QWidget::focusInEvent ( <a href="qfocusevent.html">QFocusEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
<a href="focus.html#keyboard-focus">keyboard focus</a> events (focus received) for the widget.
<p> A widget normally must <a href="#setFocusPolicy">setFocusPolicy</a>() to something other than
<a href="#FocusPolicy-enum">NoFocus</a> in order to receive focus events. (Note that the
application programmer can call <a href="#setFocus">setFocus</a>() on any widget, even
those that do not normally accept focus.)
<p> The default implementation updates the widget (except for toplevel
widgets that do not specify a <a href="#focusPolicy">focusPolicy</a>() ). It also calls
<a href="#setMicroFocusHint">setMicroFocusHint</a>(), hinting any system-specific input tools about
the focus of the user's attention.
<p> <p>See also <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, <a href="#keyPressEvent">keyPressEvent</a>(), <a href="#keyReleaseEvent">keyReleaseEvent</a>(), <a href="#event">event</a>(), and <a href="qfocusevent.html">QFocusEvent</a>.

<h3 class=fn>bool <a name="focusNextPrevChild"></a>QWidget::focusNextPrevChild ( bool&nbsp;next )<tt> [virtual protected]</tt>
</h3>
Finds a new widget to give the <a href="focus.html#keyboard-focus">keyboard focus</a> to, as appropriate
for Tab and Shift+Tab, and returns TRUE if is can find a new
widget and FALSE if it can't,
<p> If <em>next</em> is TRUE, this function searches "forwards", if <em>next</em>
is FALSE, it searches "backwards".
<p> Sometimes, you will want to reimplement this function. For
example, a web browser might reimplement it to move its "current
active link" forwards or backwards, and call
<a href="#focusNextPrevChild">QWidget::focusNextPrevChild</a>() only when it reaches the last or
first link on the "page".
<p> Child widgets call <a href="#focusNextPrevChild">focusNextPrevChild</a>() on their parent widgets,
but only the top-level widget decides where to redirect focus. By
overriding this method for an object, you thus gain control of
focus traversal for all child widgets.
<p> <b>Warning:</b> <a href="qscrollview.html">QScrollView</a> uses it own logic for this function, which
does the right thing in most cases. But if you are using a
QScrollView and want complete control of the focus chain you'll
need to override <a href="#focusNextPrevChild">QScrollView::focusNextPrevChild</a>() and your
top-level widgets' focusNextPrevChild() functions.
<p> <p>See also <a href="#focusData">focusData</a>().

<h3 class=fn>void <a name="focusOutEvent"></a>QWidget::focusOutEvent ( <a href="qfocusevent.html">QFocusEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
<a href="focus.html#keyboard-focus">keyboard focus</a> events (focus lost) for the widget.
<p> A widget normally must <a href="#setFocusPolicy">setFocusPolicy</a>() to something other than
<a href="#FocusPolicy-enum">NoFocus</a> in order to receive focus events. (Note that the
application programmer can call <a href="#setFocus">setFocus</a>() on any widget, even
those that do not normally accept focus.)
<p> The default implementation updates the widget (except for toplevel
widgets that do not specify a <a href="#focusPolicy">focusPolicy</a>() ). It also calls
<a href="#setMicroFocusHint">setMicroFocusHint</a>(), hinting any system-specific input tools about
the focus of the user's attention.
<p> <p>See also <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, <a href="#keyPressEvent">keyPressEvent</a>(), <a href="#keyReleaseEvent">keyReleaseEvent</a>(), <a href="#event">event</a>(), and <a href="qfocusevent.html">QFocusEvent</a>.

<p>Example: <a href="qmag-example.html#x1796">qmag/qmag.cpp</a>.
<h3 class=fn><a href="qwidget.html#FocusPolicy-enum">FocusPolicy</a> <a name="focusPolicy"></a>QWidget::focusPolicy () const
</h3><p>Returns the way the widget accepts keyboard focus.
See the <a href="qwidget.html#focusPolicy-prop">"focusPolicy"</a> property for details.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="focusProxy"></a>QWidget::focusProxy () const
</h3>
Returns the focus proxy, or 0 if there is no focus proxy.
<p> <p>See also <a href="#setFocusProxy">setFocusProxy</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="focusWidget"></a>QWidget::focusWidget () const
</h3>
Returns the focus widget in this widget's window. This is not the
same as <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>(), which returns the focus
widget in the currently active window.

<h3 class=fn><a href="qfont.html">QFont</a> <a name="font"></a>QWidget::font () const
</h3><p>Returns the font currently set for the widget.
See the <a href="qwidget.html#font-prop">"font"</a> property for details.
<h3 class=fn>void <a name="fontChange"></a>QWidget::fontChange ( const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp;&nbsp;oldFont )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called from <a href="#setFont">setFont</a>(). <em>oldFont</em> is the
previous font; you can get the new font from <a href="#font">font</a>().
<p> Reimplement this function if your widget needs to know when its
font changes. You will almost certainly need to update the widget
using <a href="#update">update</a>().
<p> The default implementation updates the widget including its
geometry.
<p> <p>See also <a href="#font-prop">font</a>, <a href="#font-prop">font</a>, <a href="#update">update</a>(), and <a href="#updateGeometry">updateGeometry</a>().

<h3 class=fn><a href="qfontinfo.html">QFontInfo</a> <a name="fontInfo"></a>QWidget::fontInfo () const
</h3>

<p> Returns the font info for the widget's current font.
Equivalent to QFontInto(widget->font()).
<p> <p>See also <a href="#font-prop">font</a>, <a href="#fontMetrics">fontMetrics</a>(), and <a href="#font-prop">font</a>.

<h3 class=fn><a href="qfontmetrics.html">QFontMetrics</a> <a name="fontMetrics"></a>QWidget::fontMetrics () const
</h3>

<p> Returns the font metrics for the widget's current font.
Equivalent to <a href="qfontmetrics.html">QFontMetrics</a>(widget->font()).
<p> <p>See also <a href="#font-prop">font</a>, <a href="#fontInfo">fontInfo</a>(), and <a href="#font-prop">font</a>.

<p>Examples: <a href="drawdemo-example.html#x1084">drawdemo/drawdemo.cpp</a> and <a href="qmag-example.html#x1797">qmag/qmag.cpp</a>.
<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="foregroundColor"></a>QWidget::foregroundColor () const
</h3>
Same as <a href="#paletteForegroundColor">paletteForegroundColor</a>()

<h3 class=fn><a href="qrect.html">QRect</a> <a name="frameGeometry"></a>QWidget::frameGeometry () const
</h3><p>Returns geometry of the widget relative to its parent including any window frame.
See the <a href="qwidget.html#frameGeometry-prop">"frameGeometry"</a> property for details.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="frameSize"></a>QWidget::frameSize () const
</h3><p>Returns the size of the widget including any window frame.
See the <a href="qwidget.html#frameSize-prop">"frameSize"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp; <a name="geometry"></a>QWidget::geometry () const
</h3><p>Returns the geometry of the widget relative to its parent and excluding the window frame.
See the <a href="qwidget.html#geometry-prop">"geometry"</a> property for details.
<h3 class=fn>WFlags <a name="getWFlags"></a>QWidget::getWFlags () const<tt> [protected]</tt>
</h3>

<p> Returns the widget flags for this this widget.
<p> Widget flags are a combination of <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.
<p> <p>See also <a href="#testWFlags">testWFlags</a>(), <a href="#setWFlags">setWFlags</a>(), and <a href="#clearWFlags">clearWFlags</a>().

<h3 class=fn>void <a name="grabKeyboard"></a>QWidget::grabKeyboard ()
</h3>
Grabs the keyboard input.
<p> This widget reveives all keyboard events until <a href="#releaseKeyboard">releaseKeyboard</a>()
is called; other widgets get no keyboard events at all. Mouse
events are not affected. Use <a href="#grabMouse">grabMouse</a>() if you want to grab that.
<p> The focus widget is not affected, except that it doesn't receive
any keyboard events. <a href="#setFocus">setFocus</a>() moves the focus as usual, but the
new focus widget receives keyboard events only after
releaseKeyboard() is called.
<p> If a different widget is currently grabbing keyboard input, that
widget's grab is released first.
<p> <p>See also <a href="#releaseKeyboard">releaseKeyboard</a>(), <a href="#grabMouse">grabMouse</a>(), <a href="#releaseMouse">releaseMouse</a>(), and <a href="#focusWidget">focusWidget</a>().

<h3 class=fn>void <a name="grabMouse"></a>QWidget::grabMouse ()
</h3>
Grabs the mouse input.
<p> This widget receives all mouse events until <a href="#releaseMouse">releaseMouse</a>() is
called; other widgets get no mouse events at all. Keyboard
events are not affected. Use <a href="#grabKeyboard">grabKeyboard</a>() if you want to grab
that.
<p> <b>Warning:</b> Bugs in mouse-grabbing applications very often lock the
terminal. Use this function with extreme caution, and consider
using the <tt>-nograb</tt> command line option while debugging.
<p> It is almost never necessary to grab the mouse when using Qt, as
Qt grabs and releases it sensibly. In particular, Qt grabs the
mouse when a mouse button is pressed and keeps it until the last
button is released.
<p> Note that only visible widgets can grab mouse input. If
<a href="#isVisible">isVisible</a>() returns FALSE for a widget, that widget cannot call
<a href="#grabMouse">grabMouse</a>().
<p> <p>See also <a href="#releaseMouse">releaseMouse</a>(), <a href="#grabKeyboard">grabKeyboard</a>(), <a href="#releaseKeyboard">releaseKeyboard</a>(), <a href="#grabKeyboard">grabKeyboard</a>(), and <a href="#focusWidget">focusWidget</a>().

<h3 class=fn>void <a name="grabMouse-2"></a>QWidget::grabMouse ( const&nbsp;<a href="qcursor.html">QCursor</a>&nbsp;&amp;&nbsp;cursor )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Grabs the mouse input and changes the cursor shape.
<p> The cursor will assume shape <em>cursor</em> (for as long as the mouse
focus is grabbed) and this widget will be the only one to receive
mouse events until <a href="#releaseMouse">releaseMouse</a>() is called().
<p> <b>Warning:</b> Grabbing the mouse might lock the terminal.
<p> <p>See also <a href="#releaseMouse">releaseMouse</a>(), <a href="#grabKeyboard">grabKeyboard</a>(), <a href="#releaseKeyboard">releaseKeyboard</a>(), and <a href="#cursor-prop">cursor</a>.

<h3 class=fn>bool <a name="hasFocus"></a>QWidget::hasFocus () const
</h3><p>Returns TRUE if this widget (or its focus proxy) has the keyboard input focus; otherwise returns FALSE.
See the <a href="qwidget.html#focus-prop">"focus"</a> property for details.
<h3 class=fn>bool <a name="hasMouse"></a>QWidget::hasMouse () const
</h3><p>Returns TRUE if the widget is under the mouse cursor; otherwise returns FALSE.
See the <a href="qwidget.html#underMouse-prop">"underMouse"</a> property for details.
<h3 class=fn>bool <a name="hasMouseTracking"></a>QWidget::hasMouseTracking () const
</h3><p>Returns TRUE if mouse tracking is enabled for the widget; otherwise returns FALSE.
See the <a href="qwidget.html#mouseTracking-prop">"mouseTracking"</a> property for details.
<h3 class=fn>int <a name="height"></a>QWidget::height () const
</h3><p>Returns the height of the widget excluding any window frame.
See the <a href="qwidget.html#height-prop">"height"</a> property for details.
<h3 class=fn>int <a name="heightForWidth"></a>QWidget::heightForWidth ( int&nbsp;w ) const<tt> [virtual]</tt>
</h3>
Returns the preferred height for this widget, given the width <em>w</em>. The default implementation returns 0, indicating that the
preferred height does not depend on the width.
<p> <b>Warning:</b> Does not look at the widget's layout.

<p>Reimplemented in <a href="qmenubar.html#heightForWidth">QMenuBar</a> and <a href="qtextedit.html#heightForWidth">QTextEdit</a>.
<h3 class=fn>void <a name="hide"></a>QWidget::hide ()<tt> [virtual slot]</tt>
</h3>
Hides the widget.
<p> You almost never have to reimplement this function. If you need to
do something after a widget is hidden, use <a href="#hideEvent">hideEvent</a>() instead.
<p> <p>See also <a href="#hideEvent">hideEvent</a>(), <a href="#hidden-prop">hidden</a>, <a href="#show">show</a>(), <a href="#showMinimized">showMinimized</a>(), <a href="#visible-prop">visible</a>, and <a href="#close">close</a>().

<p>Examples: <a href="mdi-example.html#x2079">mdi/application.cpp</a>, <a href="popup-example.html#x1619">popup/popup.cpp</a>, <a href="progress-example.html#x89">progress/progress.cpp</a>, <a href="scrollview-example.html#x658">scrollview/scrollview.cpp</a>, <a href="qaxcontainer-example-webbrowser.html#x2516">webbrowser/mainwindow.ui.h</a>, and <a href="xform-example.html#x1267">xform/xform.cpp</a>.
<p>Reimplemented in <a href="qmenubar.html#hide">QMenuBar</a>.
<h3 class=fn>void <a name="hideEvent"></a>QWidget::hideEvent ( <a href="qhideevent.html">QHideEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget hide events.
<p> Hide events are sent to widgets immediately after they have been
hidden.
<p> <p>See also <a href="#event">event</a>() and <a href="qhideevent.html">QHideEvent</a>.

<p>Reimplemented in <a href="qscrollbar.html#hideEvent">QScrollBar</a>.
<h3 class=fn>const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;* <a name="icon"></a>QWidget::icon () const
</h3><p>Returns the widget's icon.
See the <a href="qwidget.html#icon-prop">"icon"</a> property for details.
<h3 class=fn><a href="qstring.html">QString</a> <a name="iconText"></a>QWidget::iconText () const
</h3><p>Returns the widget's icon text.
See the <a href="qwidget.html#iconText-prop">"iconText"</a> property for details.
<h3 class=fn>void <a name="iconify"></a>QWidget::iconify ()<tt> [slot]</tt>
</h3> 
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> 
<h3 class=fn>void <a name="imComposeEvent"></a>QWidget::imComposeEvent ( <a href="qimevent.html">QIMEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive Input Method composition events. This handler
is called when the user has entered some text using an Input Method.
<p> The default implementation calls e->ignore(), which rejects the
Input Method event. See the <a href="qimevent.html">QIMEvent</a> documentation for more
details.
<p> <p>See also <a href="#event">event</a>() and <a href="qimevent.html">QIMEvent</a>.

<h3 class=fn>void <a name="imEndEvent"></a>QWidget::imEndEvent ( <a href="qimevent.html">QIMEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive Input Method composition events. This handler
is called when the user has finished inputting text via an Input
Method.
<p> The default implementation calls e->ignore(), which rejects the
Input Method event. See the <a href="qimevent.html">QIMEvent</a> documentation for more
details.
<p> <p>See also <a href="#event">event</a>() and <a href="qimevent.html">QIMEvent</a>.

<h3 class=fn>void <a name="imStartEvent"></a>QWidget::imStartEvent ( <a href="qimevent.html">QIMEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive Input Method composition events. This handler
is called when the user begins entering text using an Input Method.
<p> The default implementation calls e->ignore(), which rejects the
Input Method event. See the <a href="qimevent.html">QIMEvent</a> documentation for more
details.
<p> <p>See also <a href="#event">event</a>() and <a href="qimevent.html">QIMEvent</a>.

<h3 class=fn>bool <a name="isActiveWindow"></a>QWidget::isActiveWindow () const
</h3><p>Returns TRUE if this widget is the active window; otherwise returns FALSE.
See the <a href="qwidget.html#isActiveWindow-prop">"isActiveWindow"</a> property for details.
<h3 class=fn>bool <a name="isDesktop"></a>QWidget::isDesktop () const
</h3><p>Returns TRUE if the widget is a desktop widget, i.e. represents the desktop; otherwise returns FALSE.
See the <a href="qwidget.html#isDesktop-prop">"isDesktop"</a> property for details.
<h3 class=fn>bool <a name="isDialog"></a>QWidget::isDialog () const
</h3><p>Returns TRUE if the widget is a dialog widget; otherwise returns FALSE.
See the <a href="qwidget.html#isDialog-prop">"isDialog"</a> property for details.
<h3 class=fn>bool <a name="isEnabled"></a>QWidget::isEnabled () const
</h3><p>Returns TRUE if the widget is enabled; otherwise returns FALSE.
See the <a href="qwidget.html#enabled-prop">"enabled"</a> property for details.
<h3 class=fn>bool <a name="isEnabledTo"></a>QWidget::isEnabledTo ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;ancestor ) const
</h3>
Returns TRUE if this widget would become enabled if <em>ancestor</em> is
enabled; otherwise returns FALSE.
<p> This is the case if neither the widget itself nor every parent up
to but excluding <em>ancestor</em> has been explicitly disabled.
<p> <a href="#isEnabledTo">isEnabledTo</a>(0) is equivalent to <a href="#isEnabled">isEnabled</a>().
<p> <p>See also <a href="#enabled-prop">enabled</a> and <a href="#enabled-prop">enabled</a>.

<h3 class=fn>bool <a name="isEnabledToTLW"></a>QWidget::isEnabledToTLW () const
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This function is deprecated. It is equivalent to <a href="#isEnabled">isEnabled</a>()

<h3 class=fn>bool <a name="isFocusEnabled"></a>QWidget::isFocusEnabled () const
</h3><p>Returns TRUE if the widget accepts keyboard focus; otherwise returns FALSE.
See the <a href="qwidget.html#focusEnabled-prop">"focusEnabled"</a> property for details.
<h3 class=fn>bool <a name="isFullScreen"></a>QWidget::isFullScreen () const
</h3><p>Returns TRUE if the widget is full screen; otherwise returns FALSE.
See the <a href="qwidget.html#fullScreen-prop">"fullScreen"</a> property for details.
<h3 class=fn>bool <a name="isHidden"></a>QWidget::isHidden () const
</h3><p>Returns TRUE if the widget is explicitly hidden; otherwise returns FALSE.
See the <a href="qwidget.html#hidden-prop">"hidden"</a> property for details.
<h3 class=fn>bool <a name="isInputMethodEnabled"></a>QWidget::isInputMethodEnabled () const
</h3><p>Returns enables or disables the use of input methods for this widget.
See the <a href="qwidget.html#inputMethodEnabled-prop">"inputMethodEnabled"</a> property for details.
<h3 class=fn>bool <a name="isMaximized"></a>QWidget::isMaximized () const
</h3><p>Returns TRUE if this widget is maximized; otherwise returns FALSE.
See the <a href="qwidget.html#maximized-prop">"maximized"</a> property for details.
<h3 class=fn>bool <a name="isMinimized"></a>QWidget::isMinimized () const
</h3><p>Returns TRUE if this widget is minimized (iconified); otherwise returns FALSE.
See the <a href="qwidget.html#minimized-prop">"minimized"</a> property for details.
<h3 class=fn>bool <a name="isModal"></a>QWidget::isModal () const
</h3><p>Returns TRUE if the widget is a modal widget; otherwise returns FALSE.
See the <a href="qwidget.html#isModal-prop">"isModal"</a> property for details.
<h3 class=fn>bool <a name="isPopup"></a>QWidget::isPopup () const
</h3><p>Returns TRUE if the widget is a popup widget; otherwise returns FALSE.
See the <a href="qwidget.html#isPopup-prop">"isPopup"</a> property for details.
<h3 class=fn>bool <a name="isShown"></a>QWidget::isShown () const
</h3><p>Returns TRUE if the widget is shown; otherwise returns FALSE.
See the <a href="qwidget.html#shown-prop">"shown"</a> property for details.
<h3 class=fn>bool <a name="isTopLevel"></a>QWidget::isTopLevel () const
</h3><p>Returns TRUE if the widget is a top-level widget; otherwise returns FALSE.
See the <a href="qwidget.html#isTopLevel-prop">"isTopLevel"</a> property for details.
<h3 class=fn>bool <a name="isUpdatesEnabled"></a>QWidget::isUpdatesEnabled () const
</h3><p>Returns TRUE if updates are enabled; otherwise returns FALSE.
See the <a href="qwidget.html#updatesEnabled-prop">"updatesEnabled"</a> property for details.
<h3 class=fn>bool <a name="isVisible"></a>QWidget::isVisible () const
</h3><p>Returns TRUE if the widget is visible; otherwise returns FALSE.
See the <a href="qwidget.html#visible-prop">"visible"</a> property for details.
<h3 class=fn>bool <a name="isVisibleTo"></a>QWidget::isVisibleTo ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;ancestor ) const
</h3>
Returns TRUE if this widget would become visible if <em>ancestor</em> is
shown; otherwise returns FALSE.
<p> The TRUE case occurs if neither the widget itself nor any parent
up to but excluding <em>ancestor</em> has been explicitly hidden.
<p> This function will still return TRUE if the widget is obscured by
other windows on the screen, but could be physically visible if it
or they were to be moved.
<p> <a href="#isVisibleTo">isVisibleTo</a>(0) is identical to <a href="#isVisible">isVisible</a>().
<p> <p>See also <a href="#show">show</a>(), <a href="#hide">hide</a>(), and <a href="#visible-prop">visible</a>.

<h3 class=fn>bool <a name="isVisibleToTLW"></a>QWidget::isVisibleToTLW () const
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This function is deprecated. It is equivalent to <a href="#isVisible">isVisible</a>()

<h3 class=fn>void <a name="keyPressEvent"></a>QWidget::keyPressEvent ( <a href="qkeyevent.html">QKeyEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive key press events for the widget.
<p> A widget must call <a href="#setFocusPolicy">setFocusPolicy</a>() to accept focus initially and
have focus in order to receive a key press event.
<p> If you reimplement this handler, it is very important that you
explicitly <a href="qkeyevent.html#ignore">ignore</a> the event
if you do not understand it, so that the widget's parent can
interpret it; otherwise, the event will be implicitly accepted.
Although top-level widgets are able to choose whether to accept
or ignore unknown events because they have no parent widgets that
could otherwise handle them, it is good practice to explicitly
ignore events to make widgets as reusable as possible.
<p> The default implementation closes popup widgets if the user
presses <b>Esc</b>. Otherwise the event is ignored.
<p> <p>See also <a href="#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qkeyevent.html#ignore">QKeyEvent::ignore</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#event">event</a>(), and <a href="qkeyevent.html">QKeyEvent</a>.

<p>Example: <a href="picture-example.html#x127">picture/picture.cpp</a>.
<p>Reimplemented in <a href="qlineedit.html#keyPressEvent">QLineEdit</a> and <a href="qtextedit.html#keyPressEvent">QTextEdit</a>.
<h3 class=fn>void <a name="keyReleaseEvent"></a>QWidget::keyReleaseEvent ( <a href="qkeyevent.html">QKeyEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive key release events for the widget.
<p> A widget must <a href="#setFocusPolicy">accept focus</a>
initially and <a href="#hasFocus">have focus</a> in order to
receive a key release event.
<p> If you reimplement this handler, it is very important that you
<a href="qkeyevent.html">ignore()</a> the release if you do not
understand it, so that the widget's parent can interpret it.
<p> The default implementation ignores the event.
<p> <p>See also <a href="#keyPressEvent">keyPressEvent</a>(), <a href="qkeyevent.html#ignore">QKeyEvent::ignore</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#event">event</a>(), and <a href="qkeyevent.html">QKeyEvent</a>.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="keyboardGrabber"></a>QWidget::keyboardGrabber ()<tt> [static]</tt>
</h3>
Returns the widget that is currently grabbing the keyboard input.
<p> If no widget in this application is currently grabbing the
keyboard, 0 is returned.
<p> <p>See also <a href="#grabMouse">grabMouse</a>() and <a href="#mouseGrabber">mouseGrabber</a>().

<h3 class=fn><a href="qlayout.html">QLayout</a>&nbsp;* <a name="layout"></a>QWidget::layout () const
</h3>

<p> Returns the layout engine that manages the geometry of this
widget's children.
<p> If the widget does not have a layout, <a href="#layout">layout</a>() returns 0.
<p> <p>See also <a href="#sizePolicy-prop">sizePolicy</a>.

<p>Examples: <a href="tutorial2-09.html#x2647">chart/optionsform.cpp</a> and <a href="simple-font-demo-example.html#x2858">fonts/simple-qfont-demo/viewer.cpp</a>.
<h3 class=fn>void <a name="leaveEvent"></a>QWidget::leaveEvent ( <a href="qevent.html">QEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget leave events.
<p> A leave event is sent to the widget when the mouse cursor leaves
the widget.
<p> <p>See also <a href="#enterEvent">enterEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="#event">event</a>().

<h3 class=fn>void <a name="lower"></a>QWidget::lower ()<tt> [slot]</tt>
</h3>
Lowers the widget to the bottom of the parent widget's stack.
<p> After this call the widget will be visually behind (and therefore
obscured by) any overlapping sibling widgets.
<p> <p>See also <a href="#raise">raise</a>() and <a href="#stackUnder">stackUnder</a>().

<h3 class=fn>bool <a name="macEvent"></a>QWidget::macEvent ( MSG * )<tt> [virtual protected]</tt>
</h3>
This special event handler can be reimplemented in a subclass to
receive native Macintosh events.
<p> In your reimplementation of this function, if you want to stop the
event being handled by Qt, return TRUE. If you return FALSE, this
native event is passed back to Qt, which translates the event into
a Qt event and sends it to the widget.
<p> <b>Warning:</b> This function is not portable.
<p> <p>See also <a href="qapplication.html#macEventFilter">QApplication::macEventFilter</a>().

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapFrom"></a>QWidget::mapFrom ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the widget coordinate <em>pos</em> from the coordinate system
of <em>parent</em> to this widget's coordinate system. The <em>parent</em>
must not be 0 and must be a parent of the calling widget.
<p> <p>See also <a href="#mapTo">mapTo</a>(), <a href="#mapFromParent">mapFromParent</a>(), <a href="#mapFromGlobal">mapFromGlobal</a>(), and <a href="#underMouse-prop">underMouse</a>.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapFromGlobal"></a>QWidget::mapFromGlobal ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the global screen coordinate <em>pos</em> to widget
coordinates.
<p> <p>See also <a href="#mapToGlobal">mapToGlobal</a>(), <a href="#mapFrom">mapFrom</a>(), and <a href="#mapFromParent">mapFromParent</a>().

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapFromParent"></a>QWidget::mapFromParent ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the parent widget coordinate <em>pos</em> to widget
coordinates.
<p> Same as <a href="#mapFromGlobal">mapFromGlobal</a>() if the widget has no parent.
<p> <p>See also <a href="#mapToParent">mapToParent</a>(), <a href="#mapFrom">mapFrom</a>(), <a href="#mapFromGlobal">mapFromGlobal</a>(), and <a href="#underMouse-prop">underMouse</a>.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapTo"></a>QWidget::mapTo ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the widget coordinate <em>pos</em> to the coordinate system
of <em>parent</em>. The <em>parent</em> must not be 0 and must be a parent
of the calling widget.
<p> <p>See also <a href="#mapFrom">mapFrom</a>(), <a href="#mapToParent">mapToParent</a>(), <a href="#mapToGlobal">mapToGlobal</a>(), and <a href="#underMouse-prop">underMouse</a>.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapToGlobal"></a>QWidget::mapToGlobal ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the widget coordinate <em>pos</em> to global screen
coordinates. For example, <tt>mapToGlobal(QPoint(0,0))</tt> would give
the global coordinates of the top-left pixel of the widget.
<p> <p>See also <a href="#mapFromGlobal">mapFromGlobal</a>(), <a href="#mapTo">mapTo</a>(), and <a href="#mapToParent">mapToParent</a>().

<p>Example: <a href="scribble-example.html#x947">scribble/scribble.cpp</a>.
<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapToParent"></a>QWidget::mapToParent ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos ) const
</h3>
Translates the widget coordinate <em>pos</em> to a coordinate in the
parent widget.
<p> Same as <a href="#mapToGlobal">mapToGlobal</a>() if the widget has no parent.
<p> <p>See also <a href="#mapFromParent">mapFromParent</a>(), <a href="#mapTo">mapTo</a>(), <a href="#mapToGlobal">mapToGlobal</a>(), and <a href="#underMouse-prop">underMouse</a>.

<h3 class=fn>int <a name="maximumHeight"></a>QWidget::maximumHeight () const
</h3><p>Returns the widget's maximum height.
See the <a href="qwidget.html#maximumHeight-prop">"maximumHeight"</a> property for details.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="maximumSize"></a>QWidget::maximumSize () const
</h3><p>Returns the widget's maximum size.
See the <a href="qwidget.html#maximumSize-prop">"maximumSize"</a> property for details.
<h3 class=fn>int <a name="maximumWidth"></a>QWidget::maximumWidth () const
</h3><p>Returns the widget's maximum width.
See the <a href="qwidget.html#maximumWidth-prop">"maximumWidth"</a> property for details.
<h3 class=fn>int <a name="metric"></a>QWidget::metric ( int&nbsp;m ) const<tt> [virtual protected]</tt>
</h3>
Internal implementation of the virtual QPaintDevice::metric()
function.
<p> Use the <a href="qpaintdevicemetrics.html">QPaintDeviceMetrics</a> class instead.
<p> <em>m</em> is the metric to get.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="microFocusHint"></a>QWidget::microFocusHint () const
</h3><p>Returns the currently set micro focus hint for this widget.
See the <a href="qwidget.html#microFocusHint-prop">"microFocusHint"</a> property for details.
<h3 class=fn>int <a name="minimumHeight"></a>QWidget::minimumHeight () const
</h3><p>Returns the widget's minimum height.
See the <a href="qwidget.html#minimumHeight-prop">"minimumHeight"</a> property for details.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="minimumSize"></a>QWidget::minimumSize () const
</h3><p>Returns the widget's minimum size.
See the <a href="qwidget.html#minimumSize-prop">"minimumSize"</a> property for details.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="minimumSizeHint"></a>QWidget::minimumSizeHint () const<tt> [virtual]</tt>
</h3><p>Returns the recommended minimum size for the widget.
See the <a href="qwidget.html#minimumSizeHint-prop">"minimumSizeHint"</a> property for details.
<p>Reimplemented in <a href="qlineedit.html#minimumSizeHint">QLineEdit</a>.
<h3 class=fn>int <a name="minimumWidth"></a>QWidget::minimumWidth () const
</h3><p>Returns the widget's minimum width.
See the <a href="qwidget.html#minimumWidth-prop">"minimumWidth"</a> property for details.
<h3 class=fn>void <a name="mouseDoubleClickEvent"></a>QWidget::mouseDoubleClickEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive mouse double click events for the widget.
<p> The default implementation generates a normal mouse press event.
<p> Note that the widgets gets a <a href="#mousePressEvent">mousePressEvent</a>() and a
<a href="#mouseReleaseEvent">mouseReleaseEvent</a>() before the <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>().
<p> <p>See also <a href="#mousePressEvent">mousePressEvent</a>(), <a href="#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), <a href="#event">event</a>(), and <a href="qmouseevent.html">QMouseEvent</a>.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="mouseGrabber"></a>QWidget::mouseGrabber ()<tt> [static]</tt>
</h3>
Returns the widget that is currently grabbing the mouse input.
<p> If no widget in this application is currently grabbing the mouse,
0 is returned.
<p> <p>See also <a href="#grabMouse">grabMouse</a>() and <a href="#keyboardGrabber">keyboardGrabber</a>().

<h3 class=fn>void <a name="mouseMoveEvent"></a>QWidget::mouseMoveEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive mouse move events for the widget.
<p> If mouse tracking is switched off, mouse move events only occur if
a mouse button is pressed while the mouse is being moved. If mouse
tracking is switched on, mouse move events occur even if no mouse
button is pressed.
<p> <a href="qmouseevent.html#pos">QMouseEvent::pos</a>() reports the position of the mouse cursor,
relative to this widget. For press and release events, the
position is usually the same as the position of the last mouse
move event, but it might be different if the user's hand shakes.
This is a feature of the underlying window system, not Qt.
<p> <p>See also <a href="#mouseTracking-prop">mouseTracking</a>, <a href="#mousePressEvent">mousePressEvent</a>(), <a href="#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="#event">event</a>(), and <a href="qmouseevent.html">QMouseEvent</a>.

<p>Examples: <a href="aclock-example.html#x1206">aclock/aclock.cpp</a>, <a href="drawlines-example.html#x1658">drawlines/connect.cpp</a>, <a href="simple_dd-example.html#x2831">iconview/simple_dd/main.cpp</a>, <a href="life-example.html#x1896">life/life.cpp</a>, <a href="popup-example.html#x1620">popup/popup.cpp</a>, <a href="qmag-example.html#x1800">qmag/qmag.cpp</a>, and <a href="scribble-example.html#x948">scribble/scribble.cpp</a>.
<p>Reimplemented in <a href="qsizegrip.html#mouseMoveEvent">QSizeGrip</a>.
<h3 class=fn>void <a name="mousePressEvent"></a>QWidget::mousePressEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive mouse press events for the widget.
<p> If you create new widgets in the <a href="#mousePressEvent">mousePressEvent</a>() the
<a href="#mouseReleaseEvent">mouseReleaseEvent</a>() may not end up where you expect, depending on
the underlying window system (or X11 window manager), the widgets'
location and maybe more.
<p> The default implementation implements the closing of popup widgets
when you click outside the window. For other widget types it does
nothing.
<p> <p>See also <a href="#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), <a href="#event">event</a>(), and <a href="qmouseevent.html">QMouseEvent</a>.

<p>Examples: <a href="biff-example.html#x1960">biff/biff.cpp</a>, <a href="drawlines-example.html#x1659">drawlines/connect.cpp</a>, <a href="simple_dd-example.html#x2832">iconview/simple_dd/main.cpp</a>, <a href="life-example.html#x1897">life/life.cpp</a>, <a href="qmag-example.html#x1801">qmag/qmag.cpp</a>, <a href="scribble-example.html#x949">scribble/scribble.cpp</a>, and <a href="tooltip-example.html#x452">tooltip/tooltip.cpp</a>.
<p>Reimplemented in <a href="qsizegrip.html#mousePressEvent">QSizeGrip</a>.
<h3 class=fn>void <a name="mouseReleaseEvent"></a>QWidget::mouseReleaseEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive mouse release events for the widget.
<p> <p>See also <a href="#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="#mouseMoveEvent">mouseMoveEvent</a>(), <a href="#event">event</a>(), and <a href="qmouseevent.html">QMouseEvent</a>.

<p>Examples: <a href="drawlines-example.html#x1660">drawlines/connect.cpp</a>, <a href="hello-example.html#x1641">hello/hello.cpp</a>, <a href="popup-example.html#x1621">popup/popup.cpp</a>, <a href="qmag-example.html#x1802">qmag/qmag.cpp</a>, <a href="scribble-example.html#x950">scribble/scribble.cpp</a>, <a href="showimg-example.html#x1350">showimg/showimg.cpp</a>, and <a href="tutorial1-14.html#x2432">t14/cannon.cpp</a>.
<h3 class=fn>void <a name="move"></a>QWidget::move ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp; )<tt> [slot]</tt>
</h3><p>Sets the position of the widget within its parent widget.
See the <a href="qwidget.html#pos-prop">"pos"</a> property for details.
<h3 class=fn>void <a name="move-2"></a>QWidget::move ( int&nbsp;x, int&nbsp;y )<tt> [virtual slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This corresponds to <a href="#move">move</a>( <a href="qpoint.html">QPoint</a>(<em>x</em>, <em>y</em>) ).

<h3 class=fn>void <a name="moveEvent"></a>QWidget::moveEvent ( <a href="qmoveevent.html">QMoveEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget move events. When the widget receives this event, it is
already at the new position.
<p> The old position is accessible through <a href="qmoveevent.html#oldPos">QMoveEvent::oldPos</a>().
<p> <p>See also <a href="#resizeEvent">resizeEvent</a>(), <a href="#event">event</a>(), <a href="#pos-prop">pos</a>, and <a href="qmoveevent.html">QMoveEvent</a>.

<h3 class=fn>bool <a name="ownCursor"></a>QWidget::ownCursor () const
</h3><p>Returns TRUE if the widget uses its own cursor; otherwise returns FALSE.
See the <a href="qwidget.html#ownCursor-prop">"ownCursor"</a> property for details.
<h3 class=fn>bool <a name="ownFont"></a>QWidget::ownFont () const
</h3><p>Returns TRUE if the widget uses its own font; otherwise returns FALSE.
See the <a href="qwidget.html#ownFont-prop">"ownFont"</a> property for details.
<h3 class=fn>bool <a name="ownPalette"></a>QWidget::ownPalette () const
</h3><p>Returns TRUE if the widget uses its own palette; otherwise returns FALSE.
See the <a href="qwidget.html#ownPalette-prop">"ownPalette"</a> property for details.
<h3 class=fn>void <a name="paintEvent"></a>QWidget::paintEvent ( <a href="qpaintevent.html">QPaintEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
paint events.
<p> A paint event is a request to repaint all or part of the widget.
It can happen as a result of <a href="#repaint">repaint</a>() or <a href="#update">update</a>(), or because the
widget was obscured and has now been uncovered, or for many other
reasons.
<p> Many widgets can simply repaint their entire surface when asked
to, but some slow widgets need to optimize by painting only the
requested region: <a href="qpaintevent.html#region">QPaintEvent::region</a>(). This speed optimization
does not change the result, as painting is clipped to that region
during event processing. <a href="qlistview.html">QListView</a> and <a href="qcanvas.html">QCanvas</a> do this, for
example.
<p> Qt also tries to speed up painting by merging multiple paint
events into one. When update() is called several times or the
window system sends several paint events, Qt merges these events
into one event with a larger region (see <a href="qregion.html#unite">QRegion::unite</a>()).
repaint() does not permit this optimization, so we suggest using
update() when possible.
<p> When the paint event occurs, the update region has normally been
erased, so that you're painting on the widget's background. There
are a couple of exceptions and <a href="qpaintevent.html#erased">QPaintEvent::erased</a>() tells you
whether the widget has been erased or not.
<p> The background can be set using <a href="#setBackgroundMode">setBackgroundMode</a>(),
<a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>() or <a href="#setBackgroundPixmap">setBackgroundPixmap</a>(). The
documentation for setBackgroundMode() elaborates on the
background; we recommend reading it.
<p> <p>See also <a href="#event">event</a>(), <a href="#repaint">repaint</a>(), <a href="#update">update</a>(), <a href="qpainter.html">QPainter</a>, <a href="qpixmap.html">QPixmap</a>, and <a href="qpaintevent.html">QPaintEvent</a>.

<p>Examples: <a href="drawlines-example.html#x1661">drawlines/connect.cpp</a>, <a href="forever-example.html#x1055">forever/forever.cpp</a>, <a href="qmag-example.html#x1803">qmag/qmag.cpp</a>, <a href="scribble-example.html#x951">scribble/scribble.cpp</a>, <a href="splitter-example.html#x1302">splitter/splitter.cpp</a>, <a href="tutorial1-08.html#x2336">t8/cannon.cpp</a>, and <a href="tutorial1-09.html#x2346">t9/cannon.cpp</a>.
<p>Reimplemented in <a href="qbutton.html#paintEvent">QButton</a>, <a href="qframe.html#paintEvent">QFrame</a>, <a href="qglwidget.html#paintEvent">QGLWidget</a>, <a href="qsizegrip.html#paintEvent">QSizeGrip</a>, <a href="qstatusbar.html#paintEvent">QStatusBar</a>, and <a href="qtabbar.html#paintEvent">QTabBar</a>.
<h3 class=fn>const&nbsp;<a href="qpalette.html">QPalette</a>&nbsp;&amp; <a name="palette"></a>QWidget::palette () const
</h3><p>Returns the widget's palette.
See the <a href="qwidget.html#palette-prop">"palette"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="paletteBackgroundColor"></a>QWidget::paletteBackgroundColor () const
</h3><p>Returns the background color of the widget.
See the <a href="qwidget.html#paletteBackgroundColor-prop">"paletteBackgroundColor"</a> property for details.
<h3 class=fn>const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;* <a name="paletteBackgroundPixmap"></a>QWidget::paletteBackgroundPixmap () const
</h3><p>Returns the background pixmap of the widget.
See the <a href="qwidget.html#paletteBackgroundPixmap-prop">"paletteBackgroundPixmap"</a> property for details.
<h3 class=fn>void <a name="paletteChange"></a>QWidget::paletteChange ( const&nbsp;<a href="qpalette.html">QPalette</a>&nbsp;&amp;&nbsp;oldPalette )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called from <a href="#setPalette">setPalette</a>(). <em>oldPalette</em>
is the previous palette; you can get the new palette from
<a href="#palette">palette</a>().
<p> Reimplement this function if your widget needs to know when its
palette changes.
<p> <p>See also <a href="#palette-prop">palette</a> and <a href="#palette-prop">palette</a>.

<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="paletteForegroundColor"></a>QWidget::paletteForegroundColor () const
</h3><p>Returns the foreground color of the widget.
See the <a href="qwidget.html#paletteForegroundColor-prop">"paletteForegroundColor"</a> property for details.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="parentWidget"></a>QWidget::parentWidget ( bool&nbsp;sameWindow = FALSE ) const
</h3>

<p> Returns the parent of this widget, or 0 if it does not have any
parent widget. If <em>sameWindow</em> is TRUE and the widget is top
level returns 0; otherwise returns the widget's parent.

<p>Example: <a href="mdi-example.html#x2081">mdi/application.cpp</a>.
<h3 class=fn>void <a name="polish"></a>QWidget::polish ()<tt> [virtual slot]</tt>
</h3>
Delayed initialization of a widget.
<p> This function will be called <em>after</em> a widget has been fully
created and <em>before</em> it is shown the very first time.
<p> Polishing is useful for final initialization which depends on
having an instantiated widget. This is something a constructor
cannot guarantee since the initialization of the subclasses might
not be finished.
<p> After this function, the widget has a proper font and palette and
<a href="qapplication.html#polish">QApplication::polish</a>() has been called.
<p> Remember to call QWidget's implementation first when reimplementing this
function to ensure that your program does not end up in infinite recursion.
<p> <p>See also <a href="#constPolish">constPolish</a>() and <a href="qapplication.html#polish">QApplication::polish</a>().

<p>Example: <a href="menu-example.html#x1883">menu/menu.cpp</a>.
<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="pos"></a>QWidget::pos () const
</h3><p>Returns the position of the widget within its parent widget.
See the <a href="qwidget.html#pos-prop">"pos"</a> property for details.
<h3 class=fn>bool <a name="qwsEvent"></a>QWidget::qwsEvent ( QWSEvent * )<tt> [virtual protected]</tt>
</h3>
This special event handler can be reimplemented in a subclass to
receive native Qt/Embedded events.
<p> In your reimplementation of this function, if you want to stop the
event being handled by Qt, return TRUE. If you return FALSE, this
native event is passed back to Qt, which translates the event into
a Qt event and sends it to the widget.
<p> <b>Warning:</b> This function is not portable.
<p> <p>See also <a href="qapplication.html#qwsEventFilter">QApplication::qwsEventFilter</a>().

<h3 class=fn>void <a name="raise"></a>QWidget::raise ()<tt> [slot]</tt>
</h3>
Raises this widget to the top of the parent widget's stack.
<p> After this call the widget will be visually in front of any
overlapping sibling widgets.
<p> <p>See also <a href="#lower">lower</a>() and <a href="#stackUnder">stackUnder</a>().

<p>Example: <a href="showimg-example.html#x1352">showimg/showimg.cpp</a>.
<h3 class=fn>void <a name="recreate"></a>QWidget::recreate ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, WFlags&nbsp;f, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE )
</h3>

<p> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This method is provided to aid porting from Qt 1.0 to 2.0. It has
been renamed <a href="#reparent">reparent</a>() in Qt 2.0.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="rect"></a>QWidget::rect () const
</h3><p>Returns the internal geometry of the widget excluding any window frame.
See the <a href="qwidget.html#rect-prop">"rect"</a> property for details.
<h3 class=fn>void <a name="releaseKeyboard"></a>QWidget::releaseKeyboard ()
</h3>
Releases the keyboard grab.
<p> <p>See also <a href="#grabKeyboard">grabKeyboard</a>(), <a href="#grabMouse">grabMouse</a>(), and <a href="#releaseMouse">releaseMouse</a>().

<h3 class=fn>void <a name="releaseMouse"></a>QWidget::releaseMouse ()
</h3>
Releases the mouse grab.
<p> <p>See also <a href="#grabMouse">grabMouse</a>(), <a href="#grabKeyboard">grabKeyboard</a>(), and <a href="#releaseKeyboard">releaseKeyboard</a>().

<h3 class=fn>void <a name="repaint"></a>QWidget::repaint ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, bool&nbsp;erase = TRUE )<tt> [slot]</tt>
</h3>
Repaints the widget directly by calling <a href="#paintEvent">paintEvent</a>() immediately,
unless updates are disabled or the widget is hidden.
<p> If <em>erase</em> is TRUE, Qt erases the area <em>(x, y, w, h)</em> before the
paintEvent() call.
<p> If <em>w</em> is negative, it is replaced with <tt>width() - x</tt>, and if
<em>h</em> is negative, it is replaced width <tt>height() - y</tt>.
<p> We suggest only using <a href="#repaint">repaint</a>() if you need an immediate repaint,
for example during animation. In almost all circumstances <a href="#update">update</a>()
is better, as it permits Qt to optimize for speed and minimize
flicker.
<p> <b>Warning:</b> If you call repaint() in a function which may itself be
called from paintEvent(), you may get infinite recursion. The
update() function never causes recursion.
<p> <p>See also <a href="#update">update</a>(), <a href="#paintEvent">paintEvent</a>(), <a href="#updatesEnabled-prop">updatesEnabled</a>, and <a href="#erase">erase</a>().

<p>Example: <a href="qwerty-example.html#x407">qwerty/qwerty.cpp</a>.
<h3 class=fn>void <a name="repaint-2"></a>QWidget::repaint ()<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This version erases and repaints the entire widget.

<h3 class=fn>void <a name="repaint-3"></a>QWidget::repaint ( bool&nbsp;erase )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This version repaints the entire widget.

<h3 class=fn>void <a name="repaint-4"></a>QWidget::repaint ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r, bool&nbsp;erase = TRUE )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Repaints the widget directly by calling <a href="#paintEvent">paintEvent</a>() directly,
unless updates are disabled or the widget is hidden.
<p> Erases the widget region <em>r</em> if <em>erase</em> is TRUE.

<h3 class=fn>void <a name="repaint-5"></a>QWidget::repaint ( const&nbsp;<a href="qregion.html">QRegion</a>&nbsp;&amp;&nbsp;reg, bool&nbsp;erase = TRUE )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Repaints the widget directly by calling <a href="#paintEvent">paintEvent</a>() directly,
unless updates are disabled or the widget is hidden.
<p> Erases the widget region <em>reg</em> if <em>erase</em> is TRUE.
<p> Only use repaint if your widget needs to be repainted immediately,
for example when doing some animation. In all other cases, use
<a href="#update">update</a>(). Calling update() many times in a row will generate a
single paint event.
<p> <b>Warning:</b> If you call <a href="#repaint">repaint</a>() in a function which may itself be
called from paintEvent(), you may get infinite recursion. The
update() function never causes recursion.
<p> <p>See also <a href="#update">update</a>(), <a href="#paintEvent">paintEvent</a>(), <a href="#updatesEnabled-prop">updatesEnabled</a>, and <a href="#erase">erase</a>().

<h3 class=fn>void <a name="reparent"></a>QWidget::reparent ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, WFlags&nbsp;f, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE )<tt> [virtual]</tt>
</h3>
Reparents the widget. The widget gets a new <em>parent</em>, new widget
flags (<em>f</em>, but as usual, use 0) at a new position in its new
parent (<em>p</em>).
<p> If <em>showIt</em> is TRUE, <a href="#show">show</a>() is called once the widget has been
reparented.
<p> If the new parent widget is in a different top-level widget, the
reparented widget and its children are appended to the end of the
<a href="#setFocusPolicy">tab chain</a> of the new parent
widget, in the same internal order as before. If one of the moved
widgets had <a href="focus.html#keyboard-focus">keyboard focus</a>, <a href="#reparent">reparent</a>() calls <a href="#clearFocus">clearFocus</a>() for that
widget.
<p> If the new parent widget is in the same top-level widget as the
old parent, reparent doesn't change the tab order or keyboard
focus.
<p> <b>Warning:</b> It is extremely unlikely that you will ever need this
function. If you have a widget that changes its content
dynamically, it is far easier to use <a href="qwidgetstack.html">QWidgetStack</a> or <a href="qwizard.html">QWizard</a>.
<p> <p>See also <a href="#getWFlags">getWFlags</a>().

<p>Example: <a href="toplevel-example.html#x2538">toplevel/options.ui.h</a>.
<h3 class=fn>void <a name="reparent-2"></a>QWidget::reparent ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p, bool&nbsp;showIt = FALSE )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> A convenience version of reparent that does not take widget flags
as argument.
<p> Calls <a href="#reparent">reparent</a>(<em>parent</em>, <a href="#getWFlags">getWFlags</a>() &amp; ~<a href="qt.html#WidgetFlags-enum">WType_Mask</a>, <em>p</em>, <em>showIt</em>).

<h3 class=fn>void <a name="resetInputContext"></a>QWidget::resetInputContext ()<tt> [protected]</tt>
</h3>
This function is called when the user finishes input composition,
e.g. changes focus to another widget, moves the cursor, etc.

<h3 class=fn>void <a name="resize"></a>QWidget::resize ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; )<tt> [slot]</tt>
</h3><p>Sets the size of the widget excluding any window frame.
See the <a href="qwidget.html#size-prop">"size"</a> property for details.
<h3 class=fn>void <a name="resize-2"></a>QWidget::resize ( int&nbsp;w, int&nbsp;h )<tt> [virtual slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This corresponds to <a href="#resize">resize</a>( <a href="qsize.html">QSize</a>(<em>w</em>, <em>h</em>) ).

<h3 class=fn>void <a name="resizeEvent"></a>QWidget::resizeEvent ( <a href="qresizeevent.html">QResizeEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget resize events. When <a href="#resizeEvent">resizeEvent</a>() is called, the widget
already has its new geometry. The old size is accessible through
<a href="qresizeevent.html#oldSize">QResizeEvent::oldSize</a>().
<p> The widget will be erased and receive a paint event immediately
after processing the resize event. No drawing need be (or should
be) done inside this handler.
<p> Widgets that have been created with the <a href="qt.html#WidgetFlags-enum">WNoAutoErase</a> flag
will not be erased. Nevertheless, they will receive a paint event
for their entire area afterwards. Again, no drawing needs to be
done inside this handler.
<p> The default implementation calls <a href="#updateMask">updateMask</a>() if the widget has
<a href="#setAutoMask">automatic masking</a> enabled.
<p> <p>See also <a href="#moveEvent">moveEvent</a>(), <a href="#event">event</a>(), <a href="#size-prop">size</a>, <a href="qresizeevent.html">QResizeEvent</a>, and <a href="#paintEvent">paintEvent</a>().

<p>Examples: <a href="drawdemo-example.html#x1089">drawdemo/drawdemo.cpp</a>, <a href="menu-example.html#x1884">menu/menu.cpp</a>, <a href="qmag-example.html#x1806">qmag/qmag.cpp</a>, <a href="scribble-example.html#x952">scribble/scribble.cpp</a>, <a href="showimg-example.html#x1353">showimg/showimg.cpp</a>, <a href="tooltip-example.html#x454">tooltip/tooltip.cpp</a>, and <a href="xform-example.html#x1269">xform/xform.cpp</a>.
<p>Reimplemented in <a href="qframe.html#resizeEvent">QFrame</a> and <a href="qglwidget.html#resizeEvent">QGLWidget</a>.
<h3 class=fn>void <a name="scroll"></a>QWidget::scroll ( int&nbsp;dx, int&nbsp;dy )
</h3>
Scrolls the widget including its children <em>dx</em> pixels to the
right and <em>dy</em> downwards. Both <em>dx</em> and <em>dy</em> may be negative.
<p> After scrolling, <a href="#scroll">scroll</a>() sends a paint event for the the part
that is read but not written. For example, when scrolling 10
pixels rightwards, the leftmost ten pixels of the widget need
repainting. The paint event may be delivered immediately or later,
depending on some heuristics (note that you might have to force
processing of paint events using <a href="qapplication.html#sendPostedEvents">QApplication::sendPostedEvents</a>()
when using scroll() and <a href="#move">move</a>() in combination).
<p> <p>See also <a href="qscrollview.html">QScrollView</a>, <a href="#erase">erase</a>(), and <a href="qpaintdevice.html#bitBlt">bitBlt</a>().

<h3 class=fn>void <a name="scroll-2"></a>QWidget::scroll ( int&nbsp;dx, int&nbsp;dy, const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This version only scrolls <em>r</em> and does not move the children of
the widget.
<p> If <em>r</em> is empty or invalid, the result is undefined.
<p> <p>See also <a href="qscrollview.html">QScrollView</a>, <a href="#erase">erase</a>(), and <a href="qpaintdevice.html#bitBlt">bitBlt</a>().

<h3 class=fn>void <a name="setAcceptDrops"></a>QWidget::setAcceptDrops ( bool&nbsp;on )<tt> [virtual]</tt>
</h3><p>Sets whether drop events are enabled for this widget to <em>on</em>.
See the <a href="qwidget.html#acceptDrops-prop">"acceptDrops"</a> property for details.
<h3 class=fn>void <a name="setActiveWindow"></a>QWidget::setActiveWindow ()<tt> [virtual]</tt>
</h3>
Sets the top-level widget containing this widget to be the active
window.
<p> An active window is a visible top-level window that has the
keyboard input focus.
<p> This function performs the same operation as clicking the mouse on
the title bar of a top-level window. On X11, the result depends on
the Window Manager. If you want to ensure that the window is
stacked on top as well you should also call <a href="#raise">raise</a>(). Note that the
window must be visible, otherwise <a href="#setActiveWindow">setActiveWindow</a>() has no effect.
<p> On Windows, if you are calling this when the application is not
currently the active one then it will not make it the active
window.  It will flash the task bar entry blue to indicate that
the window has done something. This is because Microsoft do not
allow an application to interrupt what the user is currently doing
in another application.
<p> <p>See also <a href="#isActiveWindow-prop">isActiveWindow</a>, <a href="#topLevelWidget">topLevelWidget</a>(), and <a href="#show">show</a>().

<p>Reimplemented in <a href="qxtwidget.html#setActiveWindow">QXtWidget</a>.
<h3 class=fn>void <a name="setAutoMask"></a>QWidget::setAutoMask ( bool )<tt> [virtual]</tt>
</h3><p>Sets whether the auto mask feature is enabled for the widget.
See the <a href="qwidget.html#autoMask-prop">"autoMask"</a> property for details.
<h3 class=fn>void <a name="setBackgroundColor"></a>QWidget::setBackgroundColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp;&nbsp;c )<tt> [virtual]</tt>
</h3><b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
Use <a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>() or <a href="#setEraseColor">setEraseColor</a>() instead. 
<p>Examples: <a href="customlayout-example.html#x1540">customlayout/main.cpp</a>, <a href="desktop-example.html#x1761">desktop/desktop.cpp</a>, <a href="hello-example.html#x1648">hello/main.cpp</a>, <a href="movies-example.html#x523">movies/main.cpp</a>, and <a href="splitter-example.html#x1303">splitter/splitter.cpp</a>.
<h3 class=fn>void <a name="setBackgroundMode"></a>QWidget::setBackgroundMode ( <a href="qt.html#BackgroundMode-enum">BackgroundMode</a> )<tt> [virtual]</tt>
</h3><p>Sets the color role used for painting the background of the widget.
See the <a href="qwidget.html#backgroundMode-prop">"backgroundMode"</a> property for details.
<h3 class=fn>void <a name="setBackgroundMode-2"></a>QWidget::setBackgroundMode ( <a href="qt.html#BackgroundMode-enum">BackgroundMode</a>&nbsp;m, <a href="qt.html#BackgroundMode-enum">BackgroundMode</a>&nbsp;visual )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the widget's own background mode to <em>m</em> and the visual
background mode to <em>visual</em>. The visual background mode is used
with the designable properties <tt>backgroundColor</tt>, <tt>foregroundColor</tt> and <tt>backgroundPixmap</tt>.
<p> For complex controls, the logical background mode sometimes
differs from a widget's own background mode. A spinbox for example
has <a href="qt.html#BackgroundMode-enum">PaletteBackground</a> as background mode (typically dark gray),
while it's embedded lineedit control uses <a href="qt.html#BackgroundMode-enum">PaletteBase</a>
(typically white). Since the lineedit covers most of the visual
area of a spinbox, it defines <a href="qt.html#BackgroundMode-enum">PaletteBase</a> to be its <em>visual</em>
background mode. Changing the <tt>backgroundColor</tt> property thus
changes the lineedit control's background, which is exactly what
the user expects in <em>Qt Designer</em>.

<h3 class=fn>void <a name="setBackgroundOrigin"></a>QWidget::setBackgroundOrigin ( <a href="qwidget.html#BackgroundOrigin-enum">BackgroundOrigin</a> )<tt> [virtual]</tt>
</h3><p>Sets the origin of the widget's background.
See the <a href="qwidget.html#backgroundOrigin-prop">"backgroundOrigin"</a> property for details.
<h3 class=fn>void <a name="setBackgroundPixmap"></a>QWidget::setBackgroundPixmap ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;pm )<tt> [virtual]</tt>
</h3><b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
Use <a href="#setPaletteBackgroundPixmap">setPaletteBackgroundPixmap</a>() or <a href="#setErasePixmap">setErasePixmap</a>() instead. 
<p>Example: <a href="desktop-example.html#x1762">desktop/desktop.cpp</a>.
<h3 class=fn>void <a name="setBaseSize"></a>QWidget::setBaseSize ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; )
</h3><p>Sets the base size of the widget.
See the <a href="qwidget.html#baseSize-prop">"baseSize"</a> property for details.
<h3 class=fn>void <a name="setBaseSize-2"></a>QWidget::setBaseSize ( int&nbsp;basew, int&nbsp;baseh )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This corresponds to <a href="#setBaseSize">setBaseSize</a>( <a href="qsize.html">QSize</a>(<em>basew</em>, <em>baseh</em>) ). Sets
the widgets base size to width <em>basew</em> and height <em>baseh</em>.

<h3 class=fn>void <a name="setCaption"></a>QWidget::setCaption ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp; )<tt> [virtual slot]</tt>
</h3><p>Sets the window caption (title).
See the <a href="qwidget.html#caption-prop">"caption"</a> property for details.
<h3 class=fn>void <a name="setCursor"></a>QWidget::setCursor ( const&nbsp;<a href="qcursor.html">QCursor</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3><p>Sets the cursor shape for this widget.
See the <a href="qwidget.html#cursor-prop">"cursor"</a> property for details.
<h3 class=fn>void <a name="setDisabled"></a>QWidget::setDisabled ( bool&nbsp;disable )<tt> [slot]</tt>
</h3>
Disables widget input events if <em>disable</em> is TRUE; otherwise
enables input events.
<p> See the <a href="#enabled-prop">enabled</a> documentation for more information.
<p> <p>See also <a href="#isEnabledTo">isEnabledTo</a>(), <a href="qkeyevent.html">QKeyEvent</a>, <a href="qmouseevent.html">QMouseEvent</a>, and <a href="#enabledChange">enabledChange</a>().

<h3 class=fn>void <a name="setEnabled"></a>QWidget::setEnabled ( bool )<tt> [virtual slot]</tt>
</h3><p>Sets whether the widget is enabled.
See the <a href="qwidget.html#enabled-prop">"enabled"</a> property for details.
<h3 class=fn>void <a name="setEraseColor"></a>QWidget::setEraseColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp;&nbsp;color )<tt> [virtual]</tt>
</h3>
Sets the erase color of the widget to <em>color</em>.
<p> The erase color is the color the widget is to be cleared to before
<a href="#paintEvent">paintEvent</a>() is called. If there is an erase pixmap (set using
<a href="#setErasePixmap">setErasePixmap</a>()), then this property has an indeterminate value.
<p> <p>See also <a href="#erasePixmap">erasePixmap</a>(), <a href="#backgroundColor">backgroundColor</a>(), <a href="#backgroundMode-prop">backgroundMode</a>, and <a href="#palette-prop">palette</a>.

<h3 class=fn>void <a name="setErasePixmap"></a>QWidget::setErasePixmap ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;pixmap )<tt> [virtual]</tt>
</h3>
Sets the widget's erase pixmap to <em>pixmap</em>.
<p> This pixmap is used to clear the widget before <a href="#paintEvent">paintEvent</a>() is
called.

<h3 class=fn>void <a name="setFixedHeight"></a>QWidget::setFixedHeight ( int&nbsp;h )
</h3>
Sets both the minimum and maximum heights of the widget to <em>h</em>
without changing the widths. Provided for convenience.
<p> <p>See also <a href="#sizeHint-prop">sizeHint</a>, <a href="#minimumSize-prop">minimumSize</a>, <a href="#maximumSize-prop">maximumSize</a>, and <a href="#setFixedSize">setFixedSize</a>().

<p>Examples: <a href="simple-font-demo-example.html#x2859">fonts/simple-qfont-demo/viewer.cpp</a>, <a href="layout-example.html#x545">layout/layout.cpp</a>, <a href="qdir-example.html#x1852">qdir/qdir.cpp</a>, and <a href="showimg-example.html#x1354">showimg/showimg.cpp</a>.
<h3 class=fn>void <a name="setFixedSize"></a>QWidget::setFixedSize ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;s )
</h3>
Sets both the minimum and maximum sizes of the widget to <em>s</em>,
thereby preventing it from ever growing or shrinking.
<p> <p>See also <a href="#maximumSize-prop">maximumSize</a> and <a href="#minimumSize-prop">minimumSize</a>.

<h3 class=fn>void <a name="setFixedSize-2"></a>QWidget::setFixedSize ( int&nbsp;w, int&nbsp;h )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the width of the widget to <em>w</em> and the height to <em>h</em>.

<h3 class=fn>void <a name="setFixedWidth"></a>QWidget::setFixedWidth ( int&nbsp;w )
</h3>
Sets both the minimum and maximum width of the widget to <em>w</em>
without changing the heights. Provided for convenience.
<p> <p>See also <a href="#sizeHint-prop">sizeHint</a>, <a href="#minimumSize-prop">minimumSize</a>, <a href="#maximumSize-prop">maximumSize</a>, and <a href="#setFixedSize">setFixedSize</a>().

<p>Examples: <a href="progressbar-example.html#x974">progressbar/progressbar.cpp</a> and <a href="qdir-example.html#x1853">qdir/qdir.cpp</a>.
<h3 class=fn>void <a name="setFocus"></a>QWidget::setFocus ()<tt> [virtual slot]</tt>
</h3>
Gives the keyboard input focus to this widget (or its focus
proxy) if this widget or one of its parents is the <a href="#isActiveWindow">active window</a>.
<p> First, a focus out event is sent to the focus widget (if any) to
tell it that it is about to lose the focus. Then a focus in event
is sent to this widget to tell it that it just received the focus.
(Nothing happens if the focus in and focus out widgets are the
same.)
<p> <a href="#setFocus">setFocus</a>() gives focus to a widget regardless of its focus policy,
but does not clear any keyboard grab (see <a href="#grabKeyboard">grabKeyboard</a>()).
<p> Be aware that if the widget is hidden, it will not accept focus.
<p> <b>Warning:</b> If you call setFocus() in a function which may itself be
called from <a href="#focusOutEvent">focusOutEvent</a>() or <a href="#focusInEvent">focusInEvent</a>(), you may get an
infinite recursion.
<p> <p>See also <a href="#focus-prop">focus</a>, <a href="#clearFocus">clearFocus</a>(), <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>(), <a href="#grabKeyboard">grabKeyboard</a>(), and <a href="#grabMouse">grabMouse</a>().

<p>Examples: <a href="addressbook-example.html#x606">addressbook/centralwidget.cpp</a>, <a href="lineedits-example.html#x181">lineedits/lineedits.cpp</a>, <a href="mdi-example.html#x2084">mdi/application.cpp</a>, <a href="popup-example.html#x1625">popup/popup.cpp</a>, <a href="rot-example.html#x1378">rot13/rot13.cpp</a>, <a href="tutorial1-08.html#x2339">t8/main.cpp</a>, and <a href="wizard-example.html#x11">wizard/wizard.cpp</a>.
<h3 class=fn>void <a name="setFocusPolicy"></a>QWidget::setFocusPolicy ( <a href="qwidget.html#FocusPolicy-enum">FocusPolicy</a> )<tt> [virtual]</tt>
</h3><p>Sets the way the widget accepts keyboard focus.
See the <a href="qwidget.html#focusPolicy-prop">"focusPolicy"</a> property for details.
<h3 class=fn>void <a name="setFocusProxy"></a>QWidget::setFocusProxy ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w )<tt> [virtual]</tt>
</h3>
Sets the widget's focus proxy to widget <em>w</em>. If <em>w</em> is 0, the
function resets this widget to have no focus proxy.
<p> Some widgets, such as <a href="qcombobox.html">QComboBox</a>, can "have focus", but create a
child widget to actually handle the focus. QComboBox, for example,
creates a <a href="qlineedit.html">QLineEdit</a> which handles the focus.
<p> <a href="#setFocusProxy">setFocusProxy</a>() sets the widget which will actually get focus when
"this widget" gets it. If there is a focus proxy, <a href="#focusPolicy">focusPolicy</a>(),
<a href="#setFocusPolicy">setFocusPolicy</a>(), <a href="#setFocus">setFocus</a>() and <a href="#hasFocus">hasFocus</a>() all operate on the
focus proxy.
<p> <p>See also <a href="#focusProxy">focusProxy</a>().

<h3 class=fn>void <a name="setFont"></a>QWidget::setFont ( const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3><p>Sets the font currently set for the widget.
See the <a href="qwidget.html#font-prop">"font"</a> property for details.
<p>Reimplemented in <a href="qcombobox.html#setFont">QComboBox</a>, <a href="qlabel.html#setFont">QLabel</a>, and <a href="qtabdialog.html#setFont">QTabDialog</a>.
<h3 class=fn>void <a name="setFont-2"></a>QWidget::setFont ( const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp;&nbsp;f, bool )
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Use <a href="#setFont">setFont</a>(const <a href="qfont.html">QFont</a>& font) instead.

<h3 class=fn>void <a name="setGeometry"></a>QWidget::setGeometry ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp; )<tt> [virtual slot]</tt>
</h3><p>Sets the geometry of the widget relative to its parent and excluding the window frame.
See the <a href="qwidget.html#geometry-prop">"geometry"</a> property for details.
<h3 class=fn>void <a name="setGeometry-2"></a>QWidget::setGeometry ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )<tt> [virtual slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This corresponds to <a href="#setGeometry">setGeometry</a>( <a href="qrect.html">QRect</a>(<em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>) ).

<h3 class=fn>void <a name="setHidden"></a>QWidget::setHidden ( bool&nbsp;hide )<tt> [slot]</tt>
</h3><p>Sets whether the widget is explicitly hidden to <em>hide</em>.
See the <a href="qwidget.html#hidden-prop">"hidden"</a> property for details.
<h3 class=fn>void <a name="setIcon"></a>QWidget::setIcon ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp; )<tt> [virtual slot]</tt>
</h3><p>Sets the widget's icon.
See the <a href="qwidget.html#icon-prop">"icon"</a> property for details.
<h3 class=fn>void <a name="setIconText"></a>QWidget::setIconText ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp; )<tt> [virtual slot]</tt>
</h3><p>Sets the widget's icon text.
See the <a href="qwidget.html#iconText-prop">"iconText"</a> property for details.
<h3 class=fn>void <a name="setInputMethodEnabled"></a>QWidget::setInputMethodEnabled ( bool&nbsp;b )
</h3><p>Sets enables or disables the use of input methods for this widget to <em>b</em>.
See the <a href="qwidget.html#inputMethodEnabled-prop">"inputMethodEnabled"</a> property for details.
<h3 class=fn>void <a name="setKeyCompression"></a>QWidget::setKeyCompression ( bool&nbsp;compress )<tt> [virtual protected]</tt>
</h3>
Enables key event compression, if <em>compress</em> is TRUE, and
disables it if <em>compress</em> is FALSE.
<p> Key compression is off by default (except for <a href="qlineedit.html">QLineEdit</a> and
<a href="qtextedit.html">QTextEdit</a>), so widgets receive one key press event for each key
press (or more, since autorepeat is usually on). If you turn it on
and your program doesn't keep up with key input, Qt may try to
compress key events so that more than one character can be
processed in each event.
<p> For example, a word processor widget might receive 2, 3 or more
characters in each <a href="qkeyevent.html#text">QKeyEvent::text</a>(), if the layout recalculation
takes too long for the CPU.
<p> If a widget supports multiple character unicode input, it is
always safe to turn the compression on.
<p> Qt performs key event compression only for printable characters.
Modifier keys, cursor movement keys, function keys and
miscellaneous action keys (e.g. Escape, Enter, Backspace,
PrintScreen) will stop key event compression, even if there are
more compressible key events available.
<p> Not all platforms support this compression, in which case turning
it on will have no effect.
<p> <p>See also <a href="qkeyevent.html#text">QKeyEvent::text</a>().

<h3 class=fn>void <a name="setMask"></a>QWidget::setMask ( const&nbsp;<a href="qbitmap.html">QBitmap</a>&nbsp;&amp;&nbsp;bitmap )<tt> [virtual]</tt>
</h3>
Causes only the pixels of the widget for which <em>bitmap</em> has a
corresponding 1 bit to be visible. Use Qt::color0 to draw
transparent regions and Qt::color1 to draw opaque regions of the
bitmap.
<p> If the region includes pixels outside the <a href="#rect">rect</a>() of the widget,
window system controls in that area may or may not be visible,
depending on the platform.
<p> Note that this effect can be slow if the region is particularly
complex.
<p> See <tt>examples/tux</tt> for an example of masking for transparency.
<p> <p>See also <a href="#clearMask">clearMask</a>().

<h3 class=fn>void <a name="setMask-2"></a>QWidget::setMask ( const&nbsp;<a href="qregion.html">QRegion</a>&nbsp;&amp;&nbsp;region )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Causes only the parts of the widget which overlap <em>region</em> to be
visible. If the region includes pixels outside the <a href="#rect">rect</a>() of the
widget, window system controls in that area may or may not be
visible, depending on the platform.
<p> Note that this effect can be slow if the region is particularly
complex.
<p> <p>See also <a href="#clearMask">clearMask</a>().

<h3 class=fn>void <a name="setMaximumHeight"></a>QWidget::setMaximumHeight ( int&nbsp;maxh )
</h3><p>Sets the widget's maximum height to <em>maxh</em>.
See the <a href="qwidget.html#maximumHeight-prop">"maximumHeight"</a> property for details.
<h3 class=fn>void <a name="setMaximumSize"></a>QWidget::setMaximumSize ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; )
</h3><p>Sets the widget's maximum size.
See the <a href="qwidget.html#maximumSize-prop">"maximumSize"</a> property for details.
<h3 class=fn>void <a name="setMaximumSize-2"></a>QWidget::setMaximumSize ( int&nbsp;maxw, int&nbsp;maxh )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This function corresponds to <a href="#setMaximumSize">setMaximumSize</a>( <a href="qsize.html">QSize</a>(<em>maxw</em>, <em>maxh</em>) ). Sets the maximum width to <em>maxw</em> and the maximum height
to <em>maxh</em>.

<h3 class=fn>void <a name="setMaximumWidth"></a>QWidget::setMaximumWidth ( int&nbsp;maxw )
</h3><p>Sets the widget's maximum width to <em>maxw</em>.
See the <a href="qwidget.html#maximumWidth-prop">"maximumWidth"</a> property for details.
<h3 class=fn>void <a name="setMicroFocusHint"></a>QWidget::setMicroFocusHint ( int&nbsp;x, int&nbsp;y, int&nbsp;width, int&nbsp;height, bool&nbsp;text = TRUE, <a href="qfont.html">QFont</a>&nbsp;*&nbsp;f = 0 )<tt> [virtual protected]</tt>
</h3>
When a widget gets focus, it should call <a href="#setMicroFocusHint">setMicroFocusHint</a>() with
some appropriate position and size, <em>x</em>, <em>y</em>, <em>width</em> and <em>height</em>. This has no <em>visual</em> effect, it just provides hints to
any system-specific input handling tools.
<p> The <em>text</em> argument should be TRUE if this is a position for text
input.
<p> In the Windows version of Qt, this method sets the system caret,
which is used for user Accessibility focus handling.  If <em>text</em>
is TRUE, it also sets the IME composition window in Far East Asian
language input systems.
<p> In the X11 version of Qt, if <em>text</em> is TRUE, this method sets the
XIM "spot" point for complex language input handling.
<p> The font <em>f</em> is a rendering hint to the currently active input method.
If <em>f</em> is 0 the widget's font is used.
<p> <p>See also <a href="#microFocusHint-prop">microFocusHint</a>.

<h3 class=fn>void <a name="setMinimumHeight"></a>QWidget::setMinimumHeight ( int&nbsp;minh )
</h3><p>Sets the widget's minimum height to <em>minh</em>.
See the <a href="qwidget.html#minimumHeight-prop">"minimumHeight"</a> property for details.
<h3 class=fn>void <a name="setMinimumSize"></a>QWidget::setMinimumSize ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; )
</h3><p>Sets the widget's minimum size.
See the <a href="qwidget.html#minimumSize-prop">"minimumSize"</a> property for details.
<h3 class=fn>void <a name="setMinimumSize-2"></a>QWidget::setMinimumSize ( int&nbsp;minw, int&nbsp;minh )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This function corresponds to <a href="#setMinimumSize">setMinimumSize</a>( <a href="qsize.html">QSize</a>(minw, minh) ).
Sets the minimum width to <em>minw</em> and the minimum height to <em>minh</em>.

<h3 class=fn>void <a name="setMinimumWidth"></a>QWidget::setMinimumWidth ( int&nbsp;minw )
</h3><p>Sets the widget's minimum width to <em>minw</em>.
See the <a href="qwidget.html#minimumWidth-prop">"minimumWidth"</a> property for details.
<h3 class=fn>void <a name="setMouseTracking"></a>QWidget::setMouseTracking ( bool&nbsp;enable )<tt> [virtual slot]</tt>
</h3><p>Sets whether mouse tracking is enabled for the widget to <em>enable</em>.
See the <a href="qwidget.html#mouseTracking-prop">"mouseTracking"</a> property for details.
<h3 class=fn>void <a name="setPalette"></a>QWidget::setPalette ( const&nbsp;<a href="qpalette.html">QPalette</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3><p>Sets the widget's palette.
See the <a href="qwidget.html#palette-prop">"palette"</a> property for details.
<p>Reimplemented in <a href="qcombobox.html#setPalette">QComboBox</a>, <a href="qscrollbar.html#setPalette">QScrollBar</a>, and <a href="qslider.html#setPalette">QSlider</a>.
<h3 class=fn>void <a name="setPalette-2"></a>QWidget::setPalette ( const&nbsp;<a href="qpalette.html">QPalette</a>&nbsp;&amp;&nbsp;p, bool )
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Use <a href="#setPalette">setPalette</a>( const <a href="qpalette.html">QPalette</a>& p ) instead.

<h3 class=fn>void <a name="setPaletteBackgroundColor"></a>QWidget::setPaletteBackgroundColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3><p>Sets the background color of the widget.
See the <a href="qwidget.html#paletteBackgroundColor-prop">"paletteBackgroundColor"</a> property for details.
<h3 class=fn>void <a name="setPaletteBackgroundPixmap"></a>QWidget::setPaletteBackgroundPixmap ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3><p>Sets the background pixmap of the widget.
See the <a href="qwidget.html#paletteBackgroundPixmap-prop">"paletteBackgroundPixmap"</a> property for details.
<h3 class=fn>void <a name="setPaletteForegroundColor"></a>QWidget::setPaletteForegroundColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; )
</h3><p>Sets the foreground color of the widget.
See the <a href="qwidget.html#paletteForegroundColor-prop">"paletteForegroundColor"</a> property for details.
<h3 class=fn>void <a name="setShown"></a>QWidget::setShown ( bool&nbsp;show )<tt> [slot]</tt>
</h3><p>Sets whether the widget is shown to <em>show</em>.
See the <a href="qwidget.html#shown-prop">"shown"</a> property for details.
<h3 class=fn>void <a name="setSizeIncrement"></a>QWidget::setSizeIncrement ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; )
</h3><p>Sets the size increment of the widget.
See the <a href="qwidget.html#sizeIncrement-prop">"sizeIncrement"</a> property for details.
<h3 class=fn>void <a name="setSizeIncrement-2"></a>QWidget::setSizeIncrement ( int&nbsp;w, int&nbsp;h )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the x (width) size increment to <em>w</em> and the y (height) size
increment to <em>h</em>.

<h3 class=fn>void <a name="setSizePolicy"></a>QWidget::setSizePolicy ( <a href="qsizepolicy.html">QSizePolicy</a> )<tt> [virtual]</tt>
</h3><p>Sets the default layout behavior of the widget.
See the <a href="qwidget.html#sizePolicy-prop">"sizePolicy"</a> property for details.
<h3 class=fn>void <a name="setSizePolicy-2"></a>QWidget::setSizePolicy ( <a href="qsizepolicy.html#SizeType-enum">QSizePolicy::SizeType</a>&nbsp;hor, <a href="qsizepolicy.html#SizeType-enum">QSizePolicy::SizeType</a>&nbsp;ver, bool&nbsp;hfw = FALSE )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the size policy of the widget to <em>hor</em>, <em>ver</em> and <em>hfw</em>
(height for width).
<p> <p>See also <a href="qsizepolicy.html#QSizePolicy">QSizePolicy::QSizePolicy</a>().

<h3 class=fn>void <a name="setStyle"></a>QWidget::setStyle ( <a href="qstyle.html">QStyle</a>&nbsp;*&nbsp;style )
</h3>
Sets the widget's GUI style to <em>style</em>. Ownership of the style
object is not transferred.
<p> If no style is set, the widget uses the application's style,
<a href="qapplication.html#style">QApplication::style</a>() instead.
<p> Setting a widget's style has no effect on existing or future child
widgets.
<p> <b>Warning:</b> This function is particularly useful for demonstration
purposes, where you want to show Qt's styling capabilities. Real
applications should avoid it and use one consistent GUI style
instead.
<p> <p>See also <a href="#style">style</a>(), <a href="qstyle.html">QStyle</a>, <a href="qapplication.html#style">QApplication::style</a>(), and <a href="qapplication.html#setStyle">QApplication::setStyle</a>().

<p>Examples: <a href="grapher-nsplugin-example.html#x2778">grapher/grapher.cpp</a> and <a href="progressbar-example.html#x975">progressbar/progressbar.cpp</a>.
<h3 class=fn><a href="qstyle.html">QStyle</a>&nbsp;* <a name="setStyle-2"></a>QWidget::setStyle ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;style )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the widget's GUI style to <em>style</em> using the <a href="qstylefactory.html">QStyleFactory</a>.

<h3 class=fn>void <a name="setTabOrder"></a>QWidget::setTabOrder ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;first, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;second )<tt> [static]</tt>
</h3>
Moves the <em>second</em> widget around the ring of focus widgets so
that <a href="focus.html#keyboard-focus">keyboard focus</a> moves from the <em>first</em> widget to the <em>second</em> widget when the Tab key is pressed.
<p> Note that since the tab order of the <em>second</em> widget is changed,
you should order a chain like this:
<p> <pre>
        <a href="#setTabOrder">setTabOrder</a>( a, b ); // a to b
        <a href="#setTabOrder">setTabOrder</a>( b, c ); // a to b to c
        <a href="#setTabOrder">setTabOrder</a>( c, d ); // a to b to c to d
    </pre>
 
<p> <em>not</em> like this:
<p> <pre>
        <a href="#setTabOrder">setTabOrder</a>( c, d ); // c to d   WRONG
        <a href="#setTabOrder">setTabOrder</a>( a, b ); // a to b AND c to d
        <a href="#setTabOrder">setTabOrder</a>( b, c ); // a to b to c, but not c to d
    </pre>
 
<p> If <em>first</em> or <em>second</em> has a focus proxy, <a href="#setTabOrder">setTabOrder</a>()
correctly substitutes the proxy.
<p> <p>See also <a href="#focusPolicy-prop">focusPolicy</a> and <a href="#setFocusProxy">setFocusProxy</a>().

<p>Example: <a href="customlayout-example.html#x1542">customlayout/main.cpp</a>.
<h3 class=fn>void <a name="setUpdatesEnabled"></a>QWidget::setUpdatesEnabled ( bool&nbsp;enable )<tt> [virtual slot]</tt>
</h3><p>Sets whether updates are enabled to <em>enable</em>.
See the <a href="qwidget.html#updatesEnabled-prop">"updatesEnabled"</a> property for details.
<h3 class=fn>void <a name="setWFlags"></a>QWidget::setWFlags ( WFlags&nbsp;f )<tt> [virtual protected]</tt>
</h3>

<p> Sets the widget flags <em>f</em>.
<p> Widget flags are a combination of <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.
<p> <p>See also <a href="#testWFlags">testWFlags</a>(), <a href="#getWFlags">getWFlags</a>(), and <a href="#clearWFlags">clearWFlags</a>().

<h3 class=fn>void <a name="setWindowOpacity"></a>QWidget::setWindowOpacity ( double&nbsp;level )
</h3><p>Sets the level of opacity for the window to <em>level</em>.
See the <a href="qwidget.html#windowOpacity-prop">"windowOpacity"</a> property for details.
<h3 class=fn>void <a name="setWindowState"></a>QWidget::setWindowState ( uint&nbsp;windowState )
</h3>

<p> Sets the <a href="qt.html#WindowState">window state</a> to <em>windowState</em>. The window state is a OR'ed
combination of Qt::WindowState: <a href="qt.html#WindowState-enum">WindowMinimized</a>, <a href="qt.html#WindowState-enum">WindowMaximized</a>, <a href="qt.html#WindowState-enum">WindowFullScreen</a> and <a href="qt.html#WindowState-enum">WindowActive</a>.
<p> If the window is not visible (i.e. <a href="#isVisible">isVisible</a>() returns FALSE), the
window state will take effect when <a href="#show">show</a>() is called. For visible
windows, the change is immediate. For example, to toggle between
full-screen and mormal mode, use the following code:
<p> <pre>
        w-&gt;setWindowState(w-&gt;windowState() ^ WindowFullScreen);
  </pre>
 
<p> In order to restore and activate a minimized window (while
preserving its maximized and/or full-screen state), use the following:
<p> <pre>
        w-&gt;setWindowState(w-&gt;windowState() &amp; ~WindowMinimized | WindowActive);
  </pre>
 
<p> Note: On some window systems <a href="qt.html#WindowState-enum">WindowActive</a> is not immediate, and may be
ignored in certain cases.
<p> <p>See also <a href="qt.html#WindowState-enum">Qt::WindowState</a> and <a href="#windowState">windowState</a>().

<h3 class=fn>void <a name="show"></a>QWidget::show ()<tt> [virtual slot]</tt>
</h3>
Shows the widget and its child widgets.
<p> If its size or position has changed, Qt guarantees that a widget
gets move and resize events just before it is shown.
<p> You almost never have to reimplement this function. If you need to
change some settings before a widget is shown, use <a href="#showEvent">showEvent</a>()
instead. If you need to do some delayed initialization use
<a href="#polish">polish</a>().
<p> <p>See also <a href="#showEvent">showEvent</a>(), <a href="#hide">hide</a>(), <a href="#showMinimized">showMinimized</a>(), <a href="#showMaximized">showMaximized</a>(), <a href="#showNormal">showNormal</a>(), <a href="#visible-prop">visible</a>, and <a href="#polish">polish</a>().

<p>Examples: <a href="aclock-example.html#x1215">aclock/main.cpp</a>, <a href="qdialog.html#x2135">life/main.cpp</a>, <a href="popup-example.html#x1628">popup/popup.cpp</a>, <a href="tutorial1-01.html#x2286">t1/main.cpp</a>, <a href="tutorial1-03.html#x2302">t3/main.cpp</a>, <a href="tutorial1-04.html#x2309">t4/main.cpp</a>, and <a href="toplevel-example.html#x2542">toplevel/options.ui.h</a>.
<p>Reimplemented in <a href="qdialog.html#show">QDialog</a> and <a href="qmenubar.html#show">QMenuBar</a>.
<h3 class=fn>void <a name="showEvent"></a>QWidget::showEvent ( <a href="qshowevent.html">QShowEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
widget show events.
<p> Non-spontaneous show events are sent to widgets immediately before
they are shown. The spontaneous show events of top-level widgets
are delivered afterwards.
<p> <p>See also <a href="#event">event</a>() and <a href="qshowevent.html">QShowEvent</a>.

<p>Example: <a href="qdir-example.html#x1854">qdir/qdir.cpp</a>.
<h3 class=fn>void <a name="showFullScreen"></a>QWidget::showFullScreen ()<tt> [slot]</tt>
</h3>
Shows the widget in full-screen mode.
<p> Calling this function only affects top-level widgets.
<p> To return from full-screen mode, call <a href="#showNormal">showNormal</a>().
<p> Full-screen mode works fine under Windows, but has certain
problems under X. These problems are due to limitations of the
ICCCM protocol that specifies the communication between X11
clients and the window manager. ICCCM simply does not understand
the concept of non-decorated full-screen windows. Therefore, the
best we can do is to request a borderless window and place and
resize it to fill the entire screen. Depending on the window
manager, this may or may not work. The borderless window is
requested using MOTIF hints, which are at least partially
supported by virtually all modern window managers.
<p> An alternative would be to bypass the window manager entirely and
create a window with the WX11BypassWM flag. This has other severe
problems though, like totally broken <a href="focus.html#keyboard-focus">keyboard focus</a> and very
strange effects on desktop changes or when the user raises other
windows.
<p> X11 window managers that follow modern post-ICCCM specifications
support full-screen mode properly.
<p> <p>See also <a href="#showNormal">showNormal</a>(), <a href="#showMaximized">showMaximized</a>(), <a href="#show">show</a>(), <a href="#hide">hide</a>(), and <a href="#visible-prop">visible</a>.

<h3 class=fn>void <a name="showMaximized"></a>QWidget::showMaximized ()<tt> [virtual slot]</tt>
</h3>
Shows the widget maximized.
<p> Calling this function only affects <a href="#isTopLevel">top-level
    widgets</a>.
<p> On X11, this function may not work properly with certain window
managers. See the <a href="geometry.html">Window Geometry
    documentation</a> for an explanation.
<p> <p>See also <a href="#setWindowState">setWindowState</a>(), <a href="#showNormal">showNormal</a>(), <a href="#showMinimized">showMinimized</a>(), <a href="#show">show</a>(), <a href="#hide">hide</a>(), and <a href="#visible-prop">visible</a>.

<p>Examples: <a href="canvas-example.html#x2968">canvas/main.cpp</a>, <a href="helpviewer-example.html#x1045">helpviewer/main.cpp</a>, <a href="mdi-example.html#x2087">mdi/application.cpp</a>, <a href="qwerty-example.html#x422">qwerty/main.cpp</a>, <a href="qwerty-example.html#x413">qwerty/qwerty.cpp</a>, and <a href="scribble-example.html#x960">scribble/main.cpp</a>.
<h3 class=fn>void <a name="showMinimized"></a>QWidget::showMinimized ()<tt> [virtual slot]</tt>
</h3>
Shows the widget minimized, as an icon.
<p> Calling this function only affects <a href="#isTopLevel">top-level
    widgets</a>.
<p> <p>See also <a href="#showNormal">showNormal</a>(), <a href="#showMaximized">showMaximized</a>(), <a href="#show">show</a>(), <a href="#hide">hide</a>(), <a href="#visible-prop">visible</a>, and <a href="#minimized-prop">minimized</a>.

<h3 class=fn>void <a name="showNormal"></a>QWidget::showNormal ()<tt> [virtual slot]</tt>
</h3>
Restores the widget after it has been maximized or minimized.
<p> Calling this function only affects <a href="#isTopLevel">top-level
    widgets</a>.
<p> <p>See also <a href="#setWindowState">setWindowState</a>(), <a href="#showMinimized">showMinimized</a>(), <a href="#showMaximized">showMaximized</a>(), <a href="#show">show</a>(), <a href="#hide">hide</a>(), and <a href="#visible-prop">visible</a>.

<p>Example: <a href="mdi-example.html#x2088">mdi/application.cpp</a>.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="size"></a>QWidget::size () const
</h3><p>Returns the size of the widget excluding any window frame.
See the <a href="qwidget.html#size-prop">"size"</a> property for details.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="sizeHint"></a>QWidget::sizeHint () const<tt> [virtual]</tt>
</h3><p>Returns the recommended size for the widget.
See the <a href="qwidget.html#sizeHint-prop">"sizeHint"</a> property for details.
<p>Reimplemented in <a href="qsizegrip.html#sizeHint">QSizeGrip</a>.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="sizeIncrement"></a>QWidget::sizeIncrement () const
</h3><p>Returns the size increment of the widget.
See the <a href="qwidget.html#sizeIncrement-prop">"sizeIncrement"</a> property for details.
<h3 class=fn><a href="qsizepolicy.html">QSizePolicy</a> <a name="sizePolicy"></a>QWidget::sizePolicy () const<tt> [virtual]</tt>
</h3><p>Returns the default layout behavior of the widget.
See the <a href="qwidget.html#sizePolicy-prop">"sizePolicy"</a> property for details.
<h3 class=fn>void <a name="stackUnder"></a>QWidget::stackUnder ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w )<tt> [slot]</tt>
</h3>
Places the widget under <em>w</em> in the parent widget's stack.
<p> To make this work, the widget itself and <em>w</em> must be siblings.
<p> <p>See also <a href="#raise">raise</a>() and <a href="#lower">lower</a>().

<h3 class=fn><a href="qstyle.html">QStyle</a>&nbsp;&amp; <a name="style"></a>QWidget::style () const
</h3>
Returns the GUI style for this widget
<p> <p>See also <a href="#setStyle">QWidget::setStyle</a>(), <a href="qapplication.html#setStyle">QApplication::setStyle</a>(), and <a href="qapplication.html#style">QApplication::style</a>().

<h3 class=fn>void <a name="styleChange"></a>QWidget::styleChange ( <a href="qstyle.html">QStyle</a>&nbsp;&amp;&nbsp;oldStyle )<tt> [virtual protected]</tt>
</h3>
This virtual function is called when the style of the widgets
changes. <em>oldStyle</em> is the previous GUI style; you can get the
new style from <a href="#style">style</a>().
<p> Reimplement this function if your widget needs to know when its
GUI style changes. You will almost certainly need to update the
widget using <a href="#update">update</a>().
<p> The default implementation updates the widget including its
geometry.
<p> <p>See also <a href="qapplication.html#setStyle">QApplication::setStyle</a>(), <a href="#style">style</a>(), <a href="#update">update</a>(), and <a href="#updateGeometry">updateGeometry</a>().

<h3 class=fn>void <a name="tabletEvent"></a>QWidget::tabletEvent ( <a href="qtabletevent.html">QTabletEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive tablet events for the widget.
<p> If you reimplement this handler, it is very important that you
<a href="qtabletevent.html">ignore()</a> the event if you do not handle
it, so that the widget's parent can interpret it.
<p> The default implementation ignores the event.
<p> <p>See also <a href="qtabletevent.html#ignore">QTabletEvent::ignore</a>(), <a href="qtabletevent.html#accept">QTabletEvent::accept</a>(), <a href="#event">event</a>(), and <a href="qtabletevent.html">QTabletEvent</a>.

<h3 class=fn>WFlags <a name="testWFlags"></a>QWidget::testWFlags ( WFlags&nbsp;f ) const
</h3>

<p> Returns the bitwise AND of the widget flags and <em>f</em>.
<p> Widget flags are a combination of <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.
<p> If you want to test for the presence of multiple flags (or
composite flags such as <a href="qt.html#WidgetFlags-enum">WStyle_Splash</a>), test the
return value for equality against the argument. For example:
<p> <pre>
    int flags = WStyle_Tool | WStyle_NoBorder;
    if ( <a href="#testWFlags">testWFlags</a>(flags) )
        ... // WStyle_Tool or WStyle_NoBorder or both are set
    if ( <a href="#testWFlags">testWFlags</a>(flags) == flags )
        ... // both WStyle_Tool and WStyle_NoBorder are set
    </pre>
 
<p> <p>See also <a href="#getWFlags">getWFlags</a>(), <a href="#setWFlags">setWFlags</a>(), and <a href="#clearWFlags">clearWFlags</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="topLevelWidget"></a>QWidget::topLevelWidget () const
</h3>
Returns the top-level widget for this widget, i.e. the next
ancestor widget that has (or could have) a window-system frame.
<p> If the widget is a top-level, the widget itself is returned.
<p> Typical usage is changing the window caption:
<p> <pre>
        aWidget-&gt;topLevelWidget()-&gt;setCaption( "New Caption" );
    </pre>
 
<p> <p>See also <a href="#isTopLevel-prop">isTopLevel</a>.

<h3 class=fn>void <a name="unsetCursor"></a>QWidget::unsetCursor ()<tt> [virtual]</tt>
</h3><p>Resets the cursor shape for this widget.
See the <a href="qwidget.html#cursor-prop">"cursor"</a> property for details.
<h3 class=fn>void <a name="unsetFont"></a>QWidget::unsetFont ()
</h3><p>Resets the font currently set for the widget.
See the <a href="qwidget.html#font-prop">"font"</a> property for details.
<h3 class=fn>void <a name="unsetPalette"></a>QWidget::unsetPalette ()
</h3><p>Resets the widget's palette.
See the <a href="qwidget.html#palette-prop">"palette"</a> property for details.
<h3 class=fn>void <a name="update"></a>QWidget::update ()<tt> [slot]</tt>
</h3>
Updates the widget unless updates are disabled or the widget is
hidden.
<p> This function does not cause an immediate repaint; instead it
schedules a paint event for processing when Qt returns to the main
event loop. This permits Qt to optimize for more speed and less
flicker than a call to <a href="#repaint">repaint</a>() does.
<p> Calling <a href="#update">update</a>() several times normally results in just one
<a href="#paintEvent">paintEvent</a>() call.
<p> Qt normally erases the widget's area before the paintEvent() call.
If the <a href="qt.html#WidgetFlags-enum">WRepaintNoErase</a> widget flag is set, the widget is
responsible for painting all its pixels itself.
<p> <p>See also <a href="#repaint">repaint</a>(), <a href="#paintEvent">paintEvent</a>(), <a href="#updatesEnabled-prop">updatesEnabled</a>, <a href="#erase">erase</a>(), and <a href="#setWFlags">setWFlags</a>().

<p>Examples: <a href="desktop-example.html#x1763">desktop/desktop.cpp</a> and <a href="scrollview-example.html#x662">scrollview/scrollview.cpp</a>.
<h3 class=fn>void <a name="update-2"></a>QWidget::update ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Updates a rectangle (<em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>) inside the widget
unless updates are disabled or the widget is hidden.
<p> This function does not cause an immediate repaint; instead it
schedules a paint event for processing when Qt returns to the main
event loop. This permits Qt to optimize for more speed and less
flicker and a call to <a href="#repaint">repaint</a>() does.
<p> Calling <a href="#update">update</a>() several times normally results in just one
<a href="#paintEvent">paintEvent</a>() call.
<p> If <em>w</em> is negative, it is replaced with <tt>width() - x</tt>. If <em>h</em>
is negative, it is replaced width <tt>height() - y</tt>.
<p> Qt normally erases the specified area before the paintEvent()
call. If the <a href="qt.html#WidgetFlags-enum">WRepaintNoErase</a> widget flag is set, the widget is
responsible for painting all its pixels itself.
<p> <p>See also <a href="#repaint">repaint</a>(), <a href="#paintEvent">paintEvent</a>(), <a href="#updatesEnabled-prop">updatesEnabled</a>, and <a href="#erase">erase</a>().

<h3 class=fn>void <a name="update-3"></a>QWidget::update ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Updates a rectangle <em>r</em> inside the widget unless updates are
disabled or the widget is hidden.
<p> This function does not cause an immediate repaint; instead it
schedules a paint event for processing when Qt returns to the main
event loop. This permits Qt to optimize for more speed and less
flicker and a call to <a href="#repaint">repaint</a>() does.
<p> Calling <a href="#update">update</a>() several times normally results in just one
<a href="#paintEvent">paintEvent</a>() call.

<h3 class=fn>void <a name="updateGeometry"></a>QWidget::updateGeometry ()
</h3>
Notifies the layout system that this widget has changed and may
need to change geometry.
<p> Call this function if the <a href="#sizeHint">sizeHint</a>() or <a href="#sizePolicy">sizePolicy</a>() have changed.
<p> For explicitly hidden widgets, <a href="#updateGeometry">updateGeometry</a>() is a no-op. The
layout system will be notified as soon as the widget is shown.

<h3 class=fn>void <a name="updateMask"></a>QWidget::updateMask ()<tt> [virtual protected]</tt>
</h3>
This function can be reimplemented in a subclass to support
transparent widgets. It should be called whenever a widget changes
state in a way that means that the shape mask must be recalculated.
<p> <p>See also <a href="#autoMask-prop">autoMask</a>, <a href="#setMask">setMask</a>(), and <a href="#clearMask">clearMask</a>().

<h3 class=fn><a href="qrect.html">QRect</a> <a name="visibleRect"></a>QWidget::visibleRect () const
</h3><p>Returns the visible rectangle.
See the <a href="qwidget.html#visibleRect-prop">"visibleRect"</a> property for details.
<h3 class=fn>void <a name="wheelEvent"></a>QWidget::wheelEvent ( <a href="qwheelevent.html">QWheelEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler, for event <em>e</em>, can be reimplemented in a
subclass to receive wheel events for the widget.
<p> If you reimplement this handler, it is very important that you
<a href="qwheelevent.html">ignore()</a> the event if you do not handle
it, so that the widget's parent can interpret it.
<p> The default implementation ignores the event.
<p> <p>See also <a href="qwheelevent.html#ignore">QWheelEvent::ignore</a>(), <a href="qwheelevent.html#accept">QWheelEvent::accept</a>(), <a href="#event">event</a>(), and <a href="qwheelevent.html">QWheelEvent</a>.

<h3 class=fn>int <a name="width"></a>QWidget::width () const
</h3><p>Returns the width of the widget excluding any window frame.
See the <a href="qwidget.html#width-prop">"width"</a> property for details.
<h3 class=fn>bool <a name="winEvent"></a>QWidget::winEvent ( MSG * )<tt> [virtual protected]</tt>
</h3>
This special event handler can be reimplemented in a subclass to
receive native Windows events.
<p> In your reimplementation of this function, if you want to stop the
event being handled by Qt, return TRUE. If you return FALSE, this
native event is passed back to Qt, which translates the event into
a Qt event and sends it to the widget.
<p> <b>Warning:</b> This function is not portable.
<p> <p>See also <a href="qapplication.html#winEventFilter">QApplication::winEventFilter</a>().

<h3 class=fn>WId <a name="winId"></a>QWidget::winId () const
</h3>

<p> Returns the window system identifier of the widget.
<p> Portable in principle, but if you use it you are probably about to
do something non-portable. Be careful.
<p> <p>See also <a href="#find">find</a>().

<h3 class=fn>void <a name="windowActivationChange"></a>QWidget::windowActivationChange ( bool&nbsp;oldActive )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called for a widget when its window is
activated or deactivated by the window system. <em>oldActive</em> is the
previous state; you can get the new setting from <a href="#isActiveWindow">isActiveWindow</a>().
<p> Reimplement this function if your widget needs to know when its
window becomes activated or deactivated.
<p> The default implementation updates the visible part of the widget
if the inactive and the active colorgroup are different for colors
other than the highlight and link colors.
<p> <p>See also <a href="#setActiveWindow">setActiveWindow</a>(), <a href="#isActiveWindow-prop">isActiveWindow</a>, <a href="#update">update</a>(), and <a href="#palette-prop">palette</a>.

<h3 class=fn>double <a name="windowOpacity"></a>QWidget::windowOpacity () const
</h3><p>Returns the level of opacity for the window.
See the <a href="qwidget.html#windowOpacity-prop">"windowOpacity"</a> property for details.
<h3 class=fn>uint <a name="windowState"></a>QWidget::windowState () const
</h3>  Returns the current <a href="qt.html#WindowState">window state</a>. The window state is a OR'ed
combination of Qt::WindowState: <a href="qt.html#WindowState-enum">WindowMinimized</a>, <a href="qt.html#WindowState-enum">WindowMaximized</a>, <a href="qt.html#WindowState-enum">WindowFullScreen</a> and <a href="qt.html#WindowState-enum">WindowActive</a>.
<p> <p>See also <a href="qt.html#WindowState-enum">Qt::WindowState</a> and <a href="#setWindowState">setWindowState</a>().

<h3 class=fn>int <a name="x"></a>QWidget::x () const
</h3><p>Returns the x coordinate of the widget relative to its parent including any window frame.
See the <a href="qwidget.html#x-prop">"x"</a> property for details.
<h3 class=fn>bool <a name="x11Event"></a>QWidget::x11Event ( XEvent * )<tt> [virtual protected]</tt>
</h3>
This special event handler can be reimplemented in a subclass to
receive native X11 events.
<p> In your reimplementation of this function, if you want to stop the
event being handled by Qt, return TRUE. If you return FALSE, this
native event is passed back to Qt, which translates the event into
a Qt event and sends it to the widget.
<p> <b>Warning:</b> This function is not portable.
<p> <p>See also <a href="qapplication.html#x11EventFilter">QApplication::x11EventFilter</a>().

<p>Reimplemented in <a href="qxtwidget.html#x11Event">QXtWidget</a>.
<h3 class=fn>int <a name="y"></a>QWidget::y () const
</h3><p>Returns the y coordinate of the widget relative to its parent and including any window frame.
See the <a href="qwidget.html#y-prop">"y"</a> property for details.
<hr><h2>Property Documentation</h2>
<h3 class=fn>bool <a name="acceptDrops-prop"></a>acceptDrops</h3>
<p>This property holds whether drop events are enabled for this widget.
<p>Setting this property to TRUE announces to the system that this
widget <em>may</em> be able to accept drop events.
<p> If the widget is the desktop (<a href="#isDesktop">QWidget::isDesktop</a>()), this may
fail if another application is using the desktop; you can call
<a href="#acceptDrops">acceptDrops</a>() to test if this occurs.
<p> <b>Warning:</b>
Do not modify this property in a Drag&Drop event handler.

<p>Set this property's value with <a href="#setAcceptDrops">setAcceptDrops</a>() and get this property's value with <a href="#acceptDrops">acceptDrops</a>().
<h3 class=fn>bool <a name="autoMask-prop"></a>autoMask</h3>
<p>This property holds whether the auto mask feature is enabled for the widget.
<p>Transparent widgets use a mask to define their visible region.
QWidget has some built-in support to make the task of
recalculating the mask easier. When setting auto mask to TRUE,
<a href="#updateMask">updateMask</a>() will be called whenever the widget is resized or
changes its focus state. Note that you must reimplement
updateMask() (which should include a call to <a href="#setMask">setMask</a>()) or nothing
will happen.
<p> Note: when you re-implement <a href="#resizeEvent">resizeEvent</a>(), <a href="#focusInEvent">focusInEvent</a>() or
<a href="#focusOutEvent">focusOutEvent</a>() in your custom widgets and still want to ensure
that the auto mask calculation works, you should add:
<p> <pre>
        if ( <a href="#autoMask">autoMask</a>() )
            <a href="#updateMask">updateMask</a>();
    </pre>
 
<p> at the end of your event handlers. This is true for all member
functions that change the appearance of the widget in a way that
requires a recalculation of the mask.
<p> While being a technically appealing concept, masks have a big
drawback: when using complex masks that cannot be expressed easily
with relatively simple regions, they can be very slow on some
window systems. The classic example is a transparent label. The
complex shape of its contents makes it necessary to represent its
mask by a bitmap, which consumes both memory and time. If all you
want is to blend the background of several neighboring widgets
together seamlessly, you will probably want to use
<a href="#setBackgroundOrigin">setBackgroundOrigin</a>() rather than a mask.
<p> <p>See also <a href="#updateMask">updateMask</a>(), <a href="#setMask">setMask</a>(), <a href="#clearMask">clearMask</a>(), and <a href="#backgroundOrigin-prop">backgroundOrigin</a>.

<p>Set this property's value with <a href="#setAutoMask">setAutoMask</a>() and get this property's value with <a href="#autoMask">autoMask</a>().
<h3 class=fn><a href="qbrush.html">QBrush</a> <a name="backgroundBrush-prop"></a>backgroundBrush</h3>
<p>This property holds the widget's background brush.
<p>The background brush depends on a widget's palette and its
background mode.
<p> <p>See also <a href="#backgroundColor">backgroundColor</a>(), <a href="#backgroundPixmap">backgroundPixmap</a>(), <a href="#eraseColor">eraseColor</a>(), <a href="#palette-prop">palette</a>, and <a href="qapplication.html#setPalette">QApplication::setPalette</a>().

<p>Get this property's value with <a href="#backgroundBrush">backgroundBrush</a>().
<h3 class=fn><a href="qt.html#BackgroundMode-enum">BackgroundMode</a> <a name="backgroundMode-prop"></a>backgroundMode</h3>
<p>This property holds the color role used for painting the background of the widget.
<p>setPaletteBackgroundColor() reads this property to determine which
entry of the <a href="#palette-prop">palette</a> to set.
<p> For most widgets the default suffices (<a href="qt.html#BackgroundMode-enum">PaletteBackground</a>,
typically gray), but some need to use <a href="qt.html#BackgroundMode-enum">PaletteBase</a> (the
background color for text output, typically white) or another
role.
<p> <a href="qlistbox.html">QListBox</a>, which is "sunken" and uses the base color to contrast
with its environment, does this in its constructor:
<p> <pre>
    <a href="#setBackgroundMode">setBackgroundMode</a>( <a href="qt.html#BackgroundMode-enum">PaletteBase</a> );
    </pre>
 
<p> You will never need to set the background mode of a built-in
widget in Qt, but you might consider setting it in your custom
widgets, so that <a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>() works as expected.
<p> Note that two of the BackgroundMode values make no sense for
<a href="#setBackgroundMode">setBackgroundMode</a>(), namely <a href="qt.html#BackgroundMode-enum">FixedPixmap</a> and <a href="qt.html#BackgroundMode-enum">FixedColor</a>. You
must call <a href="#setBackgroundPixmap">setBackgroundPixmap</a>() and setPaletteBackgroundColor()
instead.

<p>Set this property's value with <a href="#setBackgroundMode">setBackgroundMode</a>() and get this property's value with <a href="#backgroundMode">backgroundMode</a>().
<h3 class=fn><a href="qwidget.html#BackgroundOrigin-enum">BackgroundOrigin</a> <a name="backgroundOrigin-prop"></a>backgroundOrigin</h3>
<p>This property holds the origin of the widget's background.
<p>The origin is either WidgetOrigin (the default), ParentOrigin,
WindowOrigin or AncestorOrigin.
<p> This only makes a difference if the widget has a background
pixmap, in which case positioning matters. Using <a href="#BackgroundOrigin-enum">WindowOrigin</a>
for several neighboring widgets makes the background blend
together seamlessly. <a href="#BackgroundOrigin-enum">AncestorOrigin</a> allows blending backgrounds
seamlessly when an ancestor of the widget has an origin other than
<a href="#BackgroundOrigin-enum">WindowOrigin</a>.
<p> <p>See also <a href="#backgroundPixmap">backgroundPixmap</a>() and <a href="#backgroundMode-prop">backgroundMode</a>.

<p>Set this property's value with <a href="#setBackgroundOrigin">setBackgroundOrigin</a>() and get this property's value with <a href="#backgroundOrigin">backgroundOrigin</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="baseSize-prop"></a>baseSize</h3>
<p>This property holds the base size of the widget.
<p>The base size is used to calculate a proper widget size if the
widget defines <a href="#sizeIncrement">sizeIncrement</a>().
<p> <p>See also <a href="#sizeIncrement-prop">sizeIncrement</a>.

<p>Set this property's value with <a href="#setBaseSize">setBaseSize</a>() and get this property's value with <a href="#baseSize">baseSize</a>().
<h3 class=fn><a href="qstring.html">QString</a> <a name="caption-prop"></a>caption</h3>
<p>This property holds the window caption (title).
<p>This property only makes sense for top-level widgets. If no
caption has been set, the caption is <a href="qstring.html#QString-null">QString::null</a>.
<p> <p>See also <a href="#icon-prop">icon</a> and <a href="#iconText-prop">iconText</a>.

<p>Set this property's value with <a href="#setCaption">setCaption</a>() and get this property's value with <a href="#caption">caption</a>().
<h3 class=fn><a href="qrect.html">QRect</a> <a name="childrenRect-prop"></a>childrenRect</h3>
<p>This property holds the bounding rectangle of the widget's children.
<p>Hidden children are excluded.
<p> <p>See also <a href="#childrenRegion-prop">childrenRegion</a> and <a href="#geometry-prop">geometry</a>.

<p>Get this property's value with <a href="#childrenRect">childrenRect</a>().
<h3 class=fn><a href="qregion.html">QRegion</a> <a name="childrenRegion-prop"></a>childrenRegion</h3>
<p>This property holds the combined region occupied by the widget's children.
<p>Hidden children are excluded.
<p> <p>See also <a href="#childrenRect-prop">childrenRect</a> and <a href="#geometry-prop">geometry</a>.

<p>Get this property's value with <a href="#childrenRegion">childrenRegion</a>().
<h3 class=fn><a href="qcolorgroup.html">QColorGroup</a> <a name="colorGroup-prop"></a>colorGroup</h3>
<p>This property holds the current color group of the widget palette.
<p>The color group is determined by the state of the widget. A
disabled widget has the <a href="qpalette.html#disabled">QPalette::disabled</a>() color group, a widget
with <a href="focus.html#keyboard-focus">keyboard focus</a> has the <a href="qpalette.html#active">QPalette::active</a>() color group, and an
inactive widget has the <a href="qpalette.html#inactive">QPalette::inactive</a>() color group.
<p> <p>See also <a href="#palette-prop">palette</a>.

<p>Get this property's value with <a href="#colorGroup">colorGroup</a>().
<h3 class=fn><a href="qcursor.html">QCursor</a> <a name="cursor-prop"></a>cursor</h3>
<p>This property holds the cursor shape for this widget.
<p>The mouse cursor will assume this shape when it's over this
widget. See the <a href="qt.html#CursorShape-enum">list of predefined cursor
    objects</a> for a range of useful shapes.
<p> An editor widget might use an I-beam cursor:
<pre>
        <a href="#setCursor">setCursor</a>( <a href="qt.html#CursorShape-enum">IbeamCursor</a> );
    </pre>
 
<p> If no cursor has been set, or after a call to <a href="#unsetCursor">unsetCursor</a>(), the
parent's cursor is used. The function unsetCursor() has no effect
on top-level widgets.
<p> <p>See also <a href="qapplication.html#setOverrideCursor">QApplication::setOverrideCursor</a>().

<p>Set this property's value with <a href="#setCursor">setCursor</a>(), get this property's value with <a href="#cursor">cursor</a>(), and reset this property's value with <a href="#unsetCursor">unsetCursor</a>().
<h3 class=fn>bool <a name="customWhatsThis-prop"></a>customWhatsThis</h3>
<p>This property holds whether the widget wants to handle What's This help manually.
<p>The default implementation of <a href="#customWhatsThis">customWhatsThis</a>() returns FALSE,
which means the widget will not receive any events in Whats This
mode.
<p> The widget may leave What's This mode by calling
<a href="qwhatsthis.html#leaveWhatsThisMode">QWhatsThis::leaveWhatsThisMode</a>(), with or without actually
displaying any help text.
<p> You can also reimplement customWhatsThis() if your widget is a
"passive interactor" supposed to work under all circumstances.
Simply don't call QWhatsThis::leaveWhatsThisMode() in that case.
<p> <p>See also <a href="qwhatsthis.html#inWhatsThisMode">QWhatsThis::inWhatsThisMode</a>() and <a href="qwhatsthis.html#leaveWhatsThisMode">QWhatsThis::leaveWhatsThisMode</a>().

<p>Get this property's value with <a href="#customWhatsThis">customWhatsThis</a>().
<h3 class=fn>bool <a name="enabled-prop"></a>enabled</h3>
<p>This property holds whether the widget is enabled.
<p>An enabled widget receives keyboard and mouse events; a disabled
widget does not. In fact, an enabled widget only receives keyboard
events when it is in focus.
<p> Some widgets display themselves differently when they are
disabled. For example a button might draw its label grayed out. If
your widget needs to know when it becomes enabled or disabled, you
can reimplement the <a href="#enabledChange">enabledChange</a>() function.
<p> Disabling a widget implicitly disables all its children. Enabling
respectively enables all child widgets unless they have been
explicitly disabled.
<p> <p>See also <a href="#enabled-prop">enabled</a>, <a href="#isEnabledTo">isEnabledTo</a>(), <a href="qkeyevent.html">QKeyEvent</a>, <a href="qmouseevent.html">QMouseEvent</a>, and <a href="#enabledChange">enabledChange</a>().

<p>Set this property's value with <a href="#setEnabled">setEnabled</a>() and get this property's value with <a href="#isEnabled">isEnabled</a>().
<h3 class=fn>bool <a name="focus-prop"></a>focus</h3>
<p>This property holds whether this widget (or its focus proxy) has the keyboard input focus.
<p>Effectively equivalent to <tt>qApp-&gt;focusWidget() == this</tt>.
<p> <p>See also <a href="#setFocus">setFocus</a>(), <a href="#clearFocus">clearFocus</a>(), <a href="#focusPolicy-prop">focusPolicy</a>, and <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>().

<p>Get this property's value with <a href="#hasFocus">hasFocus</a>().
<h3 class=fn>bool <a name="focusEnabled-prop"></a>focusEnabled</h3>
<p>This property holds whether the widget accepts <a href="focus.html#keyboard-focus">keyboard focus</a>.
<p>Keyboard focus is initially disabled (i.e. <a href="#focusPolicy">focusPolicy</a>() ==
<a href="#FocusPolicy-enum">QWidget::NoFocus</a>).
<p> You must enable keyboard focus for a widget if it processes
keyboard events. This is normally done from the widget's
constructor. For instance, the <a href="qlineedit.html">QLineEdit</a> constructor calls
<a href="#setFocusPolicy">setFocusPolicy</a>(QWidget::StrongFocus).
<p> <p>See also <a href="#focusPolicy-prop">focusPolicy</a>, <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#keyPressEvent">keyPressEvent</a>(), <a href="#keyReleaseEvent">keyReleaseEvent</a>(), and <a href="#enabled-prop">enabled</a>.

<p>Get this property's value with <a href="#isFocusEnabled">isFocusEnabled</a>().
<h3 class=fn><a href="qwidget.html#FocusPolicy-enum">FocusPolicy</a> <a name="focusPolicy-prop"></a>focusPolicy</h3>
<p>This property holds the way the widget accepts <a href="focus.html#keyboard-focus">keyboard focus</a>.
<p>The policy is <a href="#FocusPolicy-enum">QWidget::TabFocus</a> if the widget accepts keyboard
focus by tabbing, <a href="#FocusPolicy-enum">QWidget::ClickFocus</a> if the widget accepts
focus by clicking, <a href="#FocusPolicy-enum">QWidget::StrongFocus</a> if it accepts both, and
<a href="#FocusPolicy-enum">QWidget::NoFocus</a> (the default) if it does not accept focus at
all.
<p> You must enable keyboard focus for a widget if it processes
keyboard events. This is normally done from the widget's
constructor. For instance, the <a href="qlineedit.html">QLineEdit</a> constructor calls
<a href="#setFocusPolicy">setFocusPolicy</a>(QWidget::StrongFocus).
<p> <p>See also <a href="#focusEnabled-prop">focusEnabled</a>, <a href="#focusInEvent">focusInEvent</a>(), <a href="#focusOutEvent">focusOutEvent</a>(), <a href="#keyPressEvent">keyPressEvent</a>(), <a href="#keyReleaseEvent">keyReleaseEvent</a>(), and <a href="#enabled-prop">enabled</a>.

<p>Set this property's value with <a href="#setFocusPolicy">setFocusPolicy</a>() and get this property's value with <a href="#focusPolicy">focusPolicy</a>().
<h3 class=fn><a href="qfont.html">QFont</a> <a name="font-prop"></a>font</h3>
<p>This property holds the font currently set for the widget.
<p>The <a href="#fontInfo">fontInfo</a>() function reports the actual font that is being used
by the widget.
<p> As long as no special font has been set, or after <a href="#unsetFont">unsetFont</a>() is
called, this is either a special font for the widget class, the
parent's font or (if this widget is a top level widget), the
default application font.
<p> This code fragment sets a 12 point helvetica bold font:
<pre>
    <a href="qfont.html">QFont</a> f( "Helvetica", 12, QFont::Bold );
    <a href="#setFont">setFont</a>( f );
    </pre>
 
<p> In addition to setting the font, <a href="#setFont">setFont</a>() informs all children
about the change.
<p> <p>See also <a href="#fontChange">fontChange</a>(), <a href="#fontInfo">fontInfo</a>(), <a href="#fontMetrics">fontMetrics</a>(), and <a href="#ownFont-prop">ownFont</a>.

<p>Set this property's value with <a href="#setFont">setFont</a>(), get this property's value with <a href="#font">font</a>(), and reset this property's value with <a href="#unsetFont">unsetFont</a>().
<h3 class=fn><a href="qrect.html">QRect</a> <a name="frameGeometry-prop"></a>frameGeometry</h3>
<p>This property holds geometry of the widget relative to its parent including any window frame.
<p>See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of geometry issues with top-level widgets.
<p> <p>See also <a href="#geometry-prop">geometry</a>, <a href="#x-prop">x</a>, <a href="#y-prop">y</a>, and <a href="#pos-prop">pos</a>.

<p>Get this property's value with <a href="#frameGeometry">frameGeometry</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="frameSize-prop"></a>frameSize</h3>
<p>This property holds the size of the widget including any window frame.
<p>
<p>Get this property's value with <a href="#frameSize">frameSize</a>().
<h3 class=fn>bool <a name="fullScreen-prop"></a>fullScreen</h3>
<p>This property holds whether the widget is full screen.
<p>Get this property's value with <a href="#isFullScreen">isFullScreen</a>().
<p><p>See also <a href="#windowState">windowState</a>(), <a href="#minimized-prop">minimized</a>, and <a href="#maximized-prop">maximized</a>.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="geometry-prop"></a>geometry</h3>
<p>This property holds the geometry of the widget relative to its parent and excluding the window frame.
<p>When changing the geometry, the widget, if visible, receives a
move event (<a href="#moveEvent">moveEvent</a>()) and/or a resize event (<a href="#resizeEvent">resizeEvent</a>())
immediately. If the widget is not currently visible, it is
guaranteed to receive appropriate events before it is shown.
<p> The size component is adjusted if it lies outside the range
defined by <a href="#minimumSize">minimumSize</a>() and <a href="#maximumSize">maximumSize</a>().
<p> <a href="#setGeometry">setGeometry</a>() is virtual, and all other overloaded setGeometry()
implementations in Qt call it.
<p> <b>Warning:</b> Calling setGeometry() inside resizeEvent() or moveEvent()
can lead to infinite recursion.
<p> See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#frameGeometry-prop">frameGeometry</a>, <a href="#rect-prop">rect</a>, <a href="#pos-prop">pos</a>, <a href="#size-prop">size</a>, <a href="#moveEvent">moveEvent</a>(), <a href="#resizeEvent">resizeEvent</a>(), <a href="#minimumSize-prop">minimumSize</a>, and <a href="#maximumSize-prop">maximumSize</a>.

<p>Set this property's value with <a href="#setGeometry">setGeometry</a>() and get this property's value with <a href="#geometry">geometry</a>().
<h3 class=fn>int <a name="height-prop"></a>height</h3>
<p>This property holds the height of the widget excluding any window frame.
<p>See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#geometry-prop">geometry</a>, <a href="#width-prop">width</a>, and <a href="#size-prop">size</a>.

<p>Get this property's value with <a href="#height">height</a>().
<h3 class=fn>bool <a name="hidden-prop"></a>hidden</h3>
<p>This property holds whether the widget is explicitly hidden.
<p>If FALSE, the widget is visible or would become visible if all its
ancestors became visible.
<p> <p>See also <a href="#hide">hide</a>(), <a href="#show">show</a>(), <a href="#visible-prop">visible</a>, <a href="#isVisibleTo">isVisibleTo</a>(), and <a href="#shown-prop">shown</a>.

<p>Set this property's value with <a href="#setHidden">setHidden</a>() and get this property's value with <a href="#isHidden">isHidden</a>().
<h3 class=fn><a href="qpixmap.html">QPixmap</a> <a name="icon-prop"></a>icon</h3>
<p>This property holds the widget's icon.
<p>This property only makes sense for top-level widgets. If no icon
has been set, <a href="#icon">icon</a>() returns 0.
<p> <p>See also <a href="#iconText-prop">iconText</a>, <a href="#caption-prop">caption</a>, and <a href="appicon.html">Setting the Application Icon</a>.

<p>Set this property's value with <a href="#setIcon">setIcon</a>() and get this property's value with <a href="#icon">icon</a>().
<h3 class=fn><a href="qstring.html">QString</a> <a name="iconText-prop"></a>iconText</h3>
<p>This property holds the widget's icon text.
<p>This property only makes sense for top-level widgets. If no icon
text has been set, this functions returns <a href="qstring.html#QString-null">QString::null</a>.
<p> <p>See also <a href="#icon-prop">icon</a> and <a href="#caption-prop">caption</a>.

<p>Set this property's value with <a href="#setIconText">setIconText</a>() and get this property's value with <a href="#iconText">iconText</a>().
<h3 class=fn>bool <a name="inputMethodEnabled-prop"></a>inputMethodEnabled</h3>
<p>This property holds enables or disables the use of input methods for this widget.
<p>Most Widgets (as eg. buttons) that do not handle text input should have
the input method disabled if they have focus. This is the default.
<p> If a widget handles text input it should set this property to TRUE.

<p>Set this property's value with <a href="#setInputMethodEnabled">setInputMethodEnabled</a>() and get this property's value with <a href="#isInputMethodEnabled">isInputMethodEnabled</a>().
<h3 class=fn>bool <a name="isActiveWindow-prop"></a>isActiveWindow</h3>
<p>This property holds whether this widget is the active window.
<p>The active window is the window that contains the widget
that has <a href="focus.html#keyboard-focus">keyboard focus</a>.
<p> When popup windows are visible, this property is TRUE for both the
active window <em>and</em> for the popup.
<p> <p>See also <a href="#setActiveWindow">setActiveWindow</a>() and <a href="qapplication.html#activeWindow">QApplication::activeWindow</a>().

<p>Get this property's value with <a href="#isActiveWindow">isActiveWindow</a>().
<h3 class=fn>bool <a name="isDesktop-prop"></a>isDesktop</h3>
<p>This property holds whether the widget is a desktop widget, i.e. represents the desktop.
<p>A desktop widget is also a top-level widget.
<p> <p>See also <a href="#isTopLevel-prop">isTopLevel</a> and <a href="qapplication.html#desktop">QApplication::desktop</a>().

<p>Get this property's value with <a href="#isDesktop">isDesktop</a>().
<h3 class=fn>bool <a name="isDialog-prop"></a>isDialog</h3>
<p>This property holds whether the widget is a dialog widget.
<p>A dialog widget is a secondary top-level widget, i.e. a top-level
widget with a parent.
<p> <p>See also <a href="#isTopLevel-prop">isTopLevel</a> and <a href="qdialog.html">QDialog</a>.

<p>Get this property's value with <a href="#isDialog">isDialog</a>().
<h3 class=fn>bool <a name="isModal-prop"></a>isModal</h3>
<p>This property holds whether the widget is a modal widget.
<p>This property only makes sense for top-level widgets. A modal
widget prevents widgets in all other top-level widgets from
getting any input.
<p> <p>See also <a href="#isTopLevel-prop">isTopLevel</a>, <a href="#isDialog-prop">isDialog</a>, and <a href="qdialog.html">QDialog</a>.

<p>Get this property's value with <a href="#isModal">isModal</a>().
<h3 class=fn>bool <a name="isPopup-prop"></a>isPopup</h3>
<p>This property holds whether the widget is a popup widget.
<p>A popup widget is created by specifying the <a href="qt.html#WidgetFlags">widget flag</a> <a href="qt.html#WidgetFlags-enum">WType_Popup</a> to the widget constructor. A popup widget is also a
top-level widget.
<p> <p>See also <a href="#isTopLevel-prop">isTopLevel</a>.

<p>Get this property's value with <a href="#isPopup">isPopup</a>().
<h3 class=fn>bool <a name="isTopLevel-prop"></a>isTopLevel</h3>
<p>This property holds whether the widget is a top-level widget.
<p>A top-level widget is a widget which usually has a frame and a
<a href="#caption-prop">caption (title)</a>. <a href="#isPopup">Popup</a> and <a href="#isDesktop">desktop</a> widgets are also top-level widgets.
<p> A top-level widget can have a <a href="#parentWidget">parent
    widget</a>. It will then be grouped with its parent and deleted
when the parent is deleted, minimized when the parent is minimized
etc. If supported by the window manager, it will also have a
common taskbar entry with its parent.
<p> <a href="qdialog.html">QDialog</a> and <a href="qmainwindow.html">QMainWindow</a> widgets are by default top-level, even if
a parent widget is specified in the constructor. This behavior is
specified by the <a href="qt.html#WidgetFlags-enum">WType_TopLevel</a> widget flag.
<p> <p>See also <a href="#topLevelWidget">topLevelWidget</a>(), <a href="#isDialog-prop">isDialog</a>, <a href="#isModal-prop">isModal</a>, <a href="#isPopup-prop">isPopup</a>, <a href="#isDesktop-prop">isDesktop</a>, and <a href="#parentWidget">parentWidget</a>().

<p>Get this property's value with <a href="#isTopLevel">isTopLevel</a>().
<h3 class=fn>bool <a name="maximized-prop"></a>maximized</h3>
<p>This property holds whether this widget is maximized.
<p>This property is only relevant for top-level widgets.
<p> Note that due to limitations in some window-systems, this does not
always report the expected results (e.g. if the user on X11
maximizes the window via the window manager, Qt has no way of
distinguishing this from any other resize). This is expected to
improve as window manager protocols evolve.
<p> <p>See also <a href="#windowState">windowState</a>(), <a href="#showMaximized">showMaximized</a>(), <a href="#visible-prop">visible</a>, <a href="#show">show</a>(), <a href="#hide">hide</a>(), <a href="#showNormal">showNormal</a>(), and <a href="#minimized-prop">minimized</a>.

<p>Get this property's value with <a href="#isMaximized">isMaximized</a>().
<h3 class=fn>int <a name="maximumHeight-prop"></a>maximumHeight</h3>
<p>This property holds the widget's maximum height.
<p>This property corresponds to <a href="#maximumSize">maximumSize</a>().<a href="#height">height</a>().
<p> <p>See also <a href="#maximumSize-prop">maximumSize</a> and <a href="#maximumWidth-prop">maximumWidth</a>.

<p>Set this property's value with <a href="#setMaximumHeight">setMaximumHeight</a>() and get this property's value with <a href="#maximumHeight">maximumHeight</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="maximumSize-prop"></a>maximumSize</h3>
<p>This property holds the widget's maximum size.
<p>The widget cannot be resized to a larger size than the maximum
widget size.
<p> <p>See also <a href="#maximumWidth-prop">maximumWidth</a>, <a href="#maximumHeight-prop">maximumHeight</a>, <a href="#maximumSize-prop">maximumSize</a>, <a href="#minimumSize-prop">minimumSize</a>, and <a href="#sizeIncrement-prop">sizeIncrement</a>.

<p>Set this property's value with <a href="#setMaximumSize">setMaximumSize</a>() and get this property's value with <a href="#maximumSize">maximumSize</a>().
<h3 class=fn>int <a name="maximumWidth-prop"></a>maximumWidth</h3>
<p>This property holds the widget's maximum width.
<p>This property corresponds to <a href="#maximumSize">maximumSize</a>().<a href="#width">width</a>().
<p> <p>See also <a href="#maximumSize-prop">maximumSize</a> and <a href="#maximumHeight-prop">maximumHeight</a>.

<p>Set this property's value with <a href="#setMaximumWidth">setMaximumWidth</a>() and get this property's value with <a href="#maximumWidth">maximumWidth</a>().
<h3 class=fn><a href="qrect.html">QRect</a> <a name="microFocusHint-prop"></a>microFocusHint</h3>
<p>This property holds the currently set micro focus hint for this widget.
<p>See the documentation of <a href="#setMicroFocusHint">setMicroFocusHint</a>() for more information.

<p>Get this property's value with <a href="#microFocusHint">microFocusHint</a>().
<h3 class=fn>bool <a name="minimized-prop"></a>minimized</h3>
<p>This property holds whether this widget is minimized (iconified).
<p>This property is only relevant for top-level widgets.
<p> <p>See also <a href="#showMinimized">showMinimized</a>(), <a href="#visible-prop">visible</a>, <a href="#show">show</a>(), <a href="#hide">hide</a>(), <a href="#showNormal">showNormal</a>(), and <a href="#maximized-prop">maximized</a>.

<p>Get this property's value with <a href="#isMinimized">isMinimized</a>().
<h3 class=fn>int <a name="minimumHeight-prop"></a>minimumHeight</h3>
<p>This property holds the widget's minimum height.
<p>This property corresponds to <a href="#minimumSize">minimumSize</a>().<a href="#height">height</a>().
<p> <p>See also <a href="#minimumSize-prop">minimumSize</a> and <a href="#minimumWidth-prop">minimumWidth</a>.

<p>Set this property's value with <a href="#setMinimumHeight">setMinimumHeight</a>() and get this property's value with <a href="#minimumHeight">minimumHeight</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="minimumSize-prop"></a>minimumSize</h3>
<p>This property holds the widget's minimum size.
<p>The widget cannot be resized to a smaller size than the minimum
widget size. The widget's size is forced to the minimum size if
the current size is smaller.
<p> If you use a layout inside the widget, the minimum size will be
set by the layout and not by <a href="#setMinimumSize">setMinimumSize</a>(), unless you set the
layout's resize mode to QLayout::FreeResize.
<p> <p>See also <a href="#minimumWidth-prop">minimumWidth</a>, <a href="#minimumHeight-prop">minimumHeight</a>, <a href="#maximumSize-prop">maximumSize</a>, <a href="#sizeIncrement-prop">sizeIncrement</a>, and <a href="qlayout.html#resizeMode-prop">QLayout::resizeMode</a>.

<p>Set this property's value with <a href="#setMinimumSize">setMinimumSize</a>() and get this property's value with <a href="#minimumSize">minimumSize</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="minimumSizeHint-prop"></a>minimumSizeHint</h3>
<p>This property holds the recommended minimum size for the widget.
<p>If the value of this property is an invalid size, no minimum size
is recommended.
<p> The default implementation of <a href="#minimumSizeHint">minimumSizeHint</a>() returns an invalid
size if there is no layout for this widget, and returns the
layout's minimum size otherwise. Most built-in widgets reimplement
minimumSizeHint().
<p> <a href="qlayout.html">QLayout</a> will never resize a widget to a size smaller than
minimumSizeHint.
<p> <p>See also <a href="qsize.html#isValid">QSize::isValid</a>(), <a href="#size-prop">size</a>, <a href="#minimumSize-prop">minimumSize</a>, and <a href="#sizePolicy-prop">sizePolicy</a>.

<p>Get this property's value with <a href="#minimumSizeHint">minimumSizeHint</a>().
<h3 class=fn>int <a name="minimumWidth-prop"></a>minimumWidth</h3>
<p>This property holds the widget's minimum width.
<p>This property corresponds to <a href="#minimumSize">minimumSize</a>().<a href="#width">width</a>().
<p> <p>See also <a href="#minimumSize-prop">minimumSize</a> and <a href="#minimumHeight-prop">minimumHeight</a>.

<p>Set this property's value with <a href="#setMinimumWidth">setMinimumWidth</a>() and get this property's value with <a href="#minimumWidth">minimumWidth</a>().
<h3 class=fn>bool <a name="mouseTracking-prop"></a>mouseTracking</h3>
<p>This property holds whether mouse tracking is enabled for the widget.
<p>If mouse tracking is disabled (the default), the widget only
receives mouse move events when at least one mouse button is
pressed while the mouse is being moved.
<p> If mouse tracking is enabled, the widget receives mouse move
events even if no buttons are pressed.
<p> <p>See also <a href="#mouseMoveEvent">mouseMoveEvent</a>() and <a href="qapplication.html#setGlobalMouseTracking">QApplication::setGlobalMouseTracking</a>().

<p>Set this property's value with <a href="#setMouseTracking">setMouseTracking</a>() and get this property's value with <a href="#hasMouseTracking">hasMouseTracking</a>().
<h3 class=fn>bool <a name="ownCursor-prop"></a>ownCursor</h3>
<p>This property holds whether the widget uses its own cursor.
<p>If FALSE, the widget uses its parent widget's cursor.
<p> <p>See also <a href="#cursor-prop">cursor</a>.

<p>Get this property's value with <a href="#ownCursor">ownCursor</a>().
<h3 class=fn>bool <a name="ownFont-prop"></a>ownFont</h3>
<p>This property holds whether the widget uses its own font.
<p>If FALSE, the widget uses its parent widget's font.
<p> <p>See also <a href="#font-prop">font</a>.

<p>Get this property's value with <a href="#ownFont">ownFont</a>().
<h3 class=fn>bool <a name="ownPalette-prop"></a>ownPalette</h3>
<p>This property holds whether the widget uses its own palette.
<p>If FALSE, the widget uses its parent widget's palette.
<p> <p>See also <a href="#palette-prop">palette</a>.

<p>Get this property's value with <a href="#ownPalette">ownPalette</a>().
<h3 class=fn><a href="qpalette.html">QPalette</a> <a name="palette-prop"></a>palette</h3>
<p>This property holds the widget's palette.
<p>As long as no special palette has been set, or after <a href="#unsetPalette">unsetPalette</a>()
has been called, this is either a special palette for the widget
class, the parent's palette or (if this widget is a top level
widget), the default application palette.
<p> Instead of defining an entirely new palette, you can also use the
<a href="#paletteBackgroundColor-prop">paletteBackgroundColor</a>,
<a href="#paletteBackgroundPixmap-prop">paletteBackgroundPixmap</a> and
<a href="#paletteForegroundColor-prop">paletteForegroundColor</a>
convenience properties to change a widget's
background and foreground appearance only.
<p> <p>See also <a href="#ownPalette-prop">ownPalette</a>, <a href="#colorGroup-prop">colorGroup</a>, and <a href="qapplication.html#palette">QApplication::palette</a>().

<p>Set this property's value with <a href="#setPalette">setPalette</a>(), get this property's value with <a href="#palette">palette</a>(), and reset this property's value with <a href="#unsetPalette">unsetPalette</a>().
<h3 class=fn><a href="qcolor.html">QColor</a> <a name="paletteBackgroundColor-prop"></a>paletteBackgroundColor</h3>
<p>This property holds the background color of the widget.
<p>The palette background color is usually set implicitly by
<a href="#setBackgroundMode">setBackgroundMode</a>(), although it can also be set explicitly by
<a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>(). setPaletteBackgroundColor() is a
convenience function that creates and sets a modified <a href="qpalette.html">QPalette</a>
with <a href="#setPalette">setPalette</a>(). The palette is modified according to the
widget's background mode. For example, if the background mode is
<a href="qt.html#BackgroundMode-enum">PaletteButton</a> the color used for the palette's <a href="qcolorgroup.html#ColorRole-enum">QColorGroup::Button</a> color entry is set.
<p> If there is a background pixmap (set using
<a href="#setPaletteBackgroundPixmap">setPaletteBackgroundPixmap</a>()), then the return value of this
function is indeterminate.
<p> <p>See also <a href="#paletteBackgroundPixmap-prop">paletteBackgroundPixmap</a>, <a href="#paletteForegroundColor-prop">paletteForegroundColor</a>, <a href="#palette-prop">palette</a>, and <a href="#colorGroup-prop">colorGroup</a>.

<p>Set this property's value with <a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>(), get this property's value with <a href="#paletteBackgroundColor">paletteBackgroundColor</a>(), and reset this property's value with <a href="#unsetPalette">unsetPalette</a>().
<h3 class=fn><a href="qpixmap.html">QPixmap</a> <a name="paletteBackgroundPixmap-prop"></a>paletteBackgroundPixmap</h3>
<p>This property holds the background pixmap of the widget.
<p>The palette background pixmap is usually set implicitly by
<a href="#setBackgroundMode">setBackgroundMode</a>(), although it can also be set explicitly by
<a href="#setPaletteBackgroundPixmap">setPaletteBackgroundPixmap</a>(). setPaletteBackgroundPixmap() is a
convenience function that creates and sets a modified <a href="qpalette.html">QPalette</a>
with <a href="#setPalette">setPalette</a>(). The palette is modified according to the
widget's background mode. For example, if the background mode is
<a href="qt.html#BackgroundMode-enum">PaletteButton</a> the pixmap used for the palette's
<a href="qcolorgroup.html#ColorRole-enum">QColorGroup::Button</a> color entry is set.
<p> If there is a plain background color (set using
<a href="#setPaletteBackgroundColor">setPaletteBackgroundColor</a>()), then this function returns 0.
<p> <p>See also <a href="#paletteBackgroundColor-prop">paletteBackgroundColor</a>, <a href="#paletteForegroundColor-prop">paletteForegroundColor</a>, <a href="#palette-prop">palette</a>, and <a href="#colorGroup-prop">colorGroup</a>.

<p>Set this property's value with <a href="#setPaletteBackgroundPixmap">setPaletteBackgroundPixmap</a>(), get this property's value with <a href="#paletteBackgroundPixmap">paletteBackgroundPixmap</a>(), and reset this property's value with <a href="#unsetPalette">unsetPalette</a>().
<h3 class=fn><a href="qcolor.html">QColor</a> <a name="paletteForegroundColor-prop"></a>paletteForegroundColor</h3>
<p>This property holds the foreground color of the widget.
<p>setPaletteForegroundColor() is a convenience function that creates
and sets a modified <a href="qpalette.html">QPalette</a> with <a href="#setPalette">setPalette</a>(). The palette is
modified according to the widget's <em>background mode</em>. For
example, if the background mode is <a href="qt.html#BackgroundMode-enum">PaletteButton</a> the palette entry
<a href="qcolorgroup.html#ColorRole-enum">QColorGroup::ButtonText</a> is set to color.
<p> <p>See also <a href="#palette-prop">palette</a>, <a href="qapplication.html#setPalette">QApplication::setPalette</a>(), <a href="#backgroundMode-prop">backgroundMode</a>, <a href="#foregroundColor">foregroundColor</a>(), <a href="#backgroundMode-prop">backgroundMode</a>, and <a href="#setEraseColor">setEraseColor</a>().

<p>Set this property's value with <a href="#setPaletteForegroundColor">setPaletteForegroundColor</a>(), get this property's value with <a href="#paletteForegroundColor">paletteForegroundColor</a>(), and reset this property's value with <a href="#unsetPalette">unsetPalette</a>().
<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="pos-prop"></a>pos</h3>
<p>This property holds the position of the widget within its parent widget.
<p>If the widget is a top-level widget, the position is that of the
widget on the desktop, including its frame.
<p> When changing the position, the widget, if visible, receives a
move event (<a href="#moveEvent">moveEvent</a>()) immediately. If the widget is not
currently visible, it is guaranteed to receive an event before it
is shown.
<p> <a href="#move">move</a>() is virtual, and all other overloaded move() implementations
in Qt call it.
<p> <b>Warning:</b> Calling move() or <a href="#setGeometry">setGeometry</a>() inside moveEvent() can
lead to infinite recursion.
<p> See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#frameGeometry-prop">frameGeometry</a>, <a href="#size-prop">size</a>, <a href="#x-prop">x</a>, and <a href="#y-prop">y</a>.

<p>Set this property's value with <a href="#move">move</a>() and get this property's value with <a href="#pos">pos</a>().
<h3 class=fn><a href="qrect.html">QRect</a> <a name="rect-prop"></a>rect</h3>
<p>This property holds the internal geometry of the widget excluding any window frame.
<p>The rect property equals <a href="qrect.html">QRect</a>(0, 0, <a href="#width">width</a>(), <a href="#height">height</a>()).
<p> See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#size-prop">size</a>.

<p>Get this property's value with <a href="#rect">rect</a>().
<h3 class=fn>bool <a name="shown-prop"></a>shown</h3>
<p>This property holds whether the widget is shown.
<p>If TRUE, the widget is visible or would become visible if all its
ancestors became visible.
<p> <p>See also <a href="#hide">hide</a>(), <a href="#show">show</a>(), <a href="#visible-prop">visible</a>, <a href="#isVisibleTo">isVisibleTo</a>(), and <a href="#hidden-prop">hidden</a>.

<p>Set this property's value with <a href="#setShown">setShown</a>() and get this property's value with <a href="#isShown">isShown</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="size-prop"></a>size</h3>
<p>This property holds the size of the widget excluding any window frame.
<p>When resizing, the widget, if visible, receives a resize event
(<a href="#resizeEvent">resizeEvent</a>()) immediately. If the widget is not currently
visible, it is guaranteed to receive an event before it is shown.
<p> The size is adjusted if it lies outside the range defined by
<a href="#minimumSize">minimumSize</a>() and <a href="#maximumSize">maximumSize</a>(). Furthermore, the size is always
at least <a href="qsize.html">QSize</a>(1, 1). For toplevel widgets, the minimum size
might be larger, depending on the window manager.
<p> If you want a top-level window to have a fixed size, call
setResizeMode( QLayout::FreeResize ) on its layout.
<p> <a href="#resize">resize</a>() is virtual, and all other overloaded resize()
implementations in Qt call it.
<p> <b>Warning:</b> Calling resize() or <a href="#setGeometry">setGeometry</a>() inside resizeEvent() can
lead to infinite recursion.
<p> <p>See also <a href="#pos-prop">pos</a>, <a href="#geometry-prop">geometry</a>, <a href="#minimumSize-prop">minimumSize</a>, <a href="#maximumSize-prop">maximumSize</a>, and <a href="#resizeEvent">resizeEvent</a>().

<p>Set this property's value with <a href="#resize">resize</a>() and get this property's value with <a href="#size">size</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="sizeHint-prop"></a>sizeHint</h3>
<p>This property holds the recommended size for the widget.
<p>If the value of this property is an invalid size, no size is
recommended.
<p> The default implementation of <a href="#sizeHint">sizeHint</a>() returns an invalid size
if there is no layout for this widget, and returns the layout's
preferred size otherwise.
<p> <p>See also <a href="qsize.html#isValid">QSize::isValid</a>(), <a href="#minimumSizeHint-prop">minimumSizeHint</a>, <a href="#sizePolicy-prop">sizePolicy</a>, <a href="#minimumSize-prop">minimumSize</a>, and <a href="#updateGeometry">updateGeometry</a>().

<p>Get this property's value with <a href="#sizeHint">sizeHint</a>().
<h3 class=fn><a href="qsize.html">QSize</a> <a name="sizeIncrement-prop"></a>sizeIncrement</h3>
<p>This property holds the size increment of the widget.
<p>When the user resizes the window, the size will move in steps of
<a href="#sizeIncrement">sizeIncrement</a>().<a href="#width">width</a>() pixels horizontally and
sizeIncrement.<a href="#height">height</a>() pixels vertically, with <a href="#baseSize">baseSize</a>() as the
basis. Preferred widget sizes are for non-negative integers <em>i</em>
and <em>j</em>:
<pre>
        <a href="#width-prop">width</a> = <a href="#baseSize">baseSize</a>().width() + i * sizeIncrement().width();
        <a href="#height-prop">height</a> = <a href="#baseSize">baseSize</a>().height() + j * sizeIncrement().height();
    </pre>
 
<p> Note that while you can set the size increment for all widgets, it
only affects top-level widgets.
<p> <b>Warning:</b> The size increment has no effect under Windows, and may
be disregarded by the window manager on X.
<p> <p>See also <a href="#size-prop">size</a>, <a href="#minimumSize-prop">minimumSize</a>, and <a href="#maximumSize-prop">maximumSize</a>.

<p>Set this property's value with <a href="#setSizeIncrement">setSizeIncrement</a>() and get this property's value with <a href="#sizeIncrement">sizeIncrement</a>().
<h3 class=fn><a href="qsizepolicy.html">QSizePolicy</a> <a name="sizePolicy-prop"></a>sizePolicy</h3>
<p>This property holds the default layout behavior of the widget.
<p>If there is a <a href="qlayout.html">QLayout</a> that manages this widget's children, the
size policy specified by that layout is used. If there is no such
QLayout, the result of this function is used.
<p> The default policy is Preferred/Preferred, which means that the
widget can be freely resized, but prefers to be the size
<a href="#sizeHint">sizeHint</a>() returns. Button-like widgets set the size policy to
specify that they may stretch horizontally, but are fixed
vertically. The same applies to lineedit controls (such as
<a href="qlineedit.html">QLineEdit</a>, <a href="qspinbox.html">QSpinBox</a> or an editable <a href="qcombobox.html">QComboBox</a>) and other
horizontally orientated widgets (such as <a href="qprogressbar.html">QProgressBar</a>).
<a href="qtoolbutton.html">QToolButton</a>'s are normally square, so they allow growth in both
directions. Widgets that support different directions (such as
<a href="qslider.html">QSlider</a>, <a href="qscrollbar.html">QScrollBar</a> or <a href="qheader.html">QHeader</a>) specify stretching in the
respective direction only. Widgets that can provide scrollbars
(usually subclasses of <a href="qscrollview.html">QScrollView</a>) tend to specify that they can
use additional space, and that they can make do with less than
sizeHint().
<p> <p>See also <a href="#sizeHint-prop">sizeHint</a>, <a href="qlayout.html">QLayout</a>, <a href="qsizepolicy.html">QSizePolicy</a>, and <a href="#updateGeometry">updateGeometry</a>().

<p>Set this property's value with <a href="#setSizePolicy">setSizePolicy</a>() and get this property's value with <a href="#sizePolicy">sizePolicy</a>().
<h3 class=fn>bool <a name="underMouse-prop"></a>underMouse</h3>
<p>This property holds whether the widget is under the mouse cursor.
<p>This value is not updated properly during drag and drop
operations.
<p> <p>See also <a href="qevent.html#Type-enum">QEvent::Enter</a> and <a href="qevent.html#Type-enum">QEvent::Leave</a>.

<p>Get this property's value with <a href="#hasMouse">hasMouse</a>().
<h3 class=fn>bool <a name="updatesEnabled-prop"></a>updatesEnabled</h3>
<p>This property holds whether updates are enabled.
<p>Calling <a href="#update">update</a>() and <a href="#repaint">repaint</a>() has no effect if updates are
disabled. Paint events from the window system are processed
normally even if updates are disabled.
<p> <a href="#setUpdatesEnabled">setUpdatesEnabled</a>() is normally used to disable updates for a
short period of time, for instance to avoid screen flicker during
large changes.
<p> Example:
<pre>
        <a href="#setUpdatesEnabled">setUpdatesEnabled</a>( FALSE );
        bigVisualChanges();
        <a href="#setUpdatesEnabled">setUpdatesEnabled</a>( TRUE );
        <a href="#repaint">repaint</a>();
    </pre>
 
<p> <p>See also <a href="#update">update</a>(), <a href="#repaint">repaint</a>(), and <a href="#paintEvent">paintEvent</a>().

<p>Set this property's value with <a href="#setUpdatesEnabled">setUpdatesEnabled</a>() and get this property's value with <a href="#isUpdatesEnabled">isUpdatesEnabled</a>().
<h3 class=fn>bool <a name="visible-prop"></a>visible</h3>
<p>This property holds whether the widget is visible.
<p>Calling <a href="#show">show</a>() sets the widget to visible status if all its parent
widgets up to the top-level widget are visible. If an ancestor is
not visible, the widget won't become visible until all its
ancestors are shown.
<p> Calling <a href="#hide">hide</a>() hides a widget explicitly. An explicitly hidden
widget will never become visible, even if all its ancestors become
visible, unless you show it.
<p> A widget receives show and hide events when its visibility status
changes. Between a hide and a show event, there is no need to
waste CPU cycles preparing or displaying information to the user.
A video application, for example, might simply stop generating new
frames.
<p> A widget that happens to be obscured by other windows on the
screen is considered to be visible. The same applies to iconified
top-level widgets and windows that exist on another virtual
desktop (on platforms that support this concept). A widget
receives spontaneous show and hide events when its mapping status
is changed by the window system, e.g. a spontaneous hide event
when the user minimizes the window, and a spontaneous show event
when the window is restored again.
<p> <p>See also <a href="#show">show</a>(), <a href="#hide">hide</a>(), <a href="#hidden-prop">hidden</a>, <a href="#isVisibleTo">isVisibleTo</a>(), <a href="#minimized-prop">minimized</a>, <a href="#showEvent">showEvent</a>(), and <a href="#hideEvent">hideEvent</a>().

<p>Get this property's value with <a href="#isVisible">isVisible</a>().
<h3 class=fn><a href="qrect.html">QRect</a> <a name="visibleRect-prop"></a>visibleRect</h3>
<p>This property holds the visible rectangle.
<p><b>This property is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> No longer necessary, you can simply call <a href="#repaint">repaint</a>(). If you do not
need the rectangle for repaint(), use <a href="#clipRegion">clipRegion</a>() instead.

<p>Get this property's value with <a href="#visibleRect">visibleRect</a>().
<h3 class=fn>int <a name="width-prop"></a>width</h3>
<p>This property holds the width of the widget excluding any window frame.
<p>See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#geometry-prop">geometry</a>, <a href="#height-prop">height</a>, and <a href="#size-prop">size</a>.

<p>Get this property's value with <a href="#width">width</a>().
<h3 class=fn>double <a name="windowOpacity-prop"></a>windowOpacity</h3>
<p>This property holds the level of opacity for the window.
<p>The valid range of opacity is from 1.0 (completely opaque) to
0.0 (completely transparent).
<p> By default the value of this property is 1.0.
<p> This feature is only present on Mac OS X and Windows 2000 and up.
<p> <b>Warning:</b> Changing this property from opaque to transparent might issue a
paint event that needs to be processed before the window is displayed
correctly. This affects mainly the use of <a href="qpixmap.html#grabWindow">QPixmap::grabWindow</a>(). Also note
that semi-transparent windows update and resize significantely slower than
opaque windows.

<p>Set this property's value with <a href="#setWindowOpacity">setWindowOpacity</a>() and get this property's value with <a href="#windowOpacity">windowOpacity</a>().
<h3 class=fn>int <a name="x-prop"></a>x</h3> <p>This property holds the x coordinate of the widget relative to its parent including any window frame.
<p>See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#frameGeometry-prop">frameGeometry</a>, <a href="#y-prop">y</a>, and <a href="#pos-prop">pos</a>.

<p>Get this property's value with <a href="#x">x</a>().
<h3 class=fn>int <a name="y-prop"></a>y</h3>
<p>This property holds the y coordinate of the widget relative to its parent and including any window frame.
<p>See the <a href="geometry.html">Window Geometry documentation</a>
for an overview of top-level widget geometry.
<p> <p>See also <a href="#frameGeometry-prop">frameGeometry</a>, <a href="#x-prop">x</a>, and <a href="#pos-prop">pos</a>.

<p>Get this property's value with <a href="#y">y</a>().
<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
