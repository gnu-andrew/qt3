<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/doc/qptrlist.doc:41 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QPtrList Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QPtrList Class Reference</h1>

<p>The QPtrList class is a template class that provides a list.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qptrlist-h.html">qptrlist.h</a>&gt;</tt>
<p>Inherits <a href="qptrcollection.html">QPtrCollection</a>.
<p>Inherited by <a href="qobjectlist.html">QObjectList</a>, <a href="qsortedlist.html">QSortedList</a>, and <a href="qstrlist.html">QStrList</a>.
<p><a href="qptrlist-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QPtrList"><b>QPtrList</b></a> ()</li>
<li class=fn><a href="#QPtrList-2"><b>QPtrList</b></a> ( const&nbsp;QPtrList&lt;type&gt;&nbsp;&amp;&nbsp;list )</li>
<li class=fn><a href="#~QPtrList"><b>~QPtrList</b></a> ()</li>
<li class=fn>QPtrList&lt;type&gt; &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QPtrList&lt;type&gt;&nbsp;&amp;&nbsp;list )</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QPtrList&lt;type&gt;&nbsp;&amp;&nbsp;list ) const</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QPtrList&lt;type&gt;&nbsp;&amp;&nbsp;list ) const</li>
<li class=fn>virtual uint <a href="#count"><b>count</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>bool <a href="#insert"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>void <a href="#inSort"><b>inSort</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>void <a href="#prepend"><b>prepend</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>void <a href="#append"><b>append</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>bool <a href="#remove"><b>remove</b></a> ( uint&nbsp;index )</li>
<li class=fn>bool <a href="#remove-2"><b>remove</b></a> ()</li>
<li class=fn>bool <a href="#remove-3"><b>remove</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>bool <a href="#removeRef"><b>removeRef</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>void <a href="#removeNode"><b>removeNode</b></a> ( QLNode&nbsp;*&nbsp;node )</li>
<li class=fn>bool <a href="#removeFirst"><b>removeFirst</b></a> ()</li>
<li class=fn>bool <a href="#removeLast"><b>removeLast</b></a> ()</li>
<li class=fn>type * <a href="#take"><b>take</b></a> ( uint&nbsp;index )</li>
<li class=fn>type * <a href="#take-2"><b>take</b></a> ()</li>
<li class=fn>type * <a href="#takeNode"><b>takeNode</b></a> ( QLNode&nbsp;*&nbsp;node )</li>
<li class=fn>virtual void <a href="#clear"><b>clear</b></a> ()</li>
<li class=fn>void <a href="#sort"><b>sort</b></a> ()</li>
<li class=fn>int <a href="#find"><b>find</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>int <a href="#findNext"><b>findNext</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>int <a href="#findRef"><b>findRef</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>int <a href="#findNextRef"><b>findNextRef</b></a> ( const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>uint <a href="#contains"><b>contains</b></a> ( const&nbsp;type&nbsp;*&nbsp;item ) const</li>
<li class=fn>uint <a href="#containsRef"><b>containsRef</b></a> ( const&nbsp;type&nbsp;*&nbsp;item ) const</li>
<li class=fn>bool <a href="#replace"><b>replace</b></a> ( uint&nbsp;index, const&nbsp;type&nbsp;*&nbsp;item )</li>
<li class=fn>type * <a href="#at"><b>at</b></a> ( uint&nbsp;index )</li>
<li class=fn>int <a href="#at-2"><b>at</b></a> () const</li>
<li class=fn>type * <a href="#current"><b>current</b></a> () const</li>
<li class=fn>QLNode * <a href="#currentNode"><b>currentNode</b></a> () const</li>
<li class=fn>type * <a href="#getFirst"><b>getFirst</b></a> () const</li>
<li class=fn>type * <a href="#getLast"><b>getLast</b></a> () const</li>
<li class=fn>type * <a href="#first"><b>first</b></a> ()</li>
<li class=fn>type * <a href="#last"><b>last</b></a> ()</li>
<li class=fn>type * <a href="#next"><b>next</b></a> ()</li>
<li class=fn>type * <a href="#prev"><b>prev</b></a> ()</li>
<li class=fn>void <a href="#toVector"><b>toVector</b></a> ( QGVector&nbsp;*&nbsp;vec ) const</li>
</ul>
<h2>Important Inherited Members</h2>
<ul>
<li class=fn>bool <a href="#autoDelete"><b>autoDelete</b></a> () const</li>
<li class=fn>void <a href="#setAutoDelete"><b>setAutoDelete</b></a> ( bool&nbsp;enable )</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>virtual int <a href="#compareItems"><b>compareItems</b></a> ( QPtrCollection::Item&nbsp;item1, QPtrCollection::Item&nbsp;item2 )</li>
<li class=fn>virtual QDataStream &amp; <a href="#read"><b>read</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QPtrCollection::Item&nbsp;&amp;&nbsp;item )</li>
<li class=fn>virtual QDataStream &amp; <a href="#write"><b>write</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QPtrCollection::Item&nbsp;item ) const</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QPtrList class is a template class that provides a list.
<p> 

<p> 
<p> <a href="qvaluelist.html">QValueList</a> is an STL-compatible alternative to this class.
<p> Define a template instance QPtrList&lt;X&gt; to create a list that
operates on pointers to X (X*).
<p> The list class is indexable and has a <a href="#at">current
    index</a> and a <a href="#current">current item</a>. The
first item corresponds to index position 0. The current index is
-1 if the current item is 0.
<p> Items are inserted with <a href="#prepend">prepend</a>(), <a href="#insert">insert</a>() or <a href="#append">append</a>(). Items are
removed with <a href="#remove">remove</a>(), <a href="#removeRef">removeRef</a>(), <a href="#removeFirst">removeFirst</a>() and
<a href="#removeLast">removeLast</a>(). You can search for an item using <a href="#find">find</a>(), <a href="#findNext">findNext</a>(),
<a href="#findRef">findRef</a>() or <a href="#findNextRef">findNextRef</a>(). The list can be sorted with <a href="#sort">sort</a>().
You can count the number of occurrences of an item with <a href="#contains">contains</a>()
or <a href="#containsRef">containsRef</a>(). You can get a pointer to the current item with
<a href="#current">current</a>(), to an item at a particular index position in the list
with <a href="#at">at</a>() or to the first or last item with <a href="#getFirst">getFirst</a>() and
<a href="#getLast">getLast</a>(). You can also iterate over the list with <a href="#first">first</a>(),
<a href="#last">last</a>(), <a href="#next">next</a>() and <a href="#prev">prev</a>() (which all update current()). The list's
deletion property is set with <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>().
<p> <a name="example"></a>
Example:
<pre>
    class Employee
    {
    public:
        Employee() : sn( 0 ) { }
        Employee( const <a href="qstring.html">QString</a>&amp; forename, const <a href="qstring.html">QString</a>&amp; surname, int salary )
            : fn( forename ), sn( surname ), sal( salary )
        { }

        void setSalary( int salary ) { sal = salary; }

        <a href="qstring.html">QString</a> forename() const { return fn; }
        <a href="qstring.html">QString</a> surname() const { return sn; }
        int salary() const { return sal; }

    private:
        <a href="qstring.html">QString</a> fn;
        <a href="qstring.html">QString</a> sn;
        int sal;
    };

    QPtrList&lt;Employee&gt; list;
    list.<a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>( TRUE ); // the list owns the objects

    list.<a href="#append">append</a>( new Employee("John", "Doe", 50000) );
    list.<a href="#append">append</a>( new Employee("Jane", "Williams", 80000) );
    list.<a href="#append">append</a>( new Employee("Tom", "Jones", 60000) );

    Employee *employee;
    for ( employee = list.<a href="#first">first</a>(); employee; employee = list.<a href="#next">next</a>() )
        cout &lt;&lt; employee-&gt;surname().latin1() &lt;&lt; ", " &lt;&lt;
                employee-&gt;forename().latin1() &lt;&lt; " earns " &lt;&lt;
                employee-&gt;salary() &lt;&lt; endl;
    cout &lt;&lt; endl;

    // very inefficient for big lists
    for ( uint i = 0; i &lt; list.<a href="#count">count</a>(); ++i )
        if ( list.<a href="#at">at</a>(i) )
            cout &lt;&lt; list.<a href="#at">at</a>( i )-&gt;surname().latin1() &lt;&lt; endl;
    </pre>
 
<p> The output is
<pre>
    Doe, John earns 50000
    Williams, Jane earns 80000
    Jones, Tom earns 60000

    Doe
    Williams
    Jones
    </pre>
 
<p> QPtrList has several member functions for traversing the list, but
using a <a href="qptrlistiterator.html">QPtrListIterator</a> can be more practical. Multiple list
iterators may traverse the same list, independently of each other
and of the current list item.
<p> In the example above we make the call <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(TRUE).
Enabling auto-deletion tells the list to delete items that are
removed. The default is to not delete items when they are removed
but this would cause a memory leak in the example because there
are no other references to the list items.
<p> When inserting an item into a list only the pointer is copied, not
the item itself, i.e. a <a href="shclass.html#shallow-copy">shallow copy</a>. It is possible to make the
list copy all of the item's data (deep copy) when an item is
inserted. <a href="#insert">insert</a>(), <a href="#inSort">inSort</a>() and <a href="#append">append</a>() call the virtual
function <a href="qptrcollection.html#newItem">QPtrCollection::newItem</a>() for the item to be inserted.
Inherit a list and reimplement <a href="qptrcollection.html#newItem">newItem</a>() to have deep copies.
<p> When removing an item from a list, the virtual function
<a href="qptrcollection.html#deleteItem">QPtrCollection::deleteItem</a>() is called. QPtrList's default
implementation is to delete the item if auto-deletion is enabled.
<p> The virtual function <a href="#compareItems">compareItems</a>() can be reimplemented to
compare two list items. This function is called from all list
functions that need to compare list items, for instance
<a href="#remove">remove</a>(const type*). If you only want to deal with pointers, there
are functions that compare pointers instead, for instance
<a href="#removeRef">removeRef</a>(const type*). These functions are somewhat faster than
those that call compareItems().
<p> List items are stored as <tt>void*</tt> in an internal QLNode, which
also holds pointers to the next and previous list items. The
functions <a href="#currentNode">currentNode</a>(), <a href="#removeNode">removeNode</a>(), and <a href="#takeNode">takeNode</a>() operate
directly on the QLNode, but they should be used with care. The
data component of the node is available through QLNode::getData().
<p> The <a href="qstrlist.html">QStrList</a> class defined in <a href="qstrlist-h.html">qstrlist.h</a> is a list of <tt>char*</tt>.
It reimplements <a href="qptrcollection.html#newItem">newItem</a>(), <a href="qptrcollection.html#deleteItem">deleteItem</a>() and <a href="#compareItems">compareItems</a>(). (But
see <a href="qstringlist.html">QStringList</a> for a list of Unicode QStrings.)
<p> <p>See also <a href="qptrlistiterator.html">QPtrListIterator</a>, <a href="collection.html">Collection Classes</a>, and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QPtrList"></a>QPtrList::QPtrList ()
</h3>

<p> Constructs an empty list.

<h3 class=fn><a name="QPtrList-2"></a>QPtrList::QPtrList ( const&nbsp;<a href="qptrlist.html">QPtrList</a>&lt;type&gt;&nbsp;&amp;&nbsp;list )
</h3>

<p> Constructs a copy of <em>list</em>.
<p> Each item in <em>list</em> is <a href="#append">appended</a> to this
list. Only the pointers are copied (shallow copy).

<h3 class=fn><a name="~QPtrList"></a>QPtrList::~QPtrList ()
</h3>

<p> Removes all items from the list and destroys the list.
<p> All list iterators that access this list will be reset.
<p> <p>See also <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>().

<h3 class=fn>void <a name="append"></a>QPtrList::append ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Inserts the <em>item</em> at the end of the list.
<p> The inserted item becomes the current list item. This is
equivalent to <tt>insert( count(), item )</tt>.
<p> <em>item</em> must not be 0.
<p> <p>See also <a href="#insert">insert</a>(), <a href="#current">current</a>(), and <a href="#prepend">prepend</a>().

<p>Examples: <a href="customlayout-example.html#x1500">customlayout/border.cpp</a>, <a href="customlayout-example.html#x1518">customlayout/card.cpp</a>, <a href="customlayout-example.html#x1477">customlayout/flow.cpp</a>, <a href="grapher-nsplugin-example.html#x2770">grapher/grapher.cpp</a>, <a href="listviews-example.html#x160">listviews/listviews.cpp</a>, <a href="listviews-example.html#x131">listviews/listviews.h</a>, and <a href="qwerty-example.html#x387">qwerty/qwerty.cpp</a>.
<h3 class=fn>type * <a name="at"></a>QPtrList::at ( uint&nbsp;index )
</h3>

<p> Returns a pointer to the item at position <em>index</em> in the list, or
0 if the index is out of range.
<p> Sets the current list item to this item if <em>index</em> is valid. The
valid range is <tt>0..(count() - 1)</tt> inclusive.
<p> This function is very efficient. It starts scanning from the first
item, last item, or current item, whichever is closest to <em>index</em>.
<p> <p>See also <a href="#current">current</a>().

<p>Examples: <a href="customlayout-example.html#x1501">customlayout/border.cpp</a>, <a href="customlayout-example.html#x1519">customlayout/card.cpp</a>, <a href="customlayout-example.html#x1478">customlayout/flow.cpp</a>, <a href="dirview-example.html#x1697">dirview/dirview.cpp</a>, <a href="mdi-example.html#x2053">mdi/application.cpp</a>, and <a href="qwerty-example.html#x388">qwerty/qwerty.cpp</a>.
<h3 class=fn>int <a name="at-2"></a>QPtrList::at () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the index of the current list item. The returned value is
-1 if the current item is 0.
<p> <p>See also <a href="#current">current</a>().

<h3 class=fn>bool <a name="autoDelete"></a>QPtrCollection::autoDelete () const
</h3>

<p> Returns the setting of the auto-delete option. The default is FALSE.
<p> <p>See also <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>().

<h3 class=fn>void <a name="clear"></a>QPtrList::clear ()<tt> [virtual]</tt>
</h3>

<p> Removes all items from the list.
<p> The removed items are deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> All list iterators that access this list will be reset.
<p> <p>See also <a href="#remove">remove</a>(), <a href="#take">take</a>(), and <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>().

<p>Reimplemented from <a href="qptrcollection.html#clear">QPtrCollection</a>.
<h3 class=fn>int <a name="compareItems"></a>QPtrList::compareItems ( <a href="qptrcollection.html#Item">QPtrCollection::Item</a>&nbsp;item1, <a href="qptrcollection.html#Item">QPtrCollection::Item</a>&nbsp;item2 )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function compares two list items.
<p> Returns:
<ul>
<li> zero if <em>item1</em> == <em>item2</em>
<li> nonzero if <em>item1</em> != <em>item2</em>
</ul>
<p> This function returns <em>int</em> rather than <em>bool</em> so that
reimplementations can return three values and use it to sort by:
<p> <ul>
<li> 0 if <em>item1</em> == <em>item2</em>
<li> &gt; 0 (positive integer) if <em>item1</em> &gt; <em>item2</em>
<li> &lt; 0 (negative integer) if <em>item1</em> &lt; <em>item2</em>
</ul>
<p> <a href="#inSort">inSort</a>() requires that <a href="#compareItems">compareItems</a>() is implemented as described
here.
<p> This function should not modify the list because some const
functions call compareItems().
<p> The default implementation compares the pointers.

<h3 class=fn>uint <a name="contains"></a>QPtrList::contains ( const&nbsp;type&nbsp;*&nbsp;item ) const
</h3>

<p> Returns the number of occurrences of <em>item</em> in the list.
<p> The <a href="#compareItems">compareItems</a>() function is called when looking for the <em>item</em>
in the list. If compareItems() is not reimplemented, it is more
efficient to call <a href="#containsRef">containsRef</a>().
<p> This function does not affect the current list item.
<p> <p>See also <a href="#containsRef">containsRef</a>() and <a href="#compareItems">compareItems</a>().

<h3 class=fn>uint <a name="containsRef"></a>QPtrList::containsRef ( const&nbsp;type&nbsp;*&nbsp;item ) const
</h3>

<p> Returns the number of occurrences of <em>item</em> in the list.
<p> Calling this function is much faster than <a href="#contains">contains</a>() because
contains() compares <em>item</em> with each list item using
<a href="#compareItems">compareItems</a>(), whereas his function only compares the pointers.
<p> This function does not affect the current list item.
<p> <p>See also <a href="#contains">contains</a>().

<h3 class=fn>uint <a name="count"></a>QPtrList::count () const<tt> [virtual]</tt>
</h3>

<p> Returns the number of items in the list.
<p> <p>See also <a href="#isEmpty">isEmpty</a>().

<p>Examples: <a href="customlayout-example.html#x1502">customlayout/border.cpp</a>, <a href="customlayout-example.html#x1520">customlayout/card.cpp</a>, <a href="customlayout-example.html#x1479">customlayout/flow.cpp</a>, <a href="dirview-example.html#x1699">dirview/dirview.cpp</a>, <a href="grapher-nsplugin-example.html#x2771">grapher/grapher.cpp</a>, <a href="mdi-example.html#x2054">mdi/application.cpp</a>, and <a href="qwerty-example.html#x389">qwerty/qwerty.cpp</a>.
<p>Reimplemented from <a href="qptrcollection.html#count">QPtrCollection</a>.
<h3 class=fn>type * <a name="current"></a>QPtrList::current () const
</h3>

<p> Returns a pointer to the current list item. The current item may
be 0 (implies that the current index is -1). 
<p> <p>See also <a href="#at">at</a>().

<h3 class=fn>QLNode * <a name="currentNode"></a>QPtrList::currentNode () const
</h3>

<p> Returns a pointer to the current list node.
<p> The node can be kept and removed later using <a href="#removeNode">removeNode</a>(). The
advantage is that the item can be removed directly without
searching the list.
<p> <b>Warning:</b> Do not call this function unless you are an expert.
<p> <p>See also <a href="#removeNode">removeNode</a>(), <a href="#takeNode">takeNode</a>(), and <a href="#current">current</a>().

<h3 class=fn>int <a name="find"></a>QPtrList::find ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Finds the first occurrence of <em>item</em> in the list.
<p> If the item is found, the list sets the current item to point to
the found item and returns the index of this item. If the item is
not found, the list sets the current item to 0, the current
index to -1, and returns -1.
<p> The <a href="#compareItems">compareItems</a>() function is called when searching for the item
in the list. If compareItems() is not reimplemented, it is more
efficient to call <a href="#findRef">findRef</a>().
<p> <p>See also <a href="#findNext">findNext</a>(), <a href="#findRef">findRef</a>(), <a href="#compareItems">compareItems</a>(), and <a href="#current">current</a>().

<h3 class=fn>int <a name="findNext"></a>QPtrList::findNext ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Finds the next occurrence of <em>item</em> in the list, starting from
the current list item.
<p> If the item is found, the list sets the current item to point to
the found item and returns the index of this item. If the item is
not found, the list sets the current item to 0, the current
index to -1, and returns -1.
<p> The <a href="#compareItems">compareItems</a>() function is called when searching for the item
in the list. If compareItems() is not reimplemented, it is more
efficient to call <a href="#findNextRef">findNextRef</a>().
<p> <p>See also <a href="#find">find</a>(), <a href="#findNextRef">findNextRef</a>(), <a href="#compareItems">compareItems</a>(), and <a href="#current">current</a>().

<h3 class=fn>int <a name="findNextRef"></a>QPtrList::findNextRef ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Finds the next occurrence of <em>item</em> in the list, starting from
the current list item.
<p> If the item is found, the list sets the current item to point to
the found item and returns the index of this item. If the item is
not found, the list sets the current item to 0, the current
index to -1, and returns -1.
<p> Calling this function is much faster than <a href="#findNext">findNext</a>() because
findNext() compares <em>item</em> with each list item using
<a href="#compareItems">compareItems</a>(), whereas this function only compares the pointers.
<p> <p>See also <a href="#findRef">findRef</a>(), <a href="#findNext">findNext</a>(), and <a href="#current">current</a>().

<h3 class=fn>int <a name="findRef"></a>QPtrList::findRef ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Finds the first occurrence of <em>item</em> in the list.
<p> If the item is found, the list sets the current item to point to
the found item and returns the index of this item. If the item is
not found, the list sets the current item to 0, the current
index to -1, and returns -1.
<p> Calling this function is much faster than <a href="#find">find</a>() because find()
compares <em>item</em> with each list item using <a href="#compareItems">compareItems</a>(), whereas
this function only compares the pointers.
<p> <p>See also <a href="#findNextRef">findNextRef</a>(), <a href="#find">find</a>(), and <a href="#current">current</a>().

<h3 class=fn>type * <a name="first"></a>QPtrList::first ()
</h3>

<p> Returns a pointer to the first item in the list and makes this the
current list item; returns 0 if the list is empty.
<p> <p>See also <a href="#getFirst">getFirst</a>(), <a href="#last">last</a>(), <a href="#next">next</a>(), <a href="#prev">prev</a>(), and <a href="#current">current</a>().

<p>Examples: <a href="grapher-nsplugin-example.html#x2772">grapher/grapher.cpp</a>, <a href="listviews-example.html#x132">listviews/listviews.h</a>, and <a href="showimg-example.html#x1343">showimg/showimg.cpp</a>.
<h3 class=fn>type * <a name="getFirst"></a>QPtrList::getFirst () const
</h3>

<p> Returns a pointer to the first item in the list, or 0 if the list
is empty.
<p> This function does not affect the current list item.
<p> <p>See also <a href="#first">first</a>() and <a href="#getLast">getLast</a>().

<h3 class=fn>type * <a name="getLast"></a>QPtrList::getLast () const
</h3>

<p> Returns a pointer to the last item in the list, or 0 if the list
is empty.
<p> This function does not affect the current list item.
<p> <p>See also <a href="#last">last</a>() and <a href="#getFirst">getFirst</a>().

<h3 class=fn>void <a name="inSort"></a>QPtrList::inSort ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Inserts the <em>item</em> at its sorted position in the list.
<p> The sort order depends on the virtual <a href="#compareItems">compareItems</a>() function. All
items must be inserted with <a href="#inSort">inSort</a>() to maintain the sorting
order.
<p> The inserted item becomes the current list item.
<p> <em>item</em> must not be 0.
<p> <b>Warning:</b> Using inSort() is slow. An alternative, especially if you
have lots of items, is to simply <a href="#append">append</a>() or <a href="#insert">insert</a>() them and
then use <a href="#sort">sort</a>(). inSort() takes up to O(n) compares. That means
inserting n items in your list will need O(n^2) compares whereas
sort() only needs O(n*log n) for the same task. So use inSort()
only if you already have a presorted list and want to insert just
a few additional items.
<p> <p>See also <a href="#insert">insert</a>(), <a href="#compareItems">compareItems</a>(), <a href="#current">current</a>(), and <a href="#sort">sort</a>().

<h3 class=fn>bool <a name="insert"></a>QPtrList::insert ( uint&nbsp;index, const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Inserts the <em>item</em> at position <em>index</em> in the list.
<p> Returns TRUE if successful, i.e. if <em>index</em> is in range;
otherwise returns FALSE. The valid range is 0 to <a href="#count">count</a>()
(inclusively). The item is appended if <em>index</em> == count().
<p> The inserted item becomes the current list item.
<p> <em>item</em> must not be 0.
<p> <p>See also <a href="#append">append</a>(), <a href="#current">current</a>(), and <a href="#replace">replace</a>().

<h3 class=fn>bool <a name="isEmpty"></a>QPtrList::isEmpty () const
</h3>

<p> Returns TRUE if the list is empty; otherwise returns FALSE.
<p> <p>See also <a href="#count">count</a>().

<h3 class=fn>type * <a name="last"></a>QPtrList::last ()
</h3>

<p> Returns a pointer to the last item in the list and makes this the
current list item; returns 0 if the list is empty.
<p> <p>See also <a href="#getLast">getLast</a>(), <a href="#first">first</a>(), <a href="#next">next</a>(), <a href="#prev">prev</a>(), and <a href="#current">current</a>().

<h3 class=fn>type * <a name="next"></a>QPtrList::next ()
</h3>

<p> Returns a pointer to the item succeeding the current item. Returns
0 if the current item is 0 or equal to the last item.
<p> Makes the succeeding item current. If the current item before this
function call was the last item, the current item will be set to
0. If the current item was 0, this function does nothing.
<p> <p>See also <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#prev">prev</a>(), and <a href="#current">current</a>().

<p>Examples: <a href="grapher-nsplugin-example.html#x2773">grapher/grapher.cpp</a>, <a href="listviews-example.html#x133">listviews/listviews.h</a>, and <a href="showimg-example.html#x1344">showimg/showimg.cpp</a>.
<h3 class=fn>bool <a name="operator!-eq"></a>QPtrList::operator!= ( const&nbsp;<a href="qptrlist.html">QPtrList</a>&lt;type&gt;&nbsp;&amp;&nbsp;list ) const
</h3>

<p> Compares this list with <em>list</em>. Returns TRUE if the lists contain
different data; otherwise returns FALSE.

<h3 class=fn><a href="qptrlist.html">QPtrList</a>&lt;type&gt;&nbsp;&amp; <a name="operator-eq"></a>QPtrList::operator= ( const&nbsp;<a href="qptrlist.html">QPtrList</a>&lt;type&gt;&nbsp;&amp;&nbsp;list )
</h3>

<p> Assigns <em>list</em> to this list and returns a reference to this list.
<p> This list is first cleared and then each item in <em>list</em> is <a href="#append">appended</a> to this list. Only the pointers are
copied (shallow copy) unless <a href="qptrcollection.html#newItem">newItem</a>() has been reimplemented.

<h3 class=fn>bool <a name="operator-eq-eq"></a>QPtrList::operator== ( const&nbsp;<a href="qptrlist.html">QPtrList</a>&lt;type&gt;&nbsp;&amp;&nbsp;list ) const
</h3>

<p> Compares this list with <em>list</em>. Returns TRUE if the lists contain
the same data; otherwise returns FALSE.

<h3 class=fn>void <a name="prepend"></a>QPtrList::prepend ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Inserts the <em>item</em> at the start of the list.
<p> The inserted item becomes the current list item. This is
equivalent to <tt>insert( 0, item )</tt>.
<p> <em>item</em> must not be 0.
<p> <p>See also <a href="#append">append</a>(), <a href="#insert">insert</a>(), and <a href="#current">current</a>().

<h3 class=fn>type * <a name="prev"></a>QPtrList::prev ()
</h3>

<p> Returns a pointer to the item preceding the current item. Returns
0 if the current item is 0 or equal to the first item.
<p> Makes the preceding item current. If the current item before this
function call was the first item, the current item will be set to
0. If the current item was 0, this function does nothing.
<p> <p>See also <a href="#first">first</a>(), <a href="#last">last</a>(), <a href="#next">next</a>(), and <a href="#current">current</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="read"></a>QPtrList::read ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qptrcollection.html#Item">QPtrCollection::Item</a>&nbsp;&amp;&nbsp;item )<tt> [virtual protected]</tt>
</h3>

<p> Reads a list item from the stream <em>s</em> and returns a reference to
the stream.
<p> The default implementation sets <em>item</em> to 0.
<p> <p>See also <a href="#write">write</a>().

<h3 class=fn>bool <a name="remove"></a>QPtrList::remove ( uint&nbsp;index )
</h3>

<p> Removes the item at position <em>index</em> in the list.
<p> Returns TRUE if successful, i.e. if <em>index</em> is in range;
otherwise returns FALSE. The valid range is <tt>0..(count() - 1)</tt>
inclusive.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#take">take</a>(), <a href="#clear">clear</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), <a href="#current">current</a>(), and <a href="#removeRef">removeRef</a>().

<h3 class=fn>bool <a name="remove-2"></a>QPtrList::remove ()
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes the current list item.
<p> Returns TRUE if successful, i.e. if the current item isn't 0;
otherwise returns FALSE.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#take">take</a>(), <a href="#clear">clear</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), <a href="#current">current</a>(), and <a href="#removeRef">removeRef</a>().

<h3 class=fn>bool <a name="remove-3"></a>QPtrList::remove ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes the first occurrence of <em>item</em> from the list.
<p> Returns TRUE if successful, i.e. if <em>item</em> is in the list;
otherwise returns FALSE.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The <a href="#compareItems">compareItems</a>() function is called when searching for the item
in the list. If compareItems() is not reimplemented, it is more
efficient to call <a href="#removeRef">removeRef</a>().
<p> If <em>item</em> is NULL then the current item is removed from the list.
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#removeRef">removeRef</a>(), <a href="#take">take</a>(), <a href="#clear">clear</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), <a href="#compareItems">compareItems</a>(), and <a href="#current">current</a>().

<h3 class=fn>bool <a name="removeFirst"></a>QPtrList::removeFirst ()
</h3>

<p> Removes the first item from the list. Returns TRUE if successful,
i.e. if the list isn't empty; otherwise returns FALSE.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The first item in the list becomes the new current list item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#removeLast">removeLast</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), <a href="#current">current</a>(), and <a href="#remove">remove</a>().

<h3 class=fn>bool <a name="removeLast"></a>QPtrList::removeLast ()
</h3>

<p> Removes the last item from the list. Returns TRUE if successful,
i.e. if the list isn't empty; otherwise returns FALSE.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The last item in the list becomes the new current list item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#removeFirst">removeFirst</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), and <a href="#current">current</a>().

<h3 class=fn>void <a name="removeNode"></a>QPtrList::removeNode ( QLNode&nbsp;*&nbsp;node )
</h3>

<p> Removes the <em>node</em> from the list.
<p> This node must exist in the list, otherwise the program may crash.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> The first item in the list will become the new current list item.
The current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the item succeeding this item or to the preceding item if
the removed item was the last item.
<p> <b>Warning:</b> Do not call this function unless you are an expert.
<p> <p>See also <a href="#takeNode">takeNode</a>(), <a href="#currentNode">currentNode</a>(), <a href="#remove">remove</a>(), and <a href="#removeRef">removeRef</a>().

<h3 class=fn>bool <a name="removeRef"></a>QPtrList::removeRef ( const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Removes the first occurrence of <em>item</em> from the list.
<p> Returns TRUE if successful, i.e. if <em>item</em> is in the list;
otherwise returns FALSE.
<p> The removed item is deleted if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled.
<p> Equivalent to:
<pre>
        if ( list.findRef( item ) != -1 )
            list.remove();
    </pre>
 
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the removed item will be set to
point to the new current item.
<p> <p>See also <a href="#remove">remove</a>(), <a href="#clear">clear</a>(), <a href="qptrcollection.html#setAutoDelete">setAutoDelete</a>(), and <a href="#current">current</a>().

<h3 class=fn>bool <a name="replace"></a>QPtrList::replace ( uint&nbsp;index, const&nbsp;type&nbsp;*&nbsp;item )
</h3>

<p> Replaces the item at position <em>index</em> with the new <em>item</em>. 
<p> Returns TRUE if successful, i.e. <em>index</em> is in the range 0 to
<a href="#count">count</a>()-1.
<p> <p>See also <a href="#append">append</a>(), <a href="#current">current</a>(), and <a href="#insert">insert</a>().

<h3 class=fn>void <a name="setAutoDelete"></a>QPtrCollection::setAutoDelete ( bool&nbsp;enable )
</h3>

<p> Sets the collection to auto-delete its contents if <em>enable</em> is
TRUE and to never delete them if <em>enable</em> is FALSE.
<p> If auto-deleting is turned on, all the items in a collection are
deleted when the collection itself is deleted. This is convenient
if the collection has the only pointer to the items.
<p> The default setting is FALSE, for safety. If you turn it on, be
careful about copying the collection - you might find yourself
with two collections deleting the same items.
<p> Note that the auto-delete setting may also affect other functions
in subclasses. For example, a subclass that has a <a href="#remove">remove</a>()
function will remove the item from its data structure, and if
auto-delete is enabled, will also delete the item.
<p> <p>See also <a href="qptrcollection.html#autoDelete">autoDelete</a>().

<p>Examples: <a href="grapher-nsplugin-example.html#x2769">grapher/grapher.cpp</a>, <a href="scribble-example.html#x924">scribble/scribble.cpp</a>, and <a href="bigtable-example.html#x1291">table/bigtable/main.cpp</a>.
<h3 class=fn>void <a name="sort"></a>QPtrList::sort ()
</h3>

<p> Sorts the list by the result of the virtual <a href="#compareItems">compareItems</a>()
function.
<p> The heap sort algorithm is used for sorting. It sorts n items with
O(n*log n) comparisons. This is the asymptotic optimal solution of
the sorting problem.
<p> If the items in your list support <a href="qcstring.html#operator-lt-2">operator&lt;</a>() and <a href="#operator-eq-eq">operator==</a>(),
you might be better off with QSortedList because it implements the
compareItems() function for you using these two operators.
<p> <p>See also <a href="#inSort">inSort</a>().

<h3 class=fn>type * <a name="take"></a>QPtrList::take ( uint&nbsp;index )
</h3>

<p> Takes the item at position <em>index</em> out of the list without
deleting it (even if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a>
is enabled).
<p> Returns a pointer to the item taken out of the list, or 0 if the
index is out of range. The valid range is <tt>0..(count() - 1)</tt>
inclusive.
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the taken item will be set to
point to the new current item.
<p> <p>See also <a href="#remove">remove</a>(), <a href="#clear">clear</a>(), and <a href="#current">current</a>().

<p>Examples: <a href="customlayout-example.html#x1503">customlayout/border.cpp</a>, <a href="customlayout-example.html#x1521">customlayout/card.cpp</a>, and <a href="customlayout-example.html#x1480">customlayout/flow.cpp</a>.
<h3 class=fn>type * <a name="take-2"></a>QPtrList::take ()
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Takes the current item out of the list without deleting it (even
if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled).
<p> Returns a pointer to the item taken out of the list, or 0 if
the current item is 0.
<p> The item after the removed item becomes the new current list item
if the removed item is not the last item in the list. If the last
item is removed, the new last item becomes the current item. The
current item is set to 0 if the list becomes empty.
<p> All list iterators that refer to the taken item will be set to
point to the new current item.
<p> <p>See also <a href="#remove">remove</a>(), <a href="#clear">clear</a>(), and <a href="#current">current</a>().

<h3 class=fn>type * <a name="takeNode"></a>QPtrList::takeNode ( QLNode&nbsp;*&nbsp;node )
</h3>

<p> Takes the <em>node</em> out of the list without deleting its item (even
if <a href="qptrcollection.html#setAutoDelete">auto-deletion</a> is enabled).
Returns a pointer to the item taken out of the list.
<p> This node must exist in the list, otherwise the program may crash.
<p> The first item in the list becomes the new current list item.
<p> All list iterators that refer to the taken item will be set to
point to the item succeeding this item or to the preceding item if
the taken item was the last item.
<p> <b>Warning:</b> Do not call this function unless you are an expert.
<p> <p>See also <a href="#removeNode">removeNode</a>() and <a href="#currentNode">currentNode</a>().

<h3 class=fn>void <a name="toVector"></a>QPtrList::toVector ( QGVector&nbsp;*&nbsp;vec ) const
</h3>

<p> Stores all list items in the vector <em>vec</em>.
<p> The vector must be of the same item type, otherwise the result
will be undefined.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="write"></a>QPtrList::write ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qptrcollection.html#Item">QPtrCollection::Item</a>&nbsp;item ) const<tt> [virtual protected]</tt>
</h3>

<p> Writes a list item, <em>item</em> to the stream <em>s</em> and returns a
reference to the stream.
<p> The default implementation does nothing.
<p> <p>See also <a href="#read">read</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
