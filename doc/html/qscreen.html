<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qgfxraster_qws.cpp:5792 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QScreen Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QScreen Class Reference</h1>

<p>The QScreen class and its descendants manage the framebuffer and
palette.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qgfx_qws-h.html">qgfx_qws.h</a>&gt;</tt>
<p><a href="qscreen-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QScreen"><b>QScreen</b></a> ( int&nbsp;display_id )</li>
<li class=fn>virtual <a href="#~QScreen"><b>~QScreen</b></a> ()</li>
<li class=fn>virtual bool <a href="#initDevice"><b>initDevice</b></a> () = 0</li>
<li class=fn>virtual bool <a href="#connect"><b>connect</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;displaySpec ) = 0</li>
<li class=fn>virtual void <a href="#disconnect"><b>disconnect</b></a> () = 0</li>
<li class=fn>virtual int <a href="#initCursor"><b>initCursor</b></a> ( void&nbsp;*&nbsp;end_of_location, bool&nbsp;init = FALSE )</li>
<li class=fn>virtual void <a href="#shutdownDevice"><b>shutdownDevice</b></a> ()</li>
<li class=fn>virtual void <a href="#setMode"><b>setMode</b></a> ( int, int, int ) = 0</li>
<li class=fn>virtual bool <a href="#supportsDepth"><b>supportsDepth</b></a> ( int&nbsp;d ) const</li>
<li class=fn>virtual QGfx * <a href="#createGfx"><b>createGfx</b></a> ( unsigned&nbsp;char&nbsp;*&nbsp;bytes, int&nbsp;w, int&nbsp;h, int&nbsp;d, int&nbsp;linestep )</li>
<li class=fn>virtual QGfx * <a href="#screenGfx"><b>screenGfx</b></a> ()</li>
<li class=fn>virtual void <a href="#save"><b>save</b></a> ()</li>
<li class=fn>virtual void <a href="#restore"><b>restore</b></a> ()</li>
<li class=fn>virtual void <a href="#blank"><b>blank</b></a> ( bool&nbsp;on )</li>
<li class=fn>virtual int <a href="#pixmapOffsetAlignment"><b>pixmapOffsetAlignment</b></a> ()</li>
<li class=fn>virtual int <a href="#pixmapLinestepAlignment"><b>pixmapLinestepAlignment</b></a> ()</li>
<li class=fn>virtual bool <a href="#onCard"><b>onCard</b></a> ( unsigned&nbsp;char&nbsp;*&nbsp;p ) const</li>
<li class=fn>virtual bool <a href="#onCard-2"><b>onCard</b></a> ( unsigned&nbsp;char&nbsp;*&nbsp;p, ulong&nbsp;&amp;&nbsp;offset ) const</li>
<li class=fn>virtual void <a href="#set"><b>set</b></a> ( unsigned int, unsigned int, unsigned int, unsigned int )</li>
<li class=fn>virtual int <a href="#alloc"><b>alloc</b></a> ( unsigned&nbsp;int&nbsp;r, unsigned&nbsp;int&nbsp;g, unsigned&nbsp;int&nbsp;b )</li>
<li class=fn>int <a href="#width"><b>width</b></a> () const</li>
<li class=fn>int <a href="#height"><b>height</b></a> () const</li>
<li class=fn>int <a href="#depth"><b>depth</b></a> () const</li>
<li class=fn>virtual int <a href="#pixmapDepth"><b>pixmapDepth</b></a> () const</li>
<li class=fn>int <a href="#pixelType"><b>pixelType</b></a> () const</li>
<li class=fn>int <a href="#linestep"><b>linestep</b></a> () const</li>
<li class=fn>int <a href="#deviceWidth"><b>deviceWidth</b></a> () const</li>
<li class=fn>int <a href="#deviceHeight"><b>deviceHeight</b></a> () const</li>
<li class=fn>uchar * <a href="#base"><b>base</b></a> () const</li>
<li class=fn>virtual uchar * <a href="#cache"><b>cache</b></a> ( int, int )</li>
<li class=fn>virtual void <a href="#uncache"><b>uncache</b></a> ( uchar * )</li>
<li class=fn>int <a href="#screenSize"><b>screenSize</b></a> () const</li>
<li class=fn>int <a href="#totalSize"><b>totalSize</b></a> () const</li>
<li class=fn>QRgb * <a href="#clut"><b>clut</b></a> ()</li>
<li class=fn>int <a href="#numCols"><b>numCols</b></a> ()</li>
<li class=fn>virtual QSize <a href="#mapToDevice"><b>mapToDevice</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;s ) const</li>
<li class=fn>virtual QSize <a href="#mapFromDevice"><b>mapFromDevice</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;s ) const</li>
<li class=fn>virtual QPoint <a href="#mapToDevice-2"><b>mapToDevice</b></a> ( const QPoint &amp;, const QSize &amp; ) const</li>
<li class=fn>virtual QPoint <a href="#mapFromDevice-2"><b>mapFromDevice</b></a> ( const QPoint &amp;, const QSize &amp; ) const</li>
<li class=fn>virtual QRect <a href="#mapToDevice-3"><b>mapToDevice</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r, const QSize &amp; ) const</li>
<li class=fn>virtual QRect <a href="#mapFromDevice-3"><b>mapFromDevice</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r, const QSize &amp; ) const</li>
<li class=fn>virtual QImage <a href="#mapToDevice-4"><b>mapToDevice</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;i ) const</li>
<li class=fn>virtual QImage <a href="#mapFromDevice-4"><b>mapFromDevice</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;i ) const</li>
<li class=fn>virtual QRegion <a href="#mapToDevice-5"><b>mapToDevice</b></a> ( const&nbsp;QRegion&nbsp;&amp;&nbsp;r, const QSize &amp; ) const</li>
<li class=fn>virtual QRegion <a href="#mapFromDevice-5"><b>mapFromDevice</b></a> ( const&nbsp;QRegion&nbsp;&amp;&nbsp;r, const QSize &amp; ) const</li>
<li class=fn>virtual int <a href="#transformOrientation"><b>transformOrientation</b></a> () const</li>
<li class=fn>virtual bool <a href="#isTransformed"><b>isTransformed</b></a> () const</li>
<li class=fn>virtual bool <a href="#isInterlaced"><b>isInterlaced</b></a> () const</li>
<li class=fn>virtual void <a href="#setDirty"><b>setDirty</b></a> ( const QRect &amp; )</li>
<li class=fn>int * <a href="#opType"><b>opType</b></a> ()</li>
<li class=fn>int * <a href="#lastOp"><b>lastOp</b></a> ()</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



The QScreen class and its descendants manage the framebuffer and
palette.
<p> QScreens act as factories for the screen cursor and QGfx's. QLinuxFbScreen
manages a Linux framebuffer; accelerated drivers subclass QLinuxFbScreen.
There can only be one screen in a Qt/Embedded application.
<p>See also <a href="qws.html">Qt/Embedded</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QScreen"></a>QScreen::QScreen ( int&nbsp;display_id )
</h3>

Create a screen; the <em>display_id</em> is the number of the Qt/Embedded server
to connect to.

<h3 class=fn><a name="~QScreen"></a>QScreen::~QScreen ()<tt> [virtual]</tt>
</h3>
Destroys a QScreen

<h3 class=fn>int <a name="alloc"></a>QScreen::alloc ( unsigned&nbsp;int&nbsp;r, unsigned&nbsp;int&nbsp;g, unsigned&nbsp;int&nbsp;b )<tt> [virtual]</tt>
</h3>
Given an RGB value <em>r</em> <em>g</em> <em>b</em>, return an index which is the closest
match to it in the screen's palette. Used in paletted modes only.

<h3 class=fn>uchar * <a name="base"></a>QScreen::base () const
</h3>

Returns a pointer to the start of the framebuffer.

<h3 class=fn>void <a name="blank"></a>QScreen::blank ( bool&nbsp;on )<tt> [virtual]</tt>
</h3>

If <em>on</em> is true, blank the screen. Otherwise unblank it.

<h3 class=fn>uchar * <a name="cache"></a>QScreen::cache ( int, int )<tt> [virtual]</tt>
</h3>

This function is used to store pixmaps in graphics memory for the
use of the accelerated drivers. See QLinuxFbScreen (where the cacheing
is implemented) for more information.

<h3 class=fn>QRgb * <a name="clut"></a>QScreen::clut ()
</h3>

Returns the screen's color lookup table (color palette). This is only
valid in paletted modes (8bpp and lower).

<h3 class=fn>bool <a name="connect"></a>QScreen::connect ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;displaySpec )<tt> [pure virtual]</tt>
</h3>

This function is called by every Qt/Embedded application on startup.
It maps in the framebuffer and in the accelerated drivers the graphics
card control registers. <em>displaySpec</em> has the following syntax:
<p>
<tt>[gfx driver][:driver specific options][:display number]</tt>
<p>
for example if you want to use the mach64 driver on fb1 as display 2:
<p>
<tt>Mach64:/dev/fb1:2</tt>
<p>
<em>displaySpec</em> is passed in via the QWS_DISPLAY environment variable
or the -display command line parameter.

<h3 class=fn>QGfx * <a name="createGfx"></a>QScreen::createGfx ( unsigned&nbsp;char&nbsp;*&nbsp;bytes, int&nbsp;w, int&nbsp;h, int&nbsp;d, int&nbsp;linestep )<tt> [virtual]</tt>
</h3>

Creates a gfx on an arbitrary buffer <em>bytes</em>, width <em>w</em> and height <em>h</em> in
pixels, depth <em>d</em> and <em>linestep</em> (length in bytes of each line in the
buffer). Accelerated drivers can check to see if <em>bytes</em> points into
graphics memory and create an accelerated Gfx.

<h3 class=fn>int <a name="depth"></a>QScreen::depth () const
</h3>

Gives the depth in bits per pixel of the framebuffer. This is the number
of bits each pixel takes up rather than the number of significant bits,
so 24bpp and 32bpp express the same range of colors (8 bits of
red, green and blue)

<h3 class=fn>int <a name="deviceHeight"></a>QScreen::deviceHeight () const
</h3>

Gives the full height of the framebuffer device, as opposed to the
height which Qt/Embedded will actually use. These can differ if the
display is centered within the framebuffer.

<h3 class=fn>int <a name="deviceWidth"></a>QScreen::deviceWidth () const
</h3>

Gives the full width of the framebuffer device, as opposed to the
width which Qt/Embedded will actually use. These can differ if the
display is centered within the framebuffer.

<h3 class=fn>void <a name="disconnect"></a>QScreen::disconnect ()<tt> [pure virtual]</tt>
</h3>

This function is called by every Qt/Embedded application just
before exitting; it's normally used to unmap the framebuffer.

<h3 class=fn>int <a name="height"></a>QScreen::height () const
</h3>

Gives the height in pixels of the framebuffer.

<h3 class=fn>int <a name="initCursor"></a>QScreen::initCursor ( void&nbsp;*&nbsp;end_of_location, bool&nbsp;init = FALSE )<tt> [virtual]</tt>
</h3>
This is used to initialize the software cursor - <em>end_of_location</em>
points to the address after the area where the cursor image can be stored.
<em>init</em> is true for the first application this method is called from
(the Qt/Embedded server), false otherwise.

<h3 class=fn>bool <a name="initDevice"></a>QScreen::initDevice ()<tt> [pure virtual]</tt>
</h3>

This function is called by the Qt/Embedded server when initializing
the framebuffer. Accelerated drivers use it to set up the graphics card.

<h3 class=fn>bool <a name="isInterlaced"></a>QScreen::isInterlaced () const<tt> [virtual]</tt>
</h3>

<p> Returns TRUE if the display is interlaced (for instance a
television screen); otherwise returns FALSE. If TRUE, drawing is
altered to look better on such displays.

<h3 class=fn>bool <a name="isTransformed"></a>QScreen::isTransformed () const<tt> [virtual]</tt>
</h3>

<p> Returns TRUE if the screen is transformed (for instance, rotated
90 degrees); otherwise returns FALSE. QScreen's version always
returns FALSE.

<h3 class=fn>int * <a name="lastOp"></a>QScreen::lastOp ()
</h3>

<p> Returns the screens last operation.

<h3 class=fn>int <a name="linestep"></a>QScreen::linestep () const
</h3>

Returns the length in bytes of each scanline of the framebuffer.

<h3 class=fn><a href="qsize.html">QSize</a> <a name="mapFromDevice"></a>QScreen::mapFromDevice ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;s ) const<tt> [virtual]</tt>
</h3>

<p> Map a framebuffer coordinate to the coordinate space used by the
application. Used by the rotated driver; the QScreen
implementation simply returns <em>s</em>.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapFromDevice-2"></a>QScreen::mapFromDevice ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Map a framebuffer coordinate to the coordinate space used by the
application. Used by the rotated driver; the QScreen
implementation simply returns the point.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="mapFromDevice-3"></a>QScreen::mapFromDevice ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Map a framebuffer coordinate to the coordinate space used by the
application. Used by the rotated driver; the QScreen
implementation simply returns <em>r</em>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="mapFromDevice-4"></a>QScreen::mapFromDevice ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;i ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Transforms an image so that it matches the application coordinate
space (e.g. rotating it 90 degrees counter-clockwise). The QScreen
implementation simply returns <em>i</em>.

<h3 class=fn><a href="qregion.html">QRegion</a> <a name="mapFromDevice-5"></a>QScreen::mapFromDevice ( const&nbsp;<a href="qregion.html">QRegion</a>&nbsp;&amp;&nbsp;r, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Transforms a region so that it matches the application coordinate
space (e.g. rotating it 90 degrees counter-clockwise). The QScreen
implementation simply returns <em>r</em>.

<h3 class=fn><a href="qsize.html">QSize</a> <a name="mapToDevice"></a>QScreen::mapToDevice ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;s ) const<tt> [virtual]</tt>
</h3>

<p> Map a user coordinate to the one to actually draw. Used by the
rotated driver; the QScreen implementation simply returns <em>s</em>.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="mapToDevice-2"></a>QScreen::mapToDevice ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Map a user coordinate to the one to actually draw. Used by the
rotated driver; the QScreen implementation simply returns the
point passed in.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="mapToDevice-3"></a>QScreen::mapToDevice ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Map a user coordinate to the one to actually draw. Used by the
rotated driver; the QScreen implementation simply returns <em>r</em>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="mapToDevice-4"></a>QScreen::mapToDevice ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;i ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Transforms an image so that it fits the device coordinate space
(e.g. rotating it 90 degrees clockwise). The QScreen
implementation simply returns <em>i</em>.

<h3 class=fn><a href="qregion.html">QRegion</a> <a name="mapToDevice-5"></a>QScreen::mapToDevice ( const&nbsp;<a href="qregion.html">QRegion</a>&nbsp;&amp;&nbsp;r, const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp; ) const<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Transforms a region so that it fits the device coordinate space
(e.g. rotating it 90 degrees clockwise). The QScreen
implementation simply returns <em>r</em>.

<h3 class=fn>int <a name="numCols"></a>QScreen::numCols ()
</h3>

Returns the number of entries in the color table returned by <a href="#clut">clut</a>().

<h3 class=fn>bool <a name="onCard"></a>QScreen::onCard ( unsigned&nbsp;char&nbsp;*&nbsp;p ) const<tt> [virtual]</tt>
</h3>

Returns true if the buffer pointed to by <em>p</em> is within graphics card
memory, false if it's in main RAM.

<h3 class=fn>bool <a name="onCard-2"></a>QScreen::onCard ( unsigned&nbsp;char&nbsp;*&nbsp;p, ulong&nbsp;&amp;&nbsp;offset ) const<tt> [virtual]</tt>
</h3>

This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This checks whether the buffer specified by <em>p</em> is on the card
(as per the other version of onCard) and returns an offset in bytes
from the start of graphics card memory in <em>offset</em> if it is.

<h3 class=fn>int * <a name="opType"></a>QScreen::opType ()
</h3>

<p> Returns the screen's operation type.

<h3 class=fn>int <a name="pixelType"></a>QScreen::pixelType () const
</h3>

Returns an integer (taking the same values as QGfx::PixelType)
that specifies the pixel storage format of the screen.

<h3 class=fn>int <a name="pixmapDepth"></a>QScreen::pixmapDepth () const<tt> [virtual]</tt>
</h3>

Gives the preferred depth for pixmaps. By default this is the same
as the screen depth, but for the VGA16 driver it's 8bpp.

<h3 class=fn>int <a name="pixmapLinestepAlignment"></a>QScreen::pixmapLinestepAlignment ()<tt> [virtual]</tt>
</h3>

Returns the value in bits to which individual scanlines of pixmaps held in
graphics card memory should be aligned. This is only useful for accelerated
drivers. By default the value returned is 64 but it can be overridden
by individual accelerated drivers.

<h3 class=fn>int <a name="pixmapOffsetAlignment"></a>QScreen::pixmapOffsetAlignment ()<tt> [virtual]</tt>
</h3>

Returns the value in bits to which the start address of pixmaps held in
graphics card memory should be aligned. This is only useful for accelerated
drivers. By default the value returned is 64 but it can be overridden
by individual accelerated drivers.

<h3 class=fn>void <a name="restore"></a>QScreen::restore ()<tt> [virtual]</tt>
</h3>
Restores the state of the graphics card from a previous <a href="#save">save</a>()

<h3 class=fn>void <a name="save"></a>QScreen::save ()<tt> [virtual]</tt>
</h3>
Saves the state of the graphics card - used so that, for instance,
the palette can be restored when switching between linux virtual
consoles. Hardware QScreen descendants should save register state
here if necessary if switching between virtual consoles (for
example to/from X) is to be permitted.

<h3 class=fn>QGfx * <a name="screenGfx"></a>QScreen::screenGfx ()<tt> [virtual]</tt>
</h3>
Returns a QGfx (normally a QGfxRaster) initialized to point to the screen,
with an origin at 0,0 and a clip region covering the whole screen.

<h3 class=fn>int <a name="screenSize"></a>QScreen::screenSize () const
</h3>

Returns the size in bytes of the screen. This is always located at
the beginning of framebuffer memory (i.e. at <a href="#base">base</a>()).

<h3 class=fn>void <a name="set"></a>QScreen::set ( unsigned int, unsigned int, unsigned int, unsigned int )<tt> [virtual]</tt>
</h3>
Sets an entry in the color palette.

<h3 class=fn>void <a name="setDirty"></a>QScreen::setDirty ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp; )<tt> [virtual]</tt>
</h3>

<p> Indicates which section of the screen has been altered. Used by
the VNC and VFB displays; the QScreen version does nothing.

<h3 class=fn>void <a name="setMode"></a>QScreen::setMode ( int, int, int )<tt> [pure virtual]</tt>
</h3>

This function can be used to set the framebuffer width, height and
depth. It's currently unused.

<h3 class=fn>void <a name="shutdownDevice"></a>QScreen::shutdownDevice ()<tt> [virtual]</tt>
</h3>
Called by the Qt/Embedded server on shutdown; never called by
a Qt/Embedded client. This is intended to support graphics card specific
shutdown; the unaccelerated implementation simply hides the mouse cursor.

<h3 class=fn>bool <a name="supportsDepth"></a>QScreen::supportsDepth ( int&nbsp;d ) const<tt> [virtual]</tt>
</h3>

Returns true if the screen supports a particular color depth <em>d</em>.
Possible values are 1,4,8,16 and 32.

<h3 class=fn>int <a name="totalSize"></a>QScreen::totalSize () const
</h3>

Returns the size in bytes of available graphics card memory, including the
screen. Offscreen memory is only used by the accelerated drivers.

<h3 class=fn>int <a name="transformOrientation"></a>QScreen::transformOrientation () const<tt> [virtual]</tt>
</h3>

<p> Used by the rotated server. The QScreeen implementation returns 0.

<h3 class=fn>void <a name="uncache"></a>QScreen::uncache ( uchar * )<tt> [virtual]</tt>
</h3>

This function is called on pixmap destruction to remove them from
graphics card memory.

<h3 class=fn>int <a name="width"></a>QScreen::width () const
</h3>

Gives the width in pixels of the framebuffer.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
