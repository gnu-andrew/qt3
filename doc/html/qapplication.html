<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qapplication.cpp:76 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QApplication Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QApplication Class Reference</h1>

<p>The QApplication class manages the GUI application's control
flow and main settings.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qapplication-h.html">qapplication.h</a>&gt;</tt>
<p>Inherits <a href="qobject.html">QObject</a>.
<p><a href="qapplication-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QApplication"><b>QApplication</b></a> ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv )</li>
<li class=fn><a href="#QApplication-2"><b>QApplication</b></a> ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv, bool&nbsp;GUIenabled )</li>
<li class=fn>enum <a href="#Type-enum"><b>Type</b></a> { Tty, GuiClient, GuiServer }</li>
<li class=fn><a href="#QApplication-3"><b>QApplication</b></a> ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv, Type&nbsp;type )</li>
<li class=fn><a href="#QApplication-4"><b>QApplication</b></a> ( Display&nbsp;*&nbsp;dpy, HANDLE&nbsp;visual = 0, HANDLE&nbsp;colormap = 0 )</li>
<li class=fn><a href="#QApplication-5"><b>QApplication</b></a> ( Display&nbsp;*&nbsp;dpy, int&nbsp;argc, char&nbsp;**&nbsp;argv, HANDLE&nbsp;visual = 0, HANDLE&nbsp;colormap = 0 )</li>
<li class=fn>virtual <a href="#~QApplication"><b>~QApplication</b></a> ()</li>
<li class=fn>int <a href="#argc"><b>argc</b></a> () const</li>
<li class=fn>char ** <a href="#argv"><b>argv</b></a> () const</li>
<li class=fn>Type <a href="#type"><b>type</b></a> () const</li>
<li class=fn>enum <a href="#ColorSpec-enum"><b>ColorSpec</b></a> { NormalColor = 0, CustomColor = 1, ManyColor = 2 }</li>
<li class=fn>QWidget * <a href="#mainWidget"><b>mainWidget</b></a> () const</li>
<li class=fn>virtual void <a href="#setMainWidget"><b>setMainWidget</b></a> ( QWidget&nbsp;*&nbsp;mainWidget )</li>
<li class=fn>virtual void <a href="#polish"><b>polish</b></a> ( QWidget&nbsp;*&nbsp;w )</li>
<li class=fn>QWidget * <a href="#focusWidget"><b>focusWidget</b></a> () const</li>
<li class=fn>QWidget * <a href="#activeWindow"><b>activeWindow</b></a> () const</li>
<li class=fn>int <a href="#exec"><b>exec</b></a> ()</li>
<li class=fn>void <a href="#processEvents"><b>processEvents</b></a> ()</li>
<li class=fn>void <a href="#processEvents-2"><b>processEvents</b></a> ( int&nbsp;maxtime )</li>
<li class=fn>void processOneEvent () &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool <a href="#hasPendingEvents"><b>hasPendingEvents</b></a> ()</li>
<li class=fn>int enter_loop () &nbsp;<em>(obsolete)</em></li>
<li class=fn>void exit_loop () &nbsp;<em>(obsolete)</em></li>
<li class=fn>int loopLevel () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>virtual bool <a href="#notify"><b>notify</b></a> ( QObject&nbsp;*&nbsp;receiver, QEvent&nbsp;*&nbsp;e )</li>
<li class=fn>void setDefaultCodec ( QTextCodec&nbsp;*&nbsp;codec ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>QTextCodec * defaultCodec () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>void <a href="#installTranslator"><b>installTranslator</b></a> ( QTranslator&nbsp;*&nbsp;mf )</li>
<li class=fn>void <a href="#removeTranslator"><b>removeTranslator</b></a> ( QTranslator&nbsp;*&nbsp;mf )</li>
<li class=fn>enum <a href="#Encoding-enum"><b>Encoding</b></a> { DefaultCodec, UnicodeUTF8 }</li>
<li class=fn>QString <a href="#translate"><b>translate</b></a> ( const&nbsp;char&nbsp;*&nbsp;context, const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment = 0, Encoding&nbsp;encoding = DefaultCodec ) const</li>
<li class=fn>QString <a href="#applicationDirPath"><b>applicationDirPath</b></a> ()</li>
<li class=fn>QString <a href="#applicationFilePath"><b>applicationFilePath</b></a> ()</li>
<li class=fn>virtual bool <a href="#macEventFilter"><b>macEventFilter</b></a> ( EventHandlerCallRef, EventRef )</li>
<li class=fn>virtual bool <a href="#winEventFilter"><b>winEventFilter</b></a> ( MSG * )</li>
<li class=fn>virtual bool <a href="#x11EventFilter"><b>x11EventFilter</b></a> ( XEvent * )</li>
<li class=fn>int <a href="#x11ProcessEvent"><b>x11ProcessEvent</b></a> ( XEvent&nbsp;*&nbsp;event )</li>
<li class=fn>virtual bool <a href="#qwsEventFilter"><b>qwsEventFilter</b></a> ( QWSEvent * )</li>
<li class=fn>void <a href="#qwsSetCustomColors"><b>qwsSetCustomColors</b></a> ( QRgb&nbsp;*&nbsp;colorTable, int&nbsp;start, int&nbsp;numColors )</li>
<li class=fn>void <a href="#winFocus"><b>winFocus</b></a> ( QWidget&nbsp;*&nbsp;widget, bool&nbsp;gotFocus )</li>
<li class=fn>bool <a href="#isSessionRestored"><b>isSessionRestored</b></a> () const</li>
<li class=fn>QString <a href="#sessionId"><b>sessionId</b></a> () const</li>
<li class=fn>QString <a href="#sessionKey"><b>sessionKey</b></a> () const</li>
<li class=fn>virtual void <a href="#commitData"><b>commitData</b></a> ( QSessionManager&nbsp;&amp;&nbsp;sm )</li>
<li class=fn>virtual void <a href="#saveState"><b>saveState</b></a> ( QSessionManager&nbsp;&amp;&nbsp;sm )</li>
<li class=fn>void <a href="#wakeUpGuiThread"><b>wakeUpGuiThread</b></a> ()</li>
<li class=fn>void <a href="#lock"><b>lock</b></a> ()</li>
<li class=fn>void <a href="#unlock"><b>unlock</b></a> ( bool&nbsp;wakeUpGui = TRUE )</li>
<li class=fn>bool <a href="#locked"><b>locked</b></a> ()</li>
<li class=fn>bool <a href="#tryLock"><b>tryLock</b></a> ()</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>void <a href="#quit"><b>quit</b></a> ()</li>
<li class=fn>void <a href="#closeAllWindows"><b>closeAllWindows</b></a> ()</li>
<li class=fn>void <a href="#aboutQt"><b>aboutQt</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#lastWindowClosed"><b>lastWindowClosed</b></a> ()</li>
<li class=fn>void <a href="#aboutToQuit"><b>aboutToQuit</b></a> ()</li>
<li class=fn>void <a href="#guiThreadAwake"><b>guiThreadAwake</b></a> ()</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QStyle &amp; <a href="#style"><b>style</b></a> ()</li>
<li class=fn>void <a href="#setStyle"><b>setStyle</b></a> ( QStyle&nbsp;*&nbsp;style )</li>
<li class=fn>QStyle * <a href="#setStyle-2"><b>setStyle</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;style )</li>
<li class=fn>int <a href="#colorSpec"><b>colorSpec</b></a> ()</li>
<li class=fn>void <a href="#setColorSpec"><b>setColorSpec</b></a> ( int&nbsp;spec )</li>
<li class=fn>QCursor * <a href="#overrideCursor"><b>overrideCursor</b></a> ()</li>
<li class=fn>void <a href="#setOverrideCursor"><b>setOverrideCursor</b></a> ( const&nbsp;QCursor&nbsp;&amp;&nbsp;cursor, bool&nbsp;replace = FALSE )</li>
<li class=fn>void <a href="#restoreOverrideCursor"><b>restoreOverrideCursor</b></a> ()</li>
<li class=fn>bool <a href="#hasGlobalMouseTracking"><b>hasGlobalMouseTracking</b></a> ()</li>
<li class=fn>void <a href="#setGlobalMouseTracking"><b>setGlobalMouseTracking</b></a> ( bool&nbsp;enable )</li>
<li class=fn>QPalette <a href="#palette"><b>palette</b></a> ( const&nbsp;QWidget&nbsp;*&nbsp;w = 0 )</li>
<li class=fn>void <a href="#setPalette"><b>setPalette</b></a> ( const&nbsp;QPalette&nbsp;&amp;&nbsp;palette, bool&nbsp;informWidgets = FALSE, const&nbsp;char&nbsp;*&nbsp;className = 0 )</li>
<li class=fn>QFont <a href="#font"><b>font</b></a> ( const&nbsp;QWidget&nbsp;*&nbsp;w = 0 )</li>
<li class=fn>void <a href="#setFont"><b>setFont</b></a> ( const&nbsp;QFont&nbsp;&amp;&nbsp;font, bool&nbsp;informWidgets = FALSE, const&nbsp;char&nbsp;*&nbsp;className = 0 )</li>
<li class=fn>QFontMetrics <a href="#fontMetrics"><b>fontMetrics</b></a> ()</li>
<li class=fn>QWidgetList * <a href="#allWidgets"><b>allWidgets</b></a> ()</li>
<li class=fn>QWidgetList * <a href="#topLevelWidgets"><b>topLevelWidgets</b></a> ()</li>
<li class=fn>QDesktopWidget * <a href="#desktop"><b>desktop</b></a> ()</li>
<li class=fn>QWidget * <a href="#activePopupWidget"><b>activePopupWidget</b></a> ()</li>
<li class=fn>QWidget * <a href="#activeModalWidget"><b>activeModalWidget</b></a> ()</li>
<li class=fn>QClipboard * <a href="#clipboard"><b>clipboard</b></a> ()</li>
<li class=fn>QWidget * <a href="#widgetAt"><b>widgetAt</b></a> ( int&nbsp;x, int&nbsp;y, bool&nbsp;child = FALSE )</li>
<li class=fn>QWidget * <a href="#widgetAt-2"><b>widgetAt</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;pos, bool&nbsp;child = FALSE )</li>
<li class=fn>QEventLoop * <a href="#eventLoop"><b>eventLoop</b></a> ()</li>
<li class=fn>void <a href="#exit"><b>exit</b></a> ( int&nbsp;retcode = 0 )</li>
<li class=fn>bool <a href="#sendEvent"><b>sendEvent</b></a> ( QObject&nbsp;*&nbsp;receiver, QEvent&nbsp;*&nbsp;event )</li>
<li class=fn>void <a href="#postEvent"><b>postEvent</b></a> ( QObject&nbsp;*&nbsp;receiver, QEvent&nbsp;*&nbsp;event )</li>
<li class=fn>void <a href="#sendPostedEvents"><b>sendPostedEvents</b></a> ( QObject&nbsp;*&nbsp;receiver, int&nbsp;event_type )</li>
<li class=fn>void <a href="#sendPostedEvents-2"><b>sendPostedEvents</b></a> ()</li>
<li class=fn>void <a href="#removePostedEvents"><b>removePostedEvents</b></a> ( QObject&nbsp;*&nbsp;receiver )</li>
<li class=fn>bool <a href="#startingUp"><b>startingUp</b></a> ()</li>
<li class=fn>bool <a href="#closingDown"><b>closingDown</b></a> ()</li>
<li class=fn>void <a href="#flushX"><b>flushX</b></a> ()</li>
<li class=fn>void <a href="#flush"><b>flush</b></a> ()</li>
<li class=fn>void <a href="#syncX"><b>syncX</b></a> ()</li>
<li class=fn>void <a href="#beep"><b>beep</b></a> ()</li>
<li class=fn>void setWinStyleHighlightColor ( const&nbsp;QColor&nbsp;&amp;&nbsp;c ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>const QColor &amp; winStyleHighlightColor () &nbsp;<em>(obsolete)</em></li>
<li class=fn>void <a href="#setDesktopSettingsAware"><b>setDesktopSettingsAware</b></a> ( bool&nbsp;on )</li>
<li class=fn>bool <a href="#desktopSettingsAware"><b>desktopSettingsAware</b></a> ()</li>
<li class=fn>void <a href="#setCursorFlashTime"><b>setCursorFlashTime</b></a> ( int&nbsp;msecs )</li>
<li class=fn>int <a href="#cursorFlashTime"><b>cursorFlashTime</b></a> ()</li>
<li class=fn>void <a href="#setDoubleClickInterval"><b>setDoubleClickInterval</b></a> ( int&nbsp;ms )</li>
<li class=fn>int <a href="#doubleClickInterval"><b>doubleClickInterval</b></a> ()</li>
<li class=fn>void <a href="#setWheelScrollLines"><b>setWheelScrollLines</b></a> ( int&nbsp;n )</li>
<li class=fn>int <a href="#wheelScrollLines"><b>wheelScrollLines</b></a> ()</li>
<li class=fn>void <a href="#setGlobalStrut"><b>setGlobalStrut</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;strut )</li>
<li class=fn>QSize <a href="#globalStrut"><b>globalStrut</b></a> ()</li>
<li class=fn>void <a href="#setLibraryPaths"><b>setLibraryPaths</b></a> ( const&nbsp;QStringList&nbsp;&amp;&nbsp;paths )</li>
<li class=fn>QStringList <a href="#libraryPaths"><b>libraryPaths</b></a> ()</li>
<li class=fn>void <a href="#addLibraryPath"><b>addLibraryPath</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;path )</li>
<li class=fn>void <a href="#removeLibraryPath"><b>removeLibraryPath</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;path )</li>
<li class=fn>void <a href="#setStartDragTime"><b>setStartDragTime</b></a> ( int&nbsp;ms )</li>
<li class=fn>int <a href="#startDragTime"><b>startDragTime</b></a> ()</li>
<li class=fn>void <a href="#setStartDragDistance"><b>setStartDragDistance</b></a> ( int&nbsp;l )</li>
<li class=fn>int <a href="#startDragDistance"><b>startDragDistance</b></a> ()</li>
<li class=fn>void <a href="#setReverseLayout"><b>setReverseLayout</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#reverseLayout"><b>reverseLayout</b></a> ()</li>
<li class=fn>int <a href="#horizontalAlignment"><b>horizontalAlignment</b></a> ( int&nbsp;align )</li>
<li class=fn>bool <a href="#isEffectEnabled"><b>isEffectEnabled</b></a> ( Qt::UIEffect&nbsp;effect )</li>
<li class=fn>void <a href="#setEffectEnabled"><b>setEffectEnabled</b></a> ( Qt::UIEffect&nbsp;effect, bool&nbsp;enable = TRUE )</li>
<li class=fn>QWSDecoration &amp; <a href="#qwsDecoration"><b>qwsDecoration</b></a> ()</li>
<li class=fn>void <a href="#qwsSetDecoration"><b>qwsSetDecoration</b></a> ( QWSDecoration&nbsp;*&nbsp;d )</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>void <a href="#qAddPostRoutine"><b>qAddPostRoutine</b></a> ( QtCleanUpFunction&nbsp;p )</li>
<li class=fn>const char * <a href="#qVersion"><b>qVersion</b></a> ()</li>
<li class=fn>bool <a href="#qSysInfo"><b>qSysInfo</b></a> ( int&nbsp;*&nbsp;wordSize, bool&nbsp;*&nbsp;bigEndian )</li>
<li class=fn>void <a href="#qDebug"><b>qDebug</b></a> ( const&nbsp;char&nbsp;*&nbsp;msg, ... )</li>
<li class=fn>void <a href="#qWarning"><b>qWarning</b></a> ( const&nbsp;char&nbsp;*&nbsp;msg, ... )</li>
<li class=fn>void <a href="#qFatal"><b>qFatal</b></a> ( const&nbsp;char&nbsp;*&nbsp;msg, ... )</li>
<li class=fn>void <a href="#qSystemWarning"><b>qSystemWarning</b></a> ( const&nbsp;char&nbsp;*&nbsp;msg, int&nbsp;code )</li>
<li class=fn>void <a href="#Q_ASSERT"><b>Q_ASSERT</b></a> ( bool&nbsp;test )</li>
<li class=fn>void <a href="#Q_CHECK_PTR"><b>Q_CHECK_PTR</b></a> ( void&nbsp;*&nbsp;p )</li>
<li class=fn>QtMsgHandler <a href="#qInstallMsgHandler"><b>qInstallMsgHandler</b></a> ( QtMsgHandler&nbsp;h )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QApplication class manages the GUI application's control
flow and main settings.
<p> 

<p> It contains the main event loop, where all events from the window
system and other sources are processed and dispatched. It also
handles the application's initialization and finalization, and
provides session management. It also handles most system-wide and
application-wide settings.
<p> For any GUI application that uses Qt, there is precisely one
QApplication object, no matter whether the application has 0, 1, 2
or more windows at any time.
<p> The QApplication object is accessible through the global pointer <tt>qApp</tt>. Its main areas of responsibility are:
<ul>
<p> <li> It initializes the application with the user's desktop settings
such as <a href="#palette">palette</a>(), <a href="#font">font</a>() and <a href="#doubleClickInterval">doubleClickInterval</a>(). It keeps track
of these properties in case the user changes the desktop globally, for
example through some kind of control panel.
<p> <li> It performs event handling, meaning that it receives events
from the underlying window system and dispatches them to the relevant
widgets. By using <a href="#sendEvent">sendEvent</a>() and <a href="#postEvent">postEvent</a>() you can send your own
events to widgets.
<p> <li> It parses common command line arguments and sets its internal
state accordingly. See the <a href="#QApplication">constructor documentation</a> below for more details about this.
<p> <li> It defines the application's look and feel, which is
encapsulated in a <a href="qstyle.html">QStyle</a> object. This can be changed at runtime
with <a href="#setStyle">setStyle</a>().
<p> <li> It specifies how the application is to allocate colors.
See <a href="#setColorSpec">setColorSpec</a>() for details.
<p> <li> It provides <a href="i18n.html#localization">localization</a> of strings that are visible to the user
via <a href="#translate">translate</a>().
<p> <li> It provides some magical objects like the <a href="#desktop">desktop</a>() and the
<a href="#clipboard">clipboard</a>().
<p> <li> It knows about the application's windows. You can ask which
widget is at a certain position using <a href="#widgetAt">widgetAt</a>(), get a list of
<a href="#topLevelWidgets">topLevelWidgets</a>() and <a href="#closeAllWindows">closeAllWindows</a>(), etc.
<p> <li> It manages the application's mouse cursor handling,
see <a href="#setOverrideCursor">setOverrideCursor</a>() and <a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>().
<p> <li> On the X window system, it provides functions to flush and sync
the communication stream, see <a href="#flushX">flushX</a>() and <a href="#syncX">syncX</a>().
<p> <li> It provides support for sophisticated <a href="session.html">session management</a>. This makes it possible
for applications to terminate gracefully when the user logs out, to
cancel a shutdown process if termination isn't possible and even to
preserve the entire application's state for a future session. See
<a href="#isSessionRestored">isSessionRestored</a>(), <a href="#sessionId">sessionId</a>() and <a href="#commitData">commitData</a>() and <a href="#saveState">saveState</a>()
for details.
<p> </ul>
<p> The <a href="simple-application.html">Application walk-through
example</a> contains a typical complete main() that does the usual
things with QApplication.
<p> Since the QApplication object does so much initialization, it
<b>must</b> be created before any other objects related to the user
interface are created.
<p> Since it also deals with common command line arguments, it is
usually a good idea to create it <em>before</em> any interpretation or
modification of <tt>argv</tt> is done in the application itself. (Note
also that for X11, <a href="#setMainWidget">setMainWidget</a>() may change the main widget
according to the <tt>-geometry</tt> option. To preserve this
functionality, you must set your defaults before setMainWidget() and
any overrides after.)
<p> <center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top" colspan="2" rowspan="1"> Groups of functions
<tr bgcolor="#f0f0f0">
<td valign="top">System settings
<td valign="top">
<a href="#desktopSettingsAware">desktopSettingsAware</a>(),
<a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>(),
<a href="#cursorFlashTime">cursorFlashTime</a>(),
<a href="#setCursorFlashTime">setCursorFlashTime</a>(),
<a href="#doubleClickInterval">doubleClickInterval</a>(),
<a href="#setDoubleClickInterval">setDoubleClickInterval</a>(),
<a href="#wheelScrollLines">wheelScrollLines</a>(),
<a href="#setWheelScrollLines">setWheelScrollLines</a>(),
<a href="#palette">palette</a>(),
<a href="#setPalette">setPalette</a>(),
<a href="#font">font</a>(),
<a href="#setFont">setFont</a>(),
<a href="#fontMetrics">fontMetrics</a>().
<tr bgcolor="#d0d0d0">
<td valign="top">Event handling
<td valign="top">
<a href="#exec">exec</a>(),
<a href="#processEvents">processEvents</a>(),
<a href="#enter_loop">enter_loop</a>(),
<a href="#exit_loop">exit_loop</a>(),
<a href="#exit">exit</a>(),
<a href="#quit">quit</a>().
<a href="#sendEvent">sendEvent</a>(),
<a href="#postEvent">postEvent</a>(),
<a href="#sendPostedEvents">sendPostedEvents</a>(),
<a href="#removePostedEvents">removePostedEvents</a>(),
<a href="#hasPendingEvents">hasPendingEvents</a>(),
<a href="#notify">notify</a>(),
<a href="#macEventFilter">macEventFilter</a>(),
<a href="#qwsEventFilter">qwsEventFilter</a>(),
<a href="#x11EventFilter">x11EventFilter</a>(),
<a href="#x11ProcessEvent">x11ProcessEvent</a>(),
<a href="#winEventFilter">winEventFilter</a>().
<tr bgcolor="#f0f0f0">
<td valign="top">GUI Styles
<td valign="top">
<a href="#style">style</a>(),
<a href="#setStyle">setStyle</a>(),
<a href="#polish">polish</a>().
<tr bgcolor="#d0d0d0">
<td valign="top">Color usage
<td valign="top">
<a href="#colorSpec">colorSpec</a>(),
<a href="#setColorSpec">setColorSpec</a>(),
<a href="#qwsSetCustomColors">qwsSetCustomColors</a>().
<tr bgcolor="#f0f0f0">
<td valign="top">Text handling
<td valign="top">
<a href="#installTranslator">installTranslator</a>(),
<a href="#removeTranslator">removeTranslator</a>()
<a href="#translate">translate</a>().
<tr bgcolor="#d0d0d0">
<td valign="top">Widgets
<td valign="top">
<a href="#mainWidget">mainWidget</a>(),
<a href="#setMainWidget">setMainWidget</a>(),
<a href="#allWidgets">allWidgets</a>(),
<a href="#topLevelWidgets">topLevelWidgets</a>(),
<a href="#desktop">desktop</a>(),
<a href="#activePopupWidget">activePopupWidget</a>(),
<a href="#activeModalWidget">activeModalWidget</a>(),
<a href="#clipboard">clipboard</a>(),
<a href="#focusWidget">focusWidget</a>(),
<a href="#winFocus">winFocus</a>(),
<a href="#activeWindow">activeWindow</a>(),
<a href="#widgetAt">widgetAt</a>().
<tr bgcolor="#f0f0f0">
<td valign="top">Advanced cursor handling
<td valign="top">
<a href="#hasGlobalMouseTracking">hasGlobalMouseTracking</a>(),
<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>(),
<a href="#overrideCursor">overrideCursor</a>(),
<a href="#setOverrideCursor">setOverrideCursor</a>(),
<a href="#restoreOverrideCursor">restoreOverrideCursor</a>().
<tr bgcolor="#d0d0d0">
<td valign="top">X Window System synchronization
<td valign="top">
<a href="#flushX">flushX</a>(),
<a href="#syncX">syncX</a>().
<tr bgcolor="#f0f0f0">
<td valign="top">Session management
<td valign="top">
<a href="#isSessionRestored">isSessionRestored</a>(),
<a href="#sessionId">sessionId</a>(),
<a href="#commitData">commitData</a>(),
<a href="#saveState">saveState</a>().
<tr bgcolor="#d0d0d0">
<td valign="top">Threading
<td valign="top">
<a href="#lock">lock</a>(), <a href="#unlock">unlock</a>(), <a href="#locked">locked</a>(), <a href="#tryLock">tryLock</a>(),
<a href="#wakeUpGuiThread">wakeUpGuiThread</a>()
<tr bgcolor="#f0f0f0">
<td valign="top">Miscellaneous
<td valign="top">
<a href="#closeAllWindows">closeAllWindows</a>(),
<a href="#startingUp">startingUp</a>(),
<a href="#closingDown">closingDown</a>(),
<a href="#type">type</a>().
</table></center>
<p> <em>Non-GUI programs:</em> While Qt is not optimized or
designed for writing non-GUI programs, it's possible to use
<a href="tools.html">some of its classes</a> without creating a
QApplication. This can be useful if you wish to share code between
a non-GUI server and a GUI client.



<p>See also <a href="application.html">Main Window and Related Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ColorSpec-enum"></a>QApplication::ColorSpec</h3>

<ul>
<li><tt>QApplication::NormalColor</tt> - the default color allocation policy
<li><tt>QApplication::CustomColor</tt> - the same as NormalColor for X11; allocates colors
to a palette on demand under Windows
<li><tt>QApplication::ManyColor</tt> - the right choice for applications that use thousands of
colors
</ul><p> See <a href="#setColorSpec">setColorSpec</a>() for full details.

<h3 class=fn><a name="Encoding-enum"></a>QApplication::Encoding</h3> 
<p> This enum type defines the 8-bit encoding of character string
arguments to <a href="#translate">translate</a>():
<ul>
<li><tt>QApplication::DefaultCodec</tt> - the encoding specified by
<a href="qtextcodec.html#codecForTr">QTextCodec::codecForTr</a>() (Latin-1 if none has been set)
<li><tt>QApplication::UnicodeUTF8</tt> - UTF-8
</ul><p> <p>See also <a href="qobject.html#tr">QObject::tr</a>(), <a href="qobject.html#trUtf8">QObject::trUtf8</a>(), and <a href="qstring.html#fromUtf8">QString::fromUtf8</a>().

<h3 class=fn><a name="Type-enum"></a>QApplication::Type</h3>

<ul>
<li><tt>QApplication::Tty</tt> - a console application
<li><tt>QApplication::GuiClient</tt> - a GUI client application
<li><tt>QApplication::GuiServer</tt> - a GUI server application
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QApplication"></a>QApplication::QApplication ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv )
</h3>
Initializes the window system and constructs an application object
with <em>argc</em> command line arguments in <em>argv</em>.
<p> The global <tt>qApp</tt> pointer refers to this application object. Only
one application object should be created.
<p> This application object must be constructed before any <a href="qpaintdevice.html">paint devices</a> (including widgets, pixmaps, bitmaps
etc.).
<p> Note that <em>argc</em> and <em>argv</em> might be changed. Qt removes command
line arguments that it recognizes. The modified <em>argc</em> and <em>argv</em>
can also be accessed later with <tt>qApp-&gt;argc()</tt> and <tt>qApp-&gt;argv()</tt>.
The documentation for <a href="#argv">argv</a>() contains a detailed description of how
to process command line arguments.
<p> Qt debugging options (not available if Qt was compiled with the
QT_NO_DEBUG flag defined):
<ul>
<li> -nograb, tells Qt that it must never grab the mouse or the keyboard.
<li> -dograb (only under X11), running under a debugger can cause
an implicit -nograb, use -dograb to override.
<li> -sync (only under X11), switches to synchronous mode for
debugging.
</ul>
<p> See <a href="debug.html">Debugging Techniques</a> for a more
detailed explanation.
<p> All Qt programs automatically support the following command line options:
<ul>
<li> -reverse causes text to be formatted for right-to-left languages
rather than in the usual left-to-right direction.
<li> -style= <em>style</em>, sets the application GUI style. Possible values
are <tt>motif</tt>, <tt>windows</tt>, and <tt>platinum</tt>. If you compiled Qt
with additional styles or have additional styles as plugins these
will be available to the <tt>-style</tt> command line option.
<li> -style <em>style</em>, is the same as listed above.
<li> -session= <em>session</em>, restores the application from an earlier
<a href="session.html">session</a>.
<li> -session <em>session</em>, is the same as listed above.
<li> -widgetcount, prints debug message at the end about number of widgets left
undestroyed and maximum number of widgets existed at the same time
</ul>
<p> The X11 version of Qt also supports some traditional X11
command line options:
<ul>
<li> -display <em>display</em>, sets the X display (default is $DISPLAY).
<li> -geometry <em>geometry</em>, sets the client geometry of the
<a href="#setMainWidget">main widget</a>.
<li> -fn or <tt>-font</tt> <em>font</em>, defines the application font. The
font should be specified using an X logical font description.
<li> -bg or <tt>-background</tt> <em>color</em>, sets the default background color
and an application palette (light and dark shades are calculated).
<li> -fg or <tt>-foreground</tt> <em>color</em>, sets the default foreground color.
<li> -btn or <tt>-button</tt> <em>color</em>, sets the default button color.
<li> -name <em>name</em>, sets the application name.
<li> -title <em>title</em>, sets the application title (caption).
<li> -visual <tt>TrueColor</tt>, forces the application to use a TrueColor visual
on an 8-bit display.
<li> -ncols <em>count</em>, limits the number of colors allocated in the
color cube on an 8-bit display, if the application is using the
<a href="#ColorSpec-enum">QApplication::ManyColor</a> color specification. If <em>count</em> is
216 then a 6x6x6 color cube is used (i.e. 6 levels of red, 6 of green,
and 6 of blue); for other values, a cube
approximately proportional to a 2x3x1 cube is used.
<li> -cmap, causes the application to install a private color map
on an 8-bit display.
</ul>
<p> <p>See also <a href="#argc">argc</a>() and <a href="#argv">argv</a>().

<h3 class=fn><a name="QApplication-2"></a>QApplication::QApplication ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv, bool&nbsp;GUIenabled )
</h3>
Constructs an application object with <em>argc</em> command line arguments
in <em>argv</em>. If <em>GUIenabled</em> is TRUE, a GUI application is
constructed, otherwise a non-GUI (console) application is created.
<p> Set <em>GUIenabled</em> to FALSE for programs without a graphical user
interface that should be able to run without a window system.
<p> On X11, the window system is initialized if <em>GUIenabled</em> is TRUE.
If <em>GUIenabled</em> is FALSE, the application does not connect to the
X-server.
On Windows and Macintosh, currently the window system is always
initialized, regardless of the value of GUIenabled. This may change in
future versions of Qt.
<p> The following example shows how to create an application that
uses a graphical interface when available.
<pre>
  int main( int argc, char **argv )
  {
#ifdef Q_WS_X11
    bool useGUI = getenv( "DISPLAY" ) != 0;
#else
    bool useGUI = TRUE;
#endif
    QApplication app(argc, argv, useGUI);

    if ( useGUI ) {
       //start GUI version
       ...
    } else {
       //start non-GUI version
       ...
    }
    return app.<a href="#exec">exec</a>();
  }
</pre>
 

<h3 class=fn><a name="QApplication-3"></a>QApplication::QApplication ( int&nbsp;&amp;&nbsp;argc, char&nbsp;**&nbsp;argv, <a href="qapplication.html#Type-enum">Type</a>&nbsp;type )
</h3>
Constructs an application object with <em>argc</em> command line arguments
in <em>argv</em>.
<p> For Qt/Embedded, passing <a href="#Type-enum">QApplication::GuiServer</a> for <em>type</em>
makes this application the server (equivalent to running with the
-qws option).

<h3 class=fn><a name="QApplication-4"></a>QApplication::QApplication ( Display&nbsp;*&nbsp;dpy, HANDLE&nbsp;visual = 0, HANDLE&nbsp;colormap = 0 )
</h3>
Create an application, given an already open display <em>dpy</em>. If <em>visual</em> and <em>colormap</em> are non-zero, the application will use those as
the default Visual and Colormap contexts.
<p> <b>Warning:</b> Qt only supports TrueColor visuals at depths higher than 8
bits-per-pixel.
<p> This is available only on X11.

<h3 class=fn><a name="QApplication-5"></a>QApplication::QApplication ( Display&nbsp;*&nbsp;dpy, int&nbsp;argc, char&nbsp;**&nbsp;argv, HANDLE&nbsp;visual = 0, HANDLE&nbsp;colormap = 0 )
</h3>
Create an application, given an already open display <em>dpy</em> and using
<em>argc</em> command line arguments in <em>argv</em>. If <em>visual</em> and <em>colormap</em> are non-zero, the application will use those as
the default Visual and Colormap contexts.
<p> <b>Warning:</b> Qt only supports TrueColor visuals at depths higher than 8
bits-per-pixel.
<p> This is available only on X11.
<p> 
<h3 class=fn><a name="~QApplication"></a>QApplication::~QApplication ()<tt> [virtual]</tt>
</h3>
Cleans up any window system resources that were allocated by this
application. Sets the global variable <tt>qApp</tt> to 0.

<h3 class=fn>void <a name="aboutQt"></a>QApplication::aboutQt ()<tt> [slot]</tt>
</h3>
Displays a simple message box about Qt. The message includes the
version number of Qt being used by the application.
<p> This is useful for inclusion in the Help menu of an application.
See the examples/menu/menu.cpp example.
<p> This function is a convenience slot for <a href="qmessagebox.html#aboutQt">QMessageBox::aboutQt</a>().

<h3 class=fn>void <a name="aboutToQuit"></a>QApplication::aboutToQuit ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the application is about to quit the
main event loop, e.g. when the event loop level drops to zero.
This may happen either after a call to <a href="#quit">quit</a>() from inside the
application or when the users shuts down the entire desktop session.
<p> The signal is particularly useful if your application has to do some
last-second cleanup. Note that no user interaction is possible in
this state.
<p> <p>See also <a href="#quit">quit</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="activeModalWidget"></a>QApplication::activeModalWidget ()<tt> [static]</tt>
</h3>
Returns the active modal widget.
<p> A modal widget is a special top level widget which is a subclass of
<a href="qdialog.html">QDialog</a> that specifies the modal parameter of the constructor as
TRUE. A modal widget must be closed before the user can continue
with other parts of the program.
<p> Modal widgets are organized in a stack. This function returns
the active modal widget at the top of the stack.
<p> <p>See also <a href="#activePopupWidget">activePopupWidget</a>() and <a href="#topLevelWidgets">topLevelWidgets</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="activePopupWidget"></a>QApplication::activePopupWidget ()<tt> [static]</tt>
</h3>
Returns the active popup widget.
<p> A popup widget is a special top level widget that sets the <a href="qt.html#WidgetFlags-enum">WType_Popup</a> widget flag, e.g. the <a href="qpopupmenu.html">QPopupMenu</a> widget. When the
application opens a popup widget, all events are sent to the popup.
Normal widgets and modal widgets cannot be accessed before the popup
widget is closed.
<p> Only other popup widgets may be opened when a popup widget is shown.
The popup widgets are organized in a stack. This function returns
the active popup widget at the top of the stack.
<p> <p>See also <a href="#activeModalWidget">activeModalWidget</a>() and <a href="#topLevelWidgets">topLevelWidgets</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="activeWindow"></a>QApplication::activeWindow () const
</h3>

<p> Returns the application top-level window that has the keyboard input
focus, or 0 if no application window has the focus. Note that
there might be an <a href="#activeWindow">activeWindow</a>() even if there is no <a href="#focusWidget">focusWidget</a>(),
for example if no widget in that window accepts key events.
<p> <p>See also <a href="qwidget.html#setFocus">QWidget::setFocus</a>(), <a href="qwidget.html#focus-prop">QWidget::focus</a>, and <a href="#focusWidget">focusWidget</a>().

<p>Example: <a href="mail-example.html#x704">network/mail/smtp.cpp</a>.
<h3 class=fn>void <a name="addLibraryPath"></a>QApplication::addLibraryPath ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;path )<tt> [static]</tt>
</h3>
Append <em>path</em> to the end of the library path list. If <em>path</em> is
empty or already in the path list, the path list is not changed.
<p> The default path list consists of a single entry, the installation
directory for plugins.  The default installation directory for plugins
is <tt>INSTALL/plugins</tt>, where <tt>INSTALL</tt> is the directory where Qt was
installed.
<p> <p>See also <a href="#removeLibraryPath">removeLibraryPath</a>(), <a href="#libraryPaths">libraryPaths</a>(), and <a href="#setLibraryPaths">setLibraryPaths</a>().

<h3 class=fn>QWidgetList * <a name="allWidgets"></a>QApplication::allWidgets ()<tt> [static]</tt>
</h3>
Returns a list of all the widgets in the application.
<p> The list is created using <tt>new</tt> and must be deleted by the caller.
<p> The list is empty (<a href="qptrlist.html#isEmpty">QPtrList::isEmpty</a>()) if there are no widgets.
<p> Note that some of the widgets may be hidden.
<p> Example that updates all widgets:
<pre>
    QWidgetList  *list = QApplication::<a href="#allWidgets">allWidgets</a>();
    QWidgetListIt it( *list );         // iterate over the widgets
    <a href="qwidget.html">QWidget</a> * w;
    while ( (w=it.current()) != 0 ) {  // for each widget...
        ++it;
        w-&gt;<a href="qwidget.html#update">update</a>();
    }
    delete list;                      // delete the list, not the widgets
  </pre>
 
<p> The QWidgetList class is defined in the <tt>qwidgetlist.h</tt> header
file.
<p> <b>Warning:</b> Delete the list as soon as you have finished using it.
The widgets in the list may be deleted by someone else at any time.
<p> <p>See also <a href="#topLevelWidgets">topLevelWidgets</a>(), <a href="qwidget.html#visible-prop">QWidget::visible</a>, and <a href="qptrlist.html#isEmpty">QPtrList::isEmpty</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="applicationDirPath"></a>QApplication::applicationDirPath ()
</h3>
Returns the directory that contains the application executable.
<p> For example, if you have installed Qt in the <tt>C:&#92;Trolltech&#92;Qt</tt>
directory, and you run the <tt>demo</tt> example, this function will
return "C:/Trolltech/Qt/examples/demo".
<p> On Mac OS X this will point to the directory actually containing the
executable, which may be inside of an application bundle (if the
application is bundled).
<p> <b>Warning:</b> On Unix, this function assumes that argv[0] contains the file
name of the executable (which it normally does). It also assumes that
the current directory hasn't been changed by the application.
<p> <p>See also <a href="#applicationFilePath">applicationFilePath</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="applicationFilePath"></a>QApplication::applicationFilePath ()
</h3>
Returns the file path of the application executable.
<p> For example, if you have installed Qt in the <tt>C:&#92;Trolltech&#92;Qt</tt>
directory, and you run the <tt>demo</tt> example, this function will
return "C:/Trolltech/Qt/examples/demo/demo.exe".
<p> <b>Warning:</b> On Unix, this function assumes that argv[0] contains the file
name of the executable (which it normally does). It also assumes that
the current directory hasn't been changed by the application.
<p> <p>See also <a href="#applicationDirPath">applicationDirPath</a>().

<h3 class=fn>int <a name="argc"></a>QApplication::argc () const
</h3>

<p> Returns the number of command line arguments.
<p> The documentation for <a href="#argv">argv</a>() describes how to process command line
arguments.
<p> <p>See also <a href="#argv">argv</a>() and <a href="#QApplication">QApplication::QApplication</a>().

<p>Examples: <a href="tutorial2-04.html#x2557">chart/main.cpp</a> and <a href="scribble-example.html#x906">scribble/scribble.cpp</a>.
<h3 class=fn>char ** <a name="argv"></a>QApplication::argv () const
</h3>

<p> Returns the command line argument vector.
<p> <tt>argv()[0]</tt> is the program name, <tt>argv()[1]</tt> is the first
argument and <tt>argv()[argc()-1]</tt> is the last argument.
<p> A QApplication object is constructed by passing <em>argc</em> and <em>argv</em> from the <tt>main()</tt> function. Some of the arguments may be
recognized as Qt options and removed from the argument vector. For
example, the X11 version of Qt knows about <tt>-display</tt>, <tt>-font</tt>
and a few more options.
<p> Example:
<pre>
        // showargs.cpp - displays program arguments in a list box

        #include &lt;<a href="qapplication-h.html">qapplication.h</a>&gt;
        #include &lt;<a href="qlistbox-h.html">qlistbox.h</a>&gt;

        int main( int argc, char **argv )
        {
            QApplication a( argc, argv );
            <a href="qlistbox.html">QListBox</a> b;
            a.<a href="#setMainWidget">setMainWidget</a>( &amp;b );
            for ( int i = 0; i &lt; a.<a href="#argc">argc</a>(); i++ )  // a.<a href="#argc">argc</a>() == argc
                b.<a href="qlistbox.html#insertItem">insertItem</a>( a.<a href="#argv">argv</a>()[i] );      // a.<a href="#argv">argv</a>()[i] == argv[i]
            b.<a href="qwidget.html#show">show</a>();
            return a.<a href="#exec">exec</a>();
        }
    </pre>
 
<p> If you run <tt>showargs -display unix:0 -font 9x15bold hello world</tt>
under X11, the list box contains the three strings "showargs",
"hello" and "world".
<p> Qt provides a global pointer, <tt>qApp</tt>, that points to the
QApplication object, and through which you can access <a href="#argc">argc</a>() and
<a href="#argv">argv</a>() in functions other than main().
<p> <p>See also <a href="#argc">argc</a>() and <a href="#QApplication">QApplication::QApplication</a>().

<p>Examples: <a href="tutorial2-04.html#x2558">chart/main.cpp</a> and <a href="scribble-example.html#x907">scribble/scribble.cpp</a>.
<h3 class=fn>void <a name="beep"></a>QApplication::beep ()<tt> [static]</tt>
</h3>
Sounds the bell, using the default volume and sound.

<h3 class=fn><a href="qclipboard.html">QClipboard</a>&nbsp;* <a name="clipboard"></a>QApplication::clipboard ()<tt> [static]</tt>
</h3>
Returns a pointer to the application global clipboard.

<p>Examples: <a href="regexptester-example.html#x2468">regexptester/regexptester.cpp</a> and <a href="showimg-example.html#x1308">showimg/showimg.cpp</a>.
<h3 class=fn>void <a name="closeAllWindows"></a>QApplication::closeAllWindows ()<tt> [slot]</tt>
</h3>
Closes all top-level windows.
<p> This function is particularly useful for applications with many
top-level windows. It could, for example, be connected to a "Quit"
entry in the file menu as shown in the following code example:
<p> <pre>
    // the "Quit" menu entry should try to close all windows
    <a href="qpopupmenu.html">QPopupMenu</a>* file = new <a href="qpopupmenu.html">QPopupMenu</a>( this );
    file-&gt;<a href="qmenudata.html#insertItem">insertItem</a>( "&amp;Quit", qApp, SLOT(<a href="#closeAllWindows">closeAllWindows</a>()), CTRL+Key_Q );

    // when the last window is closed, the application should quit
    <a href="qobject.html#connect">connect</a>( qApp, SIGNAL( <a href="#lastWindowClosed">lastWindowClosed</a>() ), qApp, SLOT( <a href="#quit">quit</a>() ) );
  </pre>
 
<p> The windows are closed in random order, until one window does not
accept the close event.
<p> <p>See also <a href="qwidget.html#close">QWidget::close</a>(), <a href="qwidget.html#closeEvent">QWidget::closeEvent</a>(), <a href="#lastWindowClosed">lastWindowClosed</a>(), <a href="#quit">quit</a>(), <a href="#topLevelWidgets">topLevelWidgets</a>(), and <a href="qwidget.html#isTopLevel-prop">QWidget::isTopLevel</a>.

<p> 
<p>Examples: <a href="qaction-application-example.html#x1127">action/application.cpp</a>, <a href="simple-application-example.html#x1544">application/application.cpp</a>, <a href="helpviewer-example.html#x980">helpviewer/helpwindow.cpp</a>, <a href="mdi-example.html#x2020">mdi/application.cpp</a>, and <a href="qwerty-example.html#x358">qwerty/qwerty.cpp</a>.
<h3 class=fn>bool <a name="closingDown"></a>QApplication::closingDown ()<tt> [static]</tt>
</h3>
Returns TRUE if the application objects are being destroyed;
otherwise returns FALSE.
<p> <p>See also <a href="#startingUp">startingUp</a>().

<h3 class=fn>int <a name="colorSpec"></a>QApplication::colorSpec ()<tt> [static]</tt>
</h3>
Returns the color specification.
<p>See also <a href="#setColorSpec">QApplication::setColorSpec</a>().

<p>Example: <a href="showimg-example.html#x1309">showimg/showimg.cpp</a>.
<h3 class=fn>void <a name="commitData"></a>QApplication::commitData ( <a href="qsessionmanager.html">QSessionManager</a>&nbsp;&amp;&nbsp;sm )<tt> [virtual]</tt>
</h3>

<p> This function deals with <a href="session.html">session
  management</a>. It is invoked when the <a href="qsessionmanager.html">QSessionManager</a> wants the
application to commit all its data.
<p> Usually this means saving all open files, after getting
permission from the user. Furthermore you may want to provide a means
by which the user can cancel the shutdown.
<p> Note that you should not exit the application within this function.
Instead, the session manager may or may not do this afterwards,
depending on the context.
<p> <b>Warning:</b> Within this function, no user interaction is possible, <em>unless</em> you ask the session manager <em>sm</em> for explicit permission.
See <a href="qsessionmanager.html#allowsInteraction">QSessionManager::allowsInteraction</a>() and
<a href="qsessionmanager.html#allowsErrorInteraction">QSessionManager::allowsErrorInteraction</a>() for details and example
usage.
<p> The default implementation requests interaction and sends a close
event to all visible top level widgets. If any event was
rejected, the shutdown is canceled.
<p> <p>See also <a href="#isSessionRestored">isSessionRestored</a>(), <a href="#sessionId">sessionId</a>(), <a href="#saveState">saveState</a>(), and <a href="session.html">the Session Management overview</a>.

<h3 class=fn>int <a name="cursorFlashTime"></a>QApplication::cursorFlashTime ()<tt> [static]</tt>
</h3>
Returns the text cursor's flash (blink) time in milliseconds. The
flash time is the time required to display, invert and restore the
caret display.
<p> The default value on X11 is 1000 milliseconds. On Windows, the
control panel value is used.
<p> Widgets should not cache this value since it may be changed at any
time by the user changing the global desktop settings.
<p> <p>See also <a href="#setCursorFlashTime">setCursorFlashTime</a>().

<h3 class=fn><a href="qtextcodec.html">QTextCodec</a>&nbsp;* <a name="defaultCodec"></a>QApplication::defaultCodec () const
</h3> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns <a href="qtextcodec.html#codecForTr">QTextCodec::codecForTr</a>().

<h3 class=fn><a href="qdesktopwidget.html">QDesktopWidget</a>&nbsp;* <a name="desktop"></a>QApplication::desktop ()<tt> [static]</tt>
</h3>
Returns the desktop widget (also called the root window).
<p> The desktop widget is useful for obtaining the size of the screen.
It may also be possible to draw on the desktop. We recommend against
assuming that it's possible to draw on the desktop, since this does
not work on all operating systems.
<p> <pre>
    <a href="qdesktopwidget.html">QDesktopWidget</a> *d = QApplication::<a href="#desktop">desktop</a>();
    int w = d-&gt;<a href="qwidget.html#width">width</a>();     // returns desktop width
    int h = d-&gt;<a href="qwidget.html#height">height</a>();    // returns desktop height
  </pre>
 

<p>Examples: <a href="canvas-example.html#x2958">canvas/main.cpp</a>, <a href="desktop-example.html#x1721">desktop/desktop.cpp</a>, <a href="helpviewer-example.html#x1037">helpviewer/main.cpp</a>, <a href="i18n-example.html#x1928">i18n/main.cpp</a>, <a href="qmag-example.html#x1765">qmag/qmag.cpp</a>, <a href="qwerty-example.html#x414">qwerty/main.cpp</a>, and <a href="scribble-example.html#x954">scribble/main.cpp</a>.
<h3 class=fn>bool <a name="desktopSettingsAware"></a>QApplication::desktopSettingsAware ()<tt> [static]</tt>
</h3>
Returns the value set by <a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>(); by default TRUE.
<p> <p>See also <a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>().

<h3 class=fn>int <a name="doubleClickInterval"></a>QApplication::doubleClickInterval ()<tt> [static]</tt>
</h3>
Returns the maximum duration for a double click.
<p> The default value on X11 is 400 milliseconds. On Windows, the
control panel value is used.
<p> <p>See also <a href="#setDoubleClickInterval">setDoubleClickInterval</a>().

<h3 class=fn>int <a name="enter_loop"></a>QApplication::enter_loop ()
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This function enters the main event loop (recursively). Do not call
it unless you really know what you are doing.
<p> Use <a href="#eventLoop">QApplication::eventLoop</a>()->enterLoop() instead.
<p> 
<h3 class=fn><a href="qeventloop.html">QEventLoop</a>&nbsp;* <a name="eventLoop"></a>QApplication::eventLoop ()<tt> [static]</tt>
</h3>
Returns the application event loop. This function will return
zero if called during and after destroying QApplication.
<p> To create your own instance of <a href="qeventloop.html">QEventLoop</a> or QEventLoop subclass create
it before you create the QApplication object.
<p> <p>See also <a href="qeventloop.html">QEventLoop</a>.

<p>Example: <a href="distributor-example.html#x2651">distributor/distributor.ui.h</a>.
<h3 class=fn>int <a name="exec"></a>QApplication::exec ()
</h3>
Enters the main event loop and waits until <a href="#exit">exit</a>() is called or the
main widget is destroyed, and returns the value that was set to
exit() (which is 0 if exit() is called via <a href="#quit">quit</a>()).
<p> It is necessary to call this function to start event handling. The
main event loop receives events from the window system and
dispatches these to the application widgets.
<p> Generally speaking, no user interaction can take place before
calling <a href="#exec">exec</a>(). As a special case, modal widgets like <a href="qmessagebox.html">QMessageBox</a>
can be used before calling exec(), because modal widgets call
exec() to start a local event loop.
<p> To make your application perform idle processing, i.e. executing a
special function whenever there are no pending events, use a
<a href="qtimer.html">QTimer</a> with 0 timeout. More advanced idle processing schemes can
be achieved using <a href="#processEvents">processEvents</a>().
<p> <p>See also <a href="#quit">quit</a>(), <a href="#exit">exit</a>(), <a href="#processEvents">processEvents</a>(), and <a href="#setMainWidget">setMainWidget</a>().

<p>Examples: <a href="helpsystem-example.html#x2700">helpsystem/main.cpp</a>, <a href="qdialog.html#x2132">life/main.cpp</a>, <a href="archivesearch-example.html#x486">network/archivesearch/main.cpp</a>, <a href="ftpclient-example.html#x777">network/ftpclient/main.cpp</a>, <a href="qaxserver-example-opengl.html#x2731">opengl/main.cpp</a>, <a href="tutorial1-01.html#x2283">t1/main.cpp</a>, and <a href="tutorial1-04.html#x2303">t4/main.cpp</a>.
<h3 class=fn>void <a name="exit"></a>QApplication::exit ( int&nbsp;retcode = 0 )<tt> [static]</tt>
</h3>
Tells the application to exit with a return code.
<p> After this function has been called, the application leaves the main
event loop and returns from the call to <a href="#exec">exec</a>(). The exec() function
returns <em>retcode</em>.
<p> By convention, a <em>retcode</em> of 0 means success, and any non-zero
value indicates an error.
<p> Note that unlike the C library function of the same name, this
function <em>does</em> return to the caller -- it is event processing that
stops.
<p> <p>See also <a href="#quit">quit</a>() and <a href="#exec">exec</a>().

<p>Examples: <a href="canvas-chart-example.html#x2875">chart/chartform.cpp</a>, <a href="extension-dialog-example.html#x2865">extension/mainform.ui.h</a>, and <a href="picture-example.html#x106">picture/picture.cpp</a>.
<h3 class=fn>void <a name="exit_loop"></a>QApplication::exit_loop ()
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This function exits from a recursive call to the main event loop.
Do not call it unless you are an expert.
<p> Use <a href="#eventLoop">QApplication::eventLoop</a>()->exitLoop() instead.
<p> 
<h3 class=fn>void <a name="flush"></a>QApplication::flush ()<tt> [static]</tt>
</h3>
Flushes the window system specific event queues.
<p> If you are doing graphical changes inside a loop that does not
return to the event loop on asynchronous window systems like X11
or double buffered window systems like MacOS X, and you want to
visualize these changes immediately (e.g. Splash Screens), call
this function.
<p> <p>See also <a href="#flushX">flushX</a>(), <a href="#sendPostedEvents">sendPostedEvents</a>(), and <a href="qpainter.html#flush">QPainter::flush</a>().

<h3 class=fn>void <a name="flushX"></a>QApplication::flushX ()<tt> [static]</tt>
</h3>
Flushes the X event queue in the X11 implementation. This normally
returns almost immediately. Does nothing on other platforms.
<p> <p>See also <a href="#syncX">syncX</a>().

<p>Example: <a href="xform-example.html#x1217">xform/xform.cpp</a>.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="focusWidget"></a>QApplication::focusWidget () const
</h3>

<p> Returns the application widget that has the keyboard input focus, or
0 if no widget in this application has the focus.
<p> <p>See also <a href="qwidget.html#setFocus">QWidget::setFocus</a>(), <a href="qwidget.html#focus-prop">QWidget::focus</a>, and <a href="#activeWindow">activeWindow</a>().

<h3 class=fn><a href="qfont.html">QFont</a> <a name="font"></a>QApplication::font ( const&nbsp;<a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w = 0 )<tt> [static]</tt>
</h3>
Returns the default font for the widget <em>w</em>, or the default
application font if <em>w</em> is 0.
<p> <p>See also <a href="#setFont">setFont</a>(), <a href="#fontMetrics">fontMetrics</a>(), and <a href="qwidget.html#font-prop">QWidget::font</a>.

<p>Examples: <a href="qfd-example.html#x1979">qfd/fontdisplayer.cpp</a>, <a href="themes-example.html#x264">themes/metal.cpp</a>, and <a href="themes-example.html#x321">themes/themes.cpp</a>.
<h3 class=fn><a href="qfontmetrics.html">QFontMetrics</a> <a name="fontMetrics"></a>QApplication::fontMetrics ()<tt> [static]</tt>
</h3>
Returns display (screen) font metrics for the application font.
<p> <p>See also <a href="#font">font</a>(), <a href="#setFont">setFont</a>(), <a href="qwidget.html#fontMetrics">QWidget::fontMetrics</a>(), and <a href="qpainter.html#fontMetrics">QPainter::fontMetrics</a>().

<h3 class=fn><a href="qsize.html">QSize</a> <a name="globalStrut"></a>QApplication::globalStrut ()<tt> [static]</tt>
</h3>

<p> Returns the application's global strut.
<p> The strut is a size object whose dimensions are the minimum that any
GUI element that the user can interact with should have. For example
no button should be resized to be smaller than the global strut size.
<p> <p>See also <a href="#setGlobalStrut">setGlobalStrut</a>().

<h3 class=fn>void <a name="guiThreadAwake"></a>QApplication::guiThreadAwake ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted after the event loop returns from a function
that could block.
<p> <p>See also <a href="#wakeUpGuiThread">wakeUpGuiThread</a>().

<h3 class=fn>bool <a name="hasGlobalMouseTracking"></a>QApplication::hasGlobalMouseTracking ()<tt> [static]</tt>
</h3>

<p> Returns TRUE if global mouse tracking is enabled; otherwise
returns FALSE.
<p> <p>See also <a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>().

<h3 class=fn>bool <a name="hasPendingEvents"></a>QApplication::hasPendingEvents ()
</h3>
This function returns TRUE if there are pending events; otherwise
returns FALSE. Pending events can be either from the window system
or posted events using <a href="#postEvent">QApplication::postEvent</a>().

<h3 class=fn>int <a name="horizontalAlignment"></a>QApplication::horizontalAlignment ( int&nbsp;align )<tt> [static]</tt>
</h3>

<p> Strips out vertical alignment flags and transforms an
alignment <em>align</em> of AlignAuto into AlignLeft or
AlignRight according to the language used. The other horizontal
alignment flags are left untouched.

<h3 class=fn>void <a name="installTranslator"></a>QApplication::installTranslator ( <a href="qtranslator.html">QTranslator</a>&nbsp;*&nbsp;mf )
</h3>
Adds the message file <em>mf</em> to the list of message files to be used
for translations.
<p> Multiple message files can be installed. Translations are searched
for in the last installed message file, then the one from last, and
so on, back to the first installed message file. The search stops as
soon as a matching translation is found.
<p> <p>See also <a href="#removeTranslator">removeTranslator</a>(), <a href="#translate">translate</a>(), and <a href="qtranslator.html#load">QTranslator::load</a>().

<p>Example: <a href="i18n-example.html#x1930">i18n/main.cpp</a>.
<h3 class=fn>bool <a name="isEffectEnabled"></a>QApplication::isEffectEnabled ( <a href="qt.html#UIEffect-enum">Qt::UIEffect</a>&nbsp;effect )<tt> [static]</tt>
</h3>
Returns TRUE if <em>effect</em> is enabled; otherwise returns FALSE.
<p> By default, Qt will try to use the desktop settings. Call
<a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>(FALSE) to prevent this.
<p> Note: All effects are disabled on screens running at less than
16-bit color depth.
<p> <p>See also <a href="#setEffectEnabled">setEffectEnabled</a>() and <a href="qt.html#UIEffect-enum">Qt::UIEffect</a>.

<h3 class=fn>bool <a name="isSessionRestored"></a>QApplication::isSessionRestored () const
</h3>

<p> Returns TRUE if the application has been restored from an earlier
<a href="session.html">session</a>; otherwise returns FALSE.
<p> <p>See also <a href="#sessionId">sessionId</a>(), <a href="#commitData">commitData</a>(), and <a href="#saveState">saveState</a>().

<h3 class=fn>void <a name="lastWindowClosed"></a>QApplication::lastWindowClosed ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the user has closed the last
top level window.
<p> The signal is very useful when your application has many top level
widgets but no main widget. You can then connect it to the <a href="#quit">quit</a>()
slot.
<p> For convenience, this signal is <em>not</em> emitted for transient top level
widgets such as popup menus and dialogs.
<p> <p>See also <a href="#mainWidget">mainWidget</a>(), <a href="#topLevelWidgets">topLevelWidgets</a>(), <a href="qwidget.html#isTopLevel-prop">QWidget::isTopLevel</a>, and <a href="qwidget.html#close">QWidget::close</a>().

<p>Examples: <a href="addressbook-example.html#x608">addressbook/main.cpp</a>, <a href="extension-dialog-example.html#x2867">extension/main.cpp</a>, <a href="helpviewer-example.html#x1039">helpviewer/main.cpp</a>, <a href="mdi-example.html#x2096">mdi/main.cpp</a>, <a href="archivesearch-example.html#x487">network/archivesearch/main.cpp</a>, <a href="qwerty-example.html#x416">qwerty/main.cpp</a>, and <a href="regexptester-example.html#x2509">regexptester/main.cpp</a>.
<h3 class=fn><a href="qstringlist.html">QStringList</a> <a name="libraryPaths"></a>QApplication::libraryPaths ()<tt> [static]</tt>
</h3>
Returns a list of paths that the application will search when
dynamically loading libraries.
The installation directory for plugins is the only entry if no
paths have been set.  The default installation directory for plugins
is <tt>INSTALL/plugins</tt>, where <tt>INSTALL</tt> is the directory where Qt was
installed. The directory of the application executable (NOT the
working directory) is also added to the plugin paths.
<p> If you want to iterate over the list, you should iterate over a
copy, e.g.
<pre>
    <a href="qstringlist.html">QStringList</a> list = app.libraryPaths();
    QStringList::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 
<p> See the <a href="plugins-howto.html">plugins documentation</a> for a
description of how the library paths are used.
<p> <p>See also <a href="#setLibraryPaths">setLibraryPaths</a>(), <a href="#addLibraryPath">addLibraryPath</a>(), <a href="#removeLibraryPath">removeLibraryPath</a>(), and <a href="qlibrary.html">QLibrary</a>.

<h3 class=fn>void <a name="lock"></a>QApplication::lock ()
</h3> 
<p> Lock the Qt Library Mutex. If another thread has already locked the
mutex, the calling thread will block until the other thread has
unlocked the mutex.
<p> <p>See also <a href="#unlock">unlock</a>(), <a href="#locked">locked</a>(), and <a href="threads.html">Thread Support in Qt</a>.

<h3 class=fn>bool <a name="locked"></a>QApplication::locked ()
</h3> 
<p> Returns TRUE if the Qt Library Mutex is locked by a different thread;
otherwise returns FALSE.
<p> <b>Warning:</b> Due to different implementations of recursive mutexes on
the supported platforms, calling this function from the same thread
that previously locked the mutex will give undefined results.
<p> <p>See also <a href="#lock">lock</a>(), <a href="#unlock">unlock</a>(), and <a href="threads.html">Thread Support in Qt</a>.

<h3 class=fn>int <a name="loopLevel"></a>QApplication::loopLevel () const
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns the current loop level.
<p> Use <a href="#eventLoop">QApplication::eventLoop</a>()->loopLevel() instead.
<p> 
<h3 class=fn>bool <a name="macEventFilter"></a>QApplication::macEventFilter ( EventHandlerCallRef, EventRef )<tt> [virtual]</tt>
</h3>
This virtual function is only implemented under Macintosh.
<p> If you create an application that inherits QApplication and
reimplement this function, you get direct access to all Carbon Events
that are received from the MacOS.
<p> Return TRUE if you want to stop the event from being processed.
Return FALSE for normal event dispatching.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="mainWidget"></a>QApplication::mainWidget () const
</h3>

<p> Returns the main application widget, or 0 if there is no main
widget.
<p> <p>See also <a href="#setMainWidget">setMainWidget</a>().

<h3 class=fn>bool <a name="notify"></a>QApplication::notify ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;e )<tt> [virtual]</tt>
</h3>
Sends event <em>e</em> to <em>receiver</em>: <em>receiver</em>->event(<em>e</em>).
Returns the value that is returned from the receiver's event handler.
<p> For certain types of events (e.g. mouse and key events),
the event will be propagated to the receiver's parent and so on up to
the top-level object if the receiver is not interested in the event
(i.e., it returns FALSE).
<p> There are five different ways that events can be processed;
reimplementing this virtual function is just one of them. All five
approaches are listed below:
<ol type=1>
<li> Reimplementing this function. This is very powerful, providing
complete control; but only one subclass can be qApp.
<p> <li> Installing an event filter on qApp. Such an event filter is able
to process all events for all widgets, so it's just as powerful as
reimplementing <a href="#notify">notify</a>(); furthermore, it's possible to have more
than one application-global event filter. Global event filters even
see mouse events for <a href="qwidget.html#isEnabled">disabled
  widgets,</a> and if <a href="#setGlobalMouseTracking">global mouse
  tracking</a> is enabled, as well as mouse move events for all
widgets.
<p> <li> Reimplementing <a href="qobject.html#event">QObject::event</a>() (as <a href="qwidget.html">QWidget</a> does). If you do
this you get Tab key presses, and you get to see the events before
any widget-specific event filters.
<p> <li> Installing an event filter on the object. Such an event filter
gets all the events except Tab and Shift-Tab key presses.
<p> <li> Reimplementing paintEvent(), mousePressEvent() and so
on. This is the commonest, easiest and least powerful way.
</ol>
<p> <p>See also <a href="qobject.html#event">QObject::event</a>() and <a href="qobject.html#installEventFilter">installEventFilter</a>().

<h3 class=fn><a href="qcursor.html">QCursor</a>&nbsp;* <a name="overrideCursor"></a>QApplication::overrideCursor ()<tt> [static]</tt>
</h3>

<p> Returns the active application override cursor.
<p> This function returns 0 if no application cursor has been defined
(i.e. the internal cursor stack is empty).
<p> <p>See also <a href="#setOverrideCursor">setOverrideCursor</a>() and <a href="#restoreOverrideCursor">restoreOverrideCursor</a>().

<h3 class=fn><a href="qpalette.html">QPalette</a> <a name="palette"></a>QApplication::palette ( const&nbsp;<a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w = 0 )<tt> [static]</tt>
</h3>
Returns the application palette.
<p> If a widget is passed in <em>w</em>, the default palette for the
widget's class is returned. This may or may not be the application
palette. In most cases there isn't a special palette for certain
types of widgets, but one notable exception is the popup menu under
Windows, if the user has defined a special background color for
menus in the display settings.
<p> <p>See also <a href="#setPalette">setPalette</a>() and <a href="qwidget.html#palette-prop">QWidget::palette</a>.

<p>Examples: <a href="desktop-example.html#x1723">desktop/desktop.cpp</a>, <a href="themes-example.html#x265">themes/metal.cpp</a>, and <a href="themes-example.html#x186">themes/wood.cpp</a>.
<h3 class=fn>void <a name="polish"></a>QApplication::polish ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w )<tt> [virtual]</tt>
</h3>
Initialization of the appearance of the widget <em>w</em> <em>before</em> it is first
shown.
<p> Usually widgets call this automatically when they are polished. It
may be used to do some style-based central customization of widgets.
<p> Note that you are not limited to the public functions of <a href="qwidget.html">QWidget</a>.
Instead, based on meta information like <a href="qobject.html#className">QObject::className</a>() you are
able to customize any kind of widget.
<p> <p>See also <a href="qstyle.html#polish">QStyle::polish</a>(), <a href="qwidget.html#polish">QWidget::polish</a>(), <a href="#setPalette">setPalette</a>(), and <a href="#setFont">setFont</a>().

<h3 class=fn>void <a name="postEvent"></a>QApplication::postEvent ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;event )<tt> [static]</tt>
</h3><p><b>Note:</b> This function is <a href="threads.html#threadsafe">thread-safe</a> when Qt is built withthread support.</p>

Adds the event <em>event</em> with the object <em>receiver</em> as the receiver of the
event, to an event queue and returns immediately.
<p> The event must be allocated on the heap since the post event queue
will take ownership of the event and delete it once it has been posted.
<p> When control returns to the main event loop, all events that are
stored in the queue will be sent using the <a href="#notify">notify</a>() function.
<p> 
<p> <p>See also <a href="#sendEvent">sendEvent</a>() and <a href="#notify">notify</a>().

<h3 class=fn>void <a name="processEvents"></a>QApplication::processEvents ()
</h3>
Processes pending events, for 3 seconds or until there are no more
events to process, whichever is shorter.
<p> You can call this function occasionally when your program is busy
performing a long operation (e.g. copying a file).
<p> <p>See also <a href="#exec">exec</a>(), <a href="qtimer.html">QTimer</a>, and <a href="qeventloop.html#processEvents">QEventLoop::processEvents</a>().

<p>Examples: <a href="fileiconview-example.html#x808">fileiconview/qfileiconview.cpp</a> and <a href="ftpclient-example.html#x778">network/ftpclient/main.cpp</a>.
<h3 class=fn>void <a name="processEvents-2"></a>QApplication::processEvents ( int&nbsp;maxtime )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Processes pending events for <em>maxtime</em> milliseconds or until
there are no more events to process, whichever is shorter.
<p> You can call this function occasionally when you program is busy
doing a long operation (e.g. copying a file).
<p> <p>See also <a href="#exec">exec</a>(), <a href="qtimer.html">QTimer</a>, and <a href="qeventloop.html#processEvents">QEventLoop::processEvents</a>().

<h3 class=fn>void <a name="processOneEvent"></a>QApplication::processOneEvent ()
</h3> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Waits for an event to occur, processes it, then returns.
<p> This function is useful for adapting Qt to situations where the
event processing must be grafted onto existing program loops.
<p> Using this function in new applications may be an indication of design
problems.
<p> <p>See also <a href="#processEvents">processEvents</a>(), <a href="#exec">exec</a>(), and <a href="qtimer.html">QTimer</a>.

<h3 class=fn>void <a name="quit"></a>QApplication::quit ()<tt> [slot]</tt>
</h3>
Tells the application to exit with return code 0 (success).
Equivalent to calling <a href="#exit">QApplication::exit</a>( 0 ).
<p> It's common to connect the <a href="#lastWindowClosed">lastWindowClosed</a>() signal to <a href="#quit">quit</a>(), and
you also often connect e.g. <a href="qbutton.html#clicked">QButton::clicked</a>() or signals in
<a href="qaction.html">QAction</a>, <a href="qpopupmenu.html">QPopupMenu</a> or <a href="qmenubar.html">QMenuBar</a> to it.
<p> Example:
<pre>
    <a href="qpushbutton.html">QPushButton</a> *quitButton = new <a href="qpushbutton.html">QPushButton</a>( "Quit" );
    <a href="qobject.html#connect">connect</a>( quitButton, SIGNAL(<a href="qbutton.html#clicked">clicked</a>()), qApp, SLOT(<a href="#quit">quit</a>()) );
  </pre>
 
<p> <p>See also <a href="#exit">exit</a>(), <a href="#aboutToQuit">aboutToQuit</a>(), <a href="#lastWindowClosed">lastWindowClosed</a>(), and <a href="qaction.html">QAction</a>.

<p>Examples: <a href="addressbook-example.html#x609">addressbook/main.cpp</a>, <a href="mdi-example.html#x2097">mdi/main.cpp</a>, <a href="archivesearch-example.html#x488">network/archivesearch/main.cpp</a>, <a href="regexptester-example.html#x2510">regexptester/main.cpp</a>, <a href="tutorial1-02.html#x2288">t2/main.cpp</a>, <a href="tutorial1-04.html#x2304">t4/main.cpp</a>, and <a href="tutorial1-06.html#x2321">t6/main.cpp</a>.
<h3 class=fn><a href="qwsdecoration.html">QWSDecoration</a>&nbsp;&amp; <a name="qwsDecoration"></a>QApplication::qwsDecoration ()<tt> [static]</tt>
</h3>
Return the <a href="qwsdecoration.html">QWSDecoration</a> used for decorating windows.
<p> This method is non-portable. It is available <em>only</em> in Qt/Embedded.
<p> <p>See also <a href="qwsdecoration.html">QWSDecoration</a>.

<h3 class=fn>bool <a name="qwsEventFilter"></a>QApplication::qwsEventFilter ( QWSEvent * )<tt> [virtual]</tt>
</h3>
This virtual function is only implemented under Qt/Embedded.
<p> If you create an application that inherits QApplication and
reimplement this function, you get direct access to all QWS (Q
Window System) events that the are received from the QWS master
process.
<p> Return TRUE if you want to stop the event from being processed.
Return FALSE for normal event dispatching.

<h3 class=fn>void <a name="qwsSetCustomColors"></a>QApplication::qwsSetCustomColors ( QRgb&nbsp;*&nbsp;colorTable, int&nbsp;start, int&nbsp;numColors )
</h3>
Set Qt/Embedded custom color table.
<p> Qt/Embedded on 8-bpp displays allocates a standard 216 color cube.
The remaining 40 colors may be used by setting a custom color
table in the QWS master process before any clients connect.
<p> <em>colorTable</em> is an array of up to 40 custom colors. <em>start</em> is
the starting index (0-39) and <em>numColors</em> is the number of colors
to be set (1-40).
<p> This method is non-portable. It is available <em>only</em> in
Qt/Embedded.

<h3 class=fn>void <a name="qwsSetDecoration"></a>QApplication::qwsSetDecoration ( <a href="qwsdecoration.html">QWSDecoration</a>&nbsp;*&nbsp;d )<tt> [static]</tt>
</h3>
Set the <a href="qwsdecoration.html">QWSDecoration</a> derived class to use for decorating the
Qt/Embedded windows to <em>d</em>.
<p> This method is non-portable. It is available <em>only</em> in
Qt/Embedded.
<p> <p>See also <a href="qwsdecoration.html">QWSDecoration</a>.

<h3 class=fn>void <a name="removeLibraryPath"></a>QApplication::removeLibraryPath ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;path )<tt> [static]</tt>
</h3>
Removes <em>path</em> from the library path list. If <em>path</em> is empty or not
in the path list, the list is not changed.
<p> <p>See also <a href="#addLibraryPath">addLibraryPath</a>(), <a href="#libraryPaths">libraryPaths</a>(), and <a href="#setLibraryPaths">setLibraryPaths</a>().

<h3 class=fn>void <a name="removePostedEvents"></a>QApplication::removePostedEvents ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver )<tt> [static]</tt>
</h3><p><b>Note:</b> This function is <a href="threads.html#threadsafe">thread-safe</a> when Qt is built withthread support.</p>

Removes all events posted using <a href="#postEvent">postEvent</a>() for <em>receiver</em>.
<p> The events are <em>not</em> dispatched, instead they are removed from the
queue. You should never need to call this function. If you do call it,
be aware that killing events may cause <em>receiver</em> to break one or
more invariants.
<p> 

<h3 class=fn>void <a name="removeTranslator"></a>QApplication::removeTranslator ( <a href="qtranslator.html">QTranslator</a>&nbsp;*&nbsp;mf )
</h3>
Removes the message file <em>mf</em> from the list of message files used by
this application. (It does not delete the message file from the file
system.)
<p> <p>See also <a href="#installTranslator">installTranslator</a>(), <a href="#translate">translate</a>(), and <a href="qobject.html#tr">QObject::tr</a>().

<p>Example: <a href="i18n-example.html#x1932">i18n/main.cpp</a>.
<h3 class=fn>void <a name="restoreOverrideCursor"></a>QApplication::restoreOverrideCursor ()<tt> [static]</tt>
</h3>
Undoes the last <a href="#setOverrideCursor">setOverrideCursor</a>().
<p> If setOverrideCursor() has been called twice, calling
<a href="#restoreOverrideCursor">restoreOverrideCursor</a>() will activate the first cursor set.
Calling this function a second time restores the original widgets'
cursors.
<p> <p>See also <a href="#setOverrideCursor">setOverrideCursor</a>() and <a href="#overrideCursor">overrideCursor</a>().

<p>Examples: <a href="distributor-example.html#x2652">distributor/distributor.ui.h</a>, <a href="archivesearch-example.html#x473">network/archivesearch/archivedialog.ui.h</a>, <a href="ftpclient-example.html#x737">network/ftpclient/ftpmainwindow.ui.h</a>, and <a href="showimg-example.html#x1311">showimg/showimg.cpp</a>.
<h3 class=fn>bool <a name="reverseLayout"></a>QApplication::reverseLayout ()<tt> [static]</tt>
</h3>
Returns TRUE if all dialogs and widgets will be laid out in a
mirrored (right to left) fashion. Returns FALSE if dialogs and
widgets will be laid out left to right.
<p> <p>See also <a href="#setReverseLayout">setReverseLayout</a>().

<h3 class=fn>void <a name="saveState"></a>QApplication::saveState ( <a href="qsessionmanager.html">QSessionManager</a>&nbsp;&amp;&nbsp;sm )<tt> [virtual]</tt>
</h3>

<p> This function deals with <a href="session.html">session
  management</a>. It is invoked when the
<a href="qsessionmanager.html">session manager</a> wants the application
to preserve its state for a future session.
<p> For example, a text editor would create a temporary file that
includes the current contents of its edit buffers, the location of
the cursor and other aspects of the current editing session.
<p> Note that you should never exit the application within this
function. Instead, the session manager may or may not do this
afterwards, depending on the context. Futhermore, most session
managers will very likely request a saved state immediately after
the application has been started. This permits the session manager
to learn about the application's restart policy.
<p> <b>Warning:</b> Within this function, no user interaction is possible, <em>unless</em> you ask the session manager <em>sm</em> for explicit permission.
See <a href="qsessionmanager.html#allowsInteraction">QSessionManager::allowsInteraction</a>() and
<a href="qsessionmanager.html#allowsErrorInteraction">QSessionManager::allowsErrorInteraction</a>() for details.
<p> <p>See also <a href="#isSessionRestored">isSessionRestored</a>(), <a href="#sessionId">sessionId</a>(), <a href="#commitData">commitData</a>(), and <a href="session.html">the Session Management overview</a>.

<h3 class=fn>bool <a name="sendEvent"></a>QApplication::sendEvent ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;event )<tt> [static]</tt>
</h3>

<p> Sends event <em>event</em> directly to receiver <em>receiver</em>, using the
<a href="#notify">notify</a>() function. Returns the value that was returned from the event
handler.
<p> The event is <em>not</em> deleted when the event has been sent. The normal
approach is to create the event on the stack, e.g.
<pre>
    <a href="qmouseevent.html">QMouseEvent</a> me( QEvent::MouseButtonPress, pos, 0, 0 );
    QApplication::<a href="#sendEvent">sendEvent</a>( mainWindow, &amp;me );
    </pre>
 
If you create the event on the heap you must delete it.
<p> <p>See also <a href="#postEvent">postEvent</a>() and <a href="#notify">notify</a>().

<p>Example: <a href="popup-example.html#x1602">popup/popup.cpp</a>.
<h3 class=fn>void <a name="sendPostedEvents"></a>QApplication::sendPostedEvents ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, int&nbsp;event_type )<tt> [static]</tt>
</h3>
Immediately dispatches all events which have been previously queued
with <a href="#postEvent">QApplication::postEvent</a>() and which are for the object <em>receiver</em>
and have the event type <em>event_type</em>.
<p> Note that events from the window system are <em>not</em> dispatched by this
function, but by <a href="#processEvents">processEvents</a>().
<p> If <em>receiver</em> is null, the events of <em>event_type</em> are sent for all
objects. If <em>event_type</em> is 0, all the events are sent for <em>receiver</em>.

<h3 class=fn>void <a name="sendPostedEvents-2"></a>QApplication::sendPostedEvents ()<tt> [static]</tt>
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Dispatches all posted events, i.e. empties the event queue.

<h3 class=fn><a href="qstring.html">QString</a> <a name="sessionId"></a>QApplication::sessionId () const
</h3>

<p> Returns the current <a href="session.html">session's</a> identifier.
<p> If the application has been restored from an earlier session, this
identifier is the same as it was in that previous session.
<p> The session identifier is guaranteed to be unique both for different
applications and for different instances of the same application.
<p> <p>See also <a href="#isSessionRestored">isSessionRestored</a>(), <a href="#sessionKey">sessionKey</a>(), <a href="#commitData">commitData</a>(), and <a href="#saveState">saveState</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="sessionKey"></a>QApplication::sessionKey () const
</h3>

<p> Returns the session key in the current <a href="session.html">session</a>.
<p> If the application has been restored from an earlier session, this
key is the same as it was when the previous session ended.
<p> The session key changes with every call of <a href="#commitData">commitData</a>() or
<a href="#saveState">saveState</a>().
<p> <p>See also <a href="#isSessionRestored">isSessionRestored</a>(), <a href="#sessionId">sessionId</a>(), <a href="#commitData">commitData</a>(), and <a href="#saveState">saveState</a>().

<h3 class=fn>void <a name="setColorSpec"></a>QApplication::setColorSpec ( int&nbsp;spec )<tt> [static]</tt>
</h3>
Sets the color specification for the application to <em>spec</em>.
<p> The color specification controls how the application allocates colors
when run on a display with a limited amount of colors, e.g. 8 bit / 256
color displays.
<p> The color specification must be set before you create the QApplication
object.
<p> The options are:
<ul>
<li> QApplication::NormalColor.
This is the default color allocation strategy. Use this option if
your application uses buttons, menus, texts and pixmaps with few
colors. With this option, the application uses system global
colors. This works fine for most applications under X11, but on
Windows machines it may cause dithering of non-standard colors.
<li> QApplication::CustomColor.
Use this option if your application needs a small number of custom
colors. On X11, this option is the same as NormalColor. On Windows, Qt
creates a Windows palette, and allocates colors to it on demand.
<li> QApplication::ManyColor.
Use this option if your application is very color hungry
(e.g. it requires thousands of colors).
Under X11 the effect is:
<ul>
<li> For 256-color displays which have at best a 256 color true color
visual, the default visual is used, and colors are allocated
from a color cube. The color cube is the 6x6x6 (216 color) "Web
palette"<sup>*</sup>, but the number of colors can be changed
by the <em>-ncols</em> option. The user can force the application to
use the true color visual with the <a href="#QApplication">-visual</a> option.
<li> For 256-color displays which have a true color visual with more
than 256 colors, use that visual. Silicon Graphics X servers
have this feature, for example. They provide an 8 bit visual
by default but can deliver true color when asked.
</ul>
On Windows, Qt creates a Windows palette, and fills it with a color cube.
</ul>
<p> Be aware that the CustomColor and ManyColor choices may lead to colormap
flashing: The foreground application gets (most) of the available
colors, while the background windows will look less attractive.
<p> Example:
<pre>
  int main( int argc, char **argv )
  {
      QApplication::<a href="#setColorSpec">setColorSpec</a>( QApplication::<a href="#ColorSpec-enum">ManyColor</a> );
      QApplication a( argc, argv );
      ...
  }
  </pre>
 
<p> <a href="qcolor.html">QColor</a> provides more functionality for controlling color allocation and
freeing up certain colors. See <a href="qcolor.html#enterAllocContext">QColor::enterAllocContext</a>() for more
information.
<p> To check what mode you end up with, call <a href="qcolor.html#numBitPlanes">QColor::numBitPlanes</a>() once
the QApplication object exists. A value greater than 8 (typically
16, 24 or 32) means true color.
<p> <sup>*</sup> The color cube used by Qt has 216 colors whose red,
green, and blue components always have one of the following values:
0x00, 0x33, 0x66, 0x99, 0xCC, or 0xFF.
<p> <p>See also <a href="#colorSpec">colorSpec</a>(), <a href="qcolor.html#numBitPlanes">QColor::numBitPlanes</a>(), and <a href="qcolor.html#enterAllocContext">QColor::enterAllocContext</a>().

<p>Examples: <a href="helpviewer-example.html#x1041">helpviewer/main.cpp</a>, <a href="qaxserver-example-opengl.html#x2732">opengl/main.cpp</a>, <a href="showimg-example.html#x1361">showimg/main.cpp</a>, <a href="tutorial1-09.html#x2347">t9/main.cpp</a>, <a href="qaxserver-example-tetrax.html#x2716">tetrax/tetrax.cpp</a>, <a href="tetrix-example.html#x354">tetrix/tetrix.cpp</a>, and <a href="themes-example.html#x348">themes/main.cpp</a>.
<h3 class=fn>void <a name="setCursorFlashTime"></a>QApplication::setCursorFlashTime ( int&nbsp;msecs )<tt> [static]</tt>
</h3>
Sets the text cursor's flash (blink) time to <em>msecs</em>
milliseconds. The flash time is the time required to display,
invert and restore the caret display. Usually the text cursor is
displayed for <em>msecs/2</em> milliseconds, then hidden for <em>msecs/2</em>
milliseconds, but this may vary.
<p> Note that on Microsoft Windows, calling this function sets the
cursor flash time for all windows.
<p> <p>See also <a href="#cursorFlashTime">cursorFlashTime</a>().

<h3 class=fn>void <a name="setDefaultCodec"></a>QApplication::setDefaultCodec ( <a href="qtextcodec.html">QTextCodec</a>&nbsp;*&nbsp;codec )
</h3> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> This is the same as <a href="qtextcodec.html#setCodecForTr">QTextCodec::setCodecForTr</a>().

<h3 class=fn>void <a name="setDesktopSettingsAware"></a>QApplication::setDesktopSettingsAware ( bool&nbsp;on )<tt> [static]</tt>
</h3>
By default, Qt will try to use the current standard colors, fonts
etc., from the underlying window system's desktop settings,
and use them for all relevant widgets. This behavior can be switched off
by calling this function with <em>on</em> set to FALSE.
<p> This static function must be called before creating the QApplication
object, like this:
<p> <pre>
  int main( int argc, char** argv ) {
    QApplication::<a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>( FALSE ); // I know better than the user
    QApplication myApp( argc, argv ); // Use default fonts &amp; colors
    ...
  }
  </pre>
 
<p> <p>See also <a href="#desktopSettingsAware">desktopSettingsAware</a>().

<h3 class=fn>void <a name="setDoubleClickInterval"></a>QApplication::setDoubleClickInterval ( int&nbsp;ms )<tt> [static]</tt>
</h3>
Sets the time limit that distinguishes a double click from two
consecutive mouse clicks to <em>ms</em> milliseconds.
<p> Note that on Microsoft Windows, calling this function sets the
double click interval for all windows.
<p> <p>See also <a href="#doubleClickInterval">doubleClickInterval</a>().

<h3 class=fn>void <a name="setEffectEnabled"></a>QApplication::setEffectEnabled ( <a href="qt.html#UIEffect-enum">Qt::UIEffect</a>&nbsp;effect, bool&nbsp;enable = TRUE )<tt> [static]</tt>
</h3>
Enables the UI effect <em>effect</em> if <em>enable</em> is TRUE, otherwise
the effect will not be used.
<p> Note: All effects are disabled on screens running at less than
16-bit color depth.
<p> <p>See also <a href="#isEffectEnabled">isEffectEnabled</a>(), <a href="qt.html#UIEffect-enum">Qt::UIEffect</a>, and <a href="#setDesktopSettingsAware">setDesktopSettingsAware</a>().

<h3 class=fn>void <a name="setFont"></a>QApplication::setFont ( const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp;&nbsp;font, bool&nbsp;informWidgets = FALSE, const&nbsp;char&nbsp;*&nbsp;className = 0 )<tt> [static]</tt>
</h3> Changes the default application font to <em>font</em>. If <em>informWidgets</em> is TRUE, then existing widgets are informed about the
change and may adjust themselves to the new application
setting. If <em>informWidgets</em> is FALSE, the change only affects newly
created widgets. If <em>className</em> is passed, the change applies only
to classes that inherit <em>className</em> (as reported by
<a href="qobject.html#inherits">QObject::inherits</a>()).
<p> On application start-up, the default font depends on the window
system. It can vary depending on both the window system version and
the locale. This function lets you override the default font; but
overriding may be a bad idea because, for example, some locales need
extra-large fonts to support their special characters.
<p> <p>See also <a href="#font">font</a>(), <a href="#fontMetrics">fontMetrics</a>(), and <a href="qwidget.html#font-prop">QWidget::font</a>.

<p>Examples: <a href="desktop-example.html#x1724">desktop/desktop.cpp</a>, <a href="themes-example.html#x266">themes/metal.cpp</a>, and <a href="themes-example.html#x323">themes/themes.cpp</a>.
<h3 class=fn>void <a name="setGlobalMouseTracking"></a>QApplication::setGlobalMouseTracking ( bool&nbsp;enable )<tt> [static]</tt>
</h3>
Enables global mouse tracking if <em>enable</em> is TRUE, or disables it
if <em>enable</em> is FALSE.
<p> Enabling global mouse tracking makes it possible for widget event
filters or application event filters to get all mouse move events,
even when no button is depressed. This is useful for special GUI
elements, e.g. tooltips.
<p> Global mouse tracking does not affect widgets and their
mouseMoveEvent(). For a widget to get mouse move events when no
button is depressed, it must do <a href="qwidget.html#setMouseTracking">QWidget::setMouseTracking</a>(TRUE).
<p> This function uses an internal counter. Each
<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>(TRUE) must have a corresponding
setGlobalMouseTracking(FALSE):
<pre>
        // at this point global mouse tracking is off
        QApplication::<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>( TRUE );
        QApplication::<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>( TRUE );
        QApplication::<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>( FALSE );
        // at this point it's still on
        QApplication::<a href="#setGlobalMouseTracking">setGlobalMouseTracking</a>( FALSE );
        // but now it's off
    </pre>
 
<p> <p>See also <a href="#hasGlobalMouseTracking">hasGlobalMouseTracking</a>() and <a href="qwidget.html#mouseTracking-prop">QWidget::mouseTracking</a>.

<h3 class=fn>void <a name="setGlobalStrut"></a>QApplication::setGlobalStrut ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;strut )<tt> [static]</tt>
</h3>
Sets the application's global strut to <em>strut</em>.
<p> The strut is a size object whose dimensions are the minimum that any
GUI element that the user can interact with should have. For example
no button should be resized to be smaller than the global strut size.
<p> The strut size should be considered when reimplementing GUI controls
that may be used on touch-screens or similar IO-devices.
<p> Example:
<pre>
  QSize&amp; WidgetClass::sizeHint() const
  {
      return QSize( 80, 25 ).expandedTo( QApplication::<a href="#globalStrut">globalStrut</a>() );
  }
  </pre>
 
<p> <p>See also <a href="#globalStrut">globalStrut</a>().

<h3 class=fn>void <a name="setLibraryPaths"></a>QApplication::setLibraryPaths ( const&nbsp;<a href="qstringlist.html">QStringList</a>&nbsp;&amp;&nbsp;paths )<tt> [static]</tt>
</h3>
Sets the list of directories to search when loading libraries to <em>paths</em>.
All existing paths will be deleted and the path list will consist of the
paths given in <em>paths</em>.
<p> <p>See also <a href="#libraryPaths">libraryPaths</a>(), <a href="#addLibraryPath">addLibraryPath</a>(), <a href="#removeLibraryPath">removeLibraryPath</a>(), and <a href="qlibrary.html">QLibrary</a>.

<h3 class=fn>void <a name="setMainWidget"></a>QApplication::setMainWidget ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;mainWidget )<tt> [virtual]</tt>
</h3>
Sets the application's main widget to <em>mainWidget</em>.
<p> In most respects the main widget is like any other widget, except
that if it is closed, the application exits. Note that
QApplication does <em>not</em> take ownership of the <em>mainWidget</em>, so
if you create your main widget on the heap you must delete it
yourself.
<p> You need not have a main widget; connecting <a href="#lastWindowClosed">lastWindowClosed</a>() to
<a href="#quit">quit</a>() is an alternative.
<p> For X11, this function also resizes and moves the main widget
according to the <em>-geometry</em> command-line option, so you should
set the default geometry (using <a href="qwidget.html#setGeometry">QWidget::setGeometry</a>()) before
calling <a href="#setMainWidget">setMainWidget</a>().
<p> <p>See also <a href="#mainWidget">mainWidget</a>(), <a href="#exec">exec</a>(), and <a href="#quit">quit</a>().

<p>Examples: <a href="tutorial2-04.html#x2560">chart/main.cpp</a>, <a href="helpsystem-example.html#x2701">helpsystem/main.cpp</a>, <a href="qdialog.html#x2133">life/main.cpp</a>, <a href="ftpclient-example.html#x779">network/ftpclient/main.cpp</a>, <a href="qaxserver-example-opengl.html#x2733">opengl/main.cpp</a>, <a href="tutorial1-01.html#x2284">t1/main.cpp</a>, and <a href="tutorial1-04.html#x2305">t4/main.cpp</a>.
<h3 class=fn>void <a name="setOverrideCursor"></a>QApplication::setOverrideCursor ( const&nbsp;<a href="qcursor.html">QCursor</a>&nbsp;&amp;&nbsp;cursor, bool&nbsp;replace = FALSE )<tt> [static]</tt>
</h3>
Sets the application override cursor to <em>cursor</em>.
<p> Application override cursors are intended for showing the user
that the application is in a special state, for example during an
operation that might take some time.
<p> This cursor will be displayed in all the application's widgets
until <a href="#restoreOverrideCursor">restoreOverrideCursor</a>() or another <a href="#setOverrideCursor">setOverrideCursor</a>() is
called.
<p> Application cursors are stored on an internal stack.
setOverrideCursor() pushes the cursor onto the stack, and
restoreOverrideCursor() pops the active cursor off the stack.
Every setOverrideCursor() must eventually be followed by a
corresponding restoreOverrideCursor(), otherwise the stack will
never be emptied.
<p> If <em>replace</em> is TRUE, the new cursor will replace the last
override cursor (the stack keeps its depth). If <em>replace</em> is
FALSE, the new stack is pushed onto the top of the stack.
<p> Example:
<pre>
        QApplication::<a href="#setOverrideCursor">setOverrideCursor</a>( QCursor(Qt::<a href="qt.html#CursorShape-enum">WaitCursor</a>) );
        calculateHugeMandelbrot();              // lunch time...
        QApplication::<a href="#restoreOverrideCursor">restoreOverrideCursor</a>();
    </pre>
 
<p> <p>See also <a href="#overrideCursor">overrideCursor</a>(), <a href="#restoreOverrideCursor">restoreOverrideCursor</a>(), and <a href="qwidget.html#cursor-prop">QWidget::cursor</a>.

<p>Examples: <a href="distributor-example.html#x2653">distributor/distributor.ui.h</a>, <a href="archivesearch-example.html#x474">network/archivesearch/archivedialog.ui.h</a>, <a href="ftpclient-example.html#x738">network/ftpclient/ftpmainwindow.ui.h</a>, and <a href="showimg-example.html#x1312">showimg/showimg.cpp</a>.
<h3 class=fn>void <a name="setPalette"></a>QApplication::setPalette ( const&nbsp;<a href="qpalette.html">QPalette</a>&nbsp;&amp;&nbsp;palette, bool&nbsp;informWidgets = FALSE, const&nbsp;char&nbsp;*&nbsp;className = 0 )<tt> [static]</tt>
</h3>
Changes the default application palette to <em>palette</em>. If <em>informWidgets</em> is TRUE, then existing widgets are informed about the
change and may adjust themselves to the new application
setting. If <em>informWidgets</em> is FALSE, the change only affects newly
created widgets.
<p> If <em>className</em> is passed, the change applies only to widgets that
inherit <em>className</em> (as reported by <a href="qobject.html#inherits">QObject::inherits</a>()). If
<em>className</em> is left 0, the change affects all widgets, thus overriding
any previously set class specific palettes.
<p> The palette may be changed according to the current GUI style in
<a href="qstyle.html#polish">QStyle::polish</a>().
<p> <p>See also <a href="qwidget.html#palette-prop">QWidget::palette</a>, <a href="#palette">palette</a>(), and <a href="qstyle.html#polish">QStyle::polish</a>().

<p>Examples: <a href="i18n-example.html#x1934">i18n/main.cpp</a>, <a href="themes-example.html#x267">themes/metal.cpp</a>, <a href="themes-example.html#x324">themes/themes.cpp</a>, and <a href="themes-example.html#x187">themes/wood.cpp</a>.
<h3 class=fn>void <a name="setReverseLayout"></a>QApplication::setReverseLayout ( bool&nbsp;b )<tt> [static]</tt>
</h3>
If <em>b</em> is TRUE, all dialogs and widgets will be laid out in a
mirrored fashion, as required by right to left languages such as
Arabic and Hebrew. If <em>b</em> is FALSE, dialogs and widgets are laid
out left to right.
<p> Changing this flag in runtime does not cause a relayout of already
instantiated widgets.
<p> <p>See also <a href="#reverseLayout">reverseLayout</a>().

<h3 class=fn>void <a name="setStartDragDistance"></a>QApplication::setStartDragDistance ( int&nbsp;l )<tt> [static]</tt>
</h3>
Sets the distance after which a drag should start to <em>l</em> pixels.
<p> <p>See also <a href="#startDragDistance">startDragDistance</a>().

<h3 class=fn>void <a name="setStartDragTime"></a>QApplication::setStartDragTime ( int&nbsp;ms )<tt> [static]</tt>
</h3>
Sets the time after which a drag should start to <em>ms</em> ms.
<p> <p>See also <a href="#startDragTime">startDragTime</a>().

<h3 class=fn>void <a name="setStyle"></a>QApplication::setStyle ( <a href="qstyle.html">QStyle</a>&nbsp;*&nbsp;style )<tt> [static]</tt>
</h3>
Sets the application's GUI style to <em>style</em>. Ownership of the style
object is transferred to QApplication, so QApplication will delete
the style object on application exit or when a new style is set.
<p> Example usage:
<pre>
    QApplication::<a href="#setStyle">setStyle</a>( new <a href="qwindowsstyle.html">QWindowsStyle</a> );
  </pre>
 
<p> When switching application styles, the color palette is set back to
the initial colors or the system defaults. This is necessary since
certain styles have to adapt the color palette to be fully
style-guide compliant.
<p> <p>See also <a href="#style">style</a>(), <a href="qstyle.html">QStyle</a>, <a href="#setPalette">setPalette</a>(), and <a href="#desktopSettingsAware">desktopSettingsAware</a>().

<p>Example: <a href="themes-example.html#x325">themes/themes.cpp</a>.
<h3 class=fn><a href="qstyle.html">QStyle</a>&nbsp;* <a name="setStyle-2"></a>QApplication::setStyle ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;style )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Requests a <a href="qstyle.html">QStyle</a> object for <em>style</em> from the <a href="qstylefactory.html">QStyleFactory</a>.
<p> The string must be one of the <a href="qstylefactory.html#keys">QStyleFactory::keys</a>(), typically one
of "windows", "motif", "cde", "motifplus", "platinum", "sgi" and
"compact". Depending on the platform, "windowsxp", "aqua" or
"macintosh" may be available.
<p> A later call to the QApplication constructor will override the
requested style when a "-style" option is passed in as a commandline
parameter.
<p> Returns 0 if an unknown <em>style</em> is passed, otherwise the QStyle object
returned is set as the application's GUI style.

<h3 class=fn>void <a name="setWheelScrollLines"></a>QApplication::setWheelScrollLines ( int&nbsp;n )<tt> [static]</tt>
</h3>
Sets the number of lines to scroll when the mouse wheel is rotated
to <em>n</em>.
<p> If this number exceeds the number of visible lines in a certain
widget, the widget should interpret the scroll operation as a
single page up / page down operation instead.
<p> <p>See also <a href="#wheelScrollLines">wheelScrollLines</a>().

<h3 class=fn>void <a name="setWinStyleHighlightColor"></a>QApplication::setWinStyleHighlightColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp;&nbsp;c )<tt> [static]</tt>
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Sets the color used to mark selections in windows style for all widgets
in the application. Will repaint all widgets if the color is changed.
<p> The default color is <tt>darkBlue</tt>.
<p>See also <a href="#winStyleHighlightColor">winStyleHighlightColor</a>().

<h3 class=fn>int <a name="startDragDistance"></a>QApplication::startDragDistance ()<tt> [static]</tt>
</h3>
If you support drag and drop in you application and a drag should
start after a mouse click and after moving the mouse a certain
distance, you should use the value which this method returns as the
distance.
<p> For example, if the mouse position of the click is stored in <tt>startPos</tt> and the current position (e.g. in the mouse move event) is
<tt>currPos</tt>, you can find out if a drag should be started with code
like this:
<pre>
  if ( ( startPos - currPos ).manhattanLength() &gt;
       QApplication::<a href="#startDragDistance">startDragDistance</a>() )
    startTheDrag();
  </pre>
 
<p> Qt uses this value internally, e.g. in <a href="qfiledialog.html">QFileDialog</a>.
<p> The default value is 4 pixels.
<p> <p>See also <a href="#setStartDragDistance">setStartDragDistance</a>(), <a href="#startDragTime">startDragTime</a>(), and <a href="qpoint.html#manhattanLength">QPoint::manhattanLength</a>().

<h3 class=fn>int <a name="startDragTime"></a>QApplication::startDragTime ()<tt> [static]</tt>
</h3>
If you support drag and drop in you application and a drag should
start after a mouse click and after a certain time elapsed, you
should use the value which this method returns as the delay (in ms).
<p> Qt also uses this delay internally, e.g. in <a href="qtextedit.html">QTextEdit</a> and <a href="qlineedit.html">QLineEdit</a>,
for starting a drag.
<p> The default value is 500 ms.
<p> <p>See also <a href="#setStartDragTime">setStartDragTime</a>() and <a href="#startDragDistance">startDragDistance</a>().

<h3 class=fn>bool <a name="startingUp"></a>QApplication::startingUp ()<tt> [static]</tt>
</h3>
Returns TRUE if an application object has not been created yet;
otherwise returns FALSE.
<p> <p>See also <a href="#closingDown">closingDown</a>().

<h3 class=fn><a href="qstyle.html">QStyle</a>&nbsp;&amp; <a name="style"></a>QApplication::style ()<tt> [static]</tt>
</h3>
Returns the application's style object.
<p> <p>See also <a href="#setStyle">setStyle</a>() and <a href="qstyle.html">QStyle</a>.

<h3 class=fn>void <a name="syncX"></a>QApplication::syncX ()<tt> [static]</tt>
</h3>
Synchronizes with the X server in the X11 implementation. This
normally takes some time. Does nothing on other platforms.
<p> <p>See also <a href="#flushX">flushX</a>().

<h3 class=fn>QWidgetList * <a name="topLevelWidgets"></a>QApplication::topLevelWidgets ()<tt> [static]</tt>
</h3>
Returns a list of the top level widgets in the application.
<p> The list is created using <tt>new</tt> and must be deleted by the caller.
<p> The list is empty (<a href="qptrlist.html#isEmpty">QPtrList::isEmpty</a>()) if there are no top level
widgets.
<p> Note that some of the top level widgets may be hidden, for example
the tooltip if no tooltip is currently shown.
<p> Example:
<pre>
    // Show all hidden top level widgets.
    QWidgetList  *list = QApplication::<a href="#topLevelWidgets">topLevelWidgets</a>();
    QWidgetListIt it( *list );  // iterate over the widgets
    <a href="qwidget.html">QWidget</a> * w;
    while ( (w=it.current()) != 0 ) {   // for each top level widget...
        ++it;
        if ( !w-&gt;<a href="qwidget.html#isVisible">isVisible</a>() )
            w-&gt;<a href="qwidget.html#show">show</a>();
    }
    delete list;                // delete the list, not the widgets
  </pre>
 
<p> <b>Warning:</b> Delete the list as soon you have finished using it.
The widgets in the list may be deleted by someone else at any time.
<p> <p>See also <a href="#allWidgets">allWidgets</a>(), <a href="qwidget.html#isTopLevel-prop">QWidget::isTopLevel</a>, <a href="qwidget.html#visible-prop">QWidget::visible</a>, and <a href="qptrlist.html#isEmpty">QPtrList::isEmpty</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="translate"></a>QApplication::translate ( const&nbsp;char&nbsp;*&nbsp;context, const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment = 0, <a href="qapplication.html#Encoding-enum">Encoding</a>&nbsp;encoding = DefaultCodec ) const
</h3><p><b>Note:</b> This function is <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
 
Returns the translation text for <em>sourceText</em>, by querying the
installed messages files. The message files are searched from the most
recently installed message file back to the first installed message
file.
<p> <a href="qobject.html#tr">QObject::tr</a>() and <a href="qobject.html#trUtf8">QObject::trUtf8</a>() provide this functionality more
conveniently.
<p> <em>context</em> is typically a class name (e.g., "MyDialog") and
<em>sourceText</em> is either English text or a short identifying text, if
the output text will be very long (as for help texts).
<p> <em>comment</em> is a disambiguating comment, for when the same <em>sourceText</em> is used in different roles within the same context. By
default, it is null. <em>encoding</em> indicates the 8-bit encoding of
character stings
<p> See the <a href="qtranslator.html">QTranslator</a> documentation for more information about
contexts and comments.
<p> If none of the message files contain a translation for <em>sourceText</em> in <em>context</em>, this function returns a <a href="qstring.html">QString</a>
equivalent of <em>sourceText</em>. The encoding of <em>sourceText</em> is
specified by <em>encoding</em>; it defaults to <a href="#Encoding-enum">DefaultCodec</a>.
<p> This function is not virtual. You can use alternative translation
techniques by subclassing <a href="qtranslator.html">QTranslator</a>.
<p> <b>Warning:</b> This method is reentrant only if all translators are
installed <em>before</em> calling this method.  Installing or removing
translators while performing translations is not supported.  Doing
so will most likely result in crashes or other undesirable behavior.
<p> <p>See also <a href="qobject.html#tr">QObject::tr</a>(), <a href="#installTranslator">installTranslator</a>(), and <a href="#defaultCodec">defaultCodec</a>().

<h3 class=fn>bool <a name="tryLock"></a>QApplication::tryLock ()
</h3> 
<p> Attempts to lock the Qt Library Mutex, and returns immediately. If
the lock was obtained, this function returns TRUE. If another thread
has locked the mutex, this function returns FALSE, instead of
waiting for the lock to become available.
<p> The mutex must be unlocked with <a href="#unlock">unlock</a>() before another thread can
successfully lock it.
<p> <p>See also <a href="#lock">lock</a>(), <a href="#unlock">unlock</a>(), and <a href="threads.html">Thread Support in Qt</a>.

<h3 class=fn><a href="qapplication.html#Type-enum">Type</a> <a name="type"></a>QApplication::type () const
</h3>
Returns the type of application, Tty, GuiClient or GuiServer.

<h3 class=fn>void <a name="unlock"></a>QApplication::unlock ( bool&nbsp;wakeUpGui = TRUE )
</h3> 
<p> Unlock the Qt Library Mutex. If <em>wakeUpGui</em> is TRUE (the default),
then the GUI thread will be woken with <a href="#wakeUpGuiThread">QApplication::wakeUpGuiThread</a>().
<p> <p>See also <a href="#lock">lock</a>(), <a href="#locked">locked</a>(), and <a href="threads.html">Thread Support in Qt</a>.

<h3 class=fn>void <a name="wakeUpGuiThread"></a>QApplication::wakeUpGuiThread ()
</h3>
<p> Wakes up the GUI thread.
<p> <p>See also <a href="#guiThreadAwake">guiThreadAwake</a>() and <a href="threads.html">Thread Support in Qt</a>.

<h3 class=fn>int <a name="wheelScrollLines"></a>QApplication::wheelScrollLines ()<tt> [static]</tt>
</h3>
Returns the number of lines to scroll when the mouse wheel is
rotated.
<p> <p>See also <a href="#setWheelScrollLines">setWheelScrollLines</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="widgetAt"></a>QApplication::widgetAt ( int&nbsp;x, int&nbsp;y, bool&nbsp;child = FALSE )<tt> [static]</tt>
</h3>
Returns a pointer to the widget at global screen position <em>(x, y)</em>, or 0 if there is no Qt widget there.
<p> If <em>child</em> is FALSE and there is a child widget at position <em>(x, y)</em>, the top-level widget containing it is returned. If <em>child</em>
is TRUE the child widget at position <em>(x, y)</em> is returned.
<p> This function is normally rather slow.
<p> <p>See also <a href="qcursor.html#pos">QCursor::pos</a>(), <a href="qwidget.html#grabMouse">QWidget::grabMouse</a>(), and <a href="qwidget.html#grabKeyboard">QWidget::grabKeyboard</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="widgetAt-2"></a>QApplication::widgetAt ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos, bool&nbsp;child = FALSE )<tt> [static]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a pointer to the widget at global screen position <em>pos</em>,
or 0 if there is no Qt widget there.
<p> If <em>child</em> is FALSE and there is a child widget at position <em>pos</em>, the top-level widget containing it is returned. If <em>child</em>
is TRUE the child widget at position <em>pos</em> is returned.

<h3 class=fn>bool <a name="winEventFilter"></a>QApplication::winEventFilter ( MSG * )<tt> [virtual]</tt>
</h3>
This virtual function is only implemented under Windows.
<p> The message procedure calls this function for every message
received. Reimplement this function if you want to process window
messages that are not processed by Qt. If you don't want
the event to be processed by Qt, then return TRUE; otherwise
return FALSE.

<h3 class=fn>void <a name="winFocus"></a>QApplication::winFocus ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;widget, bool&nbsp;gotFocus )
</h3>
This function is available only on Windows.
<p> If <em>gotFocus</em> is TRUE, <em>widget</em> will become the active window.
Otherwise the active window is reset to NULL.

<h3 class=fn>const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp; <a name="winStyleHighlightColor"></a>QApplication::winStyleHighlightColor ()<tt> [static]</tt>
</h3>

<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns the color used to mark selections in windows style.
<p> <p>See also <a href="#setWinStyleHighlightColor">setWinStyleHighlightColor</a>().

<h3 class=fn>bool <a name="x11EventFilter"></a>QApplication::x11EventFilter ( XEvent * )<tt> [virtual]</tt>
</h3>
This virtual function is only implemented under X11.
<p> If you create an application that inherits QApplication and
reimplement this function, you get direct access to all X events
that the are received from the X server.
<p> Return TRUE if you want to stop the event from being processed.
Return FALSE for normal event dispatching.
<p> <p>See also <a href="#x11ProcessEvent">x11ProcessEvent</a>().

<h3 class=fn>int <a name="x11ProcessEvent"></a>QApplication::x11ProcessEvent ( XEvent&nbsp;*&nbsp;event )
</h3>
This function does the core processing of individual X
<em>event</em>s, normally by dispatching Qt events to the right
destination.
<p> It returns 1 if the event was consumed by special handling, 0 if
the <em>event</em> was consumed by normal handling, and -1 if the <em>event</em> was for an unrecognized widget.
<p> <p>See also <a href="#x11EventFilter">x11EventFilter</a>().

<hr><h2>Related Functions</h2>
<h3 class=fn>void <a name="Q_ASSERT"></a>Q_ASSERT ( bool&nbsp;test )
</h3>

<p> 
<p> Prints a warning message containing the source code file name and
line number if <em>test</em> is FALSE.
<p> This is really a macro defined in <a href="qglobal-h.html">qglobal.h</a>.
<p> Q_ASSERT is useful for testing pre- and post-conditions.
<p> Example:
<pre>
        //
        // File: div.cpp
        //

        #include &lt;<a href="qglobal-h.html">qglobal.h</a>&gt;

        int divide( int a, int b )
        {
            <a href="#Q_ASSERT">Q_ASSERT</a>( b != 0 );                 // this is line 9
            return a/b;
        }
    </pre>
 
<p> If <tt>b</tt> is zero, the Q_ASSERT statement will output the following
message using the <a href="#qWarning">qWarning</a>() function:
<pre>
        ASSERT: "b != 0" in div.cpp (9)
    </pre>
 
<p> <p>See also <a href="#qWarning">qWarning</a>() and <a href="debug.html">Debugging</a>.

<h3 class=fn>void <a name="Q_CHECK_PTR"></a>Q_CHECK_PTR ( void&nbsp;*&nbsp;p )
</h3>

<p> 
<p> If <em>p</em> is 0, prints a warning message containing the source code file
name and line number, saying that the program ran out of memory.
<p> This is really a macro defined in <a href="qglobal-h.html">qglobal.h</a>.
<p> Example:
<pre>
        int *a;

        <a href="#Q_CHECK_PTR">Q_CHECK_PTR</a>( a = new int[80] );  // WRONG!

        a = new (nothrow) int[80];       // Right
        <a href="#Q_CHECK_PTR">Q_CHECK_PTR</a>( a );
    </pre>
 
<p> <p>See also <a href="#qWarning">qWarning</a>() and <a href="debug.html">Debugging</a>.

<h3 class=fn>void <a name="qAddPostRoutine"></a>qAddPostRoutine ( QtCleanUpFunction&nbsp;p )
</h3>

<p> Adds a global routine that will be called from the QApplication
destructor. This function is normally used to add cleanup routines
for program-wide functionality.
<p> The function given by <em>p</em> should take no arguments and return
nothing, like this:
<pre>
    static int *global_ptr = 0;

    static void cleanup_ptr()
    {
        delete [] global_ptr;
        global_ptr = 0;
    }

    void init_ptr()
    {
        global_ptr = new int[100];      // allocate data
        <a href="#qAddPostRoutine">qAddPostRoutine</a>( cleanup_ptr ); // delete later
    }
  </pre>
 
<p> Note that for an application- or module-wide cleanup,
<a href="#qAddPostRoutine">qAddPostRoutine</a>() is often not suitable. People have a tendency to
make such modules dynamically loaded, and then unload those modules
long before the QApplication destructor is called, for example.
<p> For modules and libraries, using a reference-counted initialization
manager or Qt' parent-child delete mechanism may be better. Here is
an example of a private class which uses the parent-child mechanism
to call a cleanup function at the right time:
<p> <pre>
    class MyPrivateInitStuff: public <a href="qobject.html">QObject</a> {
    private:
        MyPrivateInitStuff( <a href="qobject.html">QObject</a> * parent ): <a href="qobject.html">QObject</a>( parent) {
            // initialization goes here
        }
        MyPrivateInitStuff * p;

    public:
        static MyPrivateInitStuff * initStuff( <a href="qobject.html">QObject</a> * parent ) {
            if ( !p )
                p = new MyPrivateInitStuff( parent );
            return p;
        }

        ~MyPrivateInitStuff() {
            // cleanup (the "post routine") goes here
        }
    }
  </pre>
 
<p> By selecting the right parent widget/object, this can often be made
to clean up the module's data at the exact right moment.

<h3 class=fn>void <a name="qDebug"></a>qDebug ( const&nbsp;char&nbsp;*&nbsp;msg, ... )
</h3>

<p> 
<p> Prints a debug message <em>msg</em>, or calls the message handler (if it
has been installed).
<p> This function takes a format string and a list of arguments,
similar to the C printf() function.
<p> Example:
<pre>
        <a href="#qDebug">qDebug</a>( "my window handle = %x", myWidget-&gt;id() );
    </pre>
 
<p> Under X11, the text is printed to stderr. Under Windows, the text
is sent to the debugger.
<p> <b>Warning:</b> The internal buffer is limited to 8196 bytes (including
the '&#92;0'-terminator).
<p> <b>Warning:</b> Passing (const char *)0 as argument to qDebug might lead
to crashes on certain platforms due to the platforms printf implementation.
<p> <p>See also <a href="#qWarning">qWarning</a>(), <a href="#qFatal">qFatal</a>(), <a href="#qInstallMsgHandler">qInstallMsgHandler</a>(), and <a href="debug.html">Debugging</a>.

<h3 class=fn>void <a name="qFatal"></a>qFatal ( const&nbsp;char&nbsp;*&nbsp;msg, ... )
</h3>

<p> 
<p> Prints a fatal error message <em>msg</em> and exits, or calls the
message handler (if it has been installed).
<p> This function takes a format string and a list of arguments,
similar to the C printf() function.
<p> Example:
<pre>
        int divide( int a, int b )
        {
            if ( b == 0 )                               // program error
                <a href="#qFatal">qFatal</a>( "divide: cannot divide by zero" );
            return a/b;
        }
    </pre>
 
<p> Under X11, the text is printed to stderr. Under Windows, the text
is sent to the debugger.
<p> <b>Warning:</b> The internal buffer is limited to 8196 bytes (including
the '&#92;0'-terminator).
<p> <b>Warning:</b> Passing (const char *)0 as argument to qFatal might lead
to crashes on certain platforms due to the platforms printf implementation.
<p> <p>See also <a href="#qDebug">qDebug</a>(), <a href="#qWarning">qWarning</a>(), <a href="#qInstallMsgHandler">qInstallMsgHandler</a>(), and <a href="debug.html">Debugging</a>.

<h3 class=fn>QtMsgHandler <a name="qInstallMsgHandler"></a>qInstallMsgHandler ( QtMsgHandler&nbsp;h )
</h3>

<p> Installs a Qt message handler <em>h</em>. Returns a pointer to the
message handler previously defined.
<p> The message handler is a function that prints out debug messages,
warnings and fatal error messages. The Qt library (debug version)
contains hundreds of warning messages that are printed when
internal errors (usually invalid function arguments) occur. If you
implement your own message handler, you get total control of these
messages.
<p> The default message handler prints the message to the standard
output under X11 or to the debugger under Windows. If it is a
fatal message, the application aborts immediately.
<p> Only one message handler can be defined, since this is usually
done on an application-wide basis to control debug output.
<p> To restore the message handler, call <tt>qInstallMsgHandler(0)</tt>.
<p> Example:
<pre>
        #include &lt;<a href="qapplication-h.html">qapplication.h</a>&gt;
        #include &lt;stdio.h&gt;
        #include &lt;stdlib.h&gt;

        void myMessageOutput( QtMsgType type, const char *msg )
        {
            switch ( type ) {
                case QtDebugMsg:
                    fprintf( stderr, "Debug: %s\n", msg );
                    break;
                case QtWarningMsg:
                    fprintf( stderr, "Warning: %s\n", msg );
                    break;
                case QtFatalMsg:
                    fprintf( stderr, "Fatal: %s\n", msg );
                    abort();                    // deliberately core dump
            }
        }

        int main( int argc, char **argv )
        {
            <a href="#qInstallMsgHandler">qInstallMsgHandler</a>( myMessageOutput );
            QApplication a( argc, argv );
            ...
            return a.<a href="#exec">exec</a>();
        }
    </pre>
 
<p> <p>See also <a href="#qDebug">qDebug</a>(), <a href="#qWarning">qWarning</a>(), <a href="#qFatal">qFatal</a>(), and <a href="debug.html">Debugging</a>.

<h3 class=fn>bool <a name="qSysInfo"></a>qSysInfo ( int&nbsp;*&nbsp;wordSize, bool&nbsp;*&nbsp;bigEndian )
</h3>

<p> Obtains information about the system.
<p> The system's word size in bits (typically 32) is returned in <em>*wordSize</em>. The <em>*bigEndian</em> is set to TRUE if this is a big-endian
machine, or to FALSE if this is a little-endian machine.
<p> In debug mode, this function calls <a href="#qFatal">qFatal</a>() with a message if the
computer is truly weird (i.e. different endianness for 16 bit and
32 bit integers); in release mode it returns FALSE.

<h3 class=fn>void <a name="qSystemWarning"></a>qSystemWarning ( const&nbsp;char&nbsp;*&nbsp;msg, int&nbsp;code )
</h3>

<p> Prints the message <em>msg</em> and uses <em>code</em> to get a system specific
error message. When <em>code</em> is -1 (the default), the system's last
error code will be used if possible. Use this method to handle
failures in platform specific API calls.
<p> This function does nothing when Qt is built with <tt>QT_NO_DEBUG</tt>
defined.

<h3 class=fn>const char * <a name="qVersion"></a>qVersion ()
</h3>

<p> Returns the Qt version number as a string, for example, "2.3.0" or
"3.0.5".
<p> The <tt>QT_VERSION</tt> define has the numeric value in the form:
0xmmiibb (m = major, i = minor, b = bugfix). For example, Qt
3.0.5's <tt>QT_VERSION</tt> is 0x030005.

<h3 class=fn>void <a name="qWarning"></a>qWarning ( const&nbsp;char&nbsp;*&nbsp;msg, ... )
</h3>

<p> 
<p> Prints a warning message <em>msg</em>, or calls the message handler (if
it has been installed).
<p> This function takes a format string and a list of arguments,
similar to the C printf() function.
<p> Example:
<pre>
        void f( int c )
        {
            if ( c &gt; 200 )
                <a href="#qWarning">qWarning</a>( "f: bad argument, c == %d", c );
        }
    </pre>
 
<p> Under X11, the text is printed to stderr. Under Windows, the text
is sent to the debugger.
<p> <b>Warning:</b> The internal buffer is limited to 8196 bytes (including
the '&#92;0'-terminator).
<p> <b>Warning:</b> Passing (const char *)0 as argument to qWarning might lead
to crashes on certain platforms due to the platforms printf implementation.
<p> <p>See also <a href="#qDebug">qDebug</a>(), <a href="#qFatal">qFatal</a>(), <a href="#qInstallMsgHandler">qInstallMsgHandler</a>(), and <a href="debug.html">Debugging</a>.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
