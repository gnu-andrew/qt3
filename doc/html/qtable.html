<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/table/qtable.cpp:1659 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QTable Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QTable Class Reference<br><small>[<a href="table.html">table module</a>]</small></h1>

<p>The QTable class provides a flexible editable table widget.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qtable-h.html">qtable.h</a>&gt;</tt>
<p>Inherits <a href="qscrollview.html">QScrollView</a>.
<p>Inherited by <a href="qdatatable.html">QDataTable</a>.
<p><a href="qtable-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QTable"><b>QTable</b></a> ( QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn><a href="#QTable-2"><b>QTable</b></a> ( int&nbsp;numRows, int&nbsp;numCols, QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn><a href="#~QTable"><b>~QTable</b></a> ()</li>
<li class=fn>QHeader * <a href="#horizontalHeader"><b>horizontalHeader</b></a> () const</li>
<li class=fn>QHeader * <a href="#verticalHeader"><b>verticalHeader</b></a> () const</li>
<li class=fn>enum <a href="#SelectionMode-enum"><b>SelectionMode</b></a> { Single, Multi, SingleRow, MultiRow, NoSelection }</li>
<li class=fn>virtual void <a href="#setSelectionMode"><b>setSelectionMode</b></a> ( SelectionMode&nbsp;mode )</li>
<li class=fn>SelectionMode <a href="#selectionMode"><b>selectionMode</b></a> () const</li>
<li class=fn>virtual void <a href="#setItem"><b>setItem</b></a> ( int&nbsp;row, int&nbsp;col, QTableItem&nbsp;*&nbsp;item )</li>
<li class=fn>virtual void <a href="#setText"><b>setText</b></a> ( int&nbsp;row, int&nbsp;col, const&nbsp;QString&nbsp;&amp;&nbsp;text )</li>
<li class=fn>virtual void <a href="#setPixmap"><b>setPixmap</b></a> ( int&nbsp;row, int&nbsp;col, const&nbsp;QPixmap&nbsp;&amp;&nbsp;pix )</li>
<li class=fn>virtual QTableItem * <a href="#item"><b>item</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual QString <a href="#text"><b>text</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual QPixmap <a href="#pixmap"><b>pixmap</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual void <a href="#clearCell"><b>clearCell</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>virtual QRect <a href="#cellGeometry"><b>cellGeometry</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual int <a href="#columnWidth"><b>columnWidth</b></a> ( int&nbsp;col ) const</li>
<li class=fn>virtual int <a href="#rowHeight"><b>rowHeight</b></a> ( int&nbsp;row ) const</li>
<li class=fn>virtual int <a href="#columnPos"><b>columnPos</b></a> ( int&nbsp;col ) const</li>
<li class=fn>virtual int <a href="#rowPos"><b>rowPos</b></a> ( int&nbsp;row ) const</li>
<li class=fn>virtual int <a href="#columnAt"><b>columnAt</b></a> ( int&nbsp;x ) const</li>
<li class=fn>virtual int <a href="#rowAt"><b>rowAt</b></a> ( int&nbsp;y ) const</li>
<li class=fn>virtual int <a href="#numRows"><b>numRows</b></a> () const</li>
<li class=fn>virtual int <a href="#numCols"><b>numCols</b></a> () const</li>
<li class=fn>void <a href="#updateCell"><b>updateCell</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>int <a href="#currentRow"><b>currentRow</b></a> () const</li>
<li class=fn>int <a href="#currentColumn"><b>currentColumn</b></a> () const</li>
<li class=fn>void <a href="#ensureCellVisible"><b>ensureCellVisible</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>bool <a href="#isSelected"><b>isSelected</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>bool <a href="#isRowSelected"><b>isRowSelected</b></a> ( int&nbsp;row, bool&nbsp;full = FALSE ) const</li>
<li class=fn>bool <a href="#isColumnSelected"><b>isColumnSelected</b></a> ( int&nbsp;col, bool&nbsp;full = FALSE ) const</li>
<li class=fn>int <a href="#numSelections"><b>numSelections</b></a> () const</li>
<li class=fn>QTableSelection <a href="#selection"><b>selection</b></a> ( int&nbsp;num ) const</li>
<li class=fn>virtual int <a href="#addSelection"><b>addSelection</b></a> ( const&nbsp;QTableSelection&nbsp;&amp;&nbsp;s )</li>
<li class=fn>virtual void <a href="#removeSelection"><b>removeSelection</b></a> ( const&nbsp;QTableSelection&nbsp;&amp;&nbsp;s )</li>
<li class=fn>virtual void <a href="#removeSelection-2"><b>removeSelection</b></a> ( int&nbsp;num )</li>
<li class=fn>virtual int <a href="#currentSelection"><b>currentSelection</b></a> () const</li>
<li class=fn>void <a href="#selectCells"><b>selectCells</b></a> ( int&nbsp;start_row, int&nbsp;start_col, int&nbsp;end_row, int&nbsp;end_col )</li>
<li class=fn>void <a href="#selectRow"><b>selectRow</b></a> ( int&nbsp;row )</li>
<li class=fn>void <a href="#selectColumn"><b>selectColumn</b></a> ( int&nbsp;col )</li>
<li class=fn>bool <a href="#showGrid"><b>showGrid</b></a> () const</li>
<li class=fn>bool <a href="#columnMovingEnabled"><b>columnMovingEnabled</b></a> () const</li>
<li class=fn>bool <a href="#rowMovingEnabled"><b>rowMovingEnabled</b></a> () const</li>
<li class=fn>virtual void <a href="#sortColumn"><b>sortColumn</b></a> ( int&nbsp;col, bool&nbsp;ascending = TRUE, bool&nbsp;wholeRows = FALSE )</li>
<li class=fn>bool <a href="#sorting"><b>sorting</b></a> () const</li>
<li class=fn>virtual void <a href="#takeItem"><b>takeItem</b></a> ( QTableItem&nbsp;*&nbsp;i )</li>
<li class=fn>virtual void <a href="#setCellWidget"><b>setCellWidget</b></a> ( int&nbsp;row, int&nbsp;col, QWidget&nbsp;*&nbsp;e )</li>
<li class=fn>virtual QWidget * <a href="#cellWidget"><b>cellWidget</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual void <a href="#clearCellWidget"><b>clearCellWidget</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>virtual QRect <a href="#cellRect"><b>cellRect</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>virtual void <a href="#paintCell-2"><b>paintCell</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;row, int&nbsp;col, const&nbsp;QRect&nbsp;&amp;&nbsp;cr, bool&nbsp;selected )</li>
<li class=fn>virtual void <a href="#paintCell"><b>paintCell</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;row, int&nbsp;col, const&nbsp;QRect&nbsp;&amp;&nbsp;cr, bool&nbsp;selected, const&nbsp;QColorGroup&nbsp;&amp;&nbsp;cg )</li>
<li class=fn>virtual void <a href="#paintFocus"><b>paintFocus</b></a> ( QPainter&nbsp;*&nbsp;p, const&nbsp;QRect&nbsp;&amp;&nbsp;cr )</li>
<li class=fn>bool <a href="#isReadOnly"><b>isReadOnly</b></a> () const</li>
<li class=fn>bool <a href="#isRowReadOnly"><b>isRowReadOnly</b></a> ( int&nbsp;row ) const</li>
<li class=fn>bool <a href="#isColumnReadOnly"><b>isColumnReadOnly</b></a> ( int&nbsp;col ) const</li>
<li class=fn>void <a href="#repaintSelections"><b>repaintSelections</b></a> ()</li>
<li class=fn>enum <a href="#FocusStyle-enum"><b>FocusStyle</b></a> { FollowStyle, SpreadSheet }</li>
<li class=fn>virtual void <a href="#setFocusStyle"><b>setFocusStyle</b></a> ( FocusStyle&nbsp;fs )</li>
<li class=fn>FocusStyle <a href="#focusStyle"><b>focusStyle</b></a> () const</li>
<li class=fn>void <a href="#updateHeaderStates"><b>updateHeaderStates</b></a> ()</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>virtual void <a href="#setNumRows"><b>setNumRows</b></a> ( int&nbsp;r )</li>
<li class=fn>virtual void <a href="#setNumCols"><b>setNumCols</b></a> ( int&nbsp;r )</li>
<li class=fn>virtual void <a href="#setShowGrid"><b>setShowGrid</b></a> ( bool&nbsp;b )</li>
<li class=fn>virtual void <a href="#hideRow"><b>hideRow</b></a> ( int&nbsp;row )</li>
<li class=fn>virtual void <a href="#hideColumn"><b>hideColumn</b></a> ( int&nbsp;col )</li>
<li class=fn>virtual void <a href="#showRow"><b>showRow</b></a> ( int&nbsp;row )</li>
<li class=fn>virtual void <a href="#showColumn"><b>showColumn</b></a> ( int&nbsp;col )</li>
<li class=fn>bool <a href="#isRowHidden"><b>isRowHidden</b></a> ( int&nbsp;row ) const</li>
<li class=fn>bool <a href="#isColumnHidden"><b>isColumnHidden</b></a> ( int&nbsp;col ) const</li>
<li class=fn>virtual void <a href="#setColumnWidth"><b>setColumnWidth</b></a> ( int&nbsp;col, int&nbsp;w )</li>
<li class=fn>virtual void <a href="#setRowHeight"><b>setRowHeight</b></a> ( int&nbsp;row, int&nbsp;h )</li>
<li class=fn>virtual void <a href="#adjustColumn"><b>adjustColumn</b></a> ( int&nbsp;col )</li>
<li class=fn>virtual void <a href="#adjustRow"><b>adjustRow</b></a> ( int&nbsp;row )</li>
<li class=fn>virtual void <a href="#setColumnStretchable"><b>setColumnStretchable</b></a> ( int&nbsp;col, bool&nbsp;stretch )</li>
<li class=fn>virtual void <a href="#setRowStretchable"><b>setRowStretchable</b></a> ( int&nbsp;row, bool&nbsp;stretch )</li>
<li class=fn>bool <a href="#isColumnStretchable"><b>isColumnStretchable</b></a> ( int&nbsp;col ) const</li>
<li class=fn>bool <a href="#isRowStretchable"><b>isRowStretchable</b></a> ( int&nbsp;row ) const</li>
<li class=fn>virtual void <a href="#setSorting"><b>setSorting</b></a> ( bool&nbsp;b )</li>
<li class=fn>virtual void <a href="#swapRows"><b>swapRows</b></a> ( int&nbsp;row1, int&nbsp;row2, bool&nbsp;swapHeader = FALSE )</li>
<li class=fn>virtual void <a href="#swapColumns"><b>swapColumns</b></a> ( int&nbsp;col1, int&nbsp;col2, bool&nbsp;swapHeader = FALSE )</li>
<li class=fn>virtual void <a href="#swapCells"><b>swapCells</b></a> ( int&nbsp;row1, int&nbsp;col1, int&nbsp;row2, int&nbsp;col2 )</li>
<li class=fn>virtual void <a href="#setLeftMargin"><b>setLeftMargin</b></a> ( int&nbsp;m )</li>
<li class=fn>virtual void <a href="#setTopMargin"><b>setTopMargin</b></a> ( int&nbsp;m )</li>
<li class=fn>virtual void <a href="#setCurrentCell"><b>setCurrentCell</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>void <a href="#clearSelection"><b>clearSelection</b></a> ( bool&nbsp;repaint = TRUE )</li>
<li class=fn>virtual void <a href="#setColumnMovingEnabled"><b>setColumnMovingEnabled</b></a> ( bool&nbsp;b )</li>
<li class=fn>virtual void <a href="#setRowMovingEnabled"><b>setRowMovingEnabled</b></a> ( bool&nbsp;b )</li>
<li class=fn>virtual void <a href="#setReadOnly"><b>setReadOnly</b></a> ( bool&nbsp;b )</li>
<li class=fn>virtual void <a href="#setRowReadOnly"><b>setRowReadOnly</b></a> ( int&nbsp;row, bool&nbsp;ro )</li>
<li class=fn>virtual void <a href="#setColumnReadOnly"><b>setColumnReadOnly</b></a> ( int&nbsp;col, bool&nbsp;ro )</li>
<li class=fn>virtual void <a href="#setDragEnabled"><b>setDragEnabled</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#dragEnabled"><b>dragEnabled</b></a> () const</li>
<li class=fn>virtual void <a href="#insertRows"><b>insertRows</b></a> ( int&nbsp;row, int&nbsp;count = 1 )</li>
<li class=fn>virtual void <a href="#insertColumns"><b>insertColumns</b></a> ( int&nbsp;col, int&nbsp;count = 1 )</li>
<li class=fn>virtual void <a href="#removeRow"><b>removeRow</b></a> ( int&nbsp;row )</li>
<li class=fn>virtual void <a href="#removeRows"><b>removeRows</b></a> ( const&nbsp;QMemArray&lt;int&gt;&nbsp;&amp;&nbsp;rows )</li>
<li class=fn>virtual void <a href="#removeColumn"><b>removeColumn</b></a> ( int&nbsp;col )</li>
<li class=fn>virtual void <a href="#removeColumns"><b>removeColumns</b></a> ( const&nbsp;QMemArray&lt;int&gt;&nbsp;&amp;&nbsp;cols )</li>
<li class=fn>virtual void <a href="#editCell"><b>editCell</b></a> ( int&nbsp;row, int&nbsp;col, bool&nbsp;replace = FALSE )</li>
<li class=fn>void <a href="#setRowLabels"><b>setRowLabels</b></a> ( const&nbsp;QStringList&nbsp;&amp;&nbsp;labels )</li>
<li class=fn>void <a href="#setColumnLabels"><b>setColumnLabels</b></a> ( const&nbsp;QStringList&nbsp;&amp;&nbsp;labels )</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#currentChanged"><b>currentChanged</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>void <a href="#clicked"><b>clicked</b></a> ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;QPoint&nbsp;&amp;&nbsp;mousePos )</li>
<li class=fn>void <a href="#doubleClicked"><b>doubleClicked</b></a> ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;QPoint&nbsp;&amp;&nbsp;mousePos )</li>
<li class=fn>void <a href="#pressed"><b>pressed</b></a> ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;QPoint&nbsp;&amp;&nbsp;mousePos )</li>
<li class=fn>void <a href="#selectionChanged"><b>selectionChanged</b></a> ()</li>
<li class=fn>void <a href="#valueChanged"><b>valueChanged</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>void <a href="#contextMenuRequested"><b>contextMenuRequested</b></a> ( int&nbsp;row, int&nbsp;col, const&nbsp;QPoint&nbsp;&amp;&nbsp;pos )</li>
<li class=fn>void <a href="#dropped"><b>dropped</b></a> ( QDropEvent&nbsp;*&nbsp;e )</li>
</ul>
<h2>Properties</h2>
<ul>
<li class=fn>bool <a href="#columnMovingEnabled-prop"><b>columnMovingEnabled</b></a>&nbsp;- whether columns can be moved by the user</li>
<li class=fn>FocusStyle <a href="#focusStyle-prop"><b>focusStyle</b></a>&nbsp;- how the current (focus) cell is drawn</li>
<li class=fn>int <a href="#numCols-prop"><b>numCols</b></a>&nbsp;- the number of columns in the table</li>
<li class=fn>int <a href="#numRows-prop"><b>numRows</b></a>&nbsp;- the number of rows in the table</li>
<li class=fn>int <a href="#numSelections-prop"><b>numSelections</b></a>&nbsp;- the number of selections &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#readOnly-prop"><b>readOnly</b></a>&nbsp;- whether the table is read-only</li>
<li class=fn>bool <a href="#rowMovingEnabled-prop"><b>rowMovingEnabled</b></a>&nbsp;- whether rows can be moved by the user</li>
<li class=fn>SelectionMode <a href="#selectionMode-prop"><b>selectionMode</b></a>&nbsp;- the current selection mode</li>
<li class=fn>bool <a href="#showGrid-prop"><b>showGrid</b></a>&nbsp;- whether the table's grid is displayed</li>
<li class=fn>bool <a href="#sorting-prop"><b>sorting</b></a>&nbsp;- whether a click on the header of a column sorts that column</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>enum <a href="#EditMode-enum"><b>EditMode</b></a> { NotEditing, Editing, Replacing }</li>
<li class=fn>virtual void <a href="#drawContents"><b>drawContents</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;cx, int&nbsp;cy, int&nbsp;cw, int&nbsp;ch )</li>
<li class=fn>void <a href="#setEditMode"><b>setEditMode</b></a> ( EditMode&nbsp;mode, int&nbsp;row, int&nbsp;col )</li>
<li class=fn>virtual void <a href="#contentsDragEnterEvent"><b>contentsDragEnterEvent</b></a> ( QDragEnterEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsDragMoveEvent"><b>contentsDragMoveEvent</b></a> ( QDragMoveEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsDragLeaveEvent"><b>contentsDragLeaveEvent</b></a> ( QDragLeaveEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsDropEvent"><b>contentsDropEvent</b></a> ( QDropEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual QDragObject * <a href="#dragObject"><b>dragObject</b></a> ()</li>
<li class=fn>virtual void <a href="#startDrag"><b>startDrag</b></a> ()</li>
<li class=fn>virtual void <a href="#paintEmptyArea"><b>paintEmptyArea</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;cx, int&nbsp;cy, int&nbsp;cw, int&nbsp;ch )</li>
<li class=fn>virtual void <a href="#activateNextCell"><b>activateNextCell</b></a> ()</li>
<li class=fn>virtual QWidget * <a href="#createEditor"><b>createEditor</b></a> ( int&nbsp;row, int&nbsp;col, bool&nbsp;initFromCell ) const</li>
<li class=fn>virtual void <a href="#setCellContentFromEditor"><b>setCellContentFromEditor</b></a> ( int&nbsp;row, int&nbsp;col )</li>
<li class=fn>virtual QWidget * <a href="#beginEdit"><b>beginEdit</b></a> ( int&nbsp;row, int&nbsp;col, bool&nbsp;replace )</li>
<li class=fn>virtual void <a href="#endEdit"><b>endEdit</b></a> ( int&nbsp;row, int&nbsp;col, bool&nbsp;accept, bool&nbsp;replace )</li>
<li class=fn>virtual void <a href="#resizeData"><b>resizeData</b></a> ( int&nbsp;len )</li>
<li class=fn>virtual void <a href="#insertWidget"><b>insertWidget</b></a> ( int&nbsp;row, int&nbsp;col, QWidget&nbsp;*&nbsp;w )</li>
<li class=fn>int <a href="#indexOf"><b>indexOf</b></a> ( int&nbsp;row, int&nbsp;col ) const</li>
<li class=fn>bool <a href="#isEditing"><b>isEditing</b></a> () const</li>
<li class=fn>EditMode <a href="#editMode"><b>editMode</b></a> () const</li>
<li class=fn>int <a href="#currEditRow"><b>currEditRow</b></a> () const</li>
<li class=fn>int <a href="#currEditCol"><b>currEditCol</b></a> () const</li>
</ul>
<h2>Protected Slots</h2>
<ul>
<li class=fn>virtual void <a href="#columnWidthChanged"><b>columnWidthChanged</b></a> ( int&nbsp;col )</li>
<li class=fn>virtual void <a href="#rowHeightChanged"><b>rowHeightChanged</b></a> ( int&nbsp;row )</li>
<li class=fn>virtual void <a href="#columnIndexChanged"><b>columnIndexChanged</b></a> ( int&nbsp;section, int&nbsp;fromIndex, int&nbsp;toIndex )</li>
<li class=fn>virtual void <a href="#rowIndexChanged"><b>rowIndexChanged</b></a> ( int&nbsp;section, int&nbsp;fromIndex, int&nbsp;toIndex )</li>
<li class=fn>virtual void <a href="#columnClicked"><b>columnClicked</b></a> ( int&nbsp;col )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QTable class provides a flexible editable table widget.

<p> 


<p> QTable is easy to use, although it does have a large API because
of the comprehensive functionality that it provides. QTable
includes functions for manipulating <a href="#headers">headers</a>, <a href="#columnsrows">rows and columns</a>,
<a href="#cells">cells</a> and <a href="#selections">selections</a>. QTable also provides in-place editing and
<a href="dnd.html">drag and drop</a>, as well as a useful set of
<a href="#signals">signals</a>. QTable efficiently supports very
large tables, for example, tables one million by one million cells
are perfectly possible. QTable is economical with memory, using
none for unused cells.
<p> <pre>
    QTable *table = new QTable( 100, 250, this );
    table-&gt;<a href="#setPixmap">setPixmap</a>( 3, 2, pix );
    table-&gt;<a href="#setText">setText</a>( 3, 2, "A pixmap" );
    </pre>
 
<p> The first line constructs the table specifying its size in rows
and columns. We then insert a pixmap and some text into the <em>same</em> <a href="#cells">cell</a>, with the pixmap appearing to the
left of the text. QTable cells can be populated with
<a href="qtableitem.html">QTableItem</a>s, <a href="qcombotableitem.html">QComboTableItem</a>s or by <a href="qchecktableitem.html">QCheckTableItem</a>s.
By default a vertical header appears at the left of the table
showing row numbers and a horizontal header appears at the top of
the table showing column numbers. (The numbers displayed start at
1, although row and column numbers within QTable begin at 0.)
<p> If you want to use mouse tracking call <a href="qwidget.html#setMouseTracking">setMouseTracking</a>( TRUE ) on
the <em>viewport</em>; (see <a href="qscrollview.html#allviews">QScrollView</a>).
<p> <center><img src="qtableitems.png" alt="Table Items"></center> 
<p> <a name="headers"></a>
<h3> Headers
</h3>
<a name="1"></a><p> QTable supports a header column, e.g. to display row numbers, and
a header row, e.g to display column titles. To set row or column
labels use <a href="qheader.html#setLabel">QHeader::setLabel</a>() on the pointers returned by
<a href="#verticalHeader">verticalHeader</a>() and <a href="#horizontalHeader">horizontalHeader</a>() respectively. The vertical
header is displayed within the table's left margin whose width is
set with <a href="#setLeftMargin">setLeftMargin</a>(). The horizontal header is displayed
within the table's top margin whose height is set with
<a href="#setTopMargin">setTopMargin</a>(). The table's grid can be switched off with
<a href="#setShowGrid">setShowGrid</a>(). If you want to hide a horizontal header call
<a href="qwidget.html#hide">hide</a>(), and call setTopMargin( 0 ) so that the area the header
would have occupied is reduced to zero size.
<p> Header labels are indexed via their section numbers. Note that the
default behavior of <a href="qheader.html">QHeader</a> regarding section numbers is overriden
for QTable. See the explanation below in the Rows and Columns
section in the discussion of moving columns and rows.
<p> <a name="columnsrows"></a>
<h3> Rows and Columns
</h3>
<a name="1-1"></a><p> Row and column sizes are set with <a href="#setRowHeight">setRowHeight</a>() and
<a href="#setColumnWidth">setColumnWidth</a>(). If you want a row high enough to show the
tallest item in its entirety, use <a href="#adjustRow">adjustRow</a>(). Similarly, to make
a column wide enough to show the widest item use <a href="#adjustColumn">adjustColumn</a>().
If you want the row height and column width to adjust
automatically as the height and width of the table changes use
<a href="#setRowStretchable">setRowStretchable</a>() and <a href="#setColumnStretchable">setColumnStretchable</a>().
<p> Rows and columns can be hidden and shown with <a href="#hideRow">hideRow</a>(),
<a href="#hideColumn">hideColumn</a>(), <a href="#showRow">showRow</a>() and <a href="#showColumn">showColumn</a>(). New rows and columns are
inserted using <a href="#insertRows">insertRows</a>() and <a href="#insertColumns">insertColumns</a>(). Additional rows
and columns are added at the  bottom (rows) or right (columns) if
you set <a href="#setNumRows">setNumRows</a>() or <a href="#setNumCols">setNumCols</a>() to be larger than <a href="#numRows">numRows</a>()
or <a href="#numCols">numCols</a>(). Existing rows and columns are removed with
<a href="#removeRow">removeRow</a>() and <a href="#removeColumn">removeColumn</a>(). Multiple rows and columns can be
removed with <a href="#removeRows">removeRows</a>() and <a href="#removeColumns">removeColumns</a>().
<p> Rows and columns can be set to be moveable using
<a href="#rowMovingEnabled">rowMovingEnabled</a>() and <a href="#columnMovingEnabled">columnMovingEnabled</a>(). The user can drag
them to reorder them holding down the Ctrl key and dragging the
mouse. For performance reasons, the default behavior of <a href="qheader.html">QHeader</a>
section numbers is overridden by QTable. Currently in QTable, when
a row or column is dragged and reordered, the section number is
also changed to its new position. Therefore, there is no
difference between the section and the index fields in QHeader.
The QTable QHeader classes do not provide a mechanism for indexing
independently of the user interface ordering.
<p> The table can be sorted using <a href="#sortColumn">sortColumn</a>(). Users can sort a
column by clicking its header if <a href="#setSorting">setSorting</a>() is set to TRUE. Rows
can be swapped with <a href="#swapRows">swapRows</a>(), columns with <a href="#swapColumns">swapColumns</a>() and
cells with <a href="#swapCells">swapCells</a>().
<p> For editable tables (see <a href="#setReadOnly">setReadOnly</a>()) you can set the read-only
property of individual rows and columns with <a href="#setRowReadOnly">setRowReadOnly</a>() and
<a href="#setColumnReadOnly">setColumnReadOnly</a>(). (Whether a cell is editable or read-only
depends on these settings and the cell's <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.)
<p> The row and column which have the focus are returned by
<a href="#currentRow">currentRow</a>() and <a href="#currentColumn">currentColumn</a>() respectively.
<p> Although many QTable functions operate in terms of rows and
columns the <a href="#indexOf">indexOf</a>() function returns a single integer
identifying a particular cell.
<p> <a name="cells"></a>
<h3> Cells
</h3>
<a name="1-2"></a><p> All of a QTable's cells are empty when the table is constructed.
<p> There are two approaches to populating the table's cells. The
first and simplest approach is to use QTableItems or <a href="qtableitem.html">QTableItem</a>
subclasses. The second approach doesn't use QTableItems at all
which is useful for very large sparse tables but requires you to
reimplement a number of functions. We'll look at each approach in
turn.
<p> To put a string in a cell use <a href="#setText">setText</a>(). This function will create
a new QTableItem for the cell if one doesn't already exist, and
displays the text in it. By default the table item's widget will
be a <a href="qlineedit.html">QLineEdit</a>. A pixmap may be put in a cell with <a href="#setPixmap">setPixmap</a>(),
which also creates a table item if required. A cell may contain <em>both</em> a pixmap and text; the pixmap is displayed to the left of the
text. Another approach is to construct a QTableItem or QTableItem
subclass, set its properties, then insert it into a cell with
<a href="#setItem">setItem</a>().
<p> If you want cells which contain comboboxes use the <a href="qcombotableitem.html">QComboTableItem</a>
class. Similarly if you require cells containing checkboxes use
the <a href="qchecktableitem.html">QCheckTableItem</a> class. These table items look and behave just
like the combobox or checkbox widgets but consume far less memory.
<p> 

<pre>        for ( int j = 0; j &lt; numRows; ++j )
    <a name="x2445"></a>        table.<a href="#setItem">setItem</a>( j, 1, new <a href="qchecktableitem.html">QCheckTableItem</a>( &amp;table, "Check me" ) );
</pre>In the example above we create a column of QCheckTableItems and
insert them into the table using setItem().
<p> QTable takes ownership of its QTableItems and will delete them
when the table itself is destroyed. You can take ownership of a
table item using <a href="#takeItem">takeItem</a>() which you use to move a cell's
contents from one cell to another, either within the same table,
or from one table to another. (See also, <a href="#swapCells">swapCells</a>()).
<p> In-place editing of the text in QTableItems, and the values in
QComboTableItems and QCheckTableItems works automatically. Cells
may be editable or read-only, see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>. If you
want fine control over editing see <a href="#beginEdit">beginEdit</a>() and <a href="#endEdit">endEdit</a>().
<p> The contents of a cell can be retrieved as a <a href="qtableitem.html">QTableItem</a> using
<a href="#item">item</a>(), or as a string with <a href="#text">text</a>() or as a pixmap (if there is
one) with <a href="#pixmap">pixmap</a>(). A cell's bounding rectangle is given by
<a href="#cellGeometry">cellGeometry</a>(). Use <a href="#updateCell">updateCell</a>() to repaint a cell, for example to
clear away a cell's visual representation after it has been
deleted with <a href="#clearCell">clearCell</a>(). The table can be forced to scroll to
show a particular cell with <a href="#ensureCellVisible">ensureCellVisible</a>(). The <a href="#isSelected">isSelected</a>()
function indicates if a cell is selected.
<p> It is possible to use your own widget as a cell's widget using
<a href="#setCellWidget">setCellWidget</a>(), but subclassing QTableItem might be a simpler
approach. The cell's widget (if there is one) can be removed with
<a href="#clearCellWidget">clearCellWidget</a>().
<p> <!-- index notes on large tables --><a name="notes-on-large-tables"></a><a name="bigtables"></a>
<h4> Large tables
</h4>
<a name="1-2-1"></a><p> For large, sparse, tables using QTableItems or other widgets is
inefficient. The solution is to <em>draw</em> the cell as it should
appear and to create and destroy cell editors on demand.
<p> This approach requires that you reimplement various functions.
Reimplement <a href="#paintCell">paintCell</a>() to display your data, and <a href="#createEditor">createEditor</a>()
and <a href="#setCellContentFromEditor">setCellContentFromEditor</a>() to support in-place editing. It
is very important to reimplement <a href="#resizeData">resizeData</a>() to have no
functionality, to prevent QTable from attempting to create a huge
array. You will also need to reimplement <a href="#item">item</a>(), <a href="#setItem">setItem</a>(),
<a href="#takeItem">takeItem</a>(), <a href="#clearCell">clearCell</a>(), and <a href="#insertWidget">insertWidget</a>(), <a href="#cellWidget">cellWidget</a>() and
<a href="#clearCellWidget">clearCellWidget</a>(). In almost every circumstance (for sorting,
removing and inserting columns and rows, etc.), you also need
to reimplement <a href="#swapRows">swapRows</a>(), <a href="#swapCells">swapCells</a>() and <a href="#swapColumns">swapColumns</a>(), including
header handling.
<p> If you represent active cells with a dictionary of QTableItems and
QWidgets, i.e. only store references to cells that are actually
used, many of the functions can be implemented with a single line
of code. (See the <a href="table-bigtable-main-cpp.html">table/bigtable/main.cpp</a> example.)
<p> For more information on cells see the <a href="qtableitem.html">QTableItem</a> documenation.
<p> <a name="selections"></a>
<h3> Selections
</h3>
<a name="1-3"></a><p> QTable's support single selection, multi-selection (multiple
cells) or no selection. The selection mode is set with
<a href="#setSelectionMode">setSelectionMode</a>(). Use <a href="#isSelected">isSelected</a>() to determine if a particular
cell is selected, and <a href="#isRowSelected">isRowSelected</a>() and <a href="#isColumnSelected">isColumnSelected</a>() to
see if a row or column is selected.
<p> QTable's support many simultaneous selections. You can
programmatically select cells with <a href="#addSelection">addSelection</a>(). The number of
selections is given by <a href="#numSelections">numSelections</a>(). The current selection is
returned by <a href="#currentSelection">currentSelection</a>(). You can remove a selection with
<a href="#removeSelection">removeSelection</a>() and remove all selections with
<a href="#clearSelection">clearSelection</a>(). Selections are <a href="qtableselection.html">QTableSelection</a> objects.
<p> To easily add a new selection use <a href="#selectCells">selectCells</a>(), <a href="#selectRow">selectRow</a>() or
<a href="#selectColumn">selectColumn</a>().
<p> Alternatively, use addSelection() to add new selections using
QTableSelection objects. The advantage of using QTableSelection
objects is that you can call <a href="qtableselection.html#expandTo">QTableSelection::expandTo</a>() to resize
the selection and can query and compare them.
<p> The number of selections is given by numSelections(). The current
selection is returned by currentSelection(). You can remove a
selection with removeSelection() and remove all selections with
clearSelection().
<p> <a name="signals"></a>
<h3> Signals
</h3>
<a name="1-4"></a><p> When the user clicks a cell the <a href="#currentChanged">currentChanged</a>() signal is
emitted. You can also connect to the lower level <a href="#clicked">clicked</a>(),
<a href="#doubleClicked">doubleClicked</a>() and <a href="#pressed">pressed</a>() signals. If the user changes the
selection the <a href="#selectionChanged">selectionChanged</a>() signal is emitted; similarly if
the user changes a cell's value the <a href="#valueChanged">valueChanged</a>() signal is
emitted. If the user right-clicks (or presses the appropriate
platform-specific key sequence) the <a href="#contextMenuRequested">contextMenuRequested</a>() signal
is emitted. If the user drops a drag and drop object the <a href="#dropped">dropped</a>()
signal is emitted with the drop event.
<p>See also <a href="advanced.html">Advanced Widgets</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="EditMode-enum"></a>QTable::EditMode</h3>

<ul>
<li><tt>QTable::NotEditing</tt> - No cell is currently being edited.
<li><tt>QTable::Editing</tt> - A cell is currently being edited. The editor was
initialised with the cell's contents.
<li><tt>QTable::Replacing</tt> - A cell is currently being edited. The editor was
not initialised with the cell's contents.
</ul>
<h3 class=fn><a name="FocusStyle-enum"></a>QTable::FocusStyle</h3>

<p> Specifies how the current cell (focus cell) is drawn.
<ul>
<li><tt>QTable::FollowStyle</tt> - The current cell is drawn according to the
current style and the cell's background is also drawn selected, if
the current cell is within a selection
<li><tt>QTable::SpreadSheet</tt> - The current cell is drawn as in a spreadsheet.
This means, it is signified by a black rectangle around the cell,
and the background of the current cell is always drawn with the
widget's base color - even when selected.
</ul><p> 
<h3 class=fn><a name="SelectionMode-enum"></a>QTable::SelectionMode</h3>

<ul>
<li><tt>QTable::NoSelection</tt> - No cell can be selected by the user.
<li><tt>QTable::Single</tt> - The user may only select a single range of cells.
<li><tt>QTable::Multi</tt> - The user may select multiple ranges of cells.
<li><tt>QTable::SingleRow</tt> - The user may select one row at once.
<li><tt>QTable::MultiRow</tt> - The user may select multiple rows.
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QTable"></a>QTable::QTable ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Creates an empty table object called <em>name</em> as a child of <em>parent</em>.
<p> Call <a href="#setNumRows">setNumRows</a>() and <a href="#setNumCols">setNumCols</a>() to set the table size before
populating the table if you're using QTableItems.
<p> <p>See also <a href="qwidget.html#clearWFlags">QWidget::clearWFlags</a>() and <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.

<h3 class=fn><a name="QTable-2"></a>QTable::QTable ( int&nbsp;numRows, int&nbsp;numCols, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Constructs an empty table called <em>name</em> with <em>numRows</em> rows and
<em>numCols</em> columns. The table is a child of <em>parent</em>.
<p> If you're using <a href="qtableitem.html">QTableItem</a>s to populate the table's cells, you
can create <a href="qtableitem.html">QTableItem</a>, <a href="qcombotableitem.html">QComboTableItem</a> and <a href="qchecktableitem.html">QCheckTableItem</a> items
and insert them into the table using <a href="#setItem">setItem</a>(). (See the <a href="qtable.html#notes-on-large-tables">notes on large tables</a> for an alternative to using QTableItems.)
<p> <p>See also <a href="qwidget.html#clearWFlags">QWidget::clearWFlags</a>() and <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a>.

<h3 class=fn><a name="~QTable"></a>QTable::~QTable ()
</h3>
Releases all the resources used by the QTable object,
including all <a href="qtableitem.html">QTableItem</a>s and their widgets.

<h3 class=fn>void <a name="activateNextCell"></a>QTable::activateNextCell ()<tt> [virtual protected]</tt>
</h3>
This function is called to activate the next cell if in-place
editing was finished by pressing the Enter key.
<p> The default behaviour is to move from top to bottom, i.e. move to
the cell beneath the cell being edited. Reimplement this function
if you want different behaviour, e.g. moving from left to right.

<h3 class=fn>int <a name="addSelection"></a>QTable::addSelection ( const&nbsp;<a href="qtableselection.html">QTableSelection</a>&nbsp;&amp;&nbsp;s )<tt> [virtual]</tt>
</h3>
Adds a selection described by <em>s</em> to the table and returns its
number or -1 if the selection is invalid.
<p> Remember to call <a href="qtableselection.html#init">QTableSelection::init</a>() and
<a href="qtableselection.html#expandTo">QTableSelection::expandTo</a>() to make the selection valid (see also
<a href="qtableselection.html#isActive">QTableSelection::isActive</a>(), or use the
<a href="qtableselection.html">QTableSelection</a>(int,int,int,int) constructor).
<p> <p>See also <a href="#numSelections-prop">numSelections</a>, <a href="#removeSelection">removeSelection</a>(), and <a href="#clearSelection">clearSelection</a>().

<h3 class=fn>void <a name="adjustColumn"></a>QTable::adjustColumn ( int&nbsp;col )<tt> [virtual slot]</tt>
</h3>
Resizes column <em>col</em> so that the column width is wide enough to
display the widest item the column contains.
<p> <p>See also <a href="#adjustRow">adjustRow</a>().

<p>Example: <a href="regexptester-example.html#x2498">regexptester/regexptester.cpp</a>.
<p>Reimplemented in <a href="qdatatable.html#adjustColumn">QDataTable</a>.
<h3 class=fn>void <a name="adjustRow"></a>QTable::adjustRow ( int&nbsp;row )<tt> [virtual slot]</tt>
</h3>
Resizes row <em>row</em> so that the row height is tall enough to
display the tallest item the row contains.
<p> <p>See also <a href="#adjustColumn">adjustColumn</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="beginEdit"></a>QTable::beginEdit ( int&nbsp;row, int&nbsp;col, bool&nbsp;replace )<tt> [virtual protected]</tt>
</h3>
This function is called to start in-place editing of the cell at
<em>row</em>, <em>col</em>. Editing is achieved by creating an editor
(<a href="#createEditor">createEditor</a>() is called) and setting the cell's editor with
<a href="#setCellWidget">setCellWidget</a>() to the newly created editor. (After editing is
complete <a href="#endEdit">endEdit</a>() will be called to replace the cell's content
with the editor's content.) If <em>replace</em> is TRUE the editor will
start empty; otherwise it will be initialized with the cell's
content (if any), i.e. the user will be modifying the original
cell content.
<p> <p>See also <a href="#endEdit">endEdit</a>().

<h3 class=fn><a href="qrect.html">QRect</a> <a name="cellGeometry"></a>QTable::cellGeometry ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the bounding rectangle of the cell at <em>row</em>, <em>col</em> in
content coordinates.

<h3 class=fn><a href="qrect.html">QRect</a> <a name="cellRect"></a>QTable::cellRect ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the geometry of cell <em>row</em>, <em>col</em> in the cell's
coordinate system. This is a convenience function useful in
<a href="#paintCell">paintCell</a>(). It is equivalent to <a href="qrect.html">QRect</a>( <a href="qpoint.html">QPoint</a>(0,0), <a href="#cellGeometry">cellGeometry</a>(
row, col).<a href="qwidget.html#size">size</a>() );
<p> <p>See also <a href="#cellGeometry">cellGeometry</a>().

<p>Example: <a href="tutorial2-08.html#x2610">chart/setdataform.cpp</a>.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="cellWidget"></a>QTable::cellWidget ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the widget that has been set for the cell at <em>row</em>, <em>col</em>, or 0 if no widget has been set.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> <p>See also <a href="#clearCellWidget">clearCellWidget</a>() and <a href="#setCellWidget">setCellWidget</a>().

<p>Example: <a href="tutorial2-08.html#x2611">chart/setdataform.cpp</a>.
<h3 class=fn>void <a name="clearCell"></a>QTable::clearCell ( int&nbsp;row, int&nbsp;col )<tt> [virtual]</tt>
</h3>
Removes the <a href="qtableitem.html">QTableItem</a> at <em>row</em>, <em>col</em>.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.

<h3 class=fn>void <a name="clearCellWidget"></a>QTable::clearCellWidget ( int&nbsp;row, int&nbsp;col )<tt> [virtual]</tt>
</h3>
Removes the widget (if there is one) set for the cell at <em>row</em>,
<em>col</em>.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> This function deletes the widget at <em>row</em>, <em>col</em>. Note that the
widget is not deleted immediately; instead <a href="qobject.html#deleteLater">QObject::deleteLater</a>()
is called on the widget to avoid problems with timing issues.
<p> <p>See also <a href="#cellWidget">cellWidget</a>() and <a href="#setCellWidget">setCellWidget</a>().

<h3 class=fn>void <a name="clearSelection"></a>QTable::clearSelection ( bool&nbsp;repaint = TRUE )<tt> [slot]</tt>
</h3>
Clears all selections and repaints the appropriate regions if <em>repaint</em> is TRUE.
<p> <p>See also <a href="#removeSelection">removeSelection</a>().

<h3 class=fn>void <a name="clicked"></a>QTable::clicked ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;mousePos )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when mouse button <em>button</em> is clicked. The
cell where the event took place is at <em>row</em>, <em>col</em>, and the
mouse's position is in <em>mousePos</em>.
<p> <p>See also <a href="qt.html#ButtonState-enum">Qt::ButtonState</a>.

<p>Example: <a href="tutorial2-08.html#x2612">chart/setdataform.cpp</a>.
<h3 class=fn>int <a name="columnAt"></a>QTable::columnAt ( int&nbsp;x ) const<tt> [virtual]</tt>
</h3>
Returns the number of the column at position <em>x</em>. <em>x</em> must be
given in content coordinates.
<p> <p>See also <a href="#columnPos">columnPos</a>() and <a href="#rowAt">rowAt</a>().

<h3 class=fn>void <a name="columnClicked"></a>QTable::columnClicked ( int&nbsp;col )<tt> [virtual protected slot]</tt>
</h3>
This function is called when the column <em>col</em> has been clicked.
The default implementation sorts this column if <a href="#sorting">sorting</a>() is TRUE.

<h3 class=fn>void <a name="columnIndexChanged"></a>QTable::columnIndexChanged ( int&nbsp;section, int&nbsp;fromIndex, int&nbsp;toIndex )<tt> [virtual protected slot]</tt>
</h3>
This function is called when column order is to be changed, i.e.
when the user moved the column header <em>section</em> from <em>fromIndex</em>
to <em>toIndex</em>.
<p> If you want to change the column order programmatically, call
<a href="#swapRows">swapRows</a>() or <a href="#swapColumns">swapColumns</a>();
<p> <p>See also <a href="qheader.html#indexChange">QHeader::indexChange</a>() and <a href="#rowIndexChanged">rowIndexChanged</a>().

<h3 class=fn>bool <a name="columnMovingEnabled"></a>QTable::columnMovingEnabled () const
</h3><p>Returns TRUE if columns can be moved by the user; otherwise returns FALSE.
See the <a href="qtable.html#columnMovingEnabled-prop">"columnMovingEnabled"</a> property for details.
<h3 class=fn>int <a name="columnPos"></a>QTable::columnPos ( int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the x-coordinate of the column <em>col</em> in content
coordinates.
<p> <p>See also <a href="#columnAt">columnAt</a>() and <a href="#rowPos">rowPos</a>().

<h3 class=fn>int <a name="columnWidth"></a>QTable::columnWidth ( int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the width of column <em>col</em>.
<p> <p>See also <a href="#setColumnWidth">setColumnWidth</a>() and <a href="#rowHeight">rowHeight</a>().

<h3 class=fn>void <a name="columnWidthChanged"></a>QTable::columnWidthChanged ( int&nbsp;col )<tt> [virtual protected slot]</tt>
</h3>
This function should be called whenever the column width of <em>col</em>
has been changed. It updates the geometry of any affected columns
and repaints the table to reflect the changes it has made.

<h3 class=fn>void <a name="contentsDragEnterEvent"></a>QTable::contentsDragEnterEvent ( <a href="qdragenterevent.html">QDragEnterEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever a QTable object receives a
<a href="qdragenterevent.html">QDragEnterEvent</a> <em>e</em>, i.e. when the user pressed the mouse
button to drag something.
<p> The focus is moved to the cell where the <a href="qdragenterevent.html">QDragEnterEvent</a> occurred.

<p>Reimplemented from <a href="qscrollview.html#contentsDragEnterEvent">QScrollView</a>.
<h3 class=fn>void <a name="contentsDragLeaveEvent"></a>QTable::contentsDragLeaveEvent ( <a href="qdragleaveevent.html">QDragLeaveEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called when a drag activity leaves <em>this</em>
QTable object with event <em>e</em>.

<p>Reimplemented from <a href="qscrollview.html#contentsDragLeaveEvent">QScrollView</a>.
<h3 class=fn>void <a name="contentsDragMoveEvent"></a>QTable::contentsDragMoveEvent ( <a href="qdragmoveevent.html">QDragMoveEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever a QTable object receives a
<a href="qdragmoveevent.html">QDragMoveEvent</a> <em>e</em>, i.e. when the user actually drags the
mouse.
<p> The focus is moved to the cell where the <a href="qdragmoveevent.html">QDragMoveEvent</a> occurred.

<p>Reimplemented from <a href="qscrollview.html#contentsDragMoveEvent">QScrollView</a>.
<h3 class=fn>void <a name="contentsDropEvent"></a>QTable::contentsDropEvent ( <a href="qdropevent.html">QDropEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called when the user ends a drag and drop by
dropping something onto <em>this</em> QTable and thus triggers the drop
event, <em>e</em>.

<p>Reimplemented from <a href="qscrollview.html#contentsDropEvent">QScrollView</a>.
<h3 class=fn>void <a name="contextMenuRequested"></a>QTable::contextMenuRequested ( int&nbsp;row, int&nbsp;col, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;pos )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the user invokes a context menu with
the right mouse button (or with a system-specific keypress). The
cell where the event took place is at <em>row</em>, <em>col</em>. <em>pos</em> is
the position where the context menu will appear in the global
coordinate system. This signal is always emitted, even if the
contents of the cell are disabled.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="createEditor"></a>QTable::createEditor ( int&nbsp;row, int&nbsp;col, bool&nbsp;initFromCell ) const<tt> [virtual protected]</tt>
</h3>
This function returns the widget which should be used as an editor
for the contents of the cell at <em>row</em>, <em>col</em>.
<p> If <em>initFromCell</em> is TRUE, the editor is used to edit the current
contents of the cell (so the editor widget should be initialized
with this content). If <em>initFromCell</em> is FALSE, the content of
the cell is replaced with the new content which the user entered
into the widget created by this function.
<p> The default functionality is as follows: if <em>initFromCell</em> is
TRUE or the cell has a <a href="qtableitem.html">QTableItem</a> and the table item's
<a href="qtableitem.html#isReplaceable">QTableItem::isReplaceable</a>() is FALSE then the cell is asked to
create an appropriate editor (using <a href="qtableitem.html#createEditor">QTableItem::createEditor</a>()).
Otherwise a <a href="qlineedit.html">QLineEdit</a> is used as the editor.
<p> If you want to create your own editor for certain cells, implement
a custom QTableItem subclass and reimplement
QTableItem::createEditor().
<p> If you are not using <a href="qtableitem.html">QTableItem</a>s and you don't want to use a
QLineEdit as the default editor, subclass QTable and reimplement
this function with code like this:
<pre>
    <a href="qtableitem.html">QTableItem</a> *i = <a href="#item">item</a>( row, col );
    if ( initFromCell || ( i &amp;&amp; !i-&gt;<a href="qtableitem.html#isReplaceable">isReplaceable</a>() ) )
        // If we had a QTableItem ask the base class to create the editor
        return QTable::createEditor( row, col, initFromCell );
    else
        return ...(create your own editor)
    </pre>
 
Ownership of the editor widget is transferred to the caller.
<p> If you reimplement this function return 0 for read-only cells. You
will need to reimplement <a href="#setCellContentFromEditor">setCellContentFromEditor</a>() to retrieve
the data the user entered.
<p> <p>See also <a href="qtableitem.html#createEditor">QTableItem::createEditor</a>().

<h3 class=fn>int <a name="currEditCol"></a>QTable::currEditCol () const<tt> [protected]</tt>
</h3>
Returns the current edited column

<h3 class=fn>int <a name="currEditRow"></a>QTable::currEditRow () const<tt> [protected]</tt>
</h3>
Returns the current edited row

<h3 class=fn>void <a name="currentChanged"></a>QTable::currentChanged ( int&nbsp;row, int&nbsp;col )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the current cell has changed to <em>row</em>, <em>col</em>.

<p>Example: <a href="tutorial2-08.html#x2613">chart/setdataform.cpp</a>.
<h3 class=fn>int <a name="currentColumn"></a>QTable::currentColumn () const
</h3>

<p> Returns the current column.
<p> <p>See also <a href="#currentRow">currentRow</a>().

<p>Example: <a href="tutorial2-08.html#x2614">chart/setdataform.cpp</a>.
<h3 class=fn>int <a name="currentRow"></a>QTable::currentRow () const
</h3>

<p> Returns the current row.
<p> <p>See also <a href="#currentColumn">currentColumn</a>().

<p>Example: <a href="tutorial2-08.html#x2615">chart/setdataform.cpp</a>.
<h3 class=fn>int <a name="currentSelection"></a>QTable::currentSelection () const<tt> [virtual]</tt>
</h3>
Returns the number of the current selection or -1 if there is no
current selection.
<p> <p>See also <a href="#numSelections-prop">numSelections</a>.

<h3 class=fn>void <a name="doubleClicked"></a>QTable::doubleClicked ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;mousePos )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when mouse button <em>button</em> is
double-clicked. The cell where the event took place is at <em>row</em>,
<em>col</em>, and the mouse's position is in <em>mousePos</em>.
<p> <p>See also <a href="qt.html#ButtonState-enum">Qt::ButtonState</a>.

<h3 class=fn>bool <a name="dragEnabled"></a>QTable::dragEnabled () const<tt> [slot]</tt>
</h3>
If this function returns TRUE, the table supports dragging.
<p> <p>See also <a href="#setDragEnabled">setDragEnabled</a>().

<h3 class=fn><a href="qdragobject.html">QDragObject</a>&nbsp;* <a name="dragObject"></a>QTable::dragObject ()<tt> [virtual protected]</tt>
</h3>
If the user presses the mouse on a selected cell, starts moving
(i.e. dragging), and <a href="#dragEnabled">dragEnabled</a>() is TRUE, this function is
called to obtain a drag object. A drag using this object begins
immediately unless <a href="#dragObject">dragObject</a>() returns 0.
<p> By default this function returns 0. You might reimplement it and
create a <a href="qdragobject.html">QDragObject</a> depending on the selected items.
<p> <p>See also <a href="#dropped">dropped</a>().

<h3 class=fn>void <a name="drawContents"></a>QTable::drawContents ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;cx, int&nbsp;cy, int&nbsp;cw, int&nbsp;ch )<tt> [virtual protected]</tt>
</h3>
Draws the table contents on the painter <em>p</em>. This function is
optimized so that it only draws the cells inside the <em>cw</em> pixels
wide and <em>ch</em> pixels high clipping rectangle at position <em>cx</em>,
<em>cy</em>.
<p> Additionally, <a href="#drawContents">drawContents</a>() highlights the current cell.

<p>Reimplemented from <a href="qscrollview.html#drawContents">QScrollView</a>.
<h3 class=fn>void <a name="dropped"></a>QTable::dropped ( <a href="qdropevent.html">QDropEvent</a>&nbsp;*&nbsp;e )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when a drop event occurred on the table.
<p> <em>e</em> contains information about the drop.

<h3 class=fn>void <a name="editCell"></a>QTable::editCell ( int&nbsp;row, int&nbsp;col, bool&nbsp;replace = FALSE )<tt> [virtual slot]</tt>
</h3>
Starts editing the cell at <em>row</em>, <em>col</em>.
<p> If <em>replace</em> is TRUE the content of this cell will be replaced by
the content of the editor when editing is finished, i.e. the user
will be entering new data; otherwise the current content of the
cell (if any) will be modified in the editor.
<p> <p>See also <a href="#beginEdit">beginEdit</a>().

<h3 class=fn><a href="qtable.html#EditMode-enum">EditMode</a> <a name="editMode"></a>QTable::editMode () const<tt> [protected]</tt>
</h3>
Returns the current edit mode
<p> <p>See also <a href="#EditMode-enum">QTable::EditMode</a>.

<h3 class=fn>void <a name="endEdit"></a>QTable::endEdit ( int&nbsp;row, int&nbsp;col, bool&nbsp;accept, bool&nbsp;replace )<tt> [virtual protected]</tt>
</h3>
This function is called when in-place editing of the cell at <em>row</em>, <em>col</em> is requested to stop.
<p> If the cell is not being edited or <em>accept</em> is FALSE the function
returns and the cell's contents are left unchanged.
<p> If <em>accept</em> is TRUE the content of the editor must be transferred
to the relevant cell. If <em>replace</em> is TRUE the current content of
this cell should be replaced by the content of the editor (this
means removing the current <a href="qtableitem.html">QTableItem</a> of the cell and creating a
new one for the cell). Otherwise (if possible) the content of the
editor should just be set to the existing QTableItem of this cell.
<p> <a href="#setCellContentFromEditor">setCellContentFromEditor</a>() is called to replace the contents of
the cell with the contents of the cell's editor.
<p> Finally <a href="#clearCellWidget">clearCellWidget</a>() is called to remove the editor widget.
<p> <p>See also <a href="#setCellContentFromEditor">setCellContentFromEditor</a>() and <a href="#beginEdit">beginEdit</a>().

<h3 class=fn>void <a name="ensureCellVisible"></a>QTable::ensureCellVisible ( int&nbsp;row, int&nbsp;col )
</h3>
Scrolls the table until the cell at <em>row</em>, <em>col</em> becomes
visible.

<h3 class=fn><a href="qtable.html#FocusStyle-enum">FocusStyle</a> <a name="focusStyle"></a>QTable::focusStyle () const
</h3><p>Returns how the current (focus) cell is drawn.
See the <a href="qtable.html#focusStyle-prop">"focusStyle"</a> property for details.
<h3 class=fn>void <a name="hideColumn"></a>QTable::hideColumn ( int&nbsp;col )<tt> [virtual slot]</tt>
</h3>
Hides column <em>col</em>.
<p> <p>See also <a href="#showColumn">showColumn</a>() and <a href="#hideRow">hideRow</a>().

<h3 class=fn>void <a name="hideRow"></a>QTable::hideRow ( int&nbsp;row )<tt> [virtual slot]</tt>
</h3>
Hides row <em>row</em>.
<p> <p>See also <a href="#showRow">showRow</a>() and <a href="#hideColumn">hideColumn</a>().

<h3 class=fn><a href="qheader.html">QHeader</a>&nbsp;* <a name="horizontalHeader"></a>QTable::horizontalHeader () const
</h3>
Returns the table's top <a href="qheader.html">QHeader</a>.
<p> This header contains the column labels.
<p> To modify a column label use <a href="qheader.html#setLabel">QHeader::setLabel</a>(), e.g.


<pre>        <a href="#horizontalHeader">horizontalHeader</a>()-&gt;setLabel( 0, tr( "File" ) );
</pre>
<p> <p>See also <a href="#verticalHeader">verticalHeader</a>(), <a href="#setTopMargin">setTopMargin</a>(), and <a href="qheader.html">QHeader</a>.

<p>Examples: <a href="tutorial2-08.html#x2616">chart/setdataform.cpp</a>, <a href="helpsystem-example.html#x2690">helpsystem/mainwindow.cpp</a>, <a href="regexptester-example.html#x2499">regexptester/regexptester.cpp</a>, and <a href="small-table-example-example.html#x2800">table/small-table-demo/main.cpp</a>.
<h3 class=fn>int <a name="indexOf"></a>QTable::indexOf ( int&nbsp;row, int&nbsp;col ) const<tt> [protected]</tt>
</h3>
Returns a single integer which identifies a particular <em>row</em> and <em>col</em> by mapping the 2D table to a 1D array.
<p> This is useful, for example, if you have a sparse table and want to
use a <a href="qintdict.html">QIntDict</a> to map integers to the cells that are used.

<h3 class=fn>void <a name="insertColumns"></a>QTable::insertColumns ( int&nbsp;col, int&nbsp;count = 1 )<tt> [virtual slot]</tt>
</h3>
Inserts <em>count</em> empty columns at column <em>col</em>.  Also clears the <a href="#selection">selection</a>(s).
<p> <p>See also <a href="#insertRows">insertRows</a>() and <a href="#removeColumn">removeColumn</a>().

<h3 class=fn>void <a name="insertRows"></a>QTable::insertRows ( int&nbsp;row, int&nbsp;count = 1 )<tt> [virtual slot]</tt>
</h3>
Inserts <em>count</em> empty rows at row <em>row</em>. Also clears the <a href="#selection">selection</a>(s).
<p> <p>See also <a href="#insertColumns">insertColumns</a>() and <a href="#removeRow">removeRow</a>().

<h3 class=fn>void <a name="insertWidget"></a>QTable::insertWidget ( int&nbsp;row, int&nbsp;col, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w )<tt> [virtual protected]</tt>
</h3>
Inserts widget <em>w</em> at <em>row</em>, <em>col</em> into the internal
data structure. See the documentation of <a href="#setCellWidget">setCellWidget</a>() for
further details.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.

<h3 class=fn>bool <a name="isColumnHidden"></a>QTable::isColumnHidden ( int&nbsp;col ) const<tt> [slot]</tt>
</h3>
Returns TRUE if column <em>col</em> is hidden; otherwise returns
FALSE.
<p> <p>See also <a href="#hideColumn">hideColumn</a>() and <a href="#isRowHidden">isRowHidden</a>().

<h3 class=fn>bool <a name="isColumnReadOnly"></a>QTable::isColumnReadOnly ( int&nbsp;col ) const
</h3>
Returns TRUE if column <em>col</em> is read-only; otherwise returns
FALSE.
<p> Whether a cell in this column is editable or read-only depends on
the cell's EditType, and this setting: see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.
<p> <p>See also <a href="#setColumnReadOnly">setColumnReadOnly</a>() and <a href="#isRowReadOnly">isRowReadOnly</a>().

<h3 class=fn>bool <a name="isColumnSelected"></a>QTable::isColumnSelected ( int&nbsp;col, bool&nbsp;full = FALSE ) const
</h3>
Returns TRUE if column <em>col</em> is selected; otherwise returns FALSE.
<p> If <em>full</em> is FALSE (the default), 'column is selected' means that
at least one cell in the column is selected. If <em>full</em> is TRUE,
then 'column is selected' means every cell in the column is
selected.
<p> <p>See also <a href="#isRowSelected">isRowSelected</a>() and <a href="#isSelected">isSelected</a>().

<h3 class=fn>bool <a name="isColumnStretchable"></a>QTable::isColumnStretchable ( int&nbsp;col ) const<tt> [slot]</tt>
</h3>
Returns TRUE if column <em>col</em> is stretchable; otherwise returns
FALSE.
<p> <p>See also <a href="#setColumnStretchable">setColumnStretchable</a>() and <a href="#isRowStretchable">isRowStretchable</a>().

<h3 class=fn>bool <a name="isEditing"></a>QTable::isEditing () const<tt> [protected]</tt>
</h3>
Returns TRUE if the <a href="#EditMode-enum">EditMode</a> is <a href="#EditMode-enum">Editing</a> or <a href="#EditMode-enum">Replacing</a>;
otherwise (i.e. the <a href="#EditMode-enum">EditMode</a> is <a href="#EditMode-enum">NotEditing</a>) returns FALSE.
<p> <p>See also <a href="#EditMode-enum">QTable::EditMode</a>.

<h3 class=fn>bool <a name="isReadOnly"></a>QTable::isReadOnly () const
</h3><p>Returns TRUE if the table is read-only; otherwise returns FALSE.
See the <a href="qtable.html#readOnly-prop">"readOnly"</a> property for details.
<h3 class=fn>bool <a name="isRowHidden"></a>QTable::isRowHidden ( int&nbsp;row ) const<tt> [slot]</tt>
</h3>
Returns TRUE if row <em>row</em> is hidden; otherwise returns
FALSE.
<p> <p>See also <a href="#hideRow">hideRow</a>() and <a href="#isColumnHidden">isColumnHidden</a>().

<h3 class=fn>bool <a name="isRowReadOnly"></a>QTable::isRowReadOnly ( int&nbsp;row ) const
</h3>
Returns TRUE if row <em>row</em> is read-only; otherwise returns FALSE.
<p> Whether a cell in this row is editable or read-only depends on the
cell's <a href="qtableitem.html#EditType-enum">EditType</a>, and this
setting: see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.
<p> <p>See also <a href="#setRowReadOnly">setRowReadOnly</a>() and <a href="#isColumnReadOnly">isColumnReadOnly</a>().

<h3 class=fn>bool <a name="isRowSelected"></a>QTable::isRowSelected ( int&nbsp;row, bool&nbsp;full = FALSE ) const
</h3>
Returns TRUE if row <em>row</em> is selected; otherwise returns FALSE.
<p> If <em>full</em> is FALSE (the default), 'row is selected' means that at
least one cell in the row is selected. If <em>full</em> is TRUE, then 'row
is selected' means every cell in the row is selected.
<p> <p>See also <a href="#isColumnSelected">isColumnSelected</a>() and <a href="#isSelected">isSelected</a>().

<h3 class=fn>bool <a name="isRowStretchable"></a>QTable::isRowStretchable ( int&nbsp;row ) const<tt> [slot]</tt>
</h3>
Returns TRUE if row <em>row</em> is stretchable; otherwise returns
FALSE.
<p> <p>See also <a href="#setRowStretchable">setRowStretchable</a>() and <a href="#isColumnStretchable">isColumnStretchable</a>().

<h3 class=fn>bool <a name="isSelected"></a>QTable::isSelected ( int&nbsp;row, int&nbsp;col ) const
</h3>
Returns TRUE if the cell at <em>row</em>, <em>col</em> is selected; otherwise
returns FALSE.
<p> <p>See also <a href="#isRowSelected">isRowSelected</a>() and <a href="#isColumnSelected">isColumnSelected</a>().

<h3 class=fn><a href="qtableitem.html">QTableItem</a>&nbsp;* <a name="item"></a>QTable::item ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the <a href="qtableitem.html">QTableItem</a> representing the contents of the cell at <em>row</em>, <em>col</em>.
<p> If <em>row</em> or <em>col</em> are out of range or no content has been set
for this cell, <a href="#item">item</a>() returns 0.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> <p>See also <a href="#setItem">setItem</a>().

<p>Example: <a href="regexptester-example.html#x2500">regexptester/regexptester.cpp</a>.
<h3 class=fn>int <a name="numCols"></a>QTable::numCols () const<tt> [virtual]</tt>
</h3><p>Returns the number of columns in the table.
See the <a href="qtable.html#numCols-prop">"numCols"</a> property for details.
<p>Reimplemented in <a href="qdatatable.html#numCols">QDataTable</a>.
<h3 class=fn>int <a name="numRows"></a>QTable::numRows () const<tt> [virtual]</tt>
</h3><p>Returns the number of rows in the table.
See the <a href="qtable.html#numRows-prop">"numRows"</a> property for details.
<p>Reimplemented in <a href="qdatatable.html#numRows">QDataTable</a>.
<h3 class=fn>int <a name="numSelections"></a>QTable::numSelections () const
</h3><p>Returns the number of selections.
See the <a href="qtable.html#numSelections-prop">"numSelections"</a> property for details.
<h3 class=fn>void <a name="paintCell"></a>QTable::paintCell ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;row, int&nbsp;col, const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;cr, bool&nbsp;selected, const&nbsp;<a href="qcolorgroup.html">QColorGroup</a>&nbsp;&amp;&nbsp;cg )<tt> [virtual]</tt>
</h3>
Paints the cell at <em>row</em>, <em>col</em> on the painter <em>p</em>. The painter
has already been translated to the cell's origin. <em>cr</em> describes
the cell coordinates in the content coordinate system.
<p> If <em>selected</em> is TRUE the cell is highlighted.
<p> <em>cg</em> is the colorgroup which should be used to draw the cell
content.
<p> If you want to draw custom cell content, for example right-aligned
text, you must either reimplement <a href="#paintCell">paintCell</a>(), or subclass
<a href="qtableitem.html">QTableItem</a> and reimplement <a href="qtableitem.html#paint">QTableItem::paint</a>() to do the custom
drawing.
<p> If you're using a QTableItem subclass, for example, to store a
data structure, then reimplementing QTableItem::paint() may be the
best approach. For data you want to draw immediately, e.g. data
retrieved from a database, it is probably best to reimplement
paintCell(). Note that if you reimplement paintCell(), i.e. don't
use <a href="qtableitem.html">QTableItem</a>s, you must reimplement other functions: see the
<a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> Note that the painter is not clipped by default in order to get
maximum efficiency. If you want clipping, use code like this:
<p> <pre>
    p-&gt;setClipRect( <a href="#cellRect">cellRect</a>(row, col), QPainter::CoordPainter );
    //... your drawing code
    p-&gt;setClipping( FALSE );
    </pre>
 

<h3 class=fn>void <a name="paintCell-2"></a>QTable::paintCell ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;row, int&nbsp;col, const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;cr, bool&nbsp;selected )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Use the other <a href="#paintCell">paintCell</a>() function. This function is only included
for backwards compatibilty.

<h3 class=fn>void <a name="paintEmptyArea"></a>QTable::paintEmptyArea ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;cx, int&nbsp;cy, int&nbsp;cw, int&nbsp;ch )<tt> [virtual protected]</tt>
</h3>
This function fills the <em>cw</em> pixels wide and <em>ch</em> pixels high
rectangle starting at position <em>cx</em>, <em>cy</em> with the background
color using the painter <em>p</em>.
<p> <a href="#paintEmptyArea">paintEmptyArea</a>() is invoked by <a href="#drawContents">drawContents</a>() to erase or fill
unused areas.

<h3 class=fn>void <a name="paintFocus"></a>QTable::paintFocus ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;cr )<tt> [virtual]</tt>
</h3>
Draws the focus rectangle of the current cell (see <a href="#currentRow">currentRow</a>(),
<a href="#currentColumn">currentColumn</a>()).
<p> The painter <em>p</em> is already translated to the cell's origin, while
<em>cr</em> specifies the cell's geometry in content coordinates.

<h3 class=fn><a href="qpixmap.html">QPixmap</a> <a name="pixmap"></a>QTable::pixmap ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the pixmap set for the cell at <em>row</em>, <em>col</em>, or a
null-pixmap if the cell contains no pixmap.
<p> <p>See also <a href="#setPixmap">setPixmap</a>().

<p>Example: <a href="tutorial2-08.html#x2617">chart/setdataform.cpp</a>.
<h3 class=fn>void <a name="pressed"></a>QTable::pressed ( int&nbsp;row, int&nbsp;col, int&nbsp;button, const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;mousePos )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when mouse button <em>button</em> is pressed. The
cell where the event took place is at <em>row</em>, <em>col</em>, and the
mouse's position is in <em>mousePos</em>.
<p> <p>See also <a href="qt.html#ButtonState-enum">Qt::ButtonState</a>.

<h3 class=fn>void <a name="removeColumn"></a>QTable::removeColumn ( int&nbsp;col )<tt> [virtual slot]</tt>
</h3>
Removes column <em>col</em>, and deletes all its cells including any
table items and widgets the cells may contain. Also clears the
<a href="#selection">selection</a>(s).
<p> <p>See also <a href="#removeColumns">removeColumns</a>(), <a href="#hideColumn">hideColumn</a>(), <a href="#insertColumns">insertColumns</a>(), and <a href="#removeRow">removeRow</a>().

<h3 class=fn>void <a name="removeColumns"></a>QTable::removeColumns ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;int&gt;&nbsp;&amp;&nbsp;cols )<tt> [virtual slot]</tt>
</h3>
Removes the columns listed in the array <em>cols</em>, and deletes all
their cells including any table items and widgets the cells may
contain.
<p> The array passed in must only contain valid columns (in the range
from 0 to <a href="#numCols">numCols</a>() - 1) with no duplicates, and must be sorted in
ascending order. Also clears the <a href="#selection">selection</a>(s).
<p> <p>See also <a href="#removeColumn">removeColumn</a>(), <a href="#insertColumns">insertColumns</a>(), and <a href="#removeRows">removeRows</a>().

<h3 class=fn>void <a name="removeRow"></a>QTable::removeRow ( int&nbsp;row )<tt> [virtual slot]</tt>
</h3>
Removes row <em>row</em>, and deletes all its cells including any table
items and widgets the cells may contain. Also clears the <a href="#selection">selection</a>(s).
<p> <p>See also <a href="#hideRow">hideRow</a>(), <a href="#insertRows">insertRows</a>(), <a href="#removeColumn">removeColumn</a>(), and <a href="#removeRows">removeRows</a>().

<h3 class=fn>void <a name="removeRows"></a>QTable::removeRows ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;int&gt;&nbsp;&amp;&nbsp;rows )<tt> [virtual slot]</tt>
</h3>
Removes the rows listed in the array <em>rows</em>, and deletes all their
cells including any table items and widgets the cells may contain.
<p> The array passed in must only contain valid rows (in the range
from 0 to <a href="#numRows">numRows</a>() - 1) with no duplicates, and must be sorted in
ascending order. Also clears the <a href="#selection">selection</a>(s).
<p> <p>See also <a href="#removeRow">removeRow</a>(), <a href="#insertRows">insertRows</a>(), and <a href="#removeColumns">removeColumns</a>().

<h3 class=fn>void <a name="removeSelection"></a>QTable::removeSelection ( const&nbsp;<a href="qtableselection.html">QTableSelection</a>&nbsp;&amp;&nbsp;s )<tt> [virtual]</tt>
</h3>
If the table has a selection, <em>s</em>, this selection is removed from
the table.
<p> <p>See also <a href="#addSelection">addSelection</a>() and <a href="#numSelections-prop">numSelections</a>.

<h3 class=fn>void <a name="removeSelection-2"></a>QTable::removeSelection ( int&nbsp;num )<tt> [virtual]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes selection number <em>num</em> from the table.
<p> <p>See also <a href="#numSelections-prop">numSelections</a>, <a href="#addSelection">addSelection</a>(), and <a href="#clearSelection">clearSelection</a>().

<h3 class=fn>void <a name="repaintSelections"></a>QTable::repaintSelections ()
</h3>
Repaints all selections

<h3 class=fn>void <a name="resizeData"></a>QTable::resizeData ( int&nbsp;len )<tt> [virtual protected]</tt>
</h3>
This is called when QTable's internal array needs to be resized to
<em>len</em> elements.
<p> If you don't use QTableItems you should reimplement this as an
empty method to avoid wasting memory. See the <a href="qtable.html#notes-on-large-tables">notes on large tables</a> for further details.

<h3 class=fn>int <a name="rowAt"></a>QTable::rowAt ( int&nbsp;y ) const<tt> [virtual]</tt>
</h3>
Returns the number of the row at position <em>y</em>. <em>y</em> must be given
in content coordinates.
<p> <p>See also <a href="#rowPos">rowPos</a>() and <a href="#columnAt">columnAt</a>().

<h3 class=fn>int <a name="rowHeight"></a>QTable::rowHeight ( int&nbsp;row ) const<tt> [virtual]</tt>
</h3>
Returns the height of row <em>row</em>.
<p> <p>See also <a href="#setRowHeight">setRowHeight</a>() and <a href="#columnWidth">columnWidth</a>().

<p>Example: <a href="small-table-example-example.html#x2801">table/small-table-demo/main.cpp</a>.
<h3 class=fn>void <a name="rowHeightChanged"></a>QTable::rowHeightChanged ( int&nbsp;row )<tt> [virtual protected slot]</tt>
</h3>
This function should be called whenever the row height of <em>row</em>
has been changed. It updates the geometry of any affected rows and
repaints the table to reflect the changes it has made.

<h3 class=fn>void <a name="rowIndexChanged"></a>QTable::rowIndexChanged ( int&nbsp;section, int&nbsp;fromIndex, int&nbsp;toIndex )<tt> [virtual protected slot]</tt>
</h3>
This function is called when the order of the rows is to be
changed, i.e. the user moved the row header section <em>section</em>
from <em>fromIndex</em> to <em>toIndex</em>.
<p> If you want to change the order programmatically, call <a href="#swapRows">swapRows</a>()
or <a href="#swapColumns">swapColumns</a>();
<p> <p>See also <a href="qheader.html#indexChange">QHeader::indexChange</a>() and <a href="#columnIndexChanged">columnIndexChanged</a>().

<h3 class=fn>bool <a name="rowMovingEnabled"></a>QTable::rowMovingEnabled () const
</h3><p>Returns TRUE if rows can be moved by the user; otherwise returns FALSE.
See the <a href="qtable.html#rowMovingEnabled-prop">"rowMovingEnabled"</a> property for details.
<h3 class=fn>int <a name="rowPos"></a>QTable::rowPos ( int&nbsp;row ) const<tt> [virtual]</tt>
</h3>
Returns the y-coordinate of the row <em>row</em> in content coordinates.
<p> <p>See also <a href="#rowAt">rowAt</a>() and <a href="#columnPos">columnPos</a>().

<h3 class=fn>void <a name="selectCells"></a>QTable::selectCells ( int&nbsp;start_row, int&nbsp;start_col, int&nbsp;end_row, int&nbsp;end_col )
</h3> Selects the range starting at <em>start_row</em> and <em>start_col</em> and
ending at <em>end_row</em> and <em>end_col</em>.
<p> <p>See also <a href="qtableselection.html">QTableSelection</a>.

<h3 class=fn>void <a name="selectColumn"></a>QTable::selectColumn ( int&nbsp;col )
</h3> Selects the column <em>col</em>.
<p> <p>See also <a href="qtableselection.html">QTableSelection</a>.

<h3 class=fn>void <a name="selectRow"></a>QTable::selectRow ( int&nbsp;row )
</h3> Selects the row <em>row</em>.
<p> <p>See also <a href="qtableselection.html">QTableSelection</a>.

<h3 class=fn><a href="qtableselection.html">QTableSelection</a> <a name="selection"></a>QTable::selection ( int&nbsp;num ) const
</h3>
Returns selection number <em>num</em>, or an inactive <a href="qtableselection.html">QTableSelection</a> if <em>num</em> is out of range (see <a href="qtableselection.html#isActive">QTableSelection::isActive</a>()).

<h3 class=fn>void <a name="selectionChanged"></a>QTable::selectionChanged ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever a selection changes.
<p> <p>See also <a href="qtableselection.html">QTableSelection</a>.

<h3 class=fn><a href="qtable.html#SelectionMode-enum">SelectionMode</a> <a name="selectionMode"></a>QTable::selectionMode () const
</h3><p>Returns the current selection mode.
See the <a href="qtable.html#selectionMode-prop">"selectionMode"</a> property for details.
<h3 class=fn>void <a name="setCellContentFromEditor"></a>QTable::setCellContentFromEditor ( int&nbsp;row, int&nbsp;col )<tt> [virtual protected]</tt>
</h3>
This function is called to replace the contents of the cell at <em>row</em>, <em>col</em> with the contents of the cell's editor.
<p> If there already exists a <a href="qtableitem.html">QTableItem</a> for the cell,
it calls <a href="qtableitem.html#setContentFromEditor">QTableItem::setContentFromEditor</a>() on this QTableItem.
<p> If, for example, you want to create different <a href="qtableitem.html">QTableItem</a>s
depending on the contents of the editor, you might reimplement
this function.
<p> If you want to work without <a href="qtableitem.html">QTableItem</a>s, you will need to
reimplement this function to save the data the user entered into
your data structure. (See the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.)
<p> <p>See also <a href="qtableitem.html#setContentFromEditor">QTableItem::setContentFromEditor</a>() and <a href="#createEditor">createEditor</a>().

<h3 class=fn>void <a name="setCellWidget"></a>QTable::setCellWidget ( int&nbsp;row, int&nbsp;col, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;e )<tt> [virtual]</tt>
</h3>
Sets the widget <em>e</em> to the cell at <em>row</em>, <em>col</em> and takes care of
placing and resizing the widget when the cell geometry changes.
<p> By default widgets are inserted into a vector with <a href="#numRows">numRows</a>() *
<a href="#numCols">numCols</a>() elements. In very large tables you will probably want to
store the widgets in a data structure that consumes less memory (see
the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>). To support the use of your own data
structure this function calls <a href="#insertWidget">insertWidget</a>() to add the widget to
the internal data structure. To use your own data structure
reimplement insertWidget(), <a href="#cellWidget">cellWidget</a>() and <a href="#clearCellWidget">clearCellWidget</a>().
<p> Cell widgets are created dynamically with the <tt>new</tt> operator. The
cell widgets are destroyed automatically once the table is
destroyed; the table takes ownership of the widget when using
setCellWidget.
<p> 
<p>Example: <a href="tutorial2-08.html#x2618">chart/setdataform.cpp</a>.
<h3 class=fn>void <a name="setColumnLabels"></a>QTable::setColumnLabels ( const&nbsp;<a href="qstringlist.html">QStringList</a>&nbsp;&amp;&nbsp;labels )<tt> [slot]</tt>
</h3> Sets the section labels of the <a href="#horizontalHeader">horizontalHeader</a>() to <em>labels</em> 
<h3 class=fn>void <a name="setColumnMovingEnabled"></a>QTable::setColumnMovingEnabled ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3><p>Sets whether columns can be moved by the user to <em>b</em>.
See the <a href="qtable.html#columnMovingEnabled-prop">"columnMovingEnabled"</a> property for details.
<h3 class=fn>void <a name="setColumnReadOnly"></a>QTable::setColumnReadOnly ( int&nbsp;col, bool&nbsp;ro )<tt> [virtual slot]</tt>
</h3>
If <em>ro</em> is TRUE, column <em>col</em> is set to be read-only; otherwise
the column is set to be editable.
<p> Whether a cell in this column is editable or read-only depends on
the cell's EditType, and this setting:
see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.
<p> <p>See also <a href="#isColumnReadOnly">isColumnReadOnly</a>(), <a href="#setRowReadOnly">setRowReadOnly</a>(), and <a href="#readOnly-prop">readOnly</a>.

<p> 
<p>Example: <a href="tutorial2-08.html#x2619">chart/setdataform.cpp</a>.
<h3 class=fn>void <a name="setColumnStretchable"></a>QTable::setColumnStretchable ( int&nbsp;col, bool&nbsp;stretch )<tt> [virtual slot]</tt>
</h3>
If <em>stretch</em> is TRUE, column <em>col</em> is set to be stretchable;
otherwise column <em>col</em> is set to be unstretchable.
<p> If the table widget's width decreases or increases stretchable
columns will grow narrower or wider to fit the space available as
completely as possible. The user cannot manually resize stretchable
columns.
<p> <p>See also <a href="#isColumnStretchable">isColumnStretchable</a>(), <a href="#setRowStretchable">setRowStretchable</a>(), and <a href="#adjustColumn">adjustColumn</a>().

<h3 class=fn>void <a name="setColumnWidth"></a>QTable::setColumnWidth ( int&nbsp;col, int&nbsp;w )<tt> [virtual slot]</tt>
</h3>
Resizes column <em>col</em> to be <em>w</em> pixels wide.
<p> <p>See also <a href="#columnWidth">columnWidth</a>() and <a href="#setRowHeight">setRowHeight</a>().

<p>Example: <a href="tutorial2-08.html#x2620">chart/setdataform.cpp</a>.
<p>Reimplemented in <a href="qdatatable.html#setColumnWidth">QDataTable</a>.
<h3 class=fn>void <a name="setCurrentCell"></a>QTable::setCurrentCell ( int&nbsp;row, int&nbsp;col )<tt> [virtual slot]</tt>
</h3>
Moves the focus to the cell at <em>row</em>, <em>col</em>.
<p> <p>See also <a href="#currentRow">currentRow</a>() and <a href="#currentColumn">currentColumn</a>().

<h3 class=fn>void <a name="setDragEnabled"></a>QTable::setDragEnabled ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3>
If <em>b</em> is TRUE, the table starts a drag (see <a href="#dragObject">dragObject</a>()) when
the user presses and moves the mouse on a selected cell.

<h3 class=fn>void <a name="setEditMode"></a>QTable::setEditMode ( <a href="qtable.html#EditMode-enum">EditMode</a>&nbsp;mode, int&nbsp;row, int&nbsp;col )<tt> [protected]</tt>
</h3>
Sets the current edit mode to <em>mode</em>, the current edit row to <em>row</em> and the current edit column to <em>col</em>.
<p> <p>See also <a href="#EditMode-enum">EditMode</a>.

<h3 class=fn>void <a name="setFocusStyle"></a>QTable::setFocusStyle ( <a href="qtable.html#FocusStyle-enum">FocusStyle</a>&nbsp;fs )<tt> [virtual]</tt>
</h3><p>Sets how the current (focus) cell is drawn to <em>fs</em>.
See the <a href="qtable.html#focusStyle-prop">"focusStyle"</a> property for details.
<h3 class=fn>void <a name="setItem"></a>QTable::setItem ( int&nbsp;row, int&nbsp;col, <a href="qtableitem.html">QTableItem</a>&nbsp;*&nbsp;item )<tt> [virtual]</tt>
</h3>
Inserts the table item <em>item</em> into the table at row <em>row</em>,
column <em>col</em>, and repaints the cell. If a table item already
exists in this cell it is deleted and replaced with <em>item</em>. The
table takes ownership of the table item.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s you may need to reimplement this
function: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> <p>See also <a href="#item">item</a>() and <a href="#takeItem">takeItem</a>().

<p>Examples: <a href="helpsystem-example.html#x2691">helpsystem/mainwindow.cpp</a> and <a href="small-table-example-example.html#x2803">table/small-table-demo/main.cpp</a>.
<h3 class=fn>void <a name="setLeftMargin"></a>QTable::setLeftMargin ( int&nbsp;m )<tt> [virtual slot]</tt>
</h3>
Sets the left margin to be <em>m</em> pixels wide.
<p> The <a href="#verticalHeader">verticalHeader</a>(), which displays row labels, occupies this
margin.
<p> In an Arabic or Hebrew <a href="i18n.html#localization">localization</a>, the verticalHeader() will
appear on the right side of the table, and this call will set the
right margin.
<p> <p>See also <a href="qscrollview.html#leftMargin">leftMargin</a>(), <a href="#setTopMargin">setTopMargin</a>(), and <a href="#verticalHeader">verticalHeader</a>().

<p>Example: <a href="regexptester-example.html#x2501">regexptester/regexptester.cpp</a>.
<h3 class=fn>void <a name="setNumCols"></a>QTable::setNumCols ( int&nbsp;r )<tt> [virtual slot]</tt>
</h3><p>Sets the number of columns in the table to <em>r</em>.
See the <a href="qtable.html#numCols-prop">"numCols"</a> property for details.
<h3 class=fn>void <a name="setNumRows"></a>QTable::setNumRows ( int&nbsp;r )<tt> [virtual slot]</tt>
</h3><p>Sets the number of rows in the table to <em>r</em>.
See the <a href="qtable.html#numRows-prop">"numRows"</a> property for details.
<h3 class=fn>void <a name="setPixmap"></a>QTable::setPixmap ( int&nbsp;row, int&nbsp;col, const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;pix )<tt> [virtual]</tt>
</h3>
Sets the pixmap in the cell at <em>row</em>, <em>col</em> to <em>pix</em>.
<p> If the cell does not contain a table item a <a href="qtableitem.html">QTableItem</a> is created
with an <a href="qtableitem.html#EditType-enum">EditType</a> of <tt>OnTyping</tt>,
otherwise the existing table item's pixmap (if any) is replaced
with <em>pix</em>.
<p> Note that <a href="qcombotableitem.html">QComboTableItem</a>s and <a href="qchecktableitem.html">QCheckTableItem</a>s don't show
pixmaps.
<p> <p>See also <a href="#pixmap">pixmap</a>(), <a href="#setText">setText</a>(), <a href="#setItem">setItem</a>(), and <a href="qtableitem.html#setPixmap">QTableItem::setPixmap</a>().

<p>Examples: <a href="tutorial2-08.html#x2623">chart/setdataform.cpp</a> and <a href="small-table-example-example.html#x2804">table/small-table-demo/main.cpp</a>.
<h3 class=fn>void <a name="setReadOnly"></a>QTable::setReadOnly ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3><p>Sets whether the table is read-only to <em>b</em>.
See the <a href="qtable.html#readOnly-prop">"readOnly"</a> property for details.
<h3 class=fn>void <a name="setRowHeight"></a>QTable::setRowHeight ( int&nbsp;row, int&nbsp;h )<tt> [virtual slot]</tt>
</h3>
Resizes row <em>row</em> to be <em>h</em> pixels high.
<p> <p>See also <a href="#rowHeight">rowHeight</a>() and <a href="#setColumnWidth">setColumnWidth</a>().

<h3 class=fn>void <a name="setRowLabels"></a>QTable::setRowLabels ( const&nbsp;<a href="qstringlist.html">QStringList</a>&nbsp;&amp;&nbsp;labels )<tt> [slot]</tt>
</h3> Sets the section labels of the <a href="#verticalHeader">verticalHeader</a>() to <em>labels</em> 
<h3 class=fn>void <a name="setRowMovingEnabled"></a>QTable::setRowMovingEnabled ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3><p>Sets whether rows can be moved by the user to <em>b</em>.
See the <a href="qtable.html#rowMovingEnabled-prop">"rowMovingEnabled"</a> property for details.
<h3 class=fn>void <a name="setRowReadOnly"></a>QTable::setRowReadOnly ( int&nbsp;row, bool&nbsp;ro )<tt> [virtual slot]</tt>
</h3>
If <em>ro</em> is TRUE, row <em>row</em> is set to be read-only; otherwise the
row is set to be editable.
<p> Whether a cell in this row is editable or read-only depends on the
cell's EditType, and this setting:
see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.
<p> <p>See also <a href="#isRowReadOnly">isRowReadOnly</a>(), <a href="#setColumnReadOnly">setColumnReadOnly</a>(), and <a href="#readOnly-prop">readOnly</a>.

<h3 class=fn>void <a name="setRowStretchable"></a>QTable::setRowStretchable ( int&nbsp;row, bool&nbsp;stretch )<tt> [virtual slot]</tt>
</h3>
If <em>stretch</em> is TRUE, row <em>row</em> is set to be stretchable;
otherwise row <em>row</em> is set to be unstretchable.
<p> If the table widget's height decreases or increases stretchable
rows will grow shorter or taller to fit the space available as
completely as possible. The user cannot manually resize
stretchable rows.
<p> <p>See also <a href="#isRowStretchable">isRowStretchable</a>() and <a href="#setColumnStretchable">setColumnStretchable</a>().

<h3 class=fn>void <a name="setSelectionMode"></a>QTable::setSelectionMode ( <a href="qtable.html#SelectionMode-enum">SelectionMode</a>&nbsp;mode )<tt> [virtual]</tt>
</h3><p>Sets the current selection mode to <em>mode</em>.
See the <a href="qtable.html#selectionMode-prop">"selectionMode"</a> property for details.
<h3 class=fn>void <a name="setShowGrid"></a>QTable::setShowGrid ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3><p>Sets whether the table's grid is displayed to <em>b</em>.
See the <a href="qtable.html#showGrid-prop">"showGrid"</a> property for details.
<h3 class=fn>void <a name="setSorting"></a>QTable::setSorting ( bool&nbsp;b )<tt> [virtual slot]</tt>
</h3><p>Sets whether a click on the header of a column sorts that column to <em>b</em>.
See the <a href="qtable.html#sorting-prop">"sorting"</a> property for details.
<h3 class=fn>void <a name="setText"></a>QTable::setText ( int&nbsp;row, int&nbsp;col, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;text )<tt> [virtual]</tt>
</h3>
Sets the text in the cell at <em>row</em>, <em>col</em> to <em>text</em>.
<p> If the cell does not contain a table item a <a href="qtableitem.html">QTableItem</a> is created
with an <a href="qtableitem.html#EditType-enum">EditType</a> of <tt>OnTyping</tt>,
otherwise the existing table item's text (if any) is replaced with
<em>text</em>.
<p> <p>See also <a href="#text">text</a>(), <a href="#setPixmap">setPixmap</a>(), <a href="#setItem">setItem</a>(), and <a href="qtableitem.html#setText">QTableItem::setText</a>().

<p>Examples: <a href="tutorial2-08.html#x2624">chart/setdataform.cpp</a>, <a href="helpsystem-example.html#x2692">helpsystem/mainwindow.cpp</a>, <a href="regexptester-example.html#x2504">regexptester/regexptester.cpp</a>, and <a href="small-table-example-example.html#x2805">table/small-table-demo/main.cpp</a>.
<h3 class=fn>void <a name="setTopMargin"></a>QTable::setTopMargin ( int&nbsp;m )<tt> [virtual slot]</tt>
</h3>
Sets the top margin to be <em>m</em> pixels high.
<p> The <a href="#horizontalHeader">horizontalHeader</a>(), which displays column labels, occupies
this margin.
<p> <p>See also <a href="qscrollview.html#topMargin">topMargin</a>() and <a href="#setLeftMargin">setLeftMargin</a>().

<p>Example: <a href="regexptester-example.html#x2505">regexptester/regexptester.cpp</a>.
<h3 class=fn>void <a name="showColumn"></a>QTable::showColumn ( int&nbsp;col )<tt> [virtual slot]</tt>
</h3>
Shows column <em>col</em>.
<p> <p>See also <a href="#hideColumn">hideColumn</a>() and <a href="#showRow">showRow</a>().

<h3 class=fn>bool <a name="showGrid"></a>QTable::showGrid () const
</h3><p>Returns TRUE if the table's grid is displayed; otherwise returns FALSE.
See the <a href="qtable.html#showGrid-prop">"showGrid"</a> property for details.
<h3 class=fn>void <a name="showRow"></a>QTable::showRow ( int&nbsp;row )<tt> [virtual slot]</tt>
</h3>
Shows row <em>row</em>.
<p> <p>See also <a href="#hideRow">hideRow</a>() and <a href="#showColumn">showColumn</a>().

<h3 class=fn>void <a name="sortColumn"></a>QTable::sortColumn ( int&nbsp;col, bool&nbsp;ascending = TRUE, bool&nbsp;wholeRows = FALSE )<tt> [virtual]</tt>
</h3>
Sorts column <em>col</em>. If <em>ascending</em> is TRUE the sort is in
ascending order, otherwise the sort is in descending order.
<p> If <em>wholeRows</em> is TRUE, entire rows are sorted using <a href="#swapRows">swapRows</a>();
otherwise only cells in the column are sorted using <a href="#swapCells">swapCells</a>().
<p> Note that if you are not using QTableItems you will need to
reimplement swapRows() and swapCells(). (See the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.)
<p> <p>See also <a href="#swapRows">swapRows</a>().

<p>Example: <a href="statistics-example.html#x2784">table/statistics/statistics.cpp</a>.
<p>Reimplemented in <a href="qdatatable.html#sortColumn">QDataTable</a>.
<h3 class=fn>bool <a name="sorting"></a>QTable::sorting () const
</h3><p>Returns TRUE if a click on the header of a column sorts that column; otherwise returns FALSE.
See the <a href="qtable.html#sorting-prop">"sorting"</a> property for details.
<h3 class=fn>void <a name="startDrag"></a>QTable::startDrag ()<tt> [virtual protected]</tt>
</h3>
Starts a drag.
<p> Usually you don't need to call or reimplement this function yourself.
<p> <p>See also <a href="#dragObject">dragObject</a>().

<h3 class=fn>void <a name="swapCells"></a>QTable::swapCells ( int&nbsp;row1, int&nbsp;col1, int&nbsp;row2, int&nbsp;col2 )<tt> [virtual slot]</tt>
</h3>
Swaps the contents of the cell at <em>row1</em>, <em>col1</em> with the
contents of the cell at <em>row2</em>, <em>col2</em>.
<p> This function is also called when the table is sorted.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s and want your users to be able to
swap cells, you will need to reimplement this function. (See the
<a href="qtable.html#notes-on-large-tables">notes on large tables</a>.)
<p> <p>See also <a href="#swapColumns">swapColumns</a>() and <a href="#swapRows">swapRows</a>().

<h3 class=fn>void <a name="swapColumns"></a>QTable::swapColumns ( int&nbsp;col1, int&nbsp;col2, bool&nbsp;swapHeader = FALSE )<tt> [virtual slot]</tt>
</h3>
Swaps the data in <em>col1</em> with <em>col2</em>.
<p> This function is used to swap the positions of two columns. It is
called when the user changes the order of columns (see
<a href="#setColumnMovingEnabled">setColumnMovingEnabled</a>(), and when columns are sorted.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s and want your users to be able to
swap columns you will need to reimplement this function. (See the
<a href="qtable.html#notes-on-large-tables">notes on large tables</a>.)
<p> If <em>swapHeader</em> is TRUE, the columns' header contents is also
swapped.
<p> <p>See also <a href="#swapCells">swapCells</a>().

<h3 class=fn>void <a name="swapRows"></a>QTable::swapRows ( int&nbsp;row1, int&nbsp;row2, bool&nbsp;swapHeader = FALSE )<tt> [virtual slot]</tt>
</h3>
Swaps the data in <em>row1</em> and <em>row2</em>.
<p> This function is used to swap the positions of two rows. It is
called when the user changes the order of rows (see
<a href="#setRowMovingEnabled">setRowMovingEnabled</a>()), and when rows are sorted.
<p> If you don't use <a href="qtableitem.html">QTableItem</a>s and want your users to be able to
swap rows, e.g. for sorting, you will need to reimplement this
function. (See the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.)
<p> If <em>swapHeader</em> is TRUE, the rows' header contents is also
swapped.
<p> This function will not update the QTable, you will have to do
this manually, e.g. by calling <a href="qscrollview.html#updateContents">updateContents</a>().
<p> <p>See also <a href="#swapColumns">swapColumns</a>() and <a href="#swapCells">swapCells</a>().

<h3 class=fn>void <a name="takeItem"></a>QTable::takeItem ( <a href="qtableitem.html">QTableItem</a>&nbsp;*&nbsp;i )<tt> [virtual]</tt>
</h3>
Takes the table item <em>i</em> out of the table. This function does <em>not</em> delete the table item. You must either delete the table item
yourself or put it into a table (using <a href="#setItem">setItem</a>()) which will then
take ownership of it.
<p> Use this function if you want to move an item from one cell in a
table to another, or to move an item from one table to another,
reinserting the item with setItem().
<p> If you want to exchange two cells use <a href="#swapCells">swapCells</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="text"></a>QTable::text ( int&nbsp;row, int&nbsp;col ) const<tt> [virtual]</tt>
</h3>
Returns the text in the cell at <em>row</em>, <em>col</em>, or <a href="qstring.html#QString-null">QString::null</a>
if the relevant item does not exist or has no text.
<p> <p>See also <a href="#setText">setText</a>() and <a href="#setPixmap">setPixmap</a>().

<p>Example: <a href="tutorial2-08.html#x2625">chart/setdataform.cpp</a>.
<p>Reimplemented in <a href="qdatatable.html#text">QDataTable</a>.
<h3 class=fn>void <a name="updateCell"></a>QTable::updateCell ( int&nbsp;row, int&nbsp;col )
</h3>
Repaints the cell at <em>row</em>, <em>col</em>.

<h3 class=fn>void <a name="updateHeaderStates"></a>QTable::updateHeaderStates ()
</h3>
This functions updates all the header states to be in sync with
the current selections. This should be called after
programatically changing, adding or removing selections, so that
the headers are updated.

<h3 class=fn>void <a name="valueChanged"></a>QTable::valueChanged ( int&nbsp;row, int&nbsp;col )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the user changed the value in the cell
at <em>row</em>, <em>col</em>.

<p>Example: <a href="tutorial2-08.html#x2626">chart/setdataform.cpp</a>.
<h3 class=fn><a href="qheader.html">QHeader</a>&nbsp;* <a name="verticalHeader"></a>QTable::verticalHeader () const
</h3>
Returns the table's vertical <a href="qheader.html">QHeader</a>.
<p> This header contains the row labels.
<p> <p>See also <a href="#horizontalHeader">horizontalHeader</a>(), <a href="#setLeftMargin">setLeftMargin</a>(), and <a href="qheader.html">QHeader</a>.

<p>Examples: <a href="helpsystem-example.html#x2693">helpsystem/mainwindow.cpp</a> and <a href="regexptester-example.html#x2506">regexptester/regexptester.cpp</a>.
<hr><h2>Property Documentation</h2>
<h3 class=fn>bool <a name="columnMovingEnabled-prop"></a>columnMovingEnabled</h3>
<p>This property holds whether columns can be moved by the user.
<p>The default is FALSE. Columns are moved by dragging whilst holding
down the Ctrl key.
<p> <b>Warning:</b> If QTable is used to move header sections as a result of user
interaction, the mapping between header indexes and section exposed by
<a href="qheader.html">QHeader</a> will not reflect the order of the headers in the table; i.e.,
QTable does not call <a href="qheader.html#moveSection">QHeader::moveSection</a>() to move sections but handles
move operations internally.
<p> <p>See also <a href="#rowMovingEnabled-prop">rowMovingEnabled</a>.

<p>Set this property's value with <a href="#setColumnMovingEnabled">setColumnMovingEnabled</a>() and get this property's value with <a href="#columnMovingEnabled">columnMovingEnabled</a>().
<h3 class=fn><a href="qtable.html#FocusStyle-enum">FocusStyle</a> <a name="focusStyle-prop"></a>focusStyle</h3>
<p>This property holds how the current (focus) cell is drawn.
<p>The default style is <a href="#FocusStyle-enum">SpreadSheet</a>.
<p> <p>See also <a href="#FocusStyle-enum">QTable::FocusStyle</a>.

<p>Set this property's value with <a href="#setFocusStyle">setFocusStyle</a>() and get this property's value with <a href="#focusStyle">focusStyle</a>().
<h3 class=fn>int <a name="numCols-prop"></a>numCols</h3>
<p>This property holds the number of columns in the table.
<p>Set this property's value with <a href="#setNumCols">setNumCols</a>() and get this property's value with <a href="#numCols">numCols</a>().
<p><p>See also <a href="#numRows-prop">numRows</a>.

<h3 class=fn>int <a name="numRows-prop"></a>numRows</h3>
<p>This property holds the number of rows in the table.
<p>Set this property's value with <a href="#setNumRows">setNumRows</a>() and get this property's value with <a href="#numRows">numRows</a>().
<p><p>See also <a href="#numCols-prop">numCols</a>.

<h3 class=fn>int <a name="numSelections-prop"></a>numSelections</h3>
<p>This property holds the number of selections.
<p>Get this property's value with <a href="#numSelections">numSelections</a>().
<p><p>See also <a href="#currentSelection">currentSelection</a>().

<h3 class=fn>bool <a name="readOnly-prop"></a>readOnly</h3>
<p>This property holds whether the table is read-only.
<p>Whether a cell in the table is editable or read-only depends on
the cell's <a href="qtableitem.html#EditType-enum">EditType</a>, and this setting:
see <a href="qtableitem.html#wheneditable">QTableItem::EditType</a>.
<p> <p>See also <a href="qwidget.html#enabled-prop">QWidget::enabled</a>, <a href="#setColumnReadOnly">setColumnReadOnly</a>(), and <a href="#setRowReadOnly">setRowReadOnly</a>().

<p>Set this property's value with <a href="#setReadOnly">setReadOnly</a>() and get this property's value with <a href="#isReadOnly">isReadOnly</a>().
<h3 class=fn>bool <a name="rowMovingEnabled-prop"></a>rowMovingEnabled</h3>
<p>This property holds whether rows can be moved by the user.
<p>The default is FALSE. Rows are moved by dragging whilst holding
down the Ctrl key.
<p> <b>Warning:</b> If QTable is used to move header sections as a result of user
interaction, the mapping between header indexes and section exposed by
<a href="qheader.html">QHeader</a> will not reflect the order of the headers in the table; i.e.,
QTable does not call <a href="qheader.html#moveSection">QHeader::moveSection</a>() to move sections but handles
move operations internally.
<p> <p>See also <a href="#columnMovingEnabled-prop">columnMovingEnabled</a>.

<p>Set this property's value with <a href="#setRowMovingEnabled">setRowMovingEnabled</a>() and get this property's value with <a href="#rowMovingEnabled">rowMovingEnabled</a>().
<h3 class=fn><a href="qtable.html#SelectionMode-enum">SelectionMode</a> <a name="selectionMode-prop"></a>selectionMode</h3>
<p>This property holds the current selection mode.
<p>The default mode is <a href="#SelectionMode-enum">Multi</a> which allows the user to select
multiple ranges of cells.
<p> <p>See also <a href="#SelectionMode-enum">SelectionMode</a> and <a href="#selectionMode-prop">selectionMode</a>.

<p>Set this property's value with <a href="#setSelectionMode">setSelectionMode</a>() and get this property's value with <a href="#selectionMode">selectionMode</a>().
<h3 class=fn>bool <a name="showGrid-prop"></a>showGrid</h3>
<p>This property holds whether the table's grid is displayed.
<p>The grid is shown by default.

<p>Set this property's value with <a href="#setShowGrid">setShowGrid</a>() and get this property's value with <a href="#showGrid">showGrid</a>().
<h3 class=fn>bool <a name="sorting-prop"></a>sorting</h3>
<p>This property holds whether a click on the header of a column sorts that column.
<p>Set this property's value with <a href="#setSorting">setSorting</a>() and get this property's value with <a href="#sorting">sorting</a>().
<p><p>See also <a href="#sortColumn">sortColumn</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
