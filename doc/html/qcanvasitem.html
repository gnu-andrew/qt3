<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/canvas/qcanvas.cpp:1843 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QCanvasItem Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QCanvasItem Class Reference<br><small>[<a href="canvas.html">canvas module</a>]</small></h1>

<p>The QCanvasItem class provides an abstract graphic object on a QCanvas.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qcanvas-h.html">qcanvas.h</a>&gt;</tt>
<p>Inherits <a href="qt.html">Qt</a>.
<p>Inherited by <a href="qcanvassprite.html">QCanvasSprite</a>, <a href="qcanvaspolygonalitem.html">QCanvasPolygonalItem</a>, and <a href="qcanvastext.html">QCanvasText</a>.
<p><a href="qcanvasitem-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QCanvasItem"><b>QCanvasItem</b></a> ( QCanvas&nbsp;*&nbsp;canvas )</li>
<li class=fn>virtual <a href="#~QCanvasItem"><b>~QCanvasItem</b></a> ()</li>
<li class=fn>double <a href="#x"><b>x</b></a> () const</li>
<li class=fn>double <a href="#y"><b>y</b></a> () const</li>
<li class=fn>double <a href="#z"><b>z</b></a> () const</li>
<li class=fn>virtual void <a href="#moveBy"><b>moveBy</b></a> ( double&nbsp;dx, double&nbsp;dy )</li>
<li class=fn>void <a href="#move"><b>move</b></a> ( double&nbsp;x, double&nbsp;y )</li>
<li class=fn>void <a href="#setX"><b>setX</b></a> ( double&nbsp;x )</li>
<li class=fn>void <a href="#setY"><b>setY</b></a> ( double&nbsp;y )</li>
<li class=fn>void <a href="#setZ"><b>setZ</b></a> ( double&nbsp;z )</li>
<li class=fn>bool <a href="#animated"><b>animated</b></a> () const</li>
<li class=fn>virtual void <a href="#setAnimated"><b>setAnimated</b></a> ( bool&nbsp;y )</li>
<li class=fn>virtual void <a href="#setVelocity"><b>setVelocity</b></a> ( double&nbsp;vx, double&nbsp;vy )</li>
<li class=fn>void <a href="#setXVelocity"><b>setXVelocity</b></a> ( double&nbsp;vx )</li>
<li class=fn>void <a href="#setYVelocity"><b>setYVelocity</b></a> ( double&nbsp;vy )</li>
<li class=fn>double <a href="#xVelocity"><b>xVelocity</b></a> () const</li>
<li class=fn>double <a href="#yVelocity"><b>yVelocity</b></a> () const</li>
<li class=fn>virtual void <a href="#advance"><b>advance</b></a> ( int&nbsp;phase )</li>
<li class=fn>virtual bool <a href="#collidesWith"><b>collidesWith</b></a> ( const&nbsp;QCanvasItem&nbsp;*&nbsp;other ) const = 0</li>
<li class=fn>QCanvasItemList <a href="#collisions"><b>collisions</b></a> ( bool&nbsp;exact ) const</li>
<li class=fn>virtual void <a href="#setCanvas"><b>setCanvas</b></a> ( QCanvas&nbsp;*&nbsp;c )</li>
<li class=fn>virtual void <a href="#draw"><b>draw</b></a> ( QPainter&nbsp;&amp;&nbsp;painter ) = 0</li>
<li class=fn>void <a href="#show"><b>show</b></a> ()</li>
<li class=fn>void <a href="#hide"><b>hide</b></a> ()</li>
<li class=fn>virtual void <a href="#setVisible"><b>setVisible</b></a> ( bool&nbsp;yes )</li>
<li class=fn>bool <a href="#isVisible"><b>isVisible</b></a> () const</li>
<li class=fn>virtual void <a href="#setSelected"><b>setSelected</b></a> ( bool&nbsp;yes )</li>
<li class=fn>bool <a href="#isSelected"><b>isSelected</b></a> () const</li>
<li class=fn>virtual void <a href="#setEnabled"><b>setEnabled</b></a> ( bool&nbsp;yes )</li>
<li class=fn>bool <a href="#isEnabled"><b>isEnabled</b></a> () const</li>
<li class=fn>virtual void <a href="#setActive"><b>setActive</b></a> ( bool&nbsp;yes )</li>
<li class=fn>bool <a href="#isActive"><b>isActive</b></a> () const</li>
<li class=fn>bool visible () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool selected () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool enabled () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>bool active () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>enum <a href="#RttiValues-enum"><b>RttiValues</b></a> { Rtti_Item = 0, Rtti_Sprite = 1, Rtti_PolygonalItem = 2, Rtti_Text = 3, Rtti_Polygon = 4, Rtti_Rectangle = 5, Rtti_Ellipse = 6, Rtti_Line = 7, Rtti_Spline = 8 }</li>
<li class=fn>virtual int <a href="#rtti"><b>rtti</b></a> () const</li>
<li class=fn>virtual QRect <a href="#boundingRect"><b>boundingRect</b></a> () const = 0</li>
<li class=fn>virtual QRect <a href="#boundingRectAdvanced"><b>boundingRectAdvanced</b></a> () const</li>
<li class=fn>QCanvas * <a href="#canvas"><b>canvas</b></a> () const</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>void <a href="#update"><b>update</b></a> ()</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QCanvasItem class provides an abstract graphic object on a <a href="qcanvas.html">QCanvas</a>.

<p> 


<p> A variety of QCanvasItem subclasses provide immediately usable
behaviour. This class is a pure abstract superclass providing the
behaviour that is shared among all the concrete canvas item classes.
QCanvasItem is not intended for direct subclassing. It is much easier
to subclass one of its subclasses, e.g. <a href="qcanvaspolygonalitem.html">QCanvasPolygonalItem</a> (the
commonest base class), <a href="qcanvasrectangle.html">QCanvasRectangle</a>, <a href="qcanvassprite.html">QCanvasSprite</a>, <a href="qcanvasellipse.html">QCanvasEllipse</a>
or <a href="qcanvastext.html">QCanvasText</a>.
<p> Canvas items are added to a canvas by constructing them and passing the
canvas to the canvas item's constructor. An item can be moved to a
different canvas using <a href="#setCanvas">setCanvas</a>().
<p> Items appear on the canvas after their <a href="#show">show()</a>
function has been called (or <a href="#setVisible">setVisible(TRUE)</a>), and <em>after</em> <a href="#update">update</a>() has been called. The
canvas only shows items that are <a href="#setVisible">visible</a>,
and then only if <a href="#update">update</a>() is called. If you created the canvas
without passing a width and height to the constructor you'll also need
to call <a href="qcanvas.html#resize">resize()</a>. Since the canvas
background defaults to white and canvas items default to white,
you may need to change colors to see your items.
<p> A QCanvasItem object can be moved in the <a href="#x">x</a>(), <a href="#y">y</a>() and <a href="#z">z</a>() dimensions
using functions such as <a href="#move">move</a>(), <a href="#moveBy">moveBy</a>(), <a href="#setX">setX</a>(), <a href="#setY">setY</a>() and <a href="#setZ">setZ</a>(). A
canvas item can be set in motion, `animated', using <a href="#setAnimated">setAnimated</a>() and
given a velocity in the x and y directions with <a href="#setXVelocity">setXVelocity</a>() and
<a href="#setYVelocity">setYVelocity</a>() -- the same effect can be achieved by calling
<a href="#setVelocity">setVelocity</a>(). Use the <a href="#collidesWith">collidesWith</a>() function to see if the canvas item
will collide on the <em>next</em> <a href="#advance">advance</a>(1) and use <a href="#collisions">collisions</a>() to see what
collisions have occurred.
<p> Use <a href="qcanvassprite.html">QCanvasSprite</a> or your own subclass of QCanvasSprite to create canvas
items which are animated, i.e. which change over time.
<p> The size of a canvas item is given by <a href="#boundingRect">boundingRect</a>(). Use
<a href="#boundingRectAdvanced">boundingRectAdvanced</a>() to see what the size of the canvas item will be
<em>after</em> the next advance(1) call.
<p> The <a href="#rtti">rtti</a>() function is used for identifying subclasses of QCanvasItem.
The <a href="#canvas">canvas</a>() function returns a pointer to the canvas which contains the
canvas item.
<p> QCanvasItem provides the <a href="#show">show</a>() and <a href="#isVisible">isVisible</a>() functions like those in
<a href="qwidget.html">QWidget</a>.
<p> QCanvasItem also provides the <a href="#setEnabled">setEnabled</a>(), <a href="#setActive">setActive</a>() and
<a href="#setSelected">setSelected</a>() functions; these functions set the relevant boolean and
cause a repaint but the boolean values they set are not used in
QCanvasItem itself. You can make use of these booleans in your subclasses.
<p> By default, canvas items have no velocity, no size, and are not in
motion. The subclasses provided in Qt do not change these defaults
except where noted.
<p> <p>See also <a href="graphics.html">Graphics Classes</a> and <a href="images.html">Image Processing Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="RttiValues-enum"></a>QCanvasItem::RttiValues</h3>

<p> This enum is used to name the different types of canvas item.
<ul>
<li><tt>QCanvasItem::Rtti_Item</tt> - Canvas item abstract base class
<li><tt>QCanvasItem::Rtti_Ellipse</tt>
<li><tt>QCanvasItem::Rtti_Line</tt>
<li><tt>QCanvasItem::Rtti_Polygon</tt>
<li><tt>QCanvasItem::Rtti_PolygonalItem</tt>
<li><tt>QCanvasItem::Rtti_Rectangle</tt>
<li><tt>QCanvasItem::Rtti_Spline</tt>
<li><tt>QCanvasItem::Rtti_Sprite</tt>
<li><tt>QCanvasItem::Rtti_Text</tt>
</ul><p> 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QCanvasItem"></a>QCanvasItem::QCanvasItem ( <a href="qcanvas.html">QCanvas</a>&nbsp;*&nbsp;canvas )
</h3>
Constructs a QCanvasItem on canvas <em>canvas</em>.
<p> <p>See also <a href="#setCanvas">setCanvas</a>().

<h3 class=fn><a name="~QCanvasItem"></a>QCanvasItem::~QCanvasItem ()<tt> [virtual]</tt>
</h3>
Destroys the QCanvasItem and removes it from its canvas.

<h3 class=fn>bool <a name="active"></a>QCanvasItem::active () const
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> 
Use <a href="#isActive">isActive</a>() instead.

<h3 class=fn>void <a name="advance"></a>QCanvasItem::advance ( int&nbsp;phase )<tt> [virtual]</tt>
</h3>
The default implementation moves the canvas item, if it is
<a href="#animated">animated</a>(), by the preset velocity if <em>phase</em> is 1, and does
nothing if <em>phase</em> is 0.
<p> Note that if you reimplement this function, the reimplementation
must not change the canvas in any way, for example it must not add
or remove items.
<p> <p>See also <a href="qcanvas.html#advance">QCanvas::advance</a>() and <a href="#setVelocity">setVelocity</a>().

<p>Example: <a href="canvas-example.html#x2913">canvas/canvas.cpp</a>.
<p>Reimplemented in <a href="qcanvassprite.html#advance">QCanvasSprite</a>.
<h3 class=fn>bool <a name="animated"></a>QCanvasItem::animated () const
</h3>
Returns TRUE if the canvas item is in motion; otherwise returns
FALSE.
<p> <p>See also <a href="#setVelocity">setVelocity</a>() and <a href="#setAnimated">setAnimated</a>().

<h3 class=fn><a href="qrect.html">QRect</a> <a name="boundingRect"></a>QCanvasItem::boundingRect () const<tt> [pure virtual]</tt>
</h3>

<p> Returns the bounding rectangle in pixels that the canvas item covers.
<p> <p>See also <a href="#boundingRectAdvanced">boundingRectAdvanced</a>().

<p>Reimplemented in <a href="qcanvassprite.html#boundingRect">QCanvasSprite</a>, <a href="qcanvaspolygonalitem.html#boundingRect">QCanvasPolygonalItem</a>, and <a href="qcanvastext.html#boundingRect">QCanvasText</a>.
<h3 class=fn><a href="qrect.html">QRect</a> <a name="boundingRectAdvanced"></a>QCanvasItem::boundingRectAdvanced () const<tt> [virtual]</tt>
</h3>
Returns the bounding rectangle of pixels that the canvas item <em>will</em> cover after <a href="#advance">advance</a>(1) is called.
<p> <p>See also <a href="#boundingRect">boundingRect</a>().

<h3 class=fn><a href="qcanvas.html">QCanvas</a>&nbsp;* <a name="canvas"></a>QCanvasItem::canvas () const
</h3>

<p> Returns the canvas containing the canvas item.

<h3 class=fn>bool <a name="collidesWith"></a>QCanvasItem::collidesWith ( const&nbsp;<a href="qcanvasitem.html">QCanvasItem</a>&nbsp;*&nbsp;other ) const<tt> [pure virtual]</tt>
</h3>

<p> Returns TRUE if the canvas item will collide with the <em>other</em>
item <em>after</em> they have moved by their current velocities;
otherwise returns FALSE.
<p> <p>See also <a href="#collisions">collisions</a>().

<p>Example: <a href="canvas-example.html#x2914">canvas/canvas.cpp</a>.
<h3 class=fn><a href="qcanvasitemlist.html">QCanvasItemList</a> <a name="collisions"></a>QCanvasItem::collisions ( bool&nbsp;exact ) const
</h3>
Returns the list of canvas items that this canvas item has
collided with.
<p> A collision is generally defined as occurring when the pixels of
one item draw on the pixels of another item, but not all
subclasses are so precise. Also, since pixel-wise collision
detection can be slow, this function works in either exact or
inexact mode, according to the <em>exact</em> parameter.
<p> If <em>exact</em> is TRUE, the canvas items returned have been
accurately tested for collision with the canvas item.
<p> If <em>exact</em> is FALSE, the canvas items returned are <em>near</em> the
canvas item. You can test the canvas items returned using
<a href="#collidesWith">collidesWith</a>() if any are interesting collision candidates. By
using this approach, you can ignore some canvas items for which
collisions are not relevant.
<p> The returned list is a list of QCanvasItems, but often you will
need to cast the items to their subclass types. The safe way to do
this is to use <a href="#rtti">rtti</a>() before casting. This provides some of the
functionality of the standard C++ dynamic cast operation even on
compilers where dynamic casts are not available.
<p> Note that a canvas item may be `on' a canvas, e.g. it was created
with the canvas as parameter, even though its coordinates place it
beyond the edge of the canvas's area. Collision detection only
works for canvas items which are wholly or partly within the
canvas's area.
<p> Note that if items have a velocity (see <a href="#setVelocity">setVelocity</a>()), then
collision testing is done based on where the item <em>will</em> be when
it moves, not its current location. For example, a "ball" item
doesn't need to actually embed into a "wall" item before a
collision is detected. For items without velocity, plain
intersection is used.

<h3 class=fn>void <a name="draw"></a>QCanvasItem::draw ( <a href="qpainter.html">QPainter</a>&nbsp;&amp;&nbsp;painter )<tt> [pure virtual]</tt>
</h3>

<p> This abstract virtual function draws the canvas item using <em>painter</em>.
<p> <b>Warning:</b> When you reimplement this function, make sure that you
leave the painter in the same state as you found it. For example,
if you start by calling <a href="qpainter.html#translate">QPainter::translate</a>(50, 50), end your
code by calling QPainter::translate(-50, -50). Be also aware that
the painter might already have some transformations set (i.e.,
don't call <a href="qpainter.html#resetXForm">QPainter::resetXForm</a>() when you're done).

<p>Reimplemented in <a href="qcanvassprite.html#draw">QCanvasSprite</a>, <a href="qcanvaspolygonalitem.html#draw">QCanvasPolygonalItem</a>, and <a href="qcanvastext.html#draw">QCanvasText</a>.
<h3 class=fn>bool <a name="enabled"></a>QCanvasItem::enabled () const
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> 
Use <a href="#isEnabled">isEnabled</a>() instead.

<h3 class=fn>void <a name="hide"></a>QCanvasItem::hide ()
</h3> Shorthand for <a href="#setVisible">setVisible</a>(FALSE). 
<h3 class=fn>bool <a name="isActive"></a>QCanvasItem::isActive () const
</h3>

<p> Returns TRUE if the QCanvasItem is active; otherwise returns FALSE.

<h3 class=fn>bool <a name="isEnabled"></a>QCanvasItem::isEnabled () const
</h3>

<p> Returns TRUE if the QCanvasItem is enabled; otherwise returns FALSE.

<h3 class=fn>bool <a name="isSelected"></a>QCanvasItem::isSelected () const
</h3>

<p> Returns TRUE if the canvas item is selected; otherwise returns FALSE.

<h3 class=fn>bool <a name="isVisible"></a>QCanvasItem::isVisible () const
</h3>

<p> Returns TRUE if the canvas item is visible; otherwise returns
FALSE.
<p> Note that in this context TRUE does <em>not</em> mean that the canvas
item is currently in a view, merely that if a view is showing the
area where the canvas item is positioned, and the item is not
obscured by items with higher z values, and the view is not
obscured by overlaying windows, it would be visible.
<p> <p>See also <a href="#setVisible">setVisible</a>() and <a href="#z">z</a>().

<h3 class=fn>void <a name="move"></a>QCanvasItem::move ( double&nbsp;x, double&nbsp;y )
</h3>
Moves the canvas item to the absolute position (<em>x</em>, <em>y</em>).

<p>Example: <a href="canvas-example.html#x2915">canvas/canvas.cpp</a>.
<h3 class=fn>void <a name="moveBy"></a>QCanvasItem::moveBy ( double&nbsp;dx, double&nbsp;dy )<tt> [virtual]</tt>
</h3>
Moves the canvas item relative to its current position by (<em>dx</em>,
<em>dy</em>).

<p>Example: <a href="canvas-example.html#x2916">canvas/canvas.cpp</a>.
<h3 class=fn>int <a name="rtti"></a>QCanvasItem::rtti () const<tt> [virtual]</tt>
</h3>
Returns 0 (QCanvasItem::Rtti_Item).
<p> Make your derived classes return their own values for <a href="#rtti">rtti</a>(), so
that you can distinguish between objects returned by
QCanvas::at(). You should use values greater than 1000 to allow
for extensions to this class.
<p> Overuse of this functionality can damage it's extensibility. For
example, once you have identified a base class of a QCanvasItem
found by QCanvas::at(), cast it to that type and call meaningful
methods rather than acting upon the object based on its rtti
value.
<p> For example:
<p> <pre>
        QCanvasItem* item;
        // Find an item, e.g. with QCanvasItem::collisions().
        ...
        if (item-&gt;<a href="#rtti">rtti</a>() == MySprite::RTTI ) {
            MySprite* s = (MySprite*)item;
            if (s-&gt;isDamagable()) s-&gt;loseHitPoints(1000);
            if (s-&gt;isHot()) myself-&gt;loseHitPoints(1000);
            ...
        }
    </pre>
 

<p>Example: <a href="canvas-example.html#x2917">canvas/canvas.cpp</a>.
<p>Reimplemented in <a href="qcanvassprite.html#rtti">QCanvasSprite</a>, <a href="qcanvaspolygonalitem.html#rtti">QCanvasPolygonalItem</a>, and <a href="qcanvastext.html#rtti">QCanvasText</a>.
<h3 class=fn>bool <a name="selected"></a>QCanvasItem::selected () const
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> 
Use <a href="#isSelected">isSelected</a>() instead.

<h3 class=fn>void <a name="setActive"></a>QCanvasItem::setActive ( bool&nbsp;yes )<tt> [virtual]</tt>
</h3>
Sets the active flag of the item to <em>yes</em>. If this changes the
item's active state the item will be redrawn when
<a href="qcanvas.html#update">QCanvas::update</a>() is next called.
<p> The <a href="qcanvas.html">QCanvas</a>, QCanvasItem and the Qt-supplied QCanvasItem
subclasses do not make use of this value. The <a href="#setActive">setActive</a>() function
is supplied because many applications need it, but it is up to you
how you use the <a href="#isActive">isActive</a>() value.

<h3 class=fn>void <a name="setAnimated"></a>QCanvasItem::setAnimated ( bool&nbsp;y )<tt> [virtual]</tt>
</h3>
Sets the canvas item to be in motion if <em>y</em> is TRUE, or not if <em>y</em> is FALSE. The speed and direction of the motion is set with
<a href="#setVelocity">setVelocity</a>(), or with <a href="#setXVelocity">setXVelocity</a>() and <a href="#setYVelocity">setYVelocity</a>().
<p> <p>See also <a href="#advance">advance</a>() and <a href="qcanvas.html#advance">QCanvas::advance</a>().

<h3 class=fn>void <a name="setCanvas"></a>QCanvasItem::setCanvas ( <a href="qcanvas.html">QCanvas</a>&nbsp;*&nbsp;c )<tt> [virtual]</tt>
</h3>
Sets the <a href="qcanvas.html">QCanvas</a> upon which the canvas item is to be drawn to <em>c</em>.
<p> <p>See also <a href="#canvas">canvas</a>().

<h3 class=fn>void <a name="setEnabled"></a>QCanvasItem::setEnabled ( bool&nbsp;yes )<tt> [virtual]</tt>
</h3>
Sets the enabled flag of the item to <em>yes</em>. If this changes the
item's enabled state the item will be redrawn when
<a href="qcanvas.html#update">QCanvas::update</a>() is next called.
<p> The <a href="qcanvas.html">QCanvas</a>, QCanvasItem and the Qt-supplied QCanvasItem
subclasses do not make use of this value. The <a href="#setEnabled">setEnabled</a>()
function is supplied because many applications need it, but it is
up to you how you use the <a href="#isEnabled">isEnabled</a>() value.

<h3 class=fn>void <a name="setSelected"></a>QCanvasItem::setSelected ( bool&nbsp;yes )<tt> [virtual]</tt>
</h3>
Sets the selected flag of the item to <em>yes</em>. If this changes the
item's selected state the item will be redrawn when
<a href="qcanvas.html#update">QCanvas::update</a>() is next called.
<p> The <a href="qcanvas.html">QCanvas</a>, QCanvasItem and the Qt-supplied QCanvasItem
subclasses do not make use of this value. The <a href="#setSelected">setSelected</a>()
function is supplied because many applications need it, but it is
up to you how you use the <a href="#isSelected">isSelected</a>() value.

<h3 class=fn>void <a name="setVelocity"></a>QCanvasItem::setVelocity ( double&nbsp;vx, double&nbsp;vy )<tt> [virtual]</tt>
</h3>
Sets the canvas item to be in motion, moving by <em>vx</em> and <em>vy</em>
pixels in the horizontal and vertical directions respectively.
<p> <p>See also <a href="#advance">advance</a>(), <a href="#setXVelocity">setXVelocity</a>(), and <a href="#setYVelocity">setYVelocity</a>().

<h3 class=fn>void <a name="setVisible"></a>QCanvasItem::setVisible ( bool&nbsp;yes )<tt> [virtual]</tt>
</h3>
Makes the canvas item visible if <em>yes</em> is TRUE, or invisible if
<em>yes</em> is FALSE. The change takes effect when <a href="qcanvas.html#update">QCanvas::update</a>() is
next called.

<h3 class=fn>void <a name="setX"></a>QCanvasItem::setX ( double&nbsp;x )
</h3>

<p> Moves the canvas item so that its x-position is <em>x</em>.
<p> <p>See also <a href="#x">x</a>() and <a href="#move">move</a>().

<p>Example: <a href="tutorial2-06.html#x2568">chart/chartform_canvas.cpp</a>.
<h3 class=fn>void <a name="setXVelocity"></a>QCanvasItem::setXVelocity ( double&nbsp;vx )
</h3>

<p> Sets the horizontal component of the canvas item's velocity to <em>vx</em>.
<p> <p>See also <a href="#setYVelocity">setYVelocity</a>() and <a href="#setVelocity">setVelocity</a>().

<h3 class=fn>void <a name="setY"></a>QCanvasItem::setY ( double&nbsp;y )
</h3>

<p> Moves the canvas item so that its y-position is <em>y</em>.
<p> <p>See also <a href="#y">y</a>() and <a href="#move">move</a>().

<p>Example: <a href="tutorial2-06.html#x2569">chart/chartform_canvas.cpp</a>.
<h3 class=fn>void <a name="setYVelocity"></a>QCanvasItem::setYVelocity ( double&nbsp;vy )
</h3>

<p> Sets the vertical component of the canvas item's velocity to <em>vy</em>.
<p> <p>See also <a href="#setXVelocity">setXVelocity</a>() and <a href="#setVelocity">setVelocity</a>().

<h3 class=fn>void <a name="setZ"></a>QCanvasItem::setZ ( double&nbsp;z )
</h3>

<p> Sets the z index of the canvas item to <em>z</em>. Higher-z items
obscure (are in front of) lower-z items.
<p> <p>See also <a href="#z">z</a>() and <a href="#move">move</a>().

<p>Examples: <a href="canvas-example.html#x2918">canvas/canvas.cpp</a> and <a href="tutorial2-06.html#x2570">chart/chartform_canvas.cpp</a>.
<h3 class=fn>void <a name="show"></a>QCanvasItem::show ()
</h3> Shorthand for <a href="#setVisible">setVisible</a>(TRUE). 
<p>Examples: <a href="canvas-example.html#x2919">canvas/canvas.cpp</a> and <a href="tutorial2-06.html#x2571">chart/chartform_canvas.cpp</a>.
<h3 class=fn>void <a name="update"></a>QCanvasItem::update ()<tt> [protected]</tt>
</h3>

<p> Call this function to repaint the canvas's changed chunks.

<h3 class=fn>bool <a name="visible"></a>QCanvasItem::visible () const
</h3>
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> 
Use <a href="#isVisible">isVisible</a>() instead.

<h3 class=fn>double <a name="x"></a>QCanvasItem::x () const
</h3>

<p> Returns the horizontal position of the canvas item. Note that
subclasses often have an origin other than the top-left corner.

<p>Example: <a href="canvas-example.html#x2920">canvas/canvas.cpp</a>.
<h3 class=fn>double <a name="xVelocity"></a>QCanvasItem::xVelocity () const
</h3>
Returns the horizontal velocity component of the canvas item.

<h3 class=fn>double <a name="y"></a>QCanvasItem::y () const
</h3>

<p> Returns the vertical position of the canvas item. Note that
subclasses often have an origin other than the top-left corner.

<p>Example: <a href="canvas-example.html#x2921">canvas/canvas.cpp</a>.
<h3 class=fn>double <a name="yVelocity"></a>QCanvasItem::yVelocity () const
</h3>
Returns the vertical velocity component of the canvas item.

<h3 class=fn>double <a name="z"></a>QCanvasItem::z () const
</h3>

<p> Returns the z index of the canvas item, which is used for visual
order: higher-z items obscure (are in front of) lower-z items.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
