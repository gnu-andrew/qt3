<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/tools/qcstring.cpp:567 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QCString Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QCString Class Reference</h1>

<p>The QCString class provides an abstraction of the classic C
zero-terminated char array (char *).
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qcstring-h.html">qcstring.h</a>&gt;</tt>
<p>Inherits <a href="qbytearray.html">QByteArray</a>.
<p><a href="qcstring-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QCString"><b>QCString</b></a> ()</li>
<li class=fn><a href="#QCString-2"><b>QCString</b></a> ( int&nbsp;size )</li>
<li class=fn><a href="#QCString-3"><b>QCString</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s )</li>
<li class=fn><a href="#QCString-4"><b>QCString</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn><a href="#QCString-5"><b>QCString</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, uint&nbsp;maxsize )</li>
<li class=fn>QCString &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s )</li>
<li class=fn>QCString &amp; <a href="#operator-eq-2"><b>operator=</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>bool <a href="#isNull"><b>isNull</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>uint <a href="#length"><b>length</b></a> () const</li>
<li class=fn>bool <a href="#resize"><b>resize</b></a> ( uint&nbsp;len )</li>
<li class=fn>bool <a href="#truncate"><b>truncate</b></a> ( uint&nbsp;pos )</li>
<li class=fn>bool <a href="#fill"><b>fill</b></a> ( char&nbsp;c, int&nbsp;len = -1 )</li>
<li class=fn>QCString <a href="#copy"><b>copy</b></a> () const</li>
<li class=fn>QCString &amp; <a href="#sprintf"><b>sprintf</b></a> ( const&nbsp;char&nbsp;*&nbsp;format, ... )</li>
<li class=fn>int <a href="#find"><b>find</b></a> ( char&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#find-2"><b>find</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#find-3"><b>find</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, int&nbsp;index = 0 ) const</li>
<li class=fn>int <a href="#findRev"><b>findRev</b></a> ( char&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#findRev-2"><b>findRev</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#findRev-3"><b>findRev</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, int&nbsp;index = -1 ) const</li>
<li class=fn>int <a href="#contains"><b>contains</b></a> ( char&nbsp;c, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-2"><b>contains</b></a> ( const&nbsp;char&nbsp;*&nbsp;str, bool&nbsp;cs = TRUE ) const</li>
<li class=fn>int <a href="#contains-3"><b>contains</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx ) const</li>
<li class=fn>QCString <a href="#left"><b>left</b></a> ( uint&nbsp;len ) const</li>
<li class=fn>QCString <a href="#right"><b>right</b></a> ( uint&nbsp;len ) const</li>
<li class=fn>QCString <a href="#mid"><b>mid</b></a> ( uint&nbsp;index, uint&nbsp;len = 0xffffffff ) const</li>
<li class=fn>QCString <a href="#leftJustify"><b>leftJustify</b></a> ( uint&nbsp;width, char&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const</li>
<li class=fn>QCString <a href="#rightJustify"><b>rightJustify</b></a> ( uint&nbsp;width, char&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const</li>
<li class=fn>QCString <a href="#lower"><b>lower</b></a> () const</li>
<li class=fn>QCString <a href="#upper"><b>upper</b></a> () const</li>
<li class=fn>QCString <a href="#stripWhiteSpace"><b>stripWhiteSpace</b></a> () const</li>
<li class=fn>QCString <a href="#simplifyWhiteSpace"><b>simplifyWhiteSpace</b></a> () const</li>
<li class=fn>QCString &amp; <a href="#insert-2"><b>insert</b></a> ( uint&nbsp;index, const&nbsp;char&nbsp;*&nbsp;s )</li>
<li class=fn>QCString &amp; <a href="#insert"><b>insert</b></a> ( uint&nbsp;index, char&nbsp;c )</li>
<li class=fn>QCString &amp; <a href="#append"><b>append</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QCString &amp; <a href="#prepend"><b>prepend</b></a> ( const&nbsp;char&nbsp;*&nbsp;s )</li>
<li class=fn>QCString &amp; <a href="#remove"><b>remove</b></a> ( uint&nbsp;index, uint&nbsp;len )</li>
<li class=fn>QCString &amp; <a href="#replace"><b>replace</b></a> ( uint&nbsp;index, uint&nbsp;len, const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QCString &amp; <a href="#replace-2"><b>replace</b></a> ( const&nbsp;QRegExp&nbsp;&amp;&nbsp;rx, const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QCString &amp; <a href="#replace-3"><b>replace</b></a> ( char&nbsp;c, const&nbsp;char&nbsp;*&nbsp;after )</li>
<li class=fn>QCString &amp; <a href="#replace-4"><b>replace</b></a> ( const&nbsp;char&nbsp;*&nbsp;before, const&nbsp;char&nbsp;*&nbsp;after )</li>
<li class=fn>QCString &amp; <a href="#replace-5"><b>replace</b></a> ( char&nbsp;c1, char&nbsp;c2 )</li>
<li class=fn>short <a href="#toShort"><b>toShort</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>ushort <a href="#toUShort"><b>toUShort</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>int <a href="#toInt"><b>toInt</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>uint <a href="#toUInt"><b>toUInt</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>long <a href="#toLong"><b>toLong</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>ulong <a href="#toULong"><b>toULong</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>float <a href="#toFloat"><b>toFloat</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>double <a href="#toDouble"><b>toDouble</b></a> ( bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>QCString &amp; <a href="#setStr"><b>setStr</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QCString &amp; <a href="#setNum-2"><b>setNum</b></a> ( short&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-3"><b>setNum</b></a> ( ushort&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-4"><b>setNum</b></a> ( int&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-5"><b>setNum</b></a> ( uint&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-6"><b>setNum</b></a> ( long&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-7"><b>setNum</b></a> ( ulong&nbsp;n )</li>
<li class=fn>QCString &amp; <a href="#setNum-8"><b>setNum</b></a> ( float&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )</li>
<li class=fn>QCString &amp; <a href="#setNum"><b>setNum</b></a> ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )</li>
<li class=fn>bool <a href="#setExpand"><b>setExpand</b></a> ( uint&nbsp;index, char&nbsp;c )</li>
<li class=fn><a href="#operator-const-char-*"><b>operator const char *</b></a> () const</li>
<li class=fn>QCString &amp; <a href="#operator+-eq"><b>operator+=</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>QCString &amp; <a href="#operator+-eq-2"><b>operator+=</b></a> ( char&nbsp;c )</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>void * <a href="#qmemmove"><b>qmemmove</b></a> ( void&nbsp;*&nbsp;dst, const&nbsp;void&nbsp;*&nbsp;src, uint&nbsp;len )</li>
<li class=fn>char * <a href="#qstrdup"><b>qstrdup</b></a> ( const&nbsp;char&nbsp;*&nbsp;src )</li>
<li class=fn>char * <a href="#qstrcpy"><b>qstrcpy</b></a> ( char&nbsp;*&nbsp;dst, const&nbsp;char&nbsp;*&nbsp;src )</li>
<li class=fn>char * <a href="#qstrncpy"><b>qstrncpy</b></a> ( char&nbsp;*&nbsp;dst, const&nbsp;char&nbsp;*&nbsp;src, uint&nbsp;len )</li>
<li class=fn>uint <a href="#qstrlen"><b>qstrlen</b></a> ( const&nbsp;char&nbsp;*&nbsp;str )</li>
<li class=fn>int <a href="#qstrcmp"><b>qstrcmp</b></a> ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2 )</li>
<li class=fn>int <a href="#qstrncmp"><b>qstrncmp</b></a> ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2, uint&nbsp;len )</li>
<li class=fn>int <a href="#qstricmp"><b>qstricmp</b></a> ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2 )</li>
<li class=fn>int <a href="#qstrnicmp"><b>qstrnicmp</b></a> ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2, uint&nbsp;len )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, const&nbsp;QCString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QCString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-eq-eq-2"><b>operator==</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-eq-eq-3"><b>operator==</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq-2"><b>operator!=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator!-eq-3"><b>operator!=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt"><b>operator&lt;</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-2"><b>operator&lt;</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-eq"><b>operator&lt;=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-lt-eq-2"><b>operator&lt;=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt"><b>operator&gt;</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-2"><b>operator&gt;</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-eq"><b>operator&gt;=</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>bool <a href="#operator-gt-eq-2"><b>operator&gt;=</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QCString <a href="#operator+"><b>operator+</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QCString <a href="#operator+-2"><b>operator+</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )</li>
<li class=fn>const QCString <a href="#operator+-3"><b>operator+</b></a> ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;QCString&nbsp;&amp;&nbsp;s2 )</li>
<li class=fn>const QCString <a href="#operator+-4"><b>operator+</b></a> ( const&nbsp;QCString&nbsp;&amp;&nbsp;s, char&nbsp;c )</li>
<li class=fn>const QCString <a href="#operator+-5"><b>operator+</b></a> ( char&nbsp;c, const&nbsp;QCString&nbsp;&amp;&nbsp;s )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



The QCString class provides an abstraction of the classic C
zero-terminated char array (char *).
<p> 



<p> QCString inherits <a href="qbytearray.html">QByteArray</a>, which is defined as
<a href="qmemarray.html">QMemArray</a>&lt;char&gt;. Since QCString is a QMemArray, it uses <a href="shclass.html">explicit sharing</a> with a reference count.
<p> QCString tries to behave like a more convenient <tt>const char *</tt>.
The price of doing this is that some algorithms will perform
badly. For example, <a href="#append">append</a>() is O(length()) since it scans for a
null terminator. Although you might use QCString for text that is
never exposed to the user, for most purposes, and especially for
user-visible text, you should use <a href="qstring.html">QString</a>. QString provides
<a href="shclass.html#implicit-sharing">implicit sharing</a>, Unicode and other <a href="i18n.html#internationalization">internationalization</a> support,
and is well optimized.
<p> Note that for the QCString methods that take a <tt>const char *</tt>
parameter the <tt>const char *</tt> must either be 0 (null) or not-null
and '&#92;0' (NUL byte) terminated; otherwise the results are
undefined.
<p> A QCString that has not been assigned to anything is <em>null</em>, i.e.
both the length and the data pointer is 0. A QCString that
references the empty string ("", a single '&#92;0' char) is <em>empty</em>.
Both null and empty QCStrings are legal parameters to the methods.
Assigning <tt>const char *</tt> 0 to QCString produces a null QCString.
<p> The <a href="#length">length</a>() function returns the length of the string; <a href="#resize">resize</a>()
resizes the string and <a href="#truncate">truncate</a>() truncates the string. A string
can be filled with a character using <a href="#fill">fill</a>(). Strings can be left
or right padded with characters using <a href="#leftJustify">leftJustify</a>() and
<a href="#rightJustify">rightJustify</a>(). Characters, strings and regular expressions can be
searched for using <a href="#find">find</a>() and <a href="#findRev">findRev</a>(), and counted using
<a href="#contains">contains</a>().
<p> Strings and characters can be inserted with <a href="#insert">insert</a>() and appended
with <a href="#append">append</a>(). A string can be prepended with <a href="#prepend">prepend</a>().
Characters can be removed from the string with <a href="#remove">remove</a>() and
replaced with <a href="#replace">replace</a>().
<p> Portions of a string can be extracted using <a href="#left">left</a>(), <a href="#right">right</a>() and
<a href="#mid">mid</a>(). Whitespace can be removed using <a href="#stripWhiteSpace">stripWhiteSpace</a>() and
<a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>(). Strings can be converted to uppercase or
lowercase with <a href="#upper">upper</a>() and <a href="#lower">lower</a>() respectively.
<p> Strings that contain numbers can be converted to numbers with
<a href="#toShort">toShort</a>(), <a href="#toInt">toInt</a>(), <a href="#toLong">toLong</a>(), <a href="#toULong">toULong</a>(), <a href="#toFloat">toFloat</a>() and <a href="#toDouble">toDouble</a>().
Numbers can be converted to strings with <a href="#setNum">setNum</a>().
<p> Many operators are overloaded to work with QCStrings. QCString
also supports some more obscure functions, e.g. <a href="#sprintf">sprintf</a>(),
<a href="#setStr">setStr</a>() and <a href="#setExpand">setExpand</a>().
<p> <a name="asciinotion"></a>
<blockquote><p align="center"><b> Note on Character Comparisons
</b>
<p><p> In QCString the notion of uppercase and lowercase and of which
character is greater than or less than another character is locale
dependent. This affects functions which support a case insensitive
option or which compare or lowercase or uppercase their arguments.
Case insensitive operations and comparisons will be accurate if
both strings contain only ASCII characters. (If <tt>$LC_CTYPE</tt> is
set, most Unix systems do "the right thing".) Functions that this
affects include <a href="#contains">contains</a>(), <a href="#find">find</a>(), <a href="#findRev">findRev</a>(), <a href="#operator-lt">operator&lt;</a>(), <a href="#operator-lt-eq">operator&lt;=</a>(), <a href="#operator-gt">operator&gt;</a>(), <a href="#operator-gt-eq">operator&gt;=</a>(), <a href="#lower">lower</a>() and
<a href="#upper">upper</a>().
<p> This issue does not apply to <a href="qstring.html">QString</a>s since they represent
characters using Unicode.
</blockquote>
<p>
<p> Performance note: The QCString methods for <a href="qregexp.html">QRegExp</a> searching are
implemented by converting the QCString to a <a href="qstring.html">QString</a> and performing
the search on that. This implies a <a href="shclass.html#deep-copy">deep copy</a> of the QCString data.
If you are going to perform many QRegExp searches on a large
QCString, you will get better performance by converting the
QCString to a QString yourself, and then searching in the QString.
<p>See also <a href="collection.html">Collection Classes</a>, <a href="shared.html">Implicitly and Explicitly Shared Classes</a>, <a href="text.html">Text Related Classes</a>, and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QCString"></a>QCString::QCString ()
</h3>

<p> Constructs a null string.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QCString-2"></a>QCString::QCString ( int&nbsp;size )
</h3>
Constructs a string with room for <em>size</em> characters, including
the '&#92;0'-terminator. Makes a null string if <em>size</em> == 0.
<p> If <em>size</em> &gt; 0, then the first and last characters in the string
are initialized to '&#92;0'. All other characters are uninitialized.
<p> <p>See also <a href="#resize">resize</a>() and <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QCString-3"></a>QCString::QCString ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s )
</h3>

<p> Constructs a <a href="shclass.html#shallow-copy">shallow copy</a> <em>s</em>.
<p> <p>See also <a href="qmemarray.html#assign">assign</a>().

<h3 class=fn><a name="QCString-4"></a>QCString::QCString ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>.
<p> If <em>str</em> is 0 a null string is created.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QCString-5"></a>QCString::QCString ( const&nbsp;char&nbsp;*&nbsp;str, uint&nbsp;maxsize )
</h3>
Constructs a string that is a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>. The copy will
be at most <em>maxsize</em> bytes long including the '&#92;0'-terminator.
<p> Example:
<pre>
    QCString str( "helloworld", 6 ); // assigns "hello" to str
    </pre>
 
<p> If <em>str</em> contains a 0 byte within the first <em>maxsize</em> bytes, the
resulting QCString will be terminated by this 0. If <em>str</em> is 0 a
null string is created.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="append"></a>QCString::append ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>

<p> Appends string <em>str</em> to the string and returns a reference to the
string. Equivalent to <a href="#operator+-eq">operator+=</a>().

<h3 class=fn>int <a name="contains"></a>QCString::contains ( char&nbsp;c, bool&nbsp;cs = TRUE ) const
</h3>
Returns the number of times the character <em>c</em> occurs in the
string.
<p> The match is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> if FALSE.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>int <a name="contains-2"></a>QCString::contains ( const&nbsp;char&nbsp;*&nbsp;str, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the number of times <em>str</em> occurs in the string.
<p> The match is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> if FALSE.
<p> This function counts overlapping substrings, for example, "banana"
contains two occurrences of "ana".
<p> <p>See also <a href="#findRev">findRev</a>() and <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>int <a name="contains-3"></a>QCString::contains ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Counts the number of overlapping occurrences of <em>rx</em> in the string.
<p> Example:
<pre>
    <a href="qstring.html">QString</a> s = "banana and panama";
    <a href="qregexp.html">QRegExp</a> r = QRegExp( "a[nm]a", TRUE, FALSE );
    s.<a href="qstring.html#contains">contains</a>( r ); // 4 matches
    </pre>
 
<p> <p>See also <a href="#find">find</a>() and <a href="#findRev">findRev</a>().

<p> <b>Warning:</b> If you want to apply this function repeatedly to the same
string it is more efficient to convert the string to a <a href="qstring.html">QString</a> and
apply the function to that.

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="copy"></a>QCString::copy () const
</h3>

<p> Returns a <a href="shclass.html#deep-copy">deep copy</a> of this string.
<p> <p>See also <a href="qmemarray.html#detach">detach</a>().

<h3 class=fn>bool <a name="fill"></a>QCString::fill ( char&nbsp;c, int&nbsp;len = -1 )
</h3>
Fills the string with <em>len</em> bytes of character <em>c</em>, followed by
a '&#92;0'-terminator.
<p> If <em>len</em> is negative, then the current string length is used.
<p> Returns FALSE is <em>len</em> is nonnegative and there is not enough
memory to resize the string; otherwise returns TRUE.

<h3 class=fn>int <a name="find"></a>QCString::find ( char&nbsp;c, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const
</h3>
Finds the first occurrence of the character <em>c</em>, starting at
position <em>index</em>.
<p> The search is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> is FALSE.
<p> Returns the position of <em>c</em>, or -1 if <em>c</em> could not be found.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<p>Example: <a href="networkprotocol-example.html#x663">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>int <a name="find-2"></a>QCString::find ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = 0, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the string <em>str</em>, starting at
position <em>index</em>.
<p> The search is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> is FALSE.
<p> Returns the position of <em>str</em>, or -1 if <em>str</em> could not be
found.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>int <a name="find-3"></a>QCString::find ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, int&nbsp;index = 0 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the <a href="qregexp.html#regular-expression">regular expression</a> <em>rx</em>,
starting at position <em>index</em>.
<p> Returns the position of the next match, or -1 if <em>rx</em> was not
found.
<p> <b>Warning:</b> If you want to apply this function repeatedly to the same
string it is more efficient to convert the string to a <a href="qstring.html">QString</a> and
apply the function to that.

<h3 class=fn>int <a name="findRev"></a>QCString::findRev ( char&nbsp;c, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const
</h3>
Finds the first occurrence of the character <em>c</em>, starting at
position <em>index</em> and searching backwards.
<p> The search is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> is FALSE.
<p> Returns the position of <em>c</em>, or -1 if <em>c</em> could not be found.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>int <a name="findRev-2"></a>QCString::findRev ( const&nbsp;char&nbsp;*&nbsp;str, int&nbsp;index = -1, bool&nbsp;cs = TRUE ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the string <em>str</em>, starting at
position <em>index</em> and searching backwards.
<p> The search is case sensitive if <em>cs</em> is TRUE, or case insensitive
if <em>cs</em> is FALSE.
<p> Returns the position of <em>str</em>, or -1 if <em>str</em> could not be
found.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>int <a name="findRev-3"></a>QCString::findRev ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, int&nbsp;index = -1 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Finds the first occurrence of the <a href="qregexp.html#regular-expression">regular expression</a> <em>rx</em>,
starting at position <em>index</em> and searching backwards.
<p> Returns the position of the next match (backwards), or -1 if <em>rx</em>
was not found.
<p> <b>Warning:</b> If you want to apply this function repeatedly to the same
string it is more efficient to convert the string to a <a href="qstring.html">QString</a> and
apply the function to that.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="insert"></a>QCString::insert ( uint&nbsp;index, char&nbsp;c )
</h3>
Inserts character <em>c</em> into the string at position <em>index</em> and
returns a reference to the string.
<p> If <em>index</em> is beyond the end of the string, the string is
padded with spaces (ASCII 32) to length <em>index</em> and then <em>c</em>
is appended.
<p> Example:
<pre>
    QCString s = "Yes";
    s.<a href="#insert">insert</a>( 3, '!');   // s == "Yes!"
    </pre>
 
<p> <p>See also <a href="#remove">remove</a>() and <a href="#replace">replace</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="insert-2"></a>QCString::insert ( uint&nbsp;index, const&nbsp;char&nbsp;*&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts string <em>s</em> into the string at position <em>index</em>.
<p> If <em>index</em> is beyond the end of the string, the string is
padded with spaces (ASCII 32) to length <em>index</em> and then <em>s</em>
is appended.
<p> <pre>
    QCString s = "I like fish";
    s.<a href="#insert">insert</a>( 2, "don't ");     // s == "I don't like fish"

    s = "x";                    // index 01234
    s.<a href="#insert">insert</a>( 3, "yz" );        // s == "x  yz"
    </pre>
 

<h3 class=fn>bool <a name="isEmpty"></a>QCString::isEmpty () const
</h3>

<p> Returns TRUE if the string is empty, i.e. if <a href="#length">length</a>() == 0;
otherwise returns FALSE. An empty string is not always a null
string.
<p> See example in <a href="#isNull">isNull</a>().
<p> <p>See also <a href="#isNull">isNull</a>(), <a href="#length">length</a>(), and <a href="qmemarray.html#size">size</a>().

<h3 class=fn>bool <a name="isNull"></a>QCString::isNull () const
</h3>

<p> Returns TRUE if the string is null, i.e. if <a href="qmemarray.html#data">data</a>() == 0; otherwise
returns FALSE. A null string is also an empty string.
<p> Example:
<pre>
    QCString a;         // a.<a href="qmemarray.html#data">data</a>() == 0,  a.<a href="qmemarray.html#size">size</a>() == 0, a.<a href="#length">length</a>() == 0
    QCString b == "";   // b.<a href="qmemarray.html#data">data</a>() == "", b.<a href="qmemarray.html#size">size</a>() == 1, b.<a href="#length">length</a>() == 0
    a.<a href="#isNull">isNull</a>();         // TRUE  because a.<a href="qmemarray.html#data">data</a>() == 0
    a.<a href="#isEmpty">isEmpty</a>();        // TRUE  because a.<a href="#length">length</a>() == 0
    b.<a href="#isNull">isNull</a>();         // FALSE because b.<a href="qmemarray.html#data">data</a>() == ""
    b.<a href="#isEmpty">isEmpty</a>();        // TRUE  because b.<a href="#length">length</a>() == 0
    </pre>
 
<p> <p>See also <a href="#isEmpty">isEmpty</a>(), <a href="#length">length</a>(), and <a href="qmemarray.html#size">size</a>().

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="left"></a>QCString::left ( uint&nbsp;len ) const
</h3>
Returns a substring that contains the <em>len</em> leftmost characters
of the string.
<p> The whole string is returned if <em>len</em> exceeds the length of the
string.
<p> Example:
<pre>
    QCString s = "Pineapple";
    QCString t = s.<a href="#left">left</a>( 4 );  // t == "Pine"
    </pre>
 
<p> <p>See also <a href="#right">right</a>() and <a href="#mid">mid</a>().

<p>Example: <a href="networkprotocol-example.html#x664">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="leftJustify"></a>QCString::leftJustify ( uint&nbsp;width, char&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const
</h3>
Returns a string of length <em>width</em> (plus one for the terminating
'&#92;0') that contains this string padded with the <em>fill</em> character.
<p> If the length of the string exceeds <em>width</em> and <em>truncate</em> is
FALSE (the default), then the returned string is a copy of the
string. If the length of the string exceeds <em>width</em> and <em>truncate</em> is TRUE, then the returned string is a <a href="#left">left</a>(<em>width</em>).
<p> Example:
<pre>
    QCString s("apple");
    QCString t = s.<a href="#leftJustify">leftJustify</a>(8, '.');  // t == "apple..."
    </pre>
 
<p> <p>See also <a href="#rightJustify">rightJustify</a>().

<h3 class=fn>uint <a name="length"></a>QCString::length () const
</h3>

<p> Returns the length of the string, excluding the '&#92;0'-terminator.
Equivalent to calling <tt>strlen(data())</tt>.
<p> Null strings and empty strings have zero length.
<p> <p>See also <a href="qmemarray.html#size">size</a>(), <a href="#isNull">isNull</a>(), and <a href="#isEmpty">isEmpty</a>().

<p>Example: <a href="networkprotocol-example.html#x665">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="lower"></a>QCString::lower () const
</h3>
Returns a new string that is a copy of this string converted to lower
case.
<p> Example:
<pre>
    QCString s("Credit");
    QCString t = s.<a href="#lower">lower</a>();  // t == "credit"
    </pre>
 
<p> <p>See also <a href="#upper">upper</a>() and <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="mid"></a>QCString::mid ( uint&nbsp;index, uint&nbsp;len = 0xffffffff ) const
</h3>
Returns a substring that contains at most <em>len</em> characters from
this string, starting at position <em>index</em>.
<p> Returns a null string if the string is empty or if <em>index</em> is out
of range. Returns the whole string from <em>index</em> if <em>index+len</em>
exceeds the length of the string.
<p> Example:
<pre>
    QCString s = "Two pineapples";
    QCString t = s.<a href="#mid">mid</a>( 4, 3 );     // t == "pin"
    </pre>
 
<p> <p>See also <a href="#left">left</a>() and <a href="#right">right</a>().

<p>Example: <a href="networkprotocol-example.html#x666">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a name="operator-const-char-*"></a>QCString::operator const char * () const
</h3>

<p> Returns the string data.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="operator+-eq"></a>QCString::operator+= ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
Appends string <em>str</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="operator+-eq-2"></a>QCString::operator+= ( char&nbsp;c )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Appends character <em>c</em> to the string and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="operator-eq"></a>QCString::operator= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s )
</h3>

<p> Assigns a <a href="shclass.html#shallow-copy">shallow copy</a> of <em>s</em> to this string and returns a
reference to this string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="operator-eq-2"></a>QCString::operator= ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em> to this string and returns a
reference to this string.
<p> If <em>str</em> is 0 a null string is created.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="prepend"></a>QCString::prepend ( const&nbsp;char&nbsp;*&nbsp;s )
</h3>

<p> Prepend <em>s</em> to the string. Equivalent to <a href="#insert">insert</a>(0, s).
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="remove"></a>QCString::remove ( uint&nbsp;index, uint&nbsp;len )
</h3>
Removes <em>len</em> characters from the string, starting at position <em>index</em>, and returns a reference to the string.
<p> If <em>index</em> is out of range, nothing happens. If <em>index</em> is
valid, but <em>index</em> + <em>len</em> is larger than the length of the
string, the string is truncated at position <em>index</em>.
<p> <pre>
    QCString s = "Montreal";
    s.<a href="#remove">remove</a>( 1, 4 );         // s == "Meal"
    </pre>
 
<p> <p>See also <a href="#insert">insert</a>() and <a href="#replace">replace</a>().

<p>Example: <a href="networkprotocol-example.html#x667">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="replace"></a>QCString::replace ( uint&nbsp;index, uint&nbsp;len, const&nbsp;char&nbsp;*&nbsp;str )
</h3>
Replaces <em>len</em> characters from the string, starting at position
<em>index</em>, with <em>str</em>, and returns a reference to the string.
<p> If <em>index</em> is out of range, nothing is removed and <em>str</em> is
appended at the end of the string. If <em>index</em> is valid, but <em>index</em> + <em>len</em> is larger than the length of the string, <em>str</em>
replaces the rest of the string from position <em>index</em>.
<p> <pre>
    QCString s = "Say yes!";
    s.<a href="#replace">replace</a>( 4, 3, "NO" );  // s == "Say NO!"
    </pre>
 
<p> <p>See also <a href="#insert">insert</a>() and <a href="#remove">remove</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="replace-2"></a>QCString::replace ( const&nbsp;<a href="qregexp.html">QRegExp</a>&nbsp;&amp;&nbsp;rx, const&nbsp;char&nbsp;*&nbsp;str )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of <em>rx</em> in the string with <em>str</em>.
Returns a reference to the string.
<p> Example:
<pre>
    <a href="qstring.html">QString</a> s = "banana";
    s.<a href="qstring.html#replace">replace</a>( QRegExp("a.*a"), "" );     // becomes "b"

    s = "banana";
    s.<a href="qstring.html#replace">replace</a>( QRegExp("^[bn]a"), "X" );  // becomes "Xnana"

    s = "banana";
    s.<a href="qstring.html#replace">replace</a>( QRegExp("^[bn]a"), "" );   // becomes "nana"
    </pre>
 
<p> <b>Warning:</b> If you want to apply this function repeatedly to the same
string it is more efficient to convert the string to a <a href="qstring.html">QString</a> and
apply the function to that.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="replace-3"></a>QCString::replace ( char&nbsp;c, const&nbsp;char&nbsp;*&nbsp;after )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of the character <em>c</em> in the string
with <em>after</em>. Returns a reference to the string.
<p> Example:
<pre>
    QCString s = "a,b,c";
    s.<a href="#replace">replace</a>( ',', " or " );
    // s == "a or b or c"
    </pre>
 

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="replace-4"></a>QCString::replace ( const&nbsp;char&nbsp;*&nbsp;before, const&nbsp;char&nbsp;*&nbsp;after )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of the string <em>before</em> in the string
with the string <em>after</em>. Returns a reference to the string.
<p> Example:
<pre>
    QCString s = "Greek is Greek";
    s.<a href="#replace">replace</a>( "Greek", "English" );
    // s == "English is English"
    </pre>
 

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="replace-5"></a>QCString::replace ( char&nbsp;c1, char&nbsp;c2 )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Replaces every occurrence of <em>c1</em> with the char <em>c2</em>.
Returns a reference to the string.

<h3 class=fn>bool <a name="resize"></a>QCString::resize ( uint&nbsp;len )
</h3>
Extends or shrinks the string to <em>len</em> bytes, including the
'&#92;0'-terminator.
<p> A '&#92;0'-terminator is set at position <tt>len - 1</tt> unless
<tt>len == 0</tt>.
<p> Example:
<pre>
    QCString s = "resize this string";
    s.<a href="#resize">resize</a>( 7 );                      // s == "resize"
    </pre>
 
<p> <p>See also <a href="#truncate">truncate</a>().

<p>Example: <a href="networkprotocol-example.html#x668">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="right"></a>QCString::right ( uint&nbsp;len ) const
</h3>
Returns a substring that contains the <em>len</em> rightmost characters
of the string.
<p> The whole string is returned if <em>len</em> exceeds the length of the
string.
<p> Example:
<pre>
    QCString s = "Pineapple";
    QCString t = s.<a href="#right">right</a>( 5 );  // t == "apple"
    </pre>
 
<p> <p>See also <a href="#left">left</a>() and <a href="#mid">mid</a>().

<p>Example: <a href="networkprotocol-example.html#x669">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="rightJustify"></a>QCString::rightJustify ( uint&nbsp;width, char&nbsp;fill = ' ', bool&nbsp;truncate = FALSE ) const
</h3>
Returns a string of length <em>width</em> (plus one for the terminating
'&#92;0') that contains zero or more of the <em>fill</em> character followed
by this string.
<p> If the length of the string exceeds <em>width</em> and <em>truncate</em> is
FALSE (the default), then the returned string is a copy of the
string. If the length of the string exceeds <em>width</em> and <em>truncate</em> is TRUE, then the returned string is a <a href="#left">left</a>(<em>width</em>).
<p> Example:
<pre>
    QCString s("pie");
    QCString t = s.<a href="#rightJustify">rightJustify</a>(8, '.');  // t == ".....pie"
    </pre>
 
<p> <p>See also <a href="#leftJustify">leftJustify</a>().

<h3 class=fn>bool <a name="setExpand"></a>QCString::setExpand ( uint&nbsp;index, char&nbsp;c )
</h3>
Sets the character at position <em>index</em> to <em>c</em> and expands the
string if necessary, padding with spaces.
<p> Returns FALSE if <em>index</em> was out of range and the string could
not be expanded; otherwise returns TRUE.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum"></a>QCString::setNum ( double&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )
</h3>
Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.
<p> The format of the string representation is specified by the format
character <em>f</em>, and the precision (number of digits after the
decimal point) is specified with <em>prec</em>.
<p> The valid formats for <em>f</em> are 'e', 'E', 'f', 'g' and 'G'. The
formats are the same as for <a href="#sprintf">sprintf</a>(); they are explained in <a href="qstring.html#arg">QString::arg</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-2"></a>QCString::setNum ( short&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-3"></a>QCString::setNum ( ushort&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-4"></a>QCString::setNum ( int&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-5"></a>QCString::setNum ( uint&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-6"></a>QCString::setNum ( long&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-7"></a>QCString::setNum ( ulong&nbsp;n )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the string to the string representation of the number <em>n</em>
and returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setNum-8"></a>QCString::setNum ( float&nbsp;n, char&nbsp;f = 'g', int&nbsp;prec = 6 )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="setStr"></a>QCString::setStr ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>
Makes a <a href="shclass.html#deep-copy">deep copy</a> of <em>str</em>. Returns a reference to the string.

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="simplifyWhiteSpace"></a>QCString::simplifyWhiteSpace () const
</h3>
Returns a new string that has white space removed from the start
and the end, plus any sequence of internal white space replaced
with a single space (ASCII 32).
<p> White space means the decimal ASCII codes 9, 10, 11, 12, 13 and
32.
<p> <pre>
    QCString s = "  lots\t of\nwhite    space ";
    QCString t = s.<a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>(); // t == "lots of white space"
    </pre>
 
<p> <p>See also <a href="#stripWhiteSpace">stripWhiteSpace</a>().

<h3 class=fn><a href="qcstring.html">QCString</a>&nbsp;&amp; <a name="sprintf"></a>QCString::sprintf ( const&nbsp;char&nbsp;*&nbsp;format, ... )
</h3>
Implemented as a call to the native vsprintf() (see the manual for
your C library).
<p> If the string is shorter than 256 characters, this <a href="#sprintf">sprintf</a>() calls
<a href="#resize">resize</a>(256) to decrease the chance of memory corruption. The
string is resized back to its actual length before sprintf()
returns.
<p> Example:
<pre>
    QCString s;
    s.<a href="#sprintf">sprintf</a>( "%d - %s", 1, "first" );         // result &lt; 256 chars

    QCString big( 25000 );                      // very long string
    big.<a href="#sprintf">sprintf</a>( "%d - %s", 2, longString );    // result &lt; 25000 chars
    </pre>
 
<p> <b>Warning:</b> All vsprintf() implementations will write past the end of
the target string (*this) if the <em>format</em> specification and
arguments happen to be longer than the target string, and some
will also fail if the target string is longer than some arbitrary
implementation limit.
<p> Giving user-supplied arguments to sprintf() is risky: Sooner or
later someone will paste a huge line into your application.

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="stripWhiteSpace"></a>QCString::stripWhiteSpace () const
</h3>
Returns a new string that has white space removed from the start
and the end.
<p> White space means the decimal ASCII codes 9, 10, 11, 12, 13 and
32.
<p> Example:
<pre>
    QCString s = " space ";
    QCString t = s.<a href="#stripWhiteSpace">stripWhiteSpace</a>();           // t == "space"
    </pre>
 
<p> <p>See also <a href="#simplifyWhiteSpace">simplifyWhiteSpace</a>().

<h3 class=fn>double <a name="toDouble"></a>QCString::toDouble ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>double</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>float <a name="toFloat"></a>QCString::toFloat ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>float</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>int <a name="toInt"></a>QCString::toInt ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>int</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>long <a name="toLong"></a>QCString::toLong ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>long</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>short <a name="toShort"></a>QCString::toShort ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to a <tt>short</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, is out of range, or if it has trailing garbage; otherwise
<em>*ok</em> is set to TRUE.

<h3 class=fn>uint <a name="toUInt"></a>QCString::toUInt ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to an <tt>unsigned int</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>ulong <a name="toULong"></a>QCString::toULong ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to an <tt>unsigned long</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, or if it has trailing garbage; otherwise <em>*ok</em> is set to
TRUE.

<h3 class=fn>ushort <a name="toUShort"></a>QCString::toUShort ( bool&nbsp;*&nbsp;ok = 0 ) const
</h3>
Returns the string converted to an <tt>unsigned short</tt> value.
<p> If <em>ok</em> is not 0: <em>*ok</em> is set to FALSE if the string is not a
number, is out of range, or if it has trailing garbage; otherwise
<em>*ok</em> is set to TRUE.

<h3 class=fn>bool <a name="truncate"></a>QCString::truncate ( uint&nbsp;pos )
</h3>

<p> Truncates the string at position <em>pos</em>.
<p> Equivalent to calling <tt>resize(pos+1)</tt>.
<p> Example:
<pre>
    QCString s = "truncate this string";
    s.<a href="#truncate">truncate</a>( 5 );                      // s == "trunc"
    </pre>
 
<p> <p>See also <a href="#resize">resize</a>().

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="upper"></a>QCString::upper () const
</h3>
Returns a new string that is a copy of this string converted to upper case.
<p> Example:
<pre>
    QCString s( "Debit" );
    QCString t = s.<a href="#upper">upper</a>();  // t == "DEBIT"
    </pre>
 
<p> <p>See also <a href="#lower">lower</a>() and <a href="#asciinotion">Note on character comparisons</a>.

<hr><h2>Related Functions</h2>
<h3 class=fn>bool <a name="operator!-eq"></a>operator!= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are different; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) != 0.

<h3 class=fn>bool <a name="operator!-eq-2"></a>operator!= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are different; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) != 0.

<h3 class=fn>bool <a name="operator!-eq-3"></a>operator!= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are different; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) != 0.

<h3 class=fn>const&nbsp;<a href="qcstring.html">QCString</a> <a name="operator+"></a>operator+ ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns a string which consists of the concatenation of <em>s1</em> and
<em>s2</em>.

<h3 class=fn>const&nbsp;<a href="qcstring.html">QCString</a> <a name="operator+-2"></a>operator+ ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which consists of the concatenation of <em>s1</em> and <em>s2</em>.

<h3 class=fn>const&nbsp;<a href="qcstring.html">QCString</a> <a name="operator+-3"></a>operator+ ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which consists of the concatenation of <em>s1</em> and <em>s2</em>.

<h3 class=fn>const&nbsp;<a href="qcstring.html">QCString</a> <a name="operator+-4"></a>operator+ ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s, char&nbsp;c )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which consists of the concatenation of <em>s</em> and <em>c</em>.

<h3 class=fn>const&nbsp;<a href="qcstring.html">QCString</a> <a name="operator+-5"></a>operator+ ( char&nbsp;c, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns a string which consists of the concatenation of <em>c</em> and <em>s</em>.

<h3 class=fn>bool <a name="operator-lt"></a>operator&lt; ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is less than <em>s2</em>; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &lt; 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-lt-2"></a>operator&lt; ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is less than <em>s2</em>; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &lt; 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt"></a>operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;str )
</h3>

<p> Writes string <em>str</em> to the stream <em>s</em>.
<p> <p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<h3 class=fn>bool <a name="operator-lt-eq"></a>operator&lt;= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is less than or equal to <em>s2</em>; otherwise
returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &lt;= 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-lt-eq-2"></a>operator&lt;= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is less than or equal to <em>s2</em>; otherwise
returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &lt;= 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-eq-eq"></a>operator== ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are equal; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) == 0.

<h3 class=fn>bool <a name="operator-eq-eq-2"></a>operator== ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are equal; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) == 0.

<h3 class=fn>bool <a name="operator-eq-eq-3"></a>operator== ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> and <em>s2</em> are equal; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) == 0.

<h3 class=fn>bool <a name="operator-gt"></a>operator&gt; ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is greater than <em>s2</em>; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &gt; 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-gt-2"></a>operator&gt; ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is greater than <em>s2</em>; otherwise returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &gt; 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-gt-eq"></a>operator&gt;= ( const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s1, const&nbsp;char&nbsp;*&nbsp;s2 )
</h3>

<p> 
<p> Returns TRUE if <em>s1</em> is greater than or equal to <em>s2</em>; otherwise
returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &gt;= 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>bool <a name="operator-gt-eq-2"></a>operator&gt;= ( const&nbsp;char&nbsp;*&nbsp;s1, const&nbsp;<a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;s2 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<p> Returns TRUE if <em>s1</em> is greater than or equal to <em>s2</em>; otherwise
returns FALSE.
<p> Equivalent to <a href="#qstrcmp">qstrcmp</a>(<em>s1</em>, <em>s2</em>) &gt;= 0.
<p> <p>See also <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qcstring.html">QCString</a>&nbsp;&amp;&nbsp;str )
</h3>

<p> Reads a string into <em>str</em> from the stream <em>s</em>.
<p> <p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<h3 class=fn>void * <a name="qmemmove"></a>qmemmove ( void&nbsp;*&nbsp;dst, const&nbsp;void&nbsp;*&nbsp;src, uint&nbsp;len )
</h3>

<p> This function is normally part of the C library. Qt implements
memmove() for platforms that do not provide it.
<p> memmove() copies <em>len</em> bytes from <em>src</em> into <em>dst</em>. The data
is copied correctly even if <em>src</em> and <em>dst</em> overlap.

<h3 class=fn>int <a name="qstrcmp"></a>qstrcmp ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2 )
</h3>

<p> 
<p> A safe strcmp() function.
<p> Compares <em>str1</em> and <em>str2</em>. Returns a negative value if <em>str1</em>
is less than <em>str2</em>, 0 if <em>str1</em> is equal to <em>str2</em> or a
positive value if <em>str1</em> is greater than <em>str2</em>.
<p> Special case I: Returns 0 if <em>str1</em> and <em>str2</em> are both 0.
<p> Special case II: Returns a random nonzero value if <em>str1</em> is 0
or <em>str2</em> is 0 (but not both).
<p> <p>See also <a href="#qstrncmp">qstrncmp</a>(), <a href="#qstricmp">qstricmp</a>(), <a href="#qstrnicmp">qstrnicmp</a>(), and <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>char * <a name="qstrcpy"></a>qstrcpy ( char&nbsp;*&nbsp;dst, const&nbsp;char&nbsp;*&nbsp;src )
</h3>

<p> 
<p> A safe strcpy() function.
<p> Copies all characters up to and including the '&#92;0' from <em>src</em>
into <em>dst</em> and returns a pointer to <em>dst</em>.

<h3 class=fn>char * <a name="qstrdup"></a>qstrdup ( const&nbsp;char&nbsp;*&nbsp;src )
</h3>

<p> Returns a duplicate string.
<p> Allocates space for a copy of <em>src</em>, copies it, and returns a
pointer to the copy. If <em>src</em> is 0, it immediately returns 0.
<p> The returned string must be deleted using <tt>delete[]</tt>.

<h3 class=fn>int <a name="qstricmp"></a>qstricmp ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2 )
</h3>

<p> A safe stricmp() function.
<p> Compares <em>str1</em> and <em>str2</em> ignoring the case.
<p> Returns a negative value if <em>str1</em> is less than <em>str2</em>, 0 if <em>str1</em> is equal to <em>str2</em> or a positive value if <em>str1</em> is greater
than <em>str2</em>.
<p> Special case I: Returns 0 if <em>str1</em> and <em>str2</em> are both 0.
<p> Special case II: Returns a random nonzero value if <em>str1</em> is 0
or <em>str2</em> is 0 (but not both).
<p> <p>See also <a href="#qstrcmp">qstrcmp</a>(), <a href="#qstrncmp">qstrncmp</a>(), <a href="#qstrnicmp">qstrnicmp</a>(), and <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>uint <a name="qstrlen"></a>qstrlen ( const&nbsp;char&nbsp;*&nbsp;str )
</h3>

<p> 
<p> A safe strlen function.
<p> Returns the number of characters that precede the terminating '&#92;0'.
or 0 if <em>str</em> is 0.

<h3 class=fn>int <a name="qstrncmp"></a>qstrncmp ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2, uint&nbsp;len )
</h3>

<p> 
<p> A safe strncmp() function.
<p> Compares at most <em>len</em> bytes of <em>str1</em> and <em>str2</em>.
<p> Returns a negative value if <em>str1</em> is less than <em>str2</em>, 0 if <em>str1</em> is equal to <em>str2</em> or a positive value if <em>str1</em> is greater
than <em>str2</em>.
<p> Special case I: Returns 0 if <em>str1</em> and <em>str2</em> are both 0.
<p> Special case II: Returns a random nonzero value if <em>str1</em> is 0
or <em>str2</em> is 0 (but not both).
<p> <p>See also <a href="#qstrcmp">qstrcmp</a>(), <a href="#qstricmp">qstricmp</a>(), <a href="#qstrnicmp">qstrnicmp</a>(), and <a href="#asciinotion">Note on character comparisons</a>.

<h3 class=fn>char * <a name="qstrncpy"></a>qstrncpy ( char&nbsp;*&nbsp;dst, const&nbsp;char&nbsp;*&nbsp;src, uint&nbsp;len )
</h3>

<p> A safe strncpy() function.
<p> Copies at most <em>len</em> bytes from <em>src</em> (stopping at <em>len</em> or the
terminating '&#92;0' whichever comes first) into <em>dst</em> and returns a
pointer to <em>dst</em>. Guarantees that <em>dst</em> is '&#92;0'-terminated. If
<em>src</em> or <em>dst</em> is 0, returns 0 immediately.
<p> <p>See also <a href="#qstrcpy">qstrcpy</a>().

<h3 class=fn>int <a name="qstrnicmp"></a>qstrnicmp ( const&nbsp;char&nbsp;*&nbsp;str1, const&nbsp;char&nbsp;*&nbsp;str2, uint&nbsp;len )
</h3>

<p> A safe strnicmp() function.
<p> Compares at most <em>len</em> bytes of <em>str1</em> and <em>str2</em> ignoring the case.
<p> Returns a negative value if <em>str1</em> is less than <em>str2</em>, 0 if <em>str1</em>
is equal to <em>str2</em> or a positive value if <em>str1</em> is greater than <em>str2</em>.
<p> Special case I: Returns 0 if <em>str1</em> and <em>str2</em> are both 0.
<p> Special case II: Returns a random nonzero value if <em>str1</em> is 0
or <em>str2</em> is 0 (but not both).
<p> <p>See also <a href="#qstrcmp">qstrcmp</a>(), <a href="#qstrncmp">qstrncmp</a>(), <a href="#qstricmp">qstricmp</a>(), and <a href="#asciinotion">Note on character comparisons</a>.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
