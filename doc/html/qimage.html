<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qimage.cpp:69 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QImage Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QImage Class Reference</h1>

<p>The QImage class provides a hardware-independent pixmap
representation with direct access to the pixel data.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qimage-h.html">qimage.h</a>&gt;</tt>
<p><a href="qimage-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>enum <a href="#Endian-enum"><b>Endian</b></a> { IgnoreEndian, BigEndian, LittleEndian }</li>
<li class=fn><a href="#QImage"><b>QImage</b></a> ()</li>
<li class=fn><a href="#QImage-2"><b>QImage</b></a> ( int&nbsp;w, int&nbsp;h, int&nbsp;depth, int&nbsp;numColors = 0, Endian&nbsp;bitOrder = IgnoreEndian )</li>
<li class=fn><a href="#QImage-3"><b>QImage</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;size, int&nbsp;depth, int&nbsp;numColors = 0, Endian&nbsp;bitOrder = IgnoreEndian )</li>
<li class=fn><a href="#QImage-4"><b>QImage</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format = 0 )</li>
<li class=fn><a href="#QImage-5"><b>QImage</b></a> ( const&nbsp;char&nbsp;*&nbsp;const&nbsp;xpm[] )</li>
<li class=fn><a href="#QImage-6"><b>QImage</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;array )</li>
<li class=fn><a href="#QImage-7"><b>QImage</b></a> ( uchar&nbsp;*&nbsp;yourdata, int&nbsp;w, int&nbsp;h, int&nbsp;depth, QRgb&nbsp;*&nbsp;colortable, int&nbsp;numColors, Endian&nbsp;bitOrder )</li>
<li class=fn><a href="#QImage-8"><b>QImage</b></a> ( uchar&nbsp;*&nbsp;yourdata, int&nbsp;w, int&nbsp;h, int&nbsp;depth, int&nbsp;bpl, QRgb&nbsp;*&nbsp;colortable, int&nbsp;numColors, Endian&nbsp;bitOrder )</li>
<li class=fn><a href="#QImage-9"><b>QImage</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;image )</li>
<li class=fn><a href="#~QImage"><b>~QImage</b></a> ()</li>
<li class=fn>QImage &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;image )</li>
<li class=fn>QImage &amp; <a href="#operator-eq-2"><b>operator=</b></a> ( const&nbsp;QPixmap&nbsp;&amp;&nbsp;pixmap )</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;i ) const</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;i ) const</li>
<li class=fn>void <a href="#detach"><b>detach</b></a> ()</li>
<li class=fn>QImage <a href="#copy"><b>copy</b></a> () const</li>
<li class=fn>QImage <a href="#copy-2"><b>copy</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, int&nbsp;conversion_flags = 0 ) const</li>
<li class=fn>QImage <a href="#copy-3"><b>copy</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r ) const</li>
<li class=fn>bool <a href="#isNull"><b>isNull</b></a> () const</li>
<li class=fn>int <a href="#width"><b>width</b></a> () const</li>
<li class=fn>int <a href="#height"><b>height</b></a> () const</li>
<li class=fn>QSize <a href="#size"><b>size</b></a> () const</li>
<li class=fn>QRect <a href="#rect"><b>rect</b></a> () const</li>
<li class=fn>int <a href="#depth"><b>depth</b></a> () const</li>
<li class=fn>int <a href="#numColors"><b>numColors</b></a> () const</li>
<li class=fn>Endian <a href="#bitOrder"><b>bitOrder</b></a> () const</li>
<li class=fn>QRgb <a href="#color"><b>color</b></a> ( int&nbsp;i ) const</li>
<li class=fn>void <a href="#setColor"><b>setColor</b></a> ( int&nbsp;i, QRgb&nbsp;c )</li>
<li class=fn>void <a href="#setNumColors"><b>setNumColors</b></a> ( int&nbsp;numColors )</li>
<li class=fn>bool <a href="#hasAlphaBuffer"><b>hasAlphaBuffer</b></a> () const</li>
<li class=fn>void <a href="#setAlphaBuffer"><b>setAlphaBuffer</b></a> ( bool&nbsp;enable )</li>
<li class=fn>bool <a href="#allGray"><b>allGray</b></a> () const</li>
<li class=fn>bool <a href="#isGrayscale"><b>isGrayscale</b></a> () const</li>
<li class=fn>uchar * <a href="#bits"><b>bits</b></a> () const</li>
<li class=fn>uchar * <a href="#scanLine"><b>scanLine</b></a> ( int&nbsp;i ) const</li>
<li class=fn>uchar ** <a href="#jumpTable"><b>jumpTable</b></a> () const</li>
<li class=fn>QRgb * <a href="#colorTable"><b>colorTable</b></a> () const</li>
<li class=fn>int <a href="#numBytes"><b>numBytes</b></a> () const</li>
<li class=fn>int <a href="#bytesPerLine"><b>bytesPerLine</b></a> () const</li>
<li class=fn>bool <a href="#create"><b>create</b></a> ( int&nbsp;width, int&nbsp;height, int&nbsp;depth, int&nbsp;numColors = 0, Endian&nbsp;bitOrder = IgnoreEndian )</li>
<li class=fn>bool <a href="#create-2"><b>create</b></a> ( const QSize &amp;, int&nbsp;depth, int&nbsp;numColors = 0, Endian&nbsp;bitOrder = IgnoreEndian )</li>
<li class=fn>void <a href="#reset"><b>reset</b></a> ()</li>
<li class=fn>void <a href="#fill"><b>fill</b></a> ( uint&nbsp;pixel )</li>
<li class=fn>void <a href="#invertPixels"><b>invertPixels</b></a> ( bool&nbsp;invertAlpha = TRUE )</li>
<li class=fn>QImage <a href="#convertDepth-2"><b>convertDepth</b></a> ( int&nbsp;depth ) const</li>
<li class=fn>QImage <a href="#convertDepthWithPalette"><b>convertDepthWithPalette</b></a> ( int&nbsp;d, QRgb&nbsp;*&nbsp;palette, int&nbsp;palette_count, int&nbsp;conversion_flags = 0 ) const</li>
<li class=fn>QImage <a href="#convertDepth"><b>convertDepth</b></a> ( int&nbsp;depth, int&nbsp;conversion_flags ) const</li>
<li class=fn>QImage <a href="#convertBitOrder"><b>convertBitOrder</b></a> ( Endian&nbsp;bitOrder ) const</li>
<li class=fn>enum <a href="#ScaleMode-enum"><b>ScaleMode</b></a> { ScaleFree, ScaleMin, ScaleMax }</li>
<li class=fn>QImage <a href="#smoothScale"><b>smoothScale</b></a> ( int&nbsp;w, int&nbsp;h, ScaleMode&nbsp;mode = ScaleFree ) const</li>
<li class=fn>QImage <a href="#smoothScale-2"><b>smoothScale</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;s, ScaleMode&nbsp;mode = ScaleFree ) const</li>
<li class=fn>QImage <a href="#scale"><b>scale</b></a> ( int&nbsp;w, int&nbsp;h, ScaleMode&nbsp;mode = ScaleFree ) const</li>
<li class=fn>QImage <a href="#scale-2"><b>scale</b></a> ( const&nbsp;QSize&nbsp;&amp;&nbsp;s, ScaleMode&nbsp;mode = ScaleFree ) const</li>
<li class=fn>QImage <a href="#scaleWidth"><b>scaleWidth</b></a> ( int&nbsp;w ) const</li>
<li class=fn>QImage <a href="#scaleHeight"><b>scaleHeight</b></a> ( int&nbsp;h ) const</li>
<li class=fn>QImage <a href="#xForm"><b>xForm</b></a> ( const&nbsp;QWMatrix&nbsp;&amp;&nbsp;matrix ) const</li>
<li class=fn>QImage <a href="#createAlphaMask"><b>createAlphaMask</b></a> ( int&nbsp;conversion_flags = 0 ) const</li>
<li class=fn>QImage <a href="#createHeuristicMask"><b>createHeuristicMask</b></a> ( bool&nbsp;clipTight = TRUE ) const</li>
<li class=fn>QImage <a href="#mirror"><b>mirror</b></a> () const</li>
<li class=fn>QImage <a href="#mirror-2"><b>mirror</b></a> ( bool&nbsp;horizontal, bool&nbsp;vertical ) const</li>
<li class=fn>QImage <a href="#swapRGB"><b>swapRGB</b></a> () const</li>
<li class=fn>bool <a href="#load"><b>load</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format = 0 )</li>
<li class=fn>bool <a href="#loadFromData"><b>loadFromData</b></a> ( const&nbsp;uchar&nbsp;*&nbsp;buf, uint&nbsp;len, const&nbsp;char&nbsp;*&nbsp;format = 0 )</li>
<li class=fn>bool <a href="#loadFromData-2"><b>loadFromData</b></a> ( QByteArray&nbsp;buf, const&nbsp;char&nbsp;*&nbsp;format = 0 )</li>
<li class=fn>bool <a href="#save"><b>save</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format, int&nbsp;quality = -1 ) const</li>
<li class=fn>bool <a href="#save-2"><b>save</b></a> ( QIODevice&nbsp;*&nbsp;device, const&nbsp;char&nbsp;*&nbsp;format, int&nbsp;quality = -1 ) const</li>
<li class=fn>bool <a href="#valid"><b>valid</b></a> ( int&nbsp;x, int&nbsp;y ) const</li>
<li class=fn>int <a href="#pixelIndex"><b>pixelIndex</b></a> ( int&nbsp;x, int&nbsp;y ) const</li>
<li class=fn>QRgb <a href="#pixel"><b>pixel</b></a> ( int&nbsp;x, int&nbsp;y ) const</li>
<li class=fn>void <a href="#setPixel"><b>setPixel</b></a> ( int&nbsp;x, int&nbsp;y, uint&nbsp;index_or_rgb )</li>
<li class=fn>int <a href="#dotsPerMeterX"><b>dotsPerMeterX</b></a> () const</li>
<li class=fn>int <a href="#dotsPerMeterY"><b>dotsPerMeterY</b></a> () const</li>
<li class=fn>void <a href="#setDotsPerMeterX"><b>setDotsPerMeterX</b></a> ( int&nbsp;x )</li>
<li class=fn>void <a href="#setDotsPerMeterY"><b>setDotsPerMeterY</b></a> ( int&nbsp;y )</li>
<li class=fn>QPoint <a href="#offset"><b>offset</b></a> () const</li>
<li class=fn>void <a href="#setOffset"><b>setOffset</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;p )</li>
<li class=fn>QValueList&lt;QImageTextKeyLang&gt; <a href="#textList"><b>textList</b></a> () const</li>
<li class=fn>QStringList <a href="#textLanguages"><b>textLanguages</b></a> () const</li>
<li class=fn>QStringList <a href="#textKeys"><b>textKeys</b></a> () const</li>
<li class=fn>QString <a href="#text"><b>text</b></a> ( const&nbsp;char&nbsp;*&nbsp;key, const&nbsp;char&nbsp;*&nbsp;lang = 0 ) const</li>
<li class=fn>QString <a href="#text-2"><b>text</b></a> ( const&nbsp;QImageTextKeyLang&nbsp;&amp;&nbsp;kl ) const</li>
<li class=fn>void <a href="#setText"><b>setText</b></a> ( const&nbsp;char&nbsp;*&nbsp;key, const&nbsp;char&nbsp;*&nbsp;lang, const&nbsp;QString&nbsp;&amp;&nbsp;s )</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QImage <a href="#fromMimeSource"><b>fromMimeSource</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;abs_name )</li>
<li class=fn>Endian <a href="#systemBitOrder"><b>systemBitOrder</b></a> ()</li>
<li class=fn>Endian <a href="#systemByteOrder"><b>systemByteOrder</b></a> ()</li>
<li class=fn>const char * <a href="#imageFormat"><b>imageFormat</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;fileName )</li>
<li class=fn>QStrList <a href="#inputFormats"><b>inputFormats</b></a> ()</li>
<li class=fn>QStrList <a href="#outputFormats"><b>outputFormats</b></a> ()</li>
<li class=fn>QStringList <a href="#inputFormatList"><b>inputFormatList</b></a> ()</li>
<li class=fn>QStringList <a href="#outputFormatList"><b>outputFormatList</b></a> ()</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, const&nbsp;QImage&nbsp;&amp;&nbsp;image )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QImage&nbsp;&amp;&nbsp;image )</li>
<li class=fn>void <a href="#bitBlt"><b>bitBlt</b></a> ( QImage&nbsp;*&nbsp;dst, int&nbsp;dx, int&nbsp;dy, const&nbsp;QImage&nbsp;*&nbsp;src, int&nbsp;sx, int&nbsp;sy, int&nbsp;sw, int&nbsp;sh, int&nbsp;conversion_flags )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QImage class provides a hardware-independent pixmap
representation with direct access to the pixel data.
<p> 



<p> It is one of the two classes Qt provides for dealing with images,
the other being <a href="qpixmap.html">QPixmap</a>. QImage is designed and optimized for I/O
and for direct pixel access/manipulation. QPixmap is designed and
optimized for drawing. There are (slow) functions to convert
between QImage and QPixmap: <a href="qpixmap.html#convertToImage">QPixmap::convertToImage</a>() and
<a href="qpixmap.html#convertFromImage">QPixmap::convertFromImage</a>().
<p> An image has the parameters <a href="#width">width</a>, <a href="#height">height</a> and <a href="#depth">depth</a> (bits per
pixel, bpp), a color table and the actual <a href="#bits">pixels</a>. QImage supports 1-bpp, 8-bpp and 32-bpp image
data. 1-bpp and 8-bpp images use a color lookup table; the pixel
value is a color table index.
<p> 32-bpp images encode an RGB value in 24 bits and ignore the color
table. The most significant byte is used for the <a href="#setAlphaBuffer">alpha buffer</a>.
<p> An entry in the color table is an RGB triplet encoded as a <tt>uint</tt>. Use the <a href="qcolor.html#qRed">qRed()</a>, <a href="qcolor.html#qGreen">qGreen()</a> and <a href="qcolor.html#qBlue">qBlue()</a> functions (<a href="qcolor-h.html">qcolor.h</a>) to access the components, and <a href="qcolor.html#qRgb">qRgb</a> to make an RGB triplet (see the <a href="qcolor.html">QColor</a> class
documentation).
<p> 1-bpp (monochrome) images have a color table with a most two
colors. There are two different formats: big endian (MSB first) or
little endian (LSB first) bit order. To access a single bit you
will must do some bit shifts:
<p> <pre>
    QImage image;
    // sets bit at (x,y) to 1
    if ( image.<a href="#bitOrder">bitOrder</a>() == QImage::<a href="#Endian-enum">LittleEndian</a> )
        *(image.<a href="#scanLine">scanLine</a>(y) + (x &gt;&gt; 3)) |= 1 &lt;&lt; (x &amp; 7);
    else
        *(image.<a href="#scanLine">scanLine</a>(y) + (x &gt;&gt; 3)) |= 1 &lt;&lt; (7 - (x &amp; 7));
    </pre>
 
<p> If this looks complicated, it might be a good idea to convert the
1-bpp image to an 8-bpp image using <a href="#convertDepth">convertDepth</a>().
<p> 8-bpp images are much easier to work with than 1-bpp images
because they have a single byte per pixel:
<p> <pre>
    QImage image;
    // set entry 19 in the color table to yellow
    image.<a href="#setColor">setColor</a>( 19, qRgb(255,255,0) );
    // set 8 bit pixel at (x,y) to value yellow (in color table)
    *(image.<a href="#scanLine">scanLine</a>(y) + x) = 19;
    </pre>
 
<p> 32-bpp images ignore the color table; instead, each pixel contains
the RGB triplet. 24 bits contain the RGB value; the most
significant byte is reserved for the alpha buffer.
<p> <pre>
    QImage image;
    // sets 32 bit pixel at (x,y) to yellow.
    uint *p = (uint *)image.<a href="#scanLine">scanLine</a>(y) + x;
    *p = <a href="qcolor.html#qRgb">qRgb</a>(255,255,0);
    </pre>
 
<p> On Qt/Embedded, scanlines are aligned to the pixel depth and may
be padded to any degree, while on all other platforms, the
scanlines are 32-bit aligned for all depths. The constructor
taking a <tt>uchar*</tt> argument always expects 32-bit aligned data.
On Qt/Embedded, an additional constructor allows the number of
bytes-per-line to be specified.
<p> QImage supports a variety of methods for getting information about
the image, for example, <a href="#colorTable">colorTable</a>(), <a href="#allGray">allGray</a>(), <a href="#isGrayscale">isGrayscale</a>(),
<a href="#bitOrder">bitOrder</a>(), <a href="#bytesPerLine">bytesPerLine</a>(), <a href="#depth">depth</a>(), <a href="#dotsPerMeterX">dotsPerMeterX</a>() and
<a href="#dotsPerMeterY">dotsPerMeterY</a>(), <a href="#hasAlphaBuffer">hasAlphaBuffer</a>(), <a href="#numBytes">numBytes</a>(), <a href="#numColors">numColors</a>(), and
<a href="#width">width</a>() and <a href="#height">height</a>().
<p> Pixel colors are retrieved with <a href="#pixel">pixel</a>() and set with <a href="#setPixel">setPixel</a>().
<p> QImage also supports a number of functions for creating a new
image that is a transformed version of the original. For example,
<a href="#copy">copy</a>(), <a href="#convertBitOrder">convertBitOrder</a>(), <a href="#convertDepth">convertDepth</a>(), <a href="#createAlphaMask">createAlphaMask</a>(),
<a href="#createHeuristicMask">createHeuristicMask</a>(), <a href="#mirror">mirror</a>(), <a href="#scale">scale</a>(), <a href="#smoothScale">smoothScale</a>(), <a href="#swapRGB">swapRGB</a>()
and <a href="#xForm">xForm</a>(). There are also functions for changing attributes of
an image in-place, for example, <a href="#setAlphaBuffer">setAlphaBuffer</a>(), <a href="#setColor">setColor</a>(),
<a href="#setDotsPerMeterX">setDotsPerMeterX</a>() and <a href="#setDotsPerMeterY">setDotsPerMeterY</a>() and <a href="#setNumColors">setNumColors</a>().
<p> Images can be loaded and saved in the supported formats. Images
are saved to a file with <a href="#save">save</a>(). Images are loaded from a file
with <a href="#load">load</a>() (or in the constructor) or from an array of data with
<a href="#loadFromData">loadFromData</a>(). The lists of supported formats are available from
<a href="#inputFormatList">inputFormatList</a>() and <a href="#outputFormatList">outputFormatList</a>().
<p> Strings of text may be added to images using <a href="#setText">setText</a>().
<p> The QImage class uses explicit <a href="shclass.html">sharing</a>,
similar to that used by <a href="qmemarray.html">QMemArray</a>.
<p> New image formats can be added as <a href="plugins-howto.html">plugins</a>.
<p> <p>See also <a href="qimageio.html">QImageIO</a>, <a href="qpixmap.html">QPixmap</a>, <a href="shclass.html">Shared Classes</a>, <a href="graphics.html">Graphics Classes</a>, <a href="images.html">Image Processing Classes</a>, and <a href="shared.html">Implicitly and Explicitly Shared Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Endian-enum"></a>QImage::Endian</h3>

<p> This enum type is used to describe the endianness of the CPU and
graphics hardware.
<ul>
<li><tt>QImage::IgnoreEndian</tt> - Endianness does not matter. Useful for some
operations that are independent of endianness.
<li><tt>QImage::BigEndian</tt> - Network byte order, as on SPARC and Motorola CPUs.
<li><tt>QImage::LittleEndian</tt> - PC/Alpha byte order.
</ul>
<h3 class=fn><a name="ScaleMode-enum"></a>QImage::ScaleMode</h3>

<p> The functions <a href="#scale">scale</a>() and <a href="#smoothScale">smoothScale</a>() use different modes for
scaling the image. The purpose of these modes is to retain the
ratio of the image if this is required.
<p> <center><img src="scaling.png"></center> 
<ul>
<li><tt>QImage::ScaleFree</tt> - The image is scaled freely: the resulting image
fits exactly into the specified size; the ratio will not
necessarily be preserved.
<li><tt>QImage::ScaleMin</tt> - The ratio of the image is preserved and the
resulting image is guaranteed to fit into the specified size
(it is as large as possible within these constraints) - the
image might be smaller than the requested size.
<li><tt>QImage::ScaleMax</tt> - The ratio of the image is preserved and the
resulting image fills the whole specified rectangle (it is as
small as possible within these constraints) - the image might
be larger than the requested size.
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QImage"></a>QImage::QImage ()
</h3>
Constructs a null image.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QImage-2"></a>QImage::QImage ( int&nbsp;w, int&nbsp;h, int&nbsp;depth, int&nbsp;numColors = 0, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder = IgnoreEndian )
</h3>
Constructs an image with <em>w</em> width, <em>h</em> height, <em>depth</em> bits
per pixel, <em>numColors</em> colors and bit order <em>bitOrder</em>.
<p> Using this constructor is the same as first constructing a null
image and then calling the <a href="#create">create</a>() function.
<p> <p>See also <a href="#create">create</a>().

<h3 class=fn><a name="QImage-3"></a>QImage::QImage ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;size, int&nbsp;depth, int&nbsp;numColors = 0, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder = IgnoreEndian )
</h3>
Constructs an image with size <em>size</em> pixels, depth <em>depth</em> bits,
<em>numColors</em> and <em>bitOrder</em> endianness.
<p> Using this constructor is the same as first constructing a null
image and then calling the <a href="#create">create</a>() function.
<p> <p>See also <a href="#create">create</a>().

<h3 class=fn><a name="QImage-4"></a>QImage::QImage ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format = 0 )
</h3>
Constructs an image and tries to load the image from the file <em>fileName</em>.
<p> If <em>format</em> is specified, the loader attempts to read the image
using the specified format. If <em>format</em> is not specified (which
is the default), the loader reads a few bytes from the header to
guess the file format.
<p> If the loading of the image failed, this object is a <a href="#isNull">null</a> image.
<p> The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p> <p>See also <a href="#load">load</a>(), <a href="#isNull">isNull</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn><a name="QImage-5"></a>QImage::QImage ( const&nbsp;char&nbsp;*&nbsp;const&nbsp;xpm[] )
</h3>
Constructs an image from <em>xpm</em>, which must be a valid XPM image.
<p> Errors are silently ignored.
<p> Note that it's possible to squeeze the XPM variable a little bit
by using an unusual declaration:
<p> <pre>
        static const char * const start_xpm[]={
            "16 15 8 1",
            "a c #cec6bd",
        ....
    </pre>
 
<p> The extra <tt>const</tt> makes the entire definition read-only, which is
slightly more efficient (e.g. when the code is in a shared
library) and ROMable when the application is to be stored in ROM.

<h3 class=fn><a name="QImage-6"></a>QImage::QImage ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;array )
</h3>
Constructs an image from the binary data <em>array</em>. It tries to
guess the file format.
<p> If the loading of the image failed, this object is a <a href="#isNull">null</a> image.
<p> <p>See also <a href="#loadFromData">loadFromData</a>(), <a href="#isNull">isNull</a>(), and <a href="#imageFormat">imageFormat</a>().

<h3 class=fn><a name="QImage-7"></a>QImage::QImage ( uchar&nbsp;*&nbsp;yourdata, int&nbsp;w, int&nbsp;h, int&nbsp;depth, QRgb&nbsp;*&nbsp;colortable, int&nbsp;numColors, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder )
</h3>
Constructs an image <em>w</em> pixels wide, <em>h</em> pixels high with a
color depth of <em>depth</em>, that uses an existing memory buffer, <em>yourdata</em>. The buffer must remain valid throughout the life of the
QImage. The image does not delete the buffer at destruction.
<p> If <em>colortable</em> is 0, a color table sufficient for <em>numColors</em>
will be allocated (and destructed later).
<p> Note that <em>yourdata</em> must be 32-bit aligned.
<p> The endianness is given in <em>bitOrder</em>.

<h3 class=fn><a name="QImage-8"></a>QImage::QImage ( uchar&nbsp;*&nbsp;yourdata, int&nbsp;w, int&nbsp;h, int&nbsp;depth, int&nbsp;bpl, QRgb&nbsp;*&nbsp;colortable, int&nbsp;numColors, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder )
</h3>
Constructs an image that uses an existing memory buffer. The
buffer must remain valid for the life of the QImage. The image
does not delete the buffer at destruction. The buffer is passed as
<em>yourdata</em>. The image's width is <em>w</em> and its height is <em>h</em>. The
color depth is <em>depth</em>. <em>bpl</em> specifies the number of bytes per
line.
<p> If <em>colortable</em> is 0, a color table sufficient for <em>numColors</em>
will be allocated (and destructed later).
<p> The endianness is specified by <em>bitOrder</em>.
<p> <b>Warning:</b> This constructor is only available on Qt/Embedded.

<h3 class=fn><a name="QImage-9"></a>QImage::QImage ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;image )
</h3>
Constructs a <a href="shclass.html">shallow copy</a> of <em>image</em>.

<h3 class=fn><a name="~QImage"></a>QImage::~QImage ()
</h3>
Destroys the image and cleans up.

<h3 class=fn>bool <a name="allGray"></a>QImage::allGray () const
</h3>
Returns TRUE if all the colors in the image are shades of gray
(i.e. their red, green and blue components are equal); otherwise
returns FALSE.
<p> This function is slow for large 16-bit (Qt/Embedded only) and 32-bit images.
<p> <p>See also <a href="#isGrayscale">isGrayscale</a>().

<h3 class=fn><a href="qimage.html#Endian-enum">Endian</a> <a name="bitOrder"></a>QImage::bitOrder () const
</h3>

<p> Returns the bit order for the image.
<p> If it is a 1-bpp image, this function returns either
QImage::BigEndian or QImage::LittleEndian.
<p> If it is not a 1-bpp image, this function returns
QImage::IgnoreEndian.
<p> <p>See also <a href="#depth">depth</a>().

<h3 class=fn>uchar * <a name="bits"></a>QImage::bits () const
</h3>

<p> Returns a pointer to the first pixel data. This is equivalent to
<a href="#scanLine">scanLine</a>(0).
<p> <p>See also <a href="#numBytes">numBytes</a>(), <a href="#scanLine">scanLine</a>(), and <a href="#jumpTable">jumpTable</a>().

<p>Example: <a href="qglwidget.html#x2119">opengl/texture/gltexobj.cpp</a>.
<h3 class=fn>int <a name="bytesPerLine"></a>QImage::bytesPerLine () const
</h3>

<p> Returns the number of bytes per image scanline. This is equivalent
to <a href="#numBytes">numBytes</a>()/height().
<p> <p>See also <a href="#numBytes">numBytes</a>() and <a href="#scanLine">scanLine</a>().

<h3 class=fn>QRgb <a name="color"></a>QImage::color ( int&nbsp;i ) const
</h3>

<p> Returns the color in the color table at index <em>i</em>. The first
color is at index 0.
<p> A color value is an RGB triplet. Use the <a href="qcolor.html#qRed">qRed()</a>, <a href="qcolor.html#qGreen">qGreen()</a> and <a href="qcolor.html#qBlue">qBlue()</a> functions (defined in <a href="qcolor-h.html">qcolor.h</a>) to
get the color value components.
<p> <p>See also <a href="#setColor">setColor</a>(), <a href="#numColors">numColors</a>(), and <a href="qcolor.html">QColor</a>.

<p>Example: <a href="themes-example.html#x207">themes/wood.cpp</a>.
<h3 class=fn>QRgb * <a name="colorTable"></a>QImage::colorTable () const
</h3>

<p> Returns a pointer to the color table.
<p> <p>See also <a href="#numColors">numColors</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="convertBitOrder"></a>QImage::convertBitOrder ( <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder ) const
</h3>
Converts the bit order of the image to <em>bitOrder</em> and returns the
converted image. The original image is not changed.
<p> Returns <tt>*this</tt> if the <em>bitOrder</em> is equal to the image bit
order, or a <a href="#isNull">null</a> image if this image cannot
be converted.
<p> <p>See also <a href="#bitOrder">bitOrder</a>(), <a href="#systemBitOrder">systemBitOrder</a>(), and <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="convertDepth"></a>QImage::convertDepth ( int&nbsp;depth, int&nbsp;conversion_flags ) const
</h3>
Converts the depth (bpp) of the image to <em>depth</em> and returns the
converted image. The original image is not changed.
<p> The <em>depth</em> argument must be 1, 8, 16 (Qt/Embedded only) or 32.
<p> Returns <tt>*this</tt> if <em>depth</em> is equal to the image depth, or a
<a href="#isNull">null</a> image if this image cannot be
converted.
<p> If the image needs to be modified to fit in a lower-resolution
result (e.g. converting from 32-bit to 8-bit), use the <em>conversion_flags</em> to specify how you'd prefer this to happen.
<p> <p>See also <a href="qt.html#ImageConversionFlags-enum">Qt::ImageConversionFlags</a>, <a href="#depth">depth</a>(), and <a href="#isNull">isNull</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="convertDepth-2"></a>QImage::convertDepth ( int&nbsp;depth ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qimage.html">QImage</a> <a name="convertDepthWithPalette"></a>QImage::convertDepthWithPalette ( int&nbsp;d, QRgb&nbsp;*&nbsp;palette, int&nbsp;palette_count, int&nbsp;conversion_flags = 0 ) const
</h3>
Returns an image with depth <em>d</em>, using the <em>palette_count</em>
colors pointed to by <em>palette</em>. If <em>d</em> is 1 or 8, the returned
image will have its color table ordered the same as <em>palette</em>.
<p> If the image needs to be modified to fit in a lower-resolution
result (e.g. converting from 32-bit to 8-bit), use the <em>conversion_flags</em> to specify how you'd prefer this to happen.
<p> Note: currently no closest-color search is made. If colors are
found that are not in the palette, the palette may not be used at
all. This result should not be considered valid because it may
change in future implementations.
<p> Currently inefficient for non-32-bit images.
<p> <p>See also <a href="qt.html#ImageConversionFlags-enum">Qt::ImageConversionFlags</a>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="copy"></a>QImage::copy () const
</h3>
Returns a <a href="shclass.html">deep copy</a> of the image.
<p> <p>See also <a href="#detach">detach</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="copy-2"></a>QImage::copy ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, int&nbsp;conversion_flags = 0 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a <a href="shclass.html">deep copy</a> of a sub-area of
the image.
<p> The returned image is always <em>w</em> by <em>h</em> pixels in size, and is
copied from position <em>x</em>, <em>y</em> in this image. In areas beyond
this image pixels are filled with pixel 0.
<p> If the image needs to be modified to fit in a lower-resolution
result (e.g. converting from 32-bit to 8-bit), use the <em>conversion_flags</em> to specify how you'd prefer this to happen.
<p> <p>See also <a href="#bitBlt">bitBlt</a>() and <a href="qt.html#ImageConversionFlags-enum">Qt::ImageConversionFlags</a>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="copy-3"></a>QImage::copy ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a <a href="shclass.html">deep copy</a> of a sub-area of
the image.
<p> The returned image always has the size of the rectangle <em>r</em>. In
areas beyond this image pixels are filled with pixel 0.

<h3 class=fn>bool <a name="create"></a>QImage::create ( int&nbsp;width, int&nbsp;height, int&nbsp;depth, int&nbsp;numColors = 0, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder = IgnoreEndian )
</h3>
Sets the image <em>width</em>, <em>height</em>, <em>depth</em>, its number of colors
(in <em>numColors</em>), and bit order. Returns TRUE if successful, or
FALSE if the parameters are incorrect or if memory cannot be
allocated.
<p> The <em>width</em> and <em>height</em> is limited to 32767. <em>depth</em> must be
1, 8, or 32. If <em>depth</em> is 1, <em>bitOrder</em> must be set to
either QImage::LittleEndian or QImage::BigEndian. For other depths
<em>bitOrder</em> must be QImage::IgnoreEndian.
<p> This function allocates a color table and a buffer for the image
data. The image data is not initialized.
<p> The image buffer is allocated as a single block that consists of a
table of <a href="#scanLine">scanline</a> pointers (<a href="#jumpTable">jumpTable</a>())
and the image data (<a href="#bits">bits</a>()).
<p> <p>See also <a href="#fill">fill</a>(), <a href="#width">width</a>(), <a href="#height">height</a>(), <a href="#depth">depth</a>(), <a href="#numColors">numColors</a>(), <a href="#bitOrder">bitOrder</a>(), <a href="#jumpTable">jumpTable</a>(), <a href="#scanLine">scanLine</a>(), <a href="#bits">bits</a>(), <a href="#bytesPerLine">bytesPerLine</a>(), and <a href="#numBytes">numBytes</a>().

<h3 class=fn>bool <a name="create-2"></a>QImage::create ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;, int&nbsp;depth, int&nbsp;numColors = 0, <a href="qimage.html#Endian-enum">Endian</a>&nbsp;bitOrder = IgnoreEndian )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qimage.html">QImage</a> <a name="createAlphaMask"></a>QImage::createAlphaMask ( int&nbsp;conversion_flags = 0 ) const
</h3>
Builds and returns a 1-bpp mask from the alpha buffer in this
image. Returns a <a href="#isNull">null</a> image if <a href="#setAlphaBuffer">alpha buffer mode</a> is disabled.
<p> See <a href="qpixmap.html#convertFromImage">QPixmap::convertFromImage</a>() for a description of the <em>conversion_flags</em> argument.
<p> The returned image has little-endian bit order, which you can
convert to big-endianness using <a href="#convertBitOrder">convertBitOrder</a>().
<p> <p>See also <a href="#createHeuristicMask">createHeuristicMask</a>(), <a href="#hasAlphaBuffer">hasAlphaBuffer</a>(), and <a href="#setAlphaBuffer">setAlphaBuffer</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="createHeuristicMask"></a>QImage::createHeuristicMask ( bool&nbsp;clipTight = TRUE ) const
</h3>
Creates and returns a 1-bpp heuristic mask for this image. It
works by selecting a color from one of the corners, then chipping
away pixels of that color starting at all the edges.
<p> The four corners vote for which color is to be masked away. In
case of a draw (this generally means that this function is not
applicable to the image), the result is arbitrary.
<p> The returned image has little-endian bit order, which you can
convert to big-endianness using <a href="#convertBitOrder">convertBitOrder</a>().
<p> If <em>clipTight</em> is TRUE the mask is just large enough to cover the
pixels; otherwise, the mask is larger than the data pixels.
<p> This function disregards the <a href="#hasAlphaBuffer">alpha buffer</a>.
<p> <p>See also <a href="#createAlphaMask">createAlphaMask</a>().

<h3 class=fn>int <a name="depth"></a>QImage::depth () const
</h3>

<p> Returns the depth of the image.
<p> The image depth is the number of bits used to encode a single
pixel, also called bits per pixel (bpp) or bit planes of an image.
<p> The supported depths are 1, 8, 16 (Qt/Embedded only) and 32.
<p> <p>See also <a href="#convertDepth">convertDepth</a>().

<h3 class=fn>void <a name="detach"></a>QImage::detach ()
</h3>
Detaches from shared image data and makes sure that this image is
the only one referring to the data.
<p> If multiple images share common data, this image makes a copy of
the data and detaches itself from the sharing mechanism.
Nothing is done if there is just a single reference.
<p> <p>See also <a href="#copy">copy</a>().

<p>Example: <a href="themes-example.html#x208">themes/wood.cpp</a>.
<h3 class=fn>int <a name="dotsPerMeterX"></a>QImage::dotsPerMeterX () const
</h3>

<p> Returns the number of pixels that fit horizontally in a physical
meter. This and <a href="#dotsPerMeterY">dotsPerMeterY</a>() define the intended scale and
aspect ratio of the image.
<p> <p>See also <a href="#setDotsPerMeterX">setDotsPerMeterX</a>().

<h3 class=fn>int <a name="dotsPerMeterY"></a>QImage::dotsPerMeterY () const
</h3>

<p> Returns the number of pixels that fit vertically in a physical
meter. This and <a href="#dotsPerMeterX">dotsPerMeterX</a>() define the intended scale and
aspect ratio of the image.
<p> <p>See also <a href="#setDotsPerMeterY">setDotsPerMeterY</a>().

<h3 class=fn>void <a name="fill"></a>QImage::fill ( uint&nbsp;pixel )
</h3>
Fills the entire image with the pixel value <em>pixel</em>.
<p> If the <a href="#depth">depth</a> of this image is 1, only the
lowest bit is used. If you say <a href="#fill">fill</a>(0), fill(2), etc., the image
is filled with 0s. If you say fill(1), fill(3), etc., the image is
filled with 1s. If the depth is 8, the lowest 8 bits are used.
<p> If the depth is 32 and the image has no alpha buffer, the <em>pixel</em>
value is written to each pixel in the image. If the image has an
alpha buffer, only the 24 RGB bits are set and the upper 8 bits
(alpha value) are left unchanged.
<p> Note: <a href="#pixel">QImage::pixel</a>() returns the color of the pixel at the given
coordinates; <a href="qcolor.html#pixel">QColor::pixel</a>() returns the pixel value of the
underlying window system (essentially an index value), so normally
you will want to use QImage::pixel() to use a color from an
existing image or <a href="qcolor.html#rgb">QColor::rgb</a>() to use a specific color.
<p> <p>See also <a href="#invertPixels">invertPixels</a>(), <a href="#depth">depth</a>(), <a href="#hasAlphaBuffer">hasAlphaBuffer</a>(), and <a href="#create">create</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="fromMimeSource"></a>QImage::fromMimeSource ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;abs_name )<tt> [static]</tt>
</h3> Convenience function. Gets the data associated with the absolute
name <em>abs_name</em> from the default mime source factory and decodes it
to an image.
<p> <p>See also <a href="qmimesourcefactory.html">QMimeSourceFactory</a>, <a href="#fromMimeSource">QImage::fromMimeSource</a>(), and <a href="qimagedrag.html#decode">QImageDrag::decode</a>().

<h3 class=fn>bool <a name="hasAlphaBuffer"></a>QImage::hasAlphaBuffer () const
</h3>

<p> Returns TRUE if alpha buffer mode is enabled; otherwise returns
FALSE.
<p> <p>See also <a href="#setAlphaBuffer">setAlphaBuffer</a>().

<h3 class=fn>int <a name="height"></a>QImage::height () const
</h3>

<p> Returns the height of the image.
<p> <p>See also <a href="#width">width</a>(), <a href="#size">size</a>(), and <a href="#rect">rect</a>().

<p>Examples: <a href="canvas-example.html#x2932">canvas/canvas.cpp</a> and <a href="qglwidget.html#x2120">opengl/texture/gltexobj.cpp</a>.
<h3 class=fn>const char * <a name="imageFormat"></a>QImage::imageFormat ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;fileName )<tt> [static]</tt>
</h3>
Returns a string that specifies the image format of the file <em>fileName</em>, or 0 if the file cannot be read or if the format is not
recognized.
<p> The <a href="qimageio.html">QImageIO</a> documentation lists the guaranteed supported image
formats, or use <a href="#inputFormats">QImage::inputFormats</a>() and <a href="#outputFormats">QImage::outputFormats</a>()
to get lists that include the installed formats.
<p> <p>See also <a href="#load">load</a>() and <a href="#save">save</a>().

<h3 class=fn><a href="qstringlist.html">QStringList</a> <a name="inputFormatList"></a>QImage::inputFormatList ()<tt> [static]</tt>
</h3>
Returns a list of image formats that are supported for image
input.
<p> Note that if you want to iterate over the list, you should iterate
over a copy, e.g.
<pre>
    <a href="qstringlist.html">QStringList</a> list = myImage.inputFormatList();
    QStringList::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 
<p> <p>See also <a href="#outputFormatList">outputFormatList</a>(), <a href="#inputFormats">inputFormats</a>(), and <a href="qimageio.html">QImageIO</a>.

<p>Example: <a href="showimg-example.html#x1321">showimg/showimg.cpp</a>.
<h3 class=fn><a href="qstrlist.html">QStrList</a> <a name="inputFormats"></a>QImage::inputFormats ()<tt> [static]</tt>
</h3>
Returns a list of image formats that are supported for image
input.
<p> <p>See also <a href="#outputFormats">outputFormats</a>(), <a href="#inputFormatList">inputFormatList</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn>void <a name="invertPixels"></a>QImage::invertPixels ( bool&nbsp;invertAlpha = TRUE )
</h3>
Inverts all pixel values in the image.
<p> If the depth is 32: if <em>invertAlpha</em> is TRUE, the alpha bits are
also inverted, otherwise they are left unchanged.
<p> If the depth is not 32, the argument <em>invertAlpha</em> has no
meaning.
<p> Note that inverting an 8-bit image means to replace all pixels
using color index <em>i</em> with a pixel using color index 255 minus <em>i</em>. Similarly for a 1-bit image. The color table is not changed.
<p> <p>See also <a href="#fill">fill</a>(), <a href="#depth">depth</a>(), and <a href="#hasAlphaBuffer">hasAlphaBuffer</a>().

<h3 class=fn>bool <a name="isGrayscale"></a>QImage::isGrayscale () const
</h3>
For 16-bit (Qt/Embedded only) and 32-bit images, this function is
equivalent to <a href="#allGray">allGray</a>().
<p> For 8-bpp images, this function returns TRUE if <a href="#color">color</a>(i) is
QRgb(i,i,i) for all indices of the color table; otherwise returns
FALSE.
<p> <p>See also <a href="#allGray">allGray</a>() and <a href="#depth">depth</a>().

<h3 class=fn>bool <a name="isNull"></a>QImage::isNull () const
</h3>

<p> Returns TRUE if it is a null image; otherwise returns FALSE.
<p> A null image has all parameters set to zero and no allocated data.

<p>Example: <a href="showimg-example.html#x1322">showimg/showimg.cpp</a>.
<h3 class=fn>uchar ** <a name="jumpTable"></a>QImage::jumpTable () const
</h3>

<p> Returns a pointer to the scanline pointer table.
<p> This is the beginning of the data block for the image.
<p> <p>See also <a href="#bits">bits</a>() and <a href="#scanLine">scanLine</a>().

<h3 class=fn>bool <a name="load"></a>QImage::load ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format = 0 )
</h3>
Loads an image from the file <em>fileName</em>. Returns TRUE if the
image was successfully loaded; otherwise returns FALSE.
<p> If <em>format</em> is specified, the loader attempts to read the image
using the specified format. If <em>format</em> is not specified (which
is the default), the loader reads a few bytes from the header to
guess the file format.
<p> The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p> <p>See also <a href="#loadFromData">loadFromData</a>(), <a href="#save">save</a>(), <a href="#imageFormat">imageFormat</a>(), <a href="qpixmap.html#load">QPixmap::load</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn>bool <a name="loadFromData"></a>QImage::loadFromData ( const&nbsp;uchar&nbsp;*&nbsp;buf, uint&nbsp;len, const&nbsp;char&nbsp;*&nbsp;format = 0 )
</h3>
Loads an image from the first <em>len</em> bytes of binary data in <em>buf</em>. Returns TRUE if the image was successfully loaded; otherwise
returns FALSE.
<p> If <em>format</em> is specified, the loader attempts to read the image
using the specified format. If <em>format</em> is not specified (which
is the default), the loader reads a few bytes from the header to
guess the file format.
<p> The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p> <p>See also <a href="#load">load</a>(), <a href="#save">save</a>(), <a href="#imageFormat">imageFormat</a>(), <a href="qpixmap.html#loadFromData">QPixmap::loadFromData</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn>bool <a name="loadFromData-2"></a>QImage::loadFromData ( <a href="qbytearray.html">QByteArray</a>&nbsp;buf, const&nbsp;char&nbsp;*&nbsp;format = 0 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Loads an image from the <a href="qbytearray.html">QByteArray</a> <em>buf</em>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="mirror"></a>QImage::mirror () const
</h3>
Returns a QImage which is a vertically mirrored copy of this
image. The original QImage is not changed.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="mirror-2"></a>QImage::mirror ( bool&nbsp;horizontal, bool&nbsp;vertical ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a mirror of the image, mirrored in the horizontal and/or
the vertical direction depending on whether <em>horizontal</em> and <em>vertical</em> are set to TRUE or FALSE. The original image is not
changed.
<p> <p>See also <a href="#smoothScale">smoothScale</a>().

<h3 class=fn>int <a name="numBytes"></a>QImage::numBytes () const
</h3>

<p> Returns the number of bytes occupied by the image data.
<p> <p>See also <a href="#bytesPerLine">bytesPerLine</a>() and <a href="#bits">bits</a>().

<h3 class=fn>int <a name="numColors"></a>QImage::numColors () const
</h3>

<p> Returns the size of the color table for the image.
<p> Notice that <a href="#numColors">numColors</a>() returns 0 for 16-bpp (Qt/Embedded only)
and 32-bpp images because these images do not use color tables,
but instead encode pixel values as RGB triplets.
<p> <p>See also <a href="#setNumColors">setNumColors</a>() and <a href="#colorTable">colorTable</a>().

<p>Example: <a href="themes-example.html#x209">themes/wood.cpp</a>.
<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="offset"></a>QImage::offset () const
</h3>

<p> Returns the number of pixels by which the image is intended to be
offset by when positioning relative to other images.

<h3 class=fn>bool <a name="operator!-eq"></a>QImage::operator!= ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;i ) const
</h3>
Returns TRUE if this image and image <em>i</em> have different contents;
otherwise returns FALSE. The comparison can be slow, unless there
is some obvious difference, such as different widths, in which
case the function will return quickly.
<p> <p>See also <a href="#operator-eq">operator=</a>().

<h3 class=fn><a href="qimage.html">QImage</a>&nbsp;&amp; <a name="operator-eq"></a>QImage::operator= ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;image )
</h3>
Assigns a <a href="shclass.html">shallow copy</a> of <em>image</em> to
this image and returns a reference to this image.
<p> <p>See also <a href="#copy">copy</a>().

<h3 class=fn><a href="qimage.html">QImage</a>&nbsp;&amp; <a name="operator-eq-2"></a>QImage::operator= ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;pixmap )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Sets the image bits to the <em>pixmap</em> contents and returns a
reference to the image.
<p> If the image shares data with other images, it will first
dereference the shared data.
<p> Makes a call to <a href="qpixmap.html#convertToImage">QPixmap::convertToImage</a>().

<h3 class=fn>bool <a name="operator-eq-eq"></a>QImage::operator== ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;i ) const
</h3>
Returns TRUE if this image and image <em>i</em> have the same contents;
otherwise returns FALSE. The comparison can be slow, unless there
is some obvious difference, such as different widths, in which
case the function will return quickly.
<p> <p>See also <a href="#operator-eq">operator=</a>().

<h3 class=fn><a href="qstringlist.html">QStringList</a> <a name="outputFormatList"></a>QImage::outputFormatList ()<tt> [static]</tt>
</h3>
Returns a list of image formats that are supported for image
output.
<p> Note that if you want to iterate over the list, you should iterate
over a copy, e.g.
<pre>
    <a href="qstringlist.html">QStringList</a> list = myImage.outputFormatList();
    QStringList::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 
<p> <p>See also <a href="#inputFormatList">inputFormatList</a>(), <a href="#outputFormats">outputFormats</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn><a href="qstrlist.html">QStrList</a> <a name="outputFormats"></a>QImage::outputFormats ()<tt> [static]</tt>
</h3>
Returns a list of image formats that are supported for image
output.
<p> <p>See also <a href="#inputFormats">inputFormats</a>(), <a href="#outputFormatList">outputFormatList</a>(), and <a href="qimageio.html">QImageIO</a>.

<p>Example: <a href="showimg-example.html#x1323">showimg/showimg.cpp</a>.
<h3 class=fn>QRgb <a name="pixel"></a>QImage::pixel ( int&nbsp;x, int&nbsp;y ) const
</h3>
Returns the color of the pixel at the coordinates (<em>x</em>, <em>y</em>).
<p> If (<em>x</em>, <em>y</em>) is not <a href="#valid">on the image</a>, the
results are undefined.
<p> <p>See also <a href="#setPixel">setPixel</a>(), <a href="qcolor.html#qRed">qRed</a>(), <a href="qcolor.html#qGreen">qGreen</a>(), <a href="qcolor.html#qBlue">qBlue</a>(), and <a href="#valid">valid</a>().

<p>Examples: <a href="canvas-example.html#x2933">canvas/canvas.cpp</a> and <a href="qmag-example.html#x1776">qmag/qmag.cpp</a>.
<h3 class=fn>int <a name="pixelIndex"></a>QImage::pixelIndex ( int&nbsp;x, int&nbsp;y ) const
</h3>
Returns the pixel index at the given coordinates.
<p> If (<em>x</em>, <em>y</em>) is not <a href="#valid">valid</a>, or if the
image is not a paletted image (<a href="#depth">depth</a>() &gt; 8), the results are
undefined.
<p> <p>See also <a href="#valid">valid</a>() and <a href="#depth">depth</a>().

<h3 class=fn><a href="qrect.html">QRect</a> <a name="rect"></a>QImage::rect () const
</h3>

<p> Returns the enclosing rectangle (0, 0, <a href="#width">width</a>(), <a href="#height">height</a>()) of the
image.
<p> <p>See also <a href="#width">width</a>(), <a href="#height">height</a>(), and <a href="#size">size</a>().

<h3 class=fn>void <a name="reset"></a>QImage::reset ()
</h3>
Resets all image parameters and deallocates the image data.

<h3 class=fn>bool <a name="save"></a>QImage::save ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;fileName, const&nbsp;char&nbsp;*&nbsp;format, int&nbsp;quality = -1 ) const
</h3>
Saves the image to the file <em>fileName</em>, using the image file
format <em>format</em> and a quality factor of <em>quality</em>. <em>quality</em>
must be in the range 0..100 or -1. Specify 0 to obtain small
compressed files, 100 for large uncompressed files, and -1 (the
default) to use the default settings.
<p> Returns TRUE if the image was successfully saved; otherwise
returns FALSE.
<p> <p>See also <a href="#load">load</a>(), <a href="#loadFromData">loadFromData</a>(), <a href="#imageFormat">imageFormat</a>(), <a href="qpixmap.html#save">QPixmap::save</a>(), and <a href="qimageio.html">QImageIO</a>.

<h3 class=fn>bool <a name="save-2"></a>QImage::save ( <a href="qiodevice.html">QIODevice</a>&nbsp;*&nbsp;device, const&nbsp;char&nbsp;*&nbsp;format, int&nbsp;quality = -1 ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This function writes a QImage to the <a href="qiodevice.html">QIODevice</a>, <em>device</em>. This
can be used, for example, to save an image directly into a
QByteArray:
<pre>
    QImage image;
    <a href="qbytearray.html">QByteArray</a> ba;
    <a href="qbuffer.html">QBuffer</a> buffer( ba );
    buffer.<a href="qiodevice.html#open">open</a>( <a href="qfile.html#open">IO_WriteOnly</a> );
    image.<a href="#save">save</a>( &amp;buffer, "PNG" ); // writes image into ba in PNG format
    </pre>
 

<h3 class=fn><a href="qimage.html">QImage</a> <a name="scale"></a>QImage::scale ( int&nbsp;w, int&nbsp;h, <a href="qimage.html#ScaleMode-enum">ScaleMode</a>&nbsp;mode = ScaleFree ) const
</h3>
Returns a copy of the image scaled to a rectangle of width <em>w</em>
and height <em>h</em> according to the ScaleMode <em>mode</em>.
<p> <ul>
<li> If <em>mode</em> is <a href="#ScaleMode-enum">ScaleFree</a>, the image is scaled to (<em>w</em>,
<em>h</em>).
<li> If <em>mode</em> is <a href="#ScaleMode-enum">ScaleMin</a>, the image is scaled to a rectangle
as large as possible inside (<em>w</em>, <em>h</em>), preserving the aspect
ratio.
<li> If <em>mode</em> is <a href="#ScaleMode-enum">ScaleMax</a>, the image is scaled to a rectangle
as small as possible outside (<em>w</em>, <em>h</em>), preserving the aspect
ratio.
</ul>
<p> If either the width <em>w</em> or the height <em>h</em> is 0 or negative, this
function returns a <a href="#isNull">null</a> image.
<p> This function uses a simple, fast algorithm. If you need better
quality, use <a href="#smoothScale">smoothScale</a>() instead.
<p> <p>See also <a href="#scaleWidth">scaleWidth</a>(), <a href="#scaleHeight">scaleHeight</a>(), <a href="#smoothScale">smoothScale</a>(), and <a href="#xForm">xForm</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="scale-2"></a>QImage::scale ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;s, <a href="qimage.html#ScaleMode-enum">ScaleMode</a>&nbsp;mode = ScaleFree ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> The requested size of the image is <em>s</em>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="scaleHeight"></a>QImage::scaleHeight ( int&nbsp;h ) const
</h3>
Returns a scaled copy of the image. The returned image has a
height of <em>h</em> pixels. This function automatically calculates the
width of the image so that the ratio of the image is preserved.
<p> If <em>h</em> is 0 or negative a <a href="#isNull">null</a> image is
returned.
<p> <p>See also <a href="#scale">scale</a>(), <a href="#scaleWidth">scaleWidth</a>(), <a href="#smoothScale">smoothScale</a>(), and <a href="#xForm">xForm</a>().

<p>Example: <a href="small-table-example-example.html#x2799">table/small-table-demo/main.cpp</a>.
<h3 class=fn><a href="qimage.html">QImage</a> <a name="scaleWidth"></a>QImage::scaleWidth ( int&nbsp;w ) const
</h3>
Returns a scaled copy of the image. The returned image has a width
of <em>w</em> pixels. This function automatically calculates the height
of the image so that the ratio of the image is preserved.
<p> If <em>w</em> is 0 or negative a <a href="#isNull">null</a> image is
returned.
<p> <p>See also <a href="#scale">scale</a>(), <a href="#scaleHeight">scaleHeight</a>(), <a href="#smoothScale">smoothScale</a>(), and <a href="#xForm">xForm</a>().

<h3 class=fn>uchar * <a name="scanLine"></a>QImage::scanLine ( int&nbsp;i ) const
</h3>

<p> Returns a pointer to the pixel data at the scanline with index <em>i</em>. The first scanline is at index 0.
<p> The scanline data is aligned on a 32-bit boundary.
<p> <b>Warning:</b> If you are accessing 32-bpp image data, cast the returned
pointer to <tt>QRgb*</tt> (QRgb has a 32-bit size) and use it to
read/write the pixel value. You cannot use the <tt>uchar*</tt> pointer
directly, because the pixel format depends on the byte order on
the underlying platform. Hint: use <a href="qcolor.html#qRed">qRed()</a>,
<a href="qcolor.html#qGreen">qGreen()</a> and <a href="qcolor.html#qBlue">qBlue()</a>, etc. (qcolor.h) to access the pixels.
<p> <b>Warning:</b> If you are accessing 16-bpp image data, you must handle
endianness yourself. (Qt/Embedded only)
<p> <p>See also <a href="#bytesPerLine">bytesPerLine</a>(), <a href="#bits">bits</a>(), and <a href="#jumpTable">jumpTable</a>().

<p>Example: <a href="desktop-example.html#x1729">desktop/desktop.cpp</a>.
<h3 class=fn>void <a name="setAlphaBuffer"></a>QImage::setAlphaBuffer ( bool&nbsp;enable )
</h3>
Enables alpha buffer mode if <em>enable</em> is TRUE, otherwise disables
it. The default setting is disabled.
<p> An 8-bpp image has 8-bit pixels. A pixel is an index into the
<a href="#color">color table</a>, which contains 32-bit color
values. In a 32-bpp image, the 32-bit pixels are the color values.
<p> This 32-bit value is encoded as follows: The lower 24 bits are
used for the red, green, and blue components. The upper 8 bits
contain the alpha component.
<p> The alpha component specifies the transparency of a pixel. 0 means
completely transparent and 255 means opaque. The alpha component
is ignored if you do not enable alpha buffer mode.
<p> The alpha buffer is used to set a mask when a QImage is translated
to a <a href="qpixmap.html">QPixmap</a>.
<p> <p>See also <a href="#hasAlphaBuffer">hasAlphaBuffer</a>() and <a href="#createAlphaMask">createAlphaMask</a>().

<h3 class=fn>void <a name="setColor"></a>QImage::setColor ( int&nbsp;i, QRgb&nbsp;c )
</h3>

<p> Sets a color in the color table at index <em>i</em> to <em>c</em>.
<p> A color value is an RGB triplet. Use the <a href="qcolor.html#qRgb">qRgb()</a> function (defined in <a href="qcolor-h.html">qcolor.h</a>) to make RGB
triplets.
<p> <p>See also <a href="#color">color</a>(), <a href="#setNumColors">setNumColors</a>(), and <a href="#numColors">numColors</a>().

<p>Examples: <a href="desktop-example.html#x1730">desktop/desktop.cpp</a> and <a href="themes-example.html#x210">themes/wood.cpp</a>.
<h3 class=fn>void <a name="setDotsPerMeterX"></a>QImage::setDotsPerMeterX ( int&nbsp;x )
</h3>
Sets the value returned by <a href="#dotsPerMeterX">dotsPerMeterX</a>() to <em>x</em>.

<h3 class=fn>void <a name="setDotsPerMeterY"></a>QImage::setDotsPerMeterY ( int&nbsp;y )
</h3>
Sets the value returned by <a href="#dotsPerMeterY">dotsPerMeterY</a>() to <em>y</em>.

<h3 class=fn>void <a name="setNumColors"></a>QImage::setNumColors ( int&nbsp;numColors )
</h3>
Resizes the color table to <em>numColors</em> colors.
<p> If the color table is expanded all the extra colors will be set to
black (RGB 0,0,0).
<p> <p>See also <a href="#numColors">numColors</a>(), <a href="#color">color</a>(), <a href="#setColor">setColor</a>(), and <a href="#colorTable">colorTable</a>().

<h3 class=fn>void <a name="setOffset"></a>QImage::setOffset ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p )
</h3>
Sets the value returned by <a href="#offset">offset</a>() to <em>p</em>.

<h3 class=fn>void <a name="setPixel"></a>QImage::setPixel ( int&nbsp;x, int&nbsp;y, uint&nbsp;index_or_rgb )
</h3>
Sets the pixel index or color at the coordinates (<em>x</em>, <em>y</em>) to
<em>index_or_rgb</em>.
<p> If (<em>x</em>, <em>y</em>) is not <a href="#valid">valid</a>, the result is
undefined.
<p> If the image is a paletted image (<a href="#depth">depth</a>() &lt;= 8) and <em>index_or_rgb</em> &gt;= <a href="#numColors">numColors</a>(), the result is undefined.
<p> <p>See also <a href="#pixelIndex">pixelIndex</a>(), <a href="#pixel">pixel</a>(), <a href="qcolor.html#qRgb">qRgb</a>(), <a href="qcolor.html#qRgba">qRgba</a>(), and <a href="#valid">valid</a>().

<h3 class=fn>void <a name="setText"></a>QImage::setText ( const&nbsp;char&nbsp;*&nbsp;key, const&nbsp;char&nbsp;*&nbsp;lang, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;s )
</h3>
Records string <em>s</em> for the keyword <em>key</em>. The <em>key</em> should be a
portable keyword recognizable by other software - some suggested
values can be found in <a href="http://www.libpng.org/pub/png/spec/1.2/png-1.2-pdg.html#C.Anc-text">the PNG specification</a>. <em>s</em> can be any text. <em>lang</em>
should specify the language code (see
<a href="http://www.rfc-editor.org/rfc/rfc1766.txt">RFC 1766</a>) or 0.

<h3 class=fn><a href="qsize.html">QSize</a> <a name="size"></a>QImage::size () const
</h3>

<p> Returns the size of the image, i.e. its width and height.
<p> <p>See also <a href="#width">width</a>(), <a href="#height">height</a>(), and <a href="#rect">rect</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="smoothScale"></a>QImage::smoothScale ( int&nbsp;w, int&nbsp;h, <a href="qimage.html#ScaleMode-enum">ScaleMode</a>&nbsp;mode = ScaleFree ) const
</h3>
Returns a smoothly scaled copy of the image. The returned image
has a size of width <em>w</em> by height <em>h</em> pixels if <em>mode</em> is <a href="#ScaleMode-enum">ScaleFree</a>. The modes <a href="#ScaleMode-enum">ScaleMin</a> and <a href="#ScaleMode-enum">ScaleMax</a> may be used to
preserve the ratio of the image: if <em>mode</em> is <a href="#ScaleMode-enum">ScaleMin</a>, the
returned image is guaranteed to fit into the rectangle specified
by <em>w</em> and <em>h</em> (it is as large as possible within the
constraints); if <em>mode</em> is <a href="#ScaleMode-enum">ScaleMax</a>, the returned image fits
at least into the specified rectangle (it is a small as possible
within the constraints).
<p> For 32-bpp images and 1-bpp/8-bpp color images the result will be
32-bpp, whereas <a href="#allGray">all-gray</a> images
(including black-and-white 1-bpp) will produce 8-bit <a href="#isGrayscale">grayscale</a> images with the palette spanning
256 grays from black to white.
<p> This function uses code based on pnmscale.c by Jef Poskanzer.
<p> pnmscale.c - read a portable anymap and scale it
<p> 
<p> Copyright (C) 1989, 1991 by Jef Poskanzer.
<p> Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that copyright notice and this permission
notice appear in supporting documentation. This software is
provided "as is" without express or implied warranty.
<p> <p>See also <a href="#scale">scale</a>() and <a href="#mirror">mirror</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="smoothScale-2"></a>QImage::smoothScale ( const&nbsp;<a href="qsize.html">QSize</a>&nbsp;&amp;&nbsp;s, <a href="qimage.html#ScaleMode-enum">ScaleMode</a>&nbsp;mode = ScaleFree ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> The requested size of the image is <em>s</em>.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="swapRGB"></a>QImage::swapRGB () const
</h3>
Returns a QImage in which the values of the red and blue
components of all pixels have been swapped, effectively converting
an RGB image to a BGR image. The original QImage is not changed.

<h3 class=fn><a href="qimage.html#Endian-enum">Endian</a> <a name="systemBitOrder"></a>QImage::systemBitOrder ()<tt> [static]</tt>
</h3>
Determines the bit order of the display hardware. Returns
QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
<p> <p>See also <a href="#systemByteOrder">systemByteOrder</a>().

<h3 class=fn><a href="qimage.html#Endian-enum">Endian</a> <a name="systemByteOrder"></a>QImage::systemByteOrder ()<tt> [static]</tt>
</h3>
Determines the host computer byte order. Returns
QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
<p> <p>See also <a href="#systemBitOrder">systemBitOrder</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="text"></a>QImage::text ( const&nbsp;char&nbsp;*&nbsp;key, const&nbsp;char&nbsp;*&nbsp;lang = 0 ) const
</h3>
Returns the string recorded for the keyword <em>key</em> in language <em>lang</em>, or in a default language if <em>lang</em> is 0.

<h3 class=fn><a href="qstring.html">QString</a> <a name="text-2"></a>QImage::text ( const&nbsp;QImageTextKeyLang&nbsp;&amp;&nbsp;kl ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the string recorded for the keyword and language <em>kl</em>.

<h3 class=fn><a href="qstringlist.html">QStringList</a> <a name="textKeys"></a>QImage::textKeys () const
</h3>
Returns the keywords for which some texts are recorded.
<p> Note that if you want to iterate over the list, you should iterate
over a copy, e.g.
<pre>
    <a href="qstringlist.html">QStringList</a> list = myImage.textKeys();
    QStringList::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 
<p> <p>See also <a href="#textList">textList</a>(), <a href="#text">text</a>(), <a href="#setText">setText</a>(), and <a href="#textLanguages">textLanguages</a>().

<h3 class=fn><a href="qstringlist.html">QStringList</a> <a name="textLanguages"></a>QImage::textLanguages () const
</h3>
Returns the language identifiers for which some texts are
recorded.
<p> Note that if you want to iterate over the list, you should iterate
over a copy, e.g.
<pre>
    <a href="qstringlist.html">QStringList</a> list = myImage.textLanguages();
    QStringList::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 
<p> <p>See also <a href="#textList">textList</a>(), <a href="#text">text</a>(), <a href="#setText">setText</a>(), and <a href="#textKeys">textKeys</a>().

<h3 class=fn><a href="qvaluelist.html">QValueList</a>&lt;QImageTextKeyLang&gt; <a name="textList"></a>QImage::textList () const
</h3>
Returns a list of QImageTextKeyLang objects that enumerate all the
texts key/language pairs set by <a href="#setText">setText</a>() for this image.
<p> Note that if you want to iterate over the list, you should iterate
over a copy, e.g.
<pre>
    <a href="qvaluelist.html">QValueList</a>&lt;QImageTextKeyLang&gt; list = myImage.textList();
    QValueList&lt;QImageTextKeyLang&gt;::Iterator it = list.<a href="qvaluelist.html#begin">begin</a>();
    while( it != list.<a href="qvaluelist.html#end">end</a>() ) {
        myProcessing( *it );
        ++it;
    }
    </pre>
 

<h3 class=fn>bool <a name="valid"></a>QImage::valid ( int&nbsp;x, int&nbsp;y ) const
</h3>
Returns TRUE if ( <em>x</em>, <em>y</em> ) is a valid coordinate in the image;
otherwise returns FALSE.
<p> <p>See also <a href="#width">width</a>(), <a href="#height">height</a>(), and <a href="#pixelIndex">pixelIndex</a>().

<p>Examples: <a href="canvas-example.html#x2934">canvas/canvas.cpp</a> and <a href="qmag-example.html#x1777">qmag/qmag.cpp</a>.
<h3 class=fn>int <a name="width"></a>QImage::width () const
</h3>

<p> Returns the width of the image.
<p> <p>See also <a href="#height">height</a>(), <a href="#size">size</a>(), and <a href="#rect">rect</a>().

<p>Examples: <a href="canvas-example.html#x2935">canvas/canvas.cpp</a> and <a href="qglwidget.html#x2121">opengl/texture/gltexobj.cpp</a>.
<h3 class=fn><a href="qimage.html">QImage</a> <a name="xForm"></a>QImage::xForm ( const&nbsp;<a href="qwmatrix.html">QWMatrix</a>&nbsp;&amp;&nbsp;matrix ) const
</h3>
Returns a copy of the image that is transformed using the
<a href="qwmatrix.html#TransformationMode">transformation matrix</a>, <em>matrix</em>.
<p> The transformation <em>matrix</em> is internally adjusted to compensate
for unwanted translation, i.e. <a href="#xForm">xForm</a>() returns the smallest image
that contains all the transformed points of the original image.
<p> <p>See also <a href="#scale">scale</a>(), <a href="qpixmap.html#xForm">QPixmap::xForm</a>(), <a href="qpixmap.html#trueMatrix">QPixmap::trueMatrix</a>(), and <a href="qwmatrix.html">QWMatrix</a>.

<hr><h2>Related Functions</h2>
<h3 class=fn>void <a name="bitBlt"></a>bitBlt ( <a href="qimage.html">QImage</a>&nbsp;*&nbsp;dst, int&nbsp;dx, int&nbsp;dy, const&nbsp;<a href="qimage.html">QImage</a>&nbsp;*&nbsp;src, int&nbsp;sx, int&nbsp;sy, int&nbsp;sw, int&nbsp;sh, int&nbsp;conversion_flags )
</h3>

<p> Copies a block of pixels from <em>src</em> to <em>dst</em>. The pixels
copied from source (src) are converted according to
<em>conversion_flags</em> if it is incompatible with the destination
(<em>dst</em>).
<p> <em>sx</em>, <em>sy</em> is the top-left pixel in <em>src</em>, <em>dx</em>, <em>dy</em>
is the top-left position in <em>dst</em> and <em>sw</em>, \sh is the
size of the copied block.
<p> The copying is clipped if areas outside <em>src</em> or <em>dst</em> are
specified.
<p> If <em>sw</em> is -1, it is adjusted to src->width(). Similarly, if <em>sh</em> is -1, it is adjusted to src->height().
<p> Currently inefficient for non 32-bit images.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt"></a>operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;image )
</h3>

<p> Writes the image <em>image</em> to the stream <em>s</em> as a PNG image, or as a
BMP image if the stream's version is 1.
<p> Note that writing the stream to a file will not produce a valid image file.
<p> <p>See also <a href="#save">QImage::save</a>() and <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;image )
</h3>

<p> Reads an image from the stream <em>s</em> and stores it in <em>image</em>.
<p> <p>See also <a href="#load">QImage::load</a>() and <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
