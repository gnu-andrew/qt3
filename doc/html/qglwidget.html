<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/opengl/qgl.cpp:1126 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QGLWidget Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QGLWidget Class Reference<br><small>[<a href="opengl.html">OpenGL module</a>]</small></h1>

<p>The QGLWidget class is a widget for rendering OpenGL graphics.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qgl-h.html">qgl.h</a>&gt;</tt>
<p>Inherits <a href="qwidget.html">QWidget</a> and <a href="qgl.html">QGL</a>.
<p><a href="qglwidget-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QGLWidget"><b>QGLWidget</b></a> ( QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;QGLWidget&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )</li>
<li class=fn><a href="#QGLWidget-2"><b>QGLWidget</b></a> ( QGLContext&nbsp;*&nbsp;context, QWidget&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;QGLWidget&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )</li>
<li class=fn><a href="#QGLWidget-3"><b>QGLWidget</b></a> ( const&nbsp;QGLFormat&nbsp;&amp;&nbsp;format, QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;QGLWidget&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )</li>
<li class=fn><a href="#~QGLWidget"><b>~QGLWidget</b></a> ()</li>
<li class=fn>void <a href="#qglColor"><b>qglColor</b></a> ( const&nbsp;QColor&nbsp;&amp;&nbsp;c ) const</li>
<li class=fn>void <a href="#qglClearColor"><b>qglClearColor</b></a> ( const&nbsp;QColor&nbsp;&amp;&nbsp;c ) const</li>
<li class=fn>bool <a href="#isValid"><b>isValid</b></a> () const</li>
<li class=fn>bool <a href="#isSharing"><b>isSharing</b></a> () const</li>
<li class=fn>virtual void <a href="#makeCurrent"><b>makeCurrent</b></a> ()</li>
<li class=fn>void <a href="#doneCurrent"><b>doneCurrent</b></a> ()</li>
<li class=fn>bool <a href="#doubleBuffer"><b>doubleBuffer</b></a> () const</li>
<li class=fn>virtual void <a href="#swapBuffers"><b>swapBuffers</b></a> ()</li>
<li class=fn>QGLFormat <a href="#format"><b>format</b></a> () const</li>
<li class=fn>const QGLContext * <a href="#context"><b>context</b></a> () const</li>
<li class=fn>virtual QPixmap <a href="#renderPixmap"><b>renderPixmap</b></a> ( int&nbsp;w = 0, int&nbsp;h = 0, bool&nbsp;useContext = FALSE )</li>
<li class=fn>virtual QImage <a href="#grabFrameBuffer"><b>grabFrameBuffer</b></a> ( bool&nbsp;withAlpha = FALSE )</li>
<li class=fn>virtual void <a href="#makeOverlayCurrent"><b>makeOverlayCurrent</b></a> ()</li>
<li class=fn>const QGLContext * <a href="#overlayContext"><b>overlayContext</b></a> () const</li>
<li class=fn>const QGLColormap &amp; <a href="#colormap"><b>colormap</b></a> () const</li>
<li class=fn>void <a href="#setColormap"><b>setColormap</b></a> ( const&nbsp;QGLColormap&nbsp;&amp;&nbsp;cmap )</li>
<li class=fn>void <a href="#renderText"><b>renderText</b></a> ( int&nbsp;x, int&nbsp;y, const&nbsp;QString&nbsp;&amp;&nbsp;str, const&nbsp;QFont&nbsp;&amp;&nbsp;fnt = QFont ( ), int&nbsp;listBase = 2000 )</li>
<li class=fn>void <a href="#renderText-2"><b>renderText</b></a> ( double&nbsp;x, double&nbsp;y, double&nbsp;z, const&nbsp;QString&nbsp;&amp;&nbsp;str, const&nbsp;QFont&nbsp;&amp;&nbsp;fnt = QFont ( ), int&nbsp;listBase = 2000 )</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>virtual void <a href="#updateGL"><b>updateGL</b></a> ()</li>
<li class=fn>virtual void <a href="#updateOverlayGL"><b>updateOverlayGL</b></a> ()</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QImage <a href="#convertToGLFormat"><b>convertToGLFormat</b></a> ( const&nbsp;QImage&nbsp;&amp;&nbsp;img )</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>virtual void <a href="#initializeGL"><b>initializeGL</b></a> ()</li>
<li class=fn>virtual void <a href="#resizeGL"><b>resizeGL</b></a> ( int&nbsp;width, int&nbsp;height )</li>
<li class=fn>virtual void <a href="#paintGL"><b>paintGL</b></a> ()</li>
<li class=fn>virtual void <a href="#initializeOverlayGL"><b>initializeOverlayGL</b></a> ()</li>
<li class=fn>virtual void <a href="#resizeOverlayGL"><b>resizeOverlayGL</b></a> ( int&nbsp;width, int&nbsp;height )</li>
<li class=fn>virtual void <a href="#paintOverlayGL"><b>paintOverlayGL</b></a> ()</li>
<li class=fn>void <a href="#setAutoBufferSwap"><b>setAutoBufferSwap</b></a> ( bool&nbsp;on )</li>
<li class=fn>bool <a href="#autoBufferSwap"><b>autoBufferSwap</b></a> () const</li>
<li class=fn>virtual void <a href="#paintEvent"><b>paintEvent</b></a> ( QPaintEvent * )</li>
<li class=fn>virtual void <a href="#resizeEvent"><b>resizeEvent</b></a> ( QResizeEvent * )</li>
<li class=fn>virtual void <a href="#glInit"><b>glInit</b></a> ()</li>
<li class=fn>virtual void <a href="#glDraw"><b>glDraw</b></a> ()</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QGLWidget class is a widget for rendering OpenGL graphics.

<p> 



<p> QGLWidget provides functionality for displaying OpenGL<sup>*</sup>
graphics integrated into a Qt application. It is very simple to
use. You inherit from it and use the subclass like any other
<a href="qwidget.html">QWidget</a>, except that instead of drawing the widget's contents
using <a href="qpainter.html">QPainter</a> etc. you use the standard OpenGL rendering
commands.
<p> QGLWidget provides three convenient virtual functions that you can
reimplement in your subclass to perform the typical OpenGL tasks:
<p> <ul>
<li> <a href="#paintGL">paintGL</a>() - Renders the OpenGL scene. Gets called whenever the widget
needs to be updated.
<li> <a href="#resizeGL">resizeGL</a>() - Sets up the OpenGL viewport, projection, etc. Gets
called whenever the the widget has been resized (and also when it
is shown for the first time because all newly created widgets get a
resize event automatically).
<li> <a href="#initializeGL">initializeGL</a>() - Sets up the OpenGL rendering context, defines display
lists, etc. Gets called once before the first time resizeGL() or
paintGL() is called.
</ul>
<p> Here is a rough outline of how a QGLWidget subclass might look:
<p> <pre>
    class MyGLDrawer : public QGLWidget
    {
        Q_OBJECT        // must include this if you use Qt signals/slots

    public:
        MyGLDrawer( <a href="qwidget.html">QWidget</a> *parent, const char *name )
            : QGLWidget(parent, name) {}

    protected:

        void initializeGL()
        {
            // Set up the rendering context, define display lists etc.:
            ...
            glClearColor( 0.0, 0.0, 0.0, 0.0 );
            glEnable(GL_DEPTH_TEST);
            ...
        }

        void resizeGL( int w, int h )
        {
            // setup viewport, projection etc.:
            glViewport( 0, 0, (GLint)w, (GLint)h );
            ...
            glFrustum( ... );
            ...
        }

        void paintGL()
        {
            // draw the scene:
            ...
            glRotatef( ... );
            glMaterialfv( ... );
            glBegin( GL_QUADS );
            glVertex3f( ... );
            glVertex3f( ... );
            ...
            glEnd();
            ...
        }

    };
    </pre>
 
<p> If you need to trigger a repaint from places other than <a href="#paintGL">paintGL</a>()
(a typical example is when using <a href="qtimer.html">timers</a> to
animate scenes), you should call the widget's <a href="#updateGL">updateGL</a>() function.
<p> Your widget's OpenGL rendering context is made current when
paintGL(), <a href="#resizeGL">resizeGL</a>(), or <a href="#initializeGL">initializeGL</a>() is called. If you need to
call the standard OpenGL API functions from other places (e.g. in
your widget's constructor or in your own paint functions), you
must call <a href="#makeCurrent">makeCurrent</a>() first.
<p> QGLWidget provides functions for requesting a new display <a href="qglformat.html">format</a> and you can also create widgets with
customized rendering <a href="qglcontext.html">contexts</a>.
<p> You can also share OpenGL display lists between QGLWidgets (see
the documentation of the QGLWidget constructors for details).
<p> <h3> Overlays
</h3>
<a name="1"></a><p> The QGLWidget creates a GL overlay context in addition to the
normal context if overlays are supported by the underlying system.
<p> If you want to use overlays, you specify it in the <a href="qglformat.html">format</a>. (Note: Overlay must be requested in the format
passed to the QGLWidget constructor.) Your GL widget should also
implement some or all of these virtual methods:
<p> <ul>
<li> <a href="#paintOverlayGL">paintOverlayGL</a>()
<li> <a href="#resizeOverlayGL">resizeOverlayGL</a>()
<li> <a href="#initializeOverlayGL">initializeOverlayGL</a>()
</ul>
<p> These methods work in the same way as the normal <a href="#paintGL">paintGL</a>() etc.
functions, except that they will be called when the overlay
context is made current. You can explicitly make the overlay
context current by using <a href="#makeOverlayCurrent">makeOverlayCurrent</a>(), and you can access
the overlay context directly (e.g. to ask for its transparent
color) by calling <a href="#overlayContext">overlayContext</a>().
<p> On X servers in which the default visual is in an overlay plane,
non-GL Qt windows can also be used for overlays. See the
examples/opengl/overlay_x11 example program for details.
<p> <sup>*</sup> OpenGL is a trademark of Silicon Graphics, Inc. in the
United States and other countries.
<p>See also <a href="graphics.html">Graphics Classes</a> and <a href="images.html">Image Processing Classes</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QGLWidget"></a>QGLWidget::QGLWidget ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;<a href="qglwidget.html">QGLWidget</a>&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )
</h3>
Constructs an OpenGL widget with a <em>parent</em> widget and a <em>name</em>.
<p> The <a href="qglformat.html#defaultFormat">default format</a> is
used. The widget will be <a href="#isValid">invalid</a> if the
system has no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.
<p> The <em>parent</em>, <em>name</em> and <a href="qt.html#WidgetFlags">widget flag</a>, <em>f</em>, arguments are passed
to the <a href="qwidget.html">QWidget</a> constructor.
<p> If the <em>shareWidget</em> parameter points to a valid QGLWidget, this
widget will share OpenGL display lists with <em>shareWidget</em>. If
this widget and <em>shareWidget</em> have different <a href="#format">formats</a>, display list sharing may fail. You can check
whether display list sharing succeeded by calling <a href="#isSharing">isSharing</a>().
<p> The initialization of OpenGL rendering state, etc. should be done
by overriding the <a href="#initializeGL">initializeGL</a>() function, rather than in the
constructor of your QGLWidget subclass.
<p> <p>See also <a href="qglformat.html#defaultFormat">QGLFormat::defaultFormat</a>().

<h3 class=fn><a name="QGLWidget-2"></a>QGLWidget::QGLWidget ( <a href="qglcontext.html">QGLContext</a>&nbsp;*&nbsp;context, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;<a href="qglwidget.html">QGLWidget</a>&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )
</h3>
Constructs an OpenGL widget with parent <em>parent</em>, called <em>name</em>.
<p> The <em>context</em> argument is a pointer to the <a href="qglcontext.html">QGLContext</a> that
you wish to be bound to this widget. This allows you to pass in
your own QGLContext sub-classes.
<p> The widget will be <a href="#isValid">invalid</a> if the system
has no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.
<p> The <em>parent</em>, <em>name</em> and <a href="qt.html#WidgetFlags">widget flag</a>, <em>f</em>, arguments are passed
to the <a href="qwidget.html">QWidget</a> constructor.
<p> If the <em>shareWidget</em> parameter points to a valid QGLWidget, this
widget will share OpenGL display lists with <em>shareWidget</em>. If
this widget and <em>shareWidget</em> have different <a href="#format">formats</a>, display list sharing may fail. You can check
whether display list sharing succeeded by calling <a href="#isSharing">isSharing</a>().
<p> The initialization of OpenGL rendering state, etc. should be done
by overriding the <a href="#initializeGL">initializeGL</a>() function, rather than in the
constructor of your QGLWidget subclass.
<p> <p>See also <a href="qglformat.html#defaultFormat">QGLFormat::defaultFormat</a>() and <a href="#isValid">isValid</a>().

<h3 class=fn><a name="QGLWidget-3"></a>QGLWidget::QGLWidget ( const&nbsp;<a href="qglformat.html">QGLFormat</a>&nbsp;&amp;&nbsp;format, <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, const&nbsp;<a href="qglwidget.html">QGLWidget</a>&nbsp;*&nbsp;shareWidget = 0, WFlags&nbsp;f = 0 )
</h3>
Constructs an OpenGL widget with parent <em>parent</em>, called <em>name</em>.
<p> The <em>format</em> argument specifies the desired <a href="qglformat.html">rendering options</a>. If the underlying OpenGL/Window system
cannot satisfy all the features requested in <em>format</em>, the
nearest subset of features will be used. After creation, the
<a href="#format">format</a>() method will return the actual format obtained.
<p> The widget will be <a href="#isValid">invalid</a> if the system
has no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.
<p> The <em>parent</em>, <em>name</em> and <a href="qt.html#WidgetFlags">widget flag</a>, <em>f</em>, arguments are passed
to the <a href="qwidget.html">QWidget</a> constructor.
<p> If the <em>shareWidget</em> parameter points to a valid QGLWidget, this
widget will share OpenGL display lists with <em>shareWidget</em>. If
this widget and <em>shareWidget</em> have different <a href="#format">formats</a>, display list sharing may fail. You can check
whether display list sharing succeeded by calling <a href="#isSharing">isSharing</a>().
<p> The initialization of OpenGL rendering state, etc. should be done
by overriding the <a href="#initializeGL">initializeGL</a>() function, rather than in the
constructor of your QGLWidget subclass.
<p> <p>See also <a href="qglformat.html#defaultFormat">QGLFormat::defaultFormat</a>() and <a href="#isValid">isValid</a>().

<h3 class=fn><a name="~QGLWidget"></a>QGLWidget::~QGLWidget ()
</h3>
Destroys the widget.

<h3 class=fn>bool <a name="autoBufferSwap"></a>QGLWidget::autoBufferSwap () const<tt> [protected]</tt>
</h3>

<p> Returns TRUE if the widget is doing automatic GL buffer swapping;
otherwise returns FALSE.
<p> <p>See also <a href="#setAutoBufferSwap">setAutoBufferSwap</a>().

<h3 class=fn>const&nbsp;<a href="qglcolormap.html">QGLColormap</a>&nbsp;&amp; <a name="colormap"></a>QGLWidget::colormap () const
</h3>

<p> Returns the colormap for this widget.
<p> Usually it is only top-level widgets that can have different
colormaps installed. Asking for the colormap of a child widget
will return the colormap for the child's top-level widget.
<p> If no colormap has been set for this widget, the QColormap
returned will be empty.
<p> <p>See also <a href="#setColormap">setColormap</a>().

<h3 class=fn>const&nbsp;<a href="qglcontext.html">QGLContext</a>&nbsp;* <a name="context"></a>QGLWidget::context () const
</h3>

<p> Returns the context of this widget.
<p> It is possible that the context is not valid (see <a href="#isValid">isValid</a>()), for
example, if the underlying hardware does not support the format
attributes that were requested.

<h3 class=fn><a href="qimage.html">QImage</a> <a name="convertToGLFormat"></a>QGLWidget::convertToGLFormat ( const&nbsp;<a href="qimage.html">QImage</a>&nbsp;&amp;&nbsp;img )<tt> [static]</tt>
</h3>
Converts the image <em>img</em> into the unnamed format expected by
OpenGL functions such as glTexImage2D(). The returned image is not
usable as a <a href="qimage.html">QImage</a>, but <a href="qimage.html#width">QImage::width</a>(), <a href="qimage.html#height">QImage::height</a>() and
<a href="qimage.html#bits">QImage::bits</a>() may be used with OpenGL. The following few lines
are from the texture example. Most of the code is irrelevant, so
we just quote the relevant bits:
<p> 

<pre>        <a href="qimage.html">QImage</a> tex1, tex2, buf;
        if ( !buf.load( "gllogo.bmp" ) ) {  // Load first image from file
</pre>
<p> We create <em>tex1</em> (and another variable) for OpenGL, and load a real
image into <em>buf</em>.
<p> <pre>    <a name="x2118"></a>    tex1 = QGLWidget::<a href="#convertToGLFormat">convertToGLFormat</a>( buf );  // flipped 32bit RGBA
</pre>
<p> A few lines later, we convert <em>buf</em> into OpenGL format and store it
in <em>tex1</em>.
<p> <pre>    <a name="x2121"></a><a name="x2120"></a>    glTexImage2D( GL_TEXTURE_2D, 0, 3, tex1.<a href="qimage.html#width">width</a>(), tex1.<a href="qimage.html#height">height</a>(), 0,
    <a name="x2119"></a>                  GL_RGBA, GL_UNSIGNED_BYTE, tex1.<a href="qimage.html#bits">bits</a>() );
</pre>
<p> Note the dimension restrictions for texture images as described in
the glTexImage2D() documentation. The width must be 2^m + 2*border
and the height 2^n + 2*border where m and n are integers and
border is either 0 or 1.
<p> Another function in the same example uses <em>tex1</em> with OpenGL.

<p>Example: <a href="qglwidget.html#x2118">opengl/texture/gltexobj.cpp</a>.
<h3 class=fn>void <a name="doneCurrent"></a>QGLWidget::doneCurrent ()
</h3>

<p> Makes no GL context the current context. Normally, you do not need
to call this function; <a href="qglcontext.html">QGLContext</a> calls it as necessary. However,
it may be useful in multithreaded environments.

<h3 class=fn>bool <a name="doubleBuffer"></a>QGLWidget::doubleBuffer () const
</h3>

<p> Returns TRUE if the contained GL rendering context has double
buffering; otherwise returns FALSE.
<p> <p>See also <a href="qglformat.html#doubleBuffer">QGLFormat::doubleBuffer</a>().

<h3 class=fn><a href="qglformat.html">QGLFormat</a> <a name="format"></a>QGLWidget::format () const
</h3>

<p> Returns the format of the contained GL rendering context.

<h3 class=fn>void <a name="glDraw"></a>QGLWidget::glDraw ()<tt> [virtual protected]</tt>
</h3>
Executes the virtual function <a href="#paintGL">paintGL</a>().
<p> The widget's rendering context will become the current context and
<a href="#initializeGL">initializeGL</a>() will be called if it hasn't already been called.

<h3 class=fn>void <a name="glInit"></a>QGLWidget::glInit ()<tt> [virtual protected]</tt>
</h3>
Initializes OpenGL for this widget's context. Calls the virtual
function <a href="#initializeGL">initializeGL</a>().

<h3 class=fn><a href="qimage.html">QImage</a> <a name="grabFrameBuffer"></a>QGLWidget::grabFrameBuffer ( bool&nbsp;withAlpha = FALSE )<tt> [virtual]</tt>
</h3>
Returns an image of the frame buffer. If <em>withAlpha</em> is TRUE the
alpha channel is included.
<p> Depending on your hardware, you can explicitly select which color
buffer to grab with a glReadBuffer() call before calling this
function.

<h3 class=fn>void <a name="initializeGL"></a>QGLWidget::initializeGL ()<tt> [virtual protected]</tt>
</h3>
This virtual function is called once before the first call to
<a href="#paintGL">paintGL</a>() or <a href="#resizeGL">resizeGL</a>(), and then once whenever the widget has
been assigned a new <a href="qglcontext.html">QGLContext</a>. Reimplement it in a subclass.
<p> This function should set up any required OpenGL context rendering
flags, defining display lists, etc.
<p> There is no need to call <a href="#makeCurrent">makeCurrent</a>() because this has already
been done when this function is called.

<h3 class=fn>void <a name="initializeOverlayGL"></a>QGLWidget::initializeOverlayGL ()<tt> [virtual protected]</tt>
</h3>
This virtual function is used in the same manner as <a href="#initializeGL">initializeGL</a>()
except that it operates on the widget's overlay context instead of
the widget's main context. This means that <a href="#initializeOverlayGL">initializeOverlayGL</a>()
is called once before the first call to <a href="#paintOverlayGL">paintOverlayGL</a>() or
<a href="#resizeOverlayGL">resizeOverlayGL</a>(). Reimplement it in a subclass.
<p> This function should set up any required OpenGL context rendering
flags, defining display lists, etc. for the overlay context.
<p> There is no need to call <a href="#makeOverlayCurrent">makeOverlayCurrent</a>() because this has
already been done when this function is called.

<h3 class=fn>bool <a name="isSharing"></a>QGLWidget::isSharing () const
</h3>

<p> Returns TRUE if display list sharing with another QGLWidget was
requested in the constructor, and the GL system was able to
provide it; otherwise returns FALSE. The GL system may fail to
provide display list sharing if the two QGLWidgets use different
formats.
<p> <p>See also <a href="#format">format</a>().

<h3 class=fn>bool <a name="isValid"></a>QGLWidget::isValid () const
</h3>

<p> Returns TRUE if the widget has a valid GL rendering context;
otherwise returns FALSE. A widget will be invalid if the system
has no <a href="qglformat.html#hasOpenGL">OpenGL support</a>.

<h3 class=fn>void <a name="makeCurrent"></a>QGLWidget::makeCurrent ()<tt> [virtual]</tt>
</h3>

<p> Makes this widget the current widget for OpenGL operations, i.e.
makes the widget's rendering context the current OpenGL rendering
context.

<h3 class=fn>void <a name="makeOverlayCurrent"></a>QGLWidget::makeOverlayCurrent ()<tt> [virtual]</tt>
</h3>

<p> Makes the overlay context of this widget current. Use this if you
need to issue OpenGL commands to the overlay context outside of
<a href="#initializeOverlayGL">initializeOverlayGL</a>(), <a href="#resizeOverlayGL">resizeOverlayGL</a>(), and <a href="#paintOverlayGL">paintOverlayGL</a>().
<p> Does nothing if this widget has no overlay.
<p> <p>See also <a href="#makeCurrent">makeCurrent</a>().

<h3 class=fn>const&nbsp;<a href="qglcontext.html">QGLContext</a>&nbsp;* <a name="overlayContext"></a>QGLWidget::overlayContext () const
</h3>

<p> Returns the overlay context of this widget, or 0 if this widget
has no overlay.
<p> <p>See also <a href="#context">context</a>().

<h3 class=fn>void <a name="paintEvent"></a>QGLWidget::paintEvent ( <a href="qpaintevent.html">QPaintEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
Handles paint events. Will cause the virtual <a href="#paintGL">paintGL</a>() function to
be called.
<p> The widget's rendering context will become the current context and
<a href="#initializeGL">initializeGL</a>() will be called if it hasn't already been called.

<p>Reimplemented from <a href="qwidget.html#paintEvent">QWidget</a>.
<h3 class=fn>void <a name="paintGL"></a>QGLWidget::paintGL ()<tt> [virtual protected]</tt>
</h3>
This virtual function is called whenever the widget needs to be
painted. Reimplement it in a subclass.
<p> There is no need to call <a href="#makeCurrent">makeCurrent</a>() because this has already
been done when this function is called.

<h3 class=fn>void <a name="paintOverlayGL"></a>QGLWidget::paintOverlayGL ()<tt> [virtual protected]</tt>
</h3>
This virtual function is used in the same manner as <a href="#paintGL">paintGL</a>()
except that it operates on the widget's overlay context instead of
the widget's main context. This means that <a href="#paintOverlayGL">paintOverlayGL</a>() is
called whenever the widget's overlay needs to be painted.
Reimplement it in a subclass.
<p> There is no need to call <a href="#makeOverlayCurrent">makeOverlayCurrent</a>() because this has
already been done when this function is called.

<h3 class=fn>void <a name="qglClearColor"></a>QGLWidget::qglClearColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp;&nbsp;c ) const
</h3>
Convenience function for specifying the clearing color to OpenGL.
Calls glClearColor (in RGBA mode) or glClearIndex (in color-index
mode) with the color <em>c</em>. Applies to the current GL context.
<p> <p>See also <a href="#qglColor">qglColor</a>(), <a href="qglcontext.html#currentContext">QGLContext::currentContext</a>(), and <a href="qcolor.html">QColor</a>.

<h3 class=fn>void <a name="qglColor"></a>QGLWidget::qglColor ( const&nbsp;<a href="qcolor.html">QColor</a>&nbsp;&amp;&nbsp;c ) const
</h3>
Convenience function for specifying a drawing color to OpenGL.
Calls glColor3 (in RGBA mode) or glIndex (in color-index mode)
with the color <em>c</em>. Applies to the current GL context.
<p> <p>See also <a href="#qglClearColor">qglClearColor</a>(), <a href="qglcontext.html#currentContext">QGLContext::currentContext</a>(), and <a href="qcolor.html">QColor</a>.

<h3 class=fn><a href="qpixmap.html">QPixmap</a> <a name="renderPixmap"></a>QGLWidget::renderPixmap ( int&nbsp;w = 0, int&nbsp;h = 0, bool&nbsp;useContext = FALSE )<tt> [virtual]</tt>
</h3>
Renders the current scene on a pixmap and returns the pixmap.
<p> You can use this method on both visible and invisible QGLWidgets.
<p> This method will create a pixmap and a temporary <a href="qglcontext.html">QGLContext</a> to
render on the pixmap. It will then call <a href="#initializeGL">initializeGL</a>(),
<a href="#resizeGL">resizeGL</a>(), and <a href="#paintGL">paintGL</a>() on this context. Finally, the widget's
original GL context is restored.
<p> The size of the pixmap will be <em>w</em> pixels wide and <em>h</em> pixels
high unless one of these parameters is 0 (the default), in which
case the pixmap will have the same size as the widget.
<p> If <em>useContext</em> is TRUE, this method will try to be more
efficient by using the existing GL context to render the pixmap.
The default is FALSE. Only use TRUE if you understand the risks.
<p> Overlays are not rendered onto the pixmap.
<p> If the GL rendering context and the desktop have different bit
depths, the result will most likely look surprising.
<p> Note that the creation of display lists, modifications of the view
frustum etc. should be done from within initializeGL(). If this is
not done, the temporary QGLContext will not be initialized
properly, and the rendered pixmap may be incomplete/corrupted.

<h3 class=fn>void <a name="renderText"></a>QGLWidget::renderText ( int&nbsp;x, int&nbsp;y, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp;&nbsp;fnt = QFont ( ), int&nbsp;listBase = 2000 )
</h3>
Renders the string <em>str</em> into the GL context of this widget.
<p> <em>x</em> and <em>y</em> are specified in window coordinates, with the origin
in the upper left-hand corner of the window. If <em>fnt</em> is not
specified, the currently set application font will be used to
render the string. To change the color of the rendered text you can
use the glColor() call (or the <a href="#qglColor">qglColor</a>() convenience function),
just before the <a href="#renderText">renderText</a>() call. Note that if you have
GL_LIGHTING enabled, the string will not appear in the color you
want. You should therefore switch lighting off before using
renderText().
<p> <em>listBase</em> specifies the index of the first display list that is
generated by this function. The default value is 2000. 256 display
lists will be generated, one for each of the first 256 characters
in the font that is used to render the string. If several fonts are
used in the same widget, the display lists for these fonts will
follow the last generated list. You would normally not have to
change this value unless you are using lists in the same range. The
lists are deleted when the widget is destroyed.
<p> Note: This function only works reliably with ASCII strings.

<h3 class=fn>void <a name="renderText-2"></a>QGLWidget::renderText ( double&nbsp;x, double&nbsp;y, double&nbsp;z, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str, const&nbsp;<a href="qfont.html">QFont</a>&nbsp;&amp;&nbsp;fnt = QFont ( ), int&nbsp;listBase = 2000 )
</h3> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <em>x</em>, <em>y</em> and <em>z</em> are specified in scene or object coordinates
relative to the currently set projection and model matrices. This
can be useful if you want to annotate models with text labels and
have the labels move with the model as it is rotated etc.

<h3 class=fn>void <a name="resizeEvent"></a>QGLWidget::resizeEvent ( <a href="qresizeevent.html">QResizeEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>

<p> Handles resize events. Calls the virtual function <a href="#resizeGL">resizeGL</a>().

<p>Reimplemented from <a href="qwidget.html#resizeEvent">QWidget</a>.
<h3 class=fn>void <a name="resizeGL"></a>QGLWidget::resizeGL ( int&nbsp;width, int&nbsp;height )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called whenever the widget has been
resized. The new size is passed in <em>width</em> and <em>height</em>.
Reimplement it in a subclass.
<p> There is no need to call <a href="#makeCurrent">makeCurrent</a>() because this has already
been done when this function is called.

<h3 class=fn>void <a name="resizeOverlayGL"></a>QGLWidget::resizeOverlayGL ( int&nbsp;width, int&nbsp;height )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is used in the same manner as <a href="#paintGL">paintGL</a>()
except that it operates on the widget's overlay context instead of
the widget's main context. This means that <a href="#resizeOverlayGL">resizeOverlayGL</a>() is
called whenever the widget has been resized. The new size is
passed in <em>width</em> and <em>height</em>. Reimplement it in a subclass.
<p> There is no need to call <a href="#makeOverlayCurrent">makeOverlayCurrent</a>() because this has
already been done when this function is called.

<h3 class=fn>void <a name="setAutoBufferSwap"></a>QGLWidget::setAutoBufferSwap ( bool&nbsp;on )<tt> [protected]</tt>
</h3>

<p> If <em>on</em> is TRUE automatic GL buffer swapping is switched on;
otherwise it is switched off.
<p> If <em>on</em> is TRUE and the widget is using a double-buffered format,
the background and foreground GL buffers will automatically be
swapped after each <a href="#paintGL">paintGL</a>() call.
<p> The buffer auto-swapping is on by default.
<p> <p>See also <a href="#autoBufferSwap">autoBufferSwap</a>(), <a href="#doubleBuffer">doubleBuffer</a>(), and <a href="#swapBuffers">swapBuffers</a>().

<h3 class=fn>void <a name="setColormap"></a>QGLWidget::setColormap ( const&nbsp;<a href="qglcolormap.html">QGLColormap</a>&nbsp;&amp;&nbsp;cmap )
</h3>

<p> Set the colormap for this widget to <em>cmap</em>. Usually it is only
top-level widgets that can have colormaps installed.
<p> <p>See also <a href="#colormap">colormap</a>().

<h3 class=fn>void <a name="swapBuffers"></a>QGLWidget::swapBuffers ()<tt> [virtual]</tt>
</h3>

<p> Swaps the screen contents with an off-screen buffer. This only
works if the widget's format specifies double buffer mode.
<p> Normally, there is no need to explicitly call this function
because it is done automatically after each widget repaint, i.e.
each time after <a href="#paintGL">paintGL</a>() has been executed.
<p> <p>See also <a href="#doubleBuffer">doubleBuffer</a>(), <a href="#setAutoBufferSwap">setAutoBufferSwap</a>(), and <a href="qglformat.html#setDoubleBuffer">QGLFormat::setDoubleBuffer</a>().

<h3 class=fn>void <a name="updateGL"></a>QGLWidget::updateGL ()<tt> [virtual slot]</tt>
</h3>

<p> Updates the widget by calling <a href="#glDraw">glDraw</a>().

<h3 class=fn>void <a name="updateOverlayGL"></a>QGLWidget::updateOverlayGL ()<tt> [virtual slot]</tt>
</h3>

<p> Updates the widget's overlay (if any). Will cause the virtual
function <a href="#paintOverlayGL">paintOverlayGL</a>() to be executed.
<p> The widget's rendering context will become the current context and
<a href="#initializeGL">initializeGL</a>() will be called if it hasn't already been called.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
