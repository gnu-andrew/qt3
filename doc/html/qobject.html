<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qobject.cpp:105 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QObject Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QObject Class Reference</h1>

<p>The QObject class is the base class of all Qt objects.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qobject-h.html">qobject.h</a>&gt;</tt>
<p>Inherits <a href="qt.html">Qt</a>.
<p>Inherited by <a href="qaccel.html">QAccel</a>, <a href="qaccessibleobject.html">QAccessibleObject</a>, <a href="qaction.html">QAction</a>, <a href="qapplication.html">QApplication</a>, <a href="qassistantclient.html">QAssistantClient</a>, <a href="qdatapump.html">QDataPump</a>, <a href="qaxobject.html">QAxObject</a>, <a href="qaxscript.html">QAxScript</a>, <a href="qaxscriptmanager.html">QAxScriptManager</a>, <a href="qwidget.html">QWidget</a>, <a href="qcanvas.html">QCanvas</a>, <a href="qstyle.html">QStyle</a>, <a href="qclipboard.html">QClipboard</a>, <a href="qcopchannel.html">QCopChannel</a>, <a href="qdns.html">QDns</a>, <a href="qlayout.html">QLayout</a>, <a href="qdragobject.html">QDragObject</a>, <a href="qeditorfactory.html">QEditorFactory</a>, <a href="qeventloop.html">QEventLoop</a>, <a href="qfileiconprovider.html">QFileIconProvider</a>, <a href="qnetworkprotocol.html">QNetworkProtocol</a>, <a href="qwskeyboardhandler.html">QWSKeyboardHandler</a>, <a href="qnetworkoperation.html">QNetworkOperation</a>, <a href="qnpinstance.html">QNPInstance</a>, <a href="qobjectcleanuphandler.html">QObjectCleanupHandler</a>, <a href="qprocess.html">QProcess</a>, <a href="qserversocket.html">QServerSocket</a>, <a href="qsessionmanager.html">QSessionManager</a>, <a href="qsignal.html">QSignal</a>, <a href="qsignalmapper.html">QSignalMapper</a>, <a href="qsocket.html">QSocket</a>, <a href="qsocketnotifier.html">QSocketNotifier</a>, <a href="qsound.html">QSound</a>, <a href="qsqldatabase.html">QSqlDatabase</a>, <a href="qsqldriver.html">QSqlDriver</a>, <a href="qsqlform.html">QSqlForm</a>, <a href="qstylesheet.html">QStyleSheet</a>, <a href="qtimer.html">QTimer</a>, <a href="qtooltipgroup.html">QToolTipGroup</a>, <a href="qtranslator.html">QTranslator</a>, <a href="qurloperator.html">QUrlOperator</a>, and <a href="qvalidator.html">QValidator</a>.
<p><a href="qobject-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QObject"><b>QObject</b></a> ( QObject&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn>virtual <a href="#~QObject"><b>~QObject</b></a> ()</li>
<li class=fn>virtual const char * <a href="#className"><b>className</b></a> () const</li>
<li class=fn>virtual QMetaObject * <a href="#metaObject"><b>metaObject</b></a> () const</li>
<li class=fn>virtual bool <a href="#event"><b>event</b></a> ( QEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual bool <a href="#eventFilter"><b>eventFilter</b></a> ( QObject&nbsp;*&nbsp;watched, QEvent&nbsp;*&nbsp;e )</li>
<li class=fn>bool <a href="#isA"><b>isA</b></a> ( const&nbsp;char&nbsp;*&nbsp;clname ) const</li>
<li class=fn>bool <a href="#inherits"><b>inherits</b></a> ( const&nbsp;char&nbsp;*&nbsp;clname ) const</li>
<li class=fn>const char * <a href="#name"><b>name</b></a> () const</li>
<li class=fn>const char * <a href="#name-2"><b>name</b></a> ( const&nbsp;char&nbsp;*&nbsp;defaultName ) const</li>
<li class=fn>virtual void <a href="#setName"><b>setName</b></a> ( const&nbsp;char&nbsp;*&nbsp;name )</li>
<li class=fn>bool <a href="#isWidgetType"><b>isWidgetType</b></a> () const</li>
<li class=fn>bool <a href="#highPriority"><b>highPriority</b></a> () const</li>
<li class=fn>bool <a href="#signalsBlocked"><b>signalsBlocked</b></a> () const</li>
<li class=fn>void <a href="#blockSignals"><b>blockSignals</b></a> ( bool&nbsp;block )</li>
<li class=fn>int <a href="#startTimer"><b>startTimer</b></a> ( int&nbsp;interval )</li>
<li class=fn>void <a href="#killTimer"><b>killTimer</b></a> ( int&nbsp;id )</li>
<li class=fn>void <a href="#killTimers"><b>killTimers</b></a> ()</li>
<li class=fn>QObject * <a href="#child"><b>child</b></a> ( const&nbsp;char&nbsp;*&nbsp;objName, const&nbsp;char&nbsp;*&nbsp;inheritsClass = 0, bool&nbsp;recursiveSearch = TRUE )</li>
<li class=fn>const QObjectList * <a href="#children"><b>children</b></a> () const</li>
<li class=fn>QObjectList * <a href="#queryList"><b>queryList</b></a> ( const&nbsp;char&nbsp;*&nbsp;inheritsClass = 0, const&nbsp;char&nbsp;*&nbsp;objName = 0, bool&nbsp;regexpMatch = TRUE, bool&nbsp;recursiveSearch = TRUE ) const</li>
<li class=fn>virtual void <a href="#insertChild"><b>insertChild</b></a> ( QObject&nbsp;*&nbsp;obj )</li>
<li class=fn>virtual void <a href="#removeChild"><b>removeChild</b></a> ( QObject&nbsp;*&nbsp;obj )</li>
<li class=fn>void <a href="#installEventFilter"><b>installEventFilter</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;filterObj )</li>
<li class=fn>void <a href="#removeEventFilter"><b>removeEventFilter</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;obj )</li>
<li class=fn>bool <a href="#connect-2"><b>connect</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;char&nbsp;*&nbsp;member ) const</li>
<li class=fn>bool <a href="#disconnect-2"><b>disconnect</b></a> ( const&nbsp;char&nbsp;*&nbsp;signal = 0, const&nbsp;QObject&nbsp;*&nbsp;receiver = 0, const&nbsp;char&nbsp;*&nbsp;member = 0 )</li>
<li class=fn>bool <a href="#disconnect-3"><b>disconnect</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member = 0 )</li>
<li class=fn>void <a href="#dumpObjectTree"><b>dumpObjectTree</b></a> ()</li>
<li class=fn>void <a href="#dumpObjectInfo"><b>dumpObjectInfo</b></a> ()</li>
<li class=fn>virtual bool <a href="#setProperty"><b>setProperty</b></a> ( const&nbsp;char&nbsp;*&nbsp;name, const&nbsp;QVariant&nbsp;&amp;&nbsp;value )</li>
<li class=fn>virtual QVariant <a href="#property"><b>property</b></a> ( const&nbsp;char&nbsp;*&nbsp;name ) const</li>
<li class=fn>QObject * <a href="#parent"><b>parent</b></a> () const</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>void <a href="#deleteLater"><b>deleteLater</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#destroyed"><b>destroyed</b></a> ()</li>
<li class=fn>void <a href="#destroyed-2"><b>destroyed</b></a> ( QObject&nbsp;*&nbsp;obj )</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>QString <a href="#tr"><b>tr</b></a> ( const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment )</li>
<li class=fn>QString <a href="#trUtf8"><b>trUtf8</b></a> ( const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment )</li>
<li class=fn>const QObjectList * <a href="#objectTrees"><b>objectTrees</b></a> ()</li>
<li class=fn>bool <a href="#connect"><b>connect</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;QObject&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )</li>
<li class=fn>bool <a href="#disconnect"><b>disconnect</b></a> ( const&nbsp;QObject&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;QObject&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )</li>
</ul>
<h2>Properties</h2>
<ul>
<li class=fn>QCString <a href="#name-prop"><b>name</b></a>&nbsp;- the name of this object</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>const QObject * <a href="#sender"><b>sender</b></a> ()</li>
<li class=fn>virtual void <a href="#timerEvent"><b>timerEvent</b></a> ( QTimerEvent * )</li>
<li class=fn>virtual void <a href="#childEvent"><b>childEvent</b></a> ( QChildEvent * )</li>
<li class=fn>virtual void <a href="#customEvent"><b>customEvent</b></a> ( QCustomEvent * )</li>
<li class=fn>virtual void <a href="#connectNotify"><b>connectNotify</b></a> ( const&nbsp;char&nbsp;*&nbsp;signal )</li>
<li class=fn>virtual void <a href="#disconnectNotify"><b>disconnectNotify</b></a> ( const&nbsp;char&nbsp;*&nbsp;signal )</li>
<li class=fn>virtual bool <a href="#checkConnectArgs"><b>checkConnectArgs</b></a> ( const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;QObject&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )</li>
</ul>
<h2>Static Protected Members</h2>
<ul>
<li class=fn>QCString <a href="#normalizeSignalSlot"><b>normalizeSignalSlot</b></a> ( const&nbsp;char&nbsp;*&nbsp;signalSlot )</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>void * <a href="#qt_find_obj_child"><b>qt_find_obj_child</b></a> ( QObject&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;type, const&nbsp;char&nbsp;*&nbsp;name )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QObject class is the base class of all Qt objects.
<p> 


<p> QObject is the heart of the <a href="object.html">Qt object model.</a> The central feature in this model is a very powerful
mechanism for seamless object communication called <a href="signalsandslots.html">signals and slots</a>. You can
connect a signal to a slot with <a href="#connect">connect</a>() and destroy the
connection with <a href="#disconnect">disconnect</a>(). To avoid never ending notification
loops you can temporarily block signals with <a href="#blockSignals">blockSignals</a>(). The
protected functions <a href="#connectNotify">connectNotify</a>() and <a href="#disconnectNotify">disconnectNotify</a>() make it
possible to track connections.
<p> QObjects organize themselves in object trees. When you create a
QObject with another object as parent, the object will
automatically do an <a href="#insertChild">insertChild</a>() on the parent and thus show up
in the parent's <a href="#children">children</a>() list. The parent takes ownership of the
object i.e. it will automatically delete its children in its
destructor. You can look for an object by name and optionally type
using <a href="#child">child</a>() or <a href="#queryList">queryList</a>(), and get the list of tree roots using
<a href="#objectTrees">objectTrees</a>().
<p> Every object has an object <a href="#name">name</a>() and can report its <a href="#className">className</a>()
and whether it <a href="#inherits">inherits</a>() another class in the QObject inheritance
hierarchy.
<p> When an object is deleted, it emits a <a href="#destroyed">destroyed</a>() signal. You can
catch this signal to avoid dangling references to QObjects. The
<a href="qguardedptr.html">QGuardedPtr</a> class provides an elegant way to use this feature.
<p> QObjects can receive events through <a href="#event">event</a>() and filter the events
of other objects. See <a href="#installEventFilter">installEventFilter</a>() and <a href="#eventFilter">eventFilter</a>() for
details. A convenience handler, <a href="#childEvent">childEvent</a>(), can be reimplemented
to catch child events.
<p> Last but not least, QObject provides the basic timer support in
Qt; see <a href="qtimer.html">QTimer</a> for high-level support for timers.
<p> Notice that the <a href="metaobjects.html#Q_OBJECT">Q_OBJECT</a> macro is mandatory for any object that
implements signals, slots or properties. You also need to run the
<a href="moc.html">moc program (Meta Object Compiler)</a> on the
source file. We strongly recommend the use of this macro in <em>all</em>
subclasses of QObject regardless of whether or not they actually
use signals, slots and properties, since failure to do so may lead
certain functions to exhibit undefined behaviour.
<p> All Qt widgets inherit QObject. The convenience function
<a href="#isWidgetType">isWidgetType</a>() returns whether an object is actually a widget. It
is much faster than <a href="#inherits">inherits</a>( "QWidget" ).
<p> Some QObject functions, e.g. <a href="#children">children</a>(), <a href="#objectTrees">objectTrees</a>() and
<a href="#queryList">queryList</a>() return a <a href="qobjectlist.html">QObjectList</a>. A QObjectList is a <a href="qptrlist.html">QPtrList</a> of
QObjects. QObjectLists support the same operations as QPtrLists
and have an iterator class, QObjectListIt.
<p>See also <a href="objectmodel.html">Object Model</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QObject"></a>QObject::QObject ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Constructs an object called <em>name</em> with parent object, <em>parent</em>.
<p> The parent of an object may be viewed as the object's owner. For
instance, a <a href="qdialog.html">dialog box</a> is the parent of the
"OK" and "Cancel" buttons it contains.
<p> The destructor of a parent object destroys all child objects.
<p> Setting <em>parent</em> to 0 constructs an object with no parent. If the
object is a widget, it will become a top-level window.
<p> The object name is some text that can be used to identify a
QObject. It's particularly useful in conjunction with <a href="designer-manual.html"><i>Qt Designer</i></a>. You can find an
object by name (and type) using <a href="#child">child</a>(). To find several objects
use <a href="#queryList">queryList</a>().
<p> <p>See also <a href="#parent">parent</a>(), <a href="#name-prop">name</a>, <a href="#child">child</a>(), and <a href="#queryList">queryList</a>().

<h3 class=fn><a name="~QObject"></a>QObject::~QObject ()<tt> [virtual]</tt>
</h3>
Destroys the object, deleting all its child objects.
<p> All signals to and from the object are automatically disconnected.
<p> <b>Warning:</b> All child objects are deleted. If any of these objects
are on the stack or global, sooner or later your program will
crash. We do not recommend holding pointers to child objects from
outside the parent. If you still do, the <a href="#destroyed">QObject::destroyed</a>()
signal gives you an opportunity to detect when an object is
destroyed.
<p> <b>Warning:</b> Deleting a QObject while pending events are waiting to be
delivered can cause a crash.  You must not delete the QObject
directly from a thread that is not the GUI thread.  Use the
<a href="#deleteLater">QObject::deleteLater</a>() method instead, which will cause the event
loop to delete the object after all pending events have been
delivered to the object.

<h3 class=fn>void <a name="blockSignals"></a>QObject::blockSignals ( bool&nbsp;block )
</h3>
Blocks signals if <em>block</em> is TRUE, or unblocks signals if <em>block</em> is FALSE.
<p> Emitted signals disappear into hyperspace if signals are blocked.
Note that the <a href="#destroyed">destroyed</a>() signals will be emitted even if the signals
for this object have been blocked.

<p>Examples: <a href="rot-example.html#x1371">rot13/rot13.cpp</a> and <a href="qaxserver-example-simple.html#x2525">simple/main.cpp</a>.
<h3 class=fn>bool <a name="checkConnectArgs"></a>QObject::checkConnectArgs ( const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )<tt> [virtual protected]</tt>
</h3>

<p> Returns TRUE if the <em>signal</em> and the <em>member</em> arguments are
compatible; otherwise returns FALSE. (The <em>receiver</em> argument is
currently ignored.)
<p> <b>Warning:</b> We recommend that you use the default implementation and
do not reimplement this function.
<p> 

<h3 class=fn><a href="qobject.html">QObject</a>&nbsp;* <a name="child"></a>QObject::child ( const&nbsp;char&nbsp;*&nbsp;objName, const&nbsp;char&nbsp;*&nbsp;inheritsClass = 0, bool&nbsp;recursiveSearch = TRUE )
</h3>
Searches the children and optionally grandchildren of this object,
and returns a child that is called <em>objName</em> that inherits <em>inheritsClass</em>. If <em>inheritsClass</em> is 0 (the default), any class
matches.
<p> If <em>recursiveSearch</em> is TRUE (the default), <a href="#child">child</a>() performs a
depth-first search of the object's children.
<p> If there is no such object, this function returns 0. If there are
more than one, the first one found is retured; if you need all of
them, use <a href="#queryList">queryList</a>().

<h3 class=fn>void <a name="childEvent"></a>QObject::childEvent ( <a href="qchildevent.html">QChildEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
child events.
<p> Child events are sent to objects when children are inserted or
removed.
<p> Note that events with <a href="qevent.html#type">QEvent::type</a>() <a href="qevent.html#Type-enum">QEvent::ChildInserted</a> are
posted (with <a href="qapplication.html#postEvent">QApplication::postEvent</a>()) to make sure that the
child's construction is completed before this function is called.
<p> If a child is removed immediately after it is inserted, the <tt>ChildInserted</tt> event may be suppressed, but the <tt>ChildRemoved</tt>
event will always be sent. In such cases it is possible that there
will be a <tt>ChildRemoved</tt> event without a corresponding <tt>ChildInserted</tt> event.
<p> If you change state based on <tt>ChildInserted</tt> events, call
<a href="qwidget.html#constPolish">QWidget::constPolish</a>(), or do
<pre>
        QApplication::<a href="qapplication.html#sendPostedEvents">sendPostedEvents</a>( this, QEvent::ChildInserted );
    </pre>
 
in functions that depend on the state. One notable example is
<a href="qwidget.html#sizeHint">QWidget::sizeHint</a>().
<p> <p>See also <a href="#event">event</a>() and <a href="qchildevent.html">QChildEvent</a>.

<p>Reimplemented in <a href="qmainwindow.html#childEvent">QMainWindow</a> and <a href="qsplitter.html#childEvent">QSplitter</a>.
<h3 class=fn>const&nbsp;<a href="qobjectlist.html">QObjectList</a>&nbsp;* <a name="children"></a>QObject::children () const
</h3>

<p> Returns a list of child objects, or 0 if this object has no
children.
<p> The <a href="qobjectlist.html">QObjectList</a> class is defined in the <a href="qobjectlist-h.html">qobjectlist.h</a> header
file.
<p> The first child added is the <a href="qptrlist.html#first">first</a>
object in the list and the last child added is the <a href="qptrlist.html#last">last</a> object in the list, i.e. new
children are appended at the end.
<p> Note that the list order changes when <a href="qwidget.html">QWidget</a> children are <a href="qwidget.html#raise">raised</a> or <a href="qwidget.html#lower">lowered.</a> A widget that is raised becomes the last object
in the list, and a widget that is lowered becomes the first object
in the list.
<p> <p>See also <a href="#child">child</a>(), <a href="#queryList">queryList</a>(), <a href="#parent">parent</a>(), <a href="#insertChild">insertChild</a>(), and <a href="#removeChild">removeChild</a>().

<h3 class=fn>const char * <a name="className"></a>QObject::className () const<tt> [virtual]</tt>
</h3>

<p> Returns the class name of this object.
<p> This function is generated by the <a href="metaobjects.html">Meta
    Object Compiler.</a>
<p> <b>Warning:</b> This function will return the wrong name if the class
definition lacks the <a href="metaobjects.html#Q_OBJECT">Q_OBJECT</a> macro.
<p> <p>See also <a href="#name-prop">name</a>, <a href="#inherits">inherits</a>(), <a href="#isA">isA</a>(), and <a href="#isWidgetType">isWidgetType</a>().

<p>Example: <a href="sql.html#x2235">sql/overview/custom1/main.cpp</a>.
<h3 class=fn>bool <a name="connect"></a>QObject::connect ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )<tt> [static]</tt>
</h3>
Connects <em>signal</em> from the <em>sender</em> object to <em>member</em> in object
<em>receiver</em>, and returns TRUE if the connection succeeds; otherwise
returns FALSE.
<p> You must use the SIGNAL() and SLOT() macros when specifying the <em>signal</em>
and the <em>member</em>, for example:
<pre>
    <a href="qlabel.html">QLabel</a>     *label  = new <a href="qlabel.html">QLabel</a>;
    <a href="qscrollbar.html">QScrollBar</a> *scroll = new <a href="qscrollbar.html">QScrollBar</a>;
    QObject::<a href="#connect">connect</a>( scroll, SIGNAL(<a href="qscrollbar.html#valueChanged">valueChanged</a>(int)),
                      label,  SLOT(<a href="qlabel.html#setNum">setNum</a>(int)) );
    </pre>
 
<p> This example ensures that the label always displays the current
scroll bar value. Note that the signal and slots parameters must not
contain any variable names, only the type. E.g. the following would
not work and return FALSE:
<a href="#connect">QObject::connect</a>( scroll, SIGNAL(valueChanged(int v)),
label,  SLOT(setNum(int v)) );
<p> A signal can also be connected to another signal:
<p> <pre>
    class MyWidget : public <a href="qwidget.html">QWidget</a>
    {
        <a href="metaobjects.html#Q_OBJECT">Q_OBJECT</a>
    public:
        MyWidget();

    signals:
        void myUsefulSignal();

    private:
        <a href="qpushbutton.html">QPushButton</a> *aButton;
    };

    MyWidget::MyWidget()
    {
        aButton = new <a href="qpushbutton.html">QPushButton</a>( this );
        <a href="#connect">connect</a>( aButton, SIGNAL(<a href="qbutton.html#clicked">clicked</a>()), SIGNAL(myUsefulSignal()) );
    }
    </pre>
 
<p> In this example, the MyWidget constructor relays a signal from a
private member variable, and makes it available under a name that
relates to MyWidget.
<p> A signal can be connected to many slots and signals. Many signals
can be connected to one slot.
<p> If a signal is connected to several slots, the slots are activated
in an arbitrary order when the signal is emitted.
<p> The function returns TRUE if it successfully connects the signal
to the slot. It will return FALSE if it cannot create the
connection, for example, if QObject is unable to verify the
existence of either <em>signal</em> or <em>member</em>, or if their signatures
aren't compatible.
<p> A signal is emitted for <em>every</em> connection you make, so if you
duplicate a connection, two signals will be emitted. You can
always break a connection using <a href="#disconnect">disconnect</a>().
<p> <p>See also <a href="#disconnect">disconnect</a>().

<p>Examples: <a href="qaction-application-example.html#x1179">action/main.cpp</a>, <a href="simple-application-example.html#x1599">application/main.cpp</a>, <a href="extension-dialog-example.html#x2868">extension/main.cpp</a>, <a href="iconview-example.html#x1460">iconview/main.cpp</a>, <a href="archivesearch-example.html#x489">network/archivesearch/main.cpp</a>, <a href="regexptester-example.html#x2512">regexptester/main.cpp</a>, and <a href="tutorial1-02.html#x2291">t2/main.cpp</a>.
<h3 class=fn>bool <a name="connect-2"></a>QObject::connect ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;char&nbsp;*&nbsp;member ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Connects <em>signal</em> from the <em>sender</em> object to this object's <em>member</em>.
<p> Equivalent to: <tt>QObject::connect(sender, signal, this, member)</tt>.
<p> <p>See also <a href="#disconnect">disconnect</a>().

<h3 class=fn>void <a name="connectNotify"></a>QObject::connectNotify ( const&nbsp;char&nbsp;*&nbsp;signal )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called when something has been connected
to <em>signal</em> in this object.
<p> <b>Warning:</b> This function violates the object-oriented principle of
modularity. However, it might be useful when you need to perform
expensive initialization only if something is connected to a
signal.
<p> <p>See also <a href="#connect">connect</a>() and <a href="#disconnectNotify">disconnectNotify</a>().

<h3 class=fn>void <a name="customEvent"></a>QObject::customEvent ( <a href="qcustomevent.html">QCustomEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
custom events. Custom events are user-defined events with a type
value at least as large as the "User" item of the <a href="qevent.html#Type-enum">QEvent::Type</a>
enum, and is typically a <a href="qcustomevent.html">QCustomEvent</a> or QCustomEvent subclass.
<p> <p>See also <a href="#event">event</a>() and <a href="qcustomevent.html">QCustomEvent</a>.

<h3 class=fn>void <a name="deleteLater"></a>QObject::deleteLater ()<tt> [slot]</tt>
</h3>
Performs a deferred deletion of this object.
<p> Instead of an immediate deletion this function schedules a
deferred delete event for processing when Qt returns to the main
event loop.

<p>Example: <a href="bigtable-example.html#x1290">table/bigtable/main.cpp</a>.
<h3 class=fn>void <a name="destroyed"></a>QObject::destroyed ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the object is being destroyed.
<p> Note that the signal is emitted by the QObject destructor, so
the object's virtual table is already degenerated at this point,
and it is not safe to call any functions on the object emitting
the signal. This signal can not be blocked.
<p> All the objects's children are destroyed immediately after this
signal is emitted.

<h3 class=fn>void <a name="destroyed-2"></a>QObject::destroyed ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;obj )<tt> [signal]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> This signal is emitted immediately before the object <em>obj</em> is
destroyed, and can not be blocked.
<p> All the objects's children are destroyed immediately after this
signal is emitted.

<h3 class=fn>bool <a name="disconnect"></a>QObject::disconnect ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;sender, const&nbsp;char&nbsp;*&nbsp;signal, const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member )<tt> [static]</tt>
</h3>
Disconnects <em>signal</em> in object <em>sender</em> from <em>member</em> in object
<em>receiver</em>.
<p> A signal-slot connection is removed when either of the objects
involved are destroyed.
<p> <a href="#disconnect">disconnect</a>() is typically used in three ways, as the following
examples demonstrate.
<ol type=1>
<li> Disconnect everything connected to an object's signals:
<pre>
       <a href="#disconnect">disconnect</a>( myObject, 0, 0, 0 );
       </pre>
 
equivalent to the non-static overloaded function
<pre>
       myObject-&gt;disconnect();
       </pre>
 
<li> Disconnect everything connected to a specific signal:
<pre>
       <a href="#disconnect">disconnect</a>( myObject, SIGNAL(mySignal()), 0, 0 );
       </pre>
 
equivalent to the non-static overloaded function
<pre>
       myObject-&gt;disconnect( SIGNAL(mySignal()) );
       </pre>
 
<li> Disconnect a specific receiver:
<pre>
       <a href="#disconnect">disconnect</a>( myObject, 0, myReceiver, 0 );
       </pre>
 
equivalent to the non-static overloaded function
<pre>
       myObject-&gt;disconnect(  myReceiver );
       </pre>
 
</ol>
<p> 0 may be used as a wildcard, meaning "any signal", "any receiving
object", or "any slot in the receiving object", respectively.
<p> The <em>sender</em> may never be 0. (You cannot disconnect signals from
more than one object in a single call.)
<p> If <em>signal</em> is 0, it disconnects <em>receiver</em> and <em>member</em> from
any signal. If not, only the specified signal is disconnected.
<p> If <em>receiver</em> is 0, it disconnects anything connected to <em>signal</em>. If not, slots in objects other than <em>receiver</em> are not
disconnected.
<p> If <em>member</em> is 0, it disconnects anything that is connected to <em>receiver</em>. If not, only slots named <em>member</em> will be disconnected,
and all other slots are left alone. The <em>member</em> must be 0 if <em>receiver</em> is left out, so you cannot disconnect a
specifically-named slot on all objects.
<p> <p>See also <a href="#connect">connect</a>().

<h3 class=fn>bool <a name="disconnect-2"></a>QObject::disconnect ( const&nbsp;char&nbsp;*&nbsp;signal = 0, const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver = 0, const&nbsp;char&nbsp;*&nbsp;member = 0 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Disconnects <em>signal</em> from <em>member</em> of <em>receiver</em>.
<p> A signal-slot connection is removed when either of the objects
involved are destroyed.

<h3 class=fn>bool <a name="disconnect-3"></a>QObject::disconnect ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;receiver, const&nbsp;char&nbsp;*&nbsp;member = 0 )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Disconnects all signals in this object from <em>receiver</em>'s <em>member</em>.
<p> A signal-slot connection is removed when either of the objects
involved are destroyed.

<h3 class=fn>void <a name="disconnectNotify"></a>QObject::disconnectNotify ( const&nbsp;char&nbsp;*&nbsp;signal )<tt> [virtual protected]</tt>
</h3>

<p> This virtual function is called when something has been
disconnected from <em>signal</em> in this object.
<p> <b>Warning:</b> This function violates the object-oriented principle of
modularity. However, it might be useful for optimizing access to
expensive resources.
<p> <p>See also <a href="#disconnect">disconnect</a>() and <a href="#connectNotify">connectNotify</a>().

<h3 class=fn>void <a name="dumpObjectInfo"></a>QObject::dumpObjectInfo ()
</h3>
Dumps information about signal connections, etc. for this object
to the debug output.
<p> This function is useful for debugging, but does nothing if the
library has been compiled in release mode (i.e. without debugging
information).

<h3 class=fn>void <a name="dumpObjectTree"></a>QObject::dumpObjectTree ()
</h3>
Dumps a tree of children to the debug output.
<p> This function is useful for debugging, but does nothing if the
library has been compiled in release mode (i.e. without debugging
information).

<h3 class=fn>bool <a name="event"></a>QObject::event ( <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;e )<tt> [virtual]</tt>
</h3>
This virtual function receives events to an object and should
return TRUE if the event <em>e</em> was recognized and processed.
<p> The <a href="#event">event</a>() function can be reimplemented to customize the
behavior of an object.
<p> <p>See also <a href="#installEventFilter">installEventFilter</a>(), <a href="#timerEvent">timerEvent</a>(), <a href="qapplication.html#sendEvent">QApplication::sendEvent</a>(), <a href="qapplication.html#postEvent">QApplication::postEvent</a>(), and <a href="qwidget.html#event">QWidget::event</a>().

<p>Reimplemented in <a href="qwidget.html#event">QWidget</a>.
<h3 class=fn>bool <a name="eventFilter"></a>QObject::eventFilter ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;watched, <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;e )<tt> [virtual]</tt>
</h3>
Filters events if this object has been installed as an event
filter for the <em>watched</em> object.
<p> In your reimplementation of this function, if you want to filter
the event <em>e</em>, out, i.e. stop it being handled further, return
TRUE; otherwise return FALSE.
<p> Example:
<pre>
    class MyMainWindow : public <a href="qmainwindow.html">QMainWindow</a>
    {
    public:
        MyMainWindow( <a href="qwidget.html">QWidget</a> *parent = 0, const char *name = 0 );

    protected:
        bool eventFilter( QObject *obj, QEvent *ev );

    private:
        <a href="qtextedit.html">QTextEdit</a> *textEdit;
    };

    MyMainWindow::MyMainWindow( <a href="qwidget.html">QWidget</a> *parent, const char *name )
        : <a href="qmainwindow.html">QMainWindow</a>( parent, name )
    {
        textEdit = new <a href="qtextedit.html">QTextEdit</a>( this );
        <a href="qmainwindow.html#setCentralWidget">setCentralWidget</a>( textEdit );
        textEdit-&gt;<a href="#installEventFilter">installEventFilter</a>( this );
    }

    bool MyMainWindow::<a href="#eventFilter">eventFilter</a>( QObject *obj, QEvent *ev )
    {
        if ( obj == textEdit ) {
            if ( e-&gt;type() == QEvent::KeyPress ) {
                <a href="qkeyevent.html">QKeyEvent</a> *k = (QKeyEvent*)ev;
                <a href="qapplication.html#qDebug">qDebug</a>( "Ate key press %d", k-&gt;<a href="qkeyevent.html#key">key</a>() );
                return TRUE;
            } else {
                return FALSE;
            }
        } else {
            // pass the event on to the parent class
            return QMainWindow::eventFilter( obj, ev );
        }
    }
    </pre>
 
<p> Notice in the example above that unhandled events are passed to
the base class's <a href="#eventFilter">eventFilter</a>() function, since the base class
might have reimplemented eventFilter() for its own internal
purposes.
<p> <b>Warning:</b> If you delete the receiver object in this function, be
sure to return TRUE. Otherwise, Qt will forward the event to the
deleted object and the program might crash.
<p> <p>See also <a href="#installEventFilter">installEventFilter</a>().

<p>Reimplemented in <a href="qaccel.html#eventFilter">QAccel</a>, <a href="qscrollview.html#eventFilter">QScrollView</a>, and <a href="qspinbox.html#eventFilter">QSpinBox</a>.
<h3 class=fn>bool <a name="highPriority"></a>QObject::highPriority () const
</h3>

<p> Returns TRUE if the object is a high-priority object, or FALSE if
it is a standard-priority object.
<p> High-priority objects are placed first in QObject's list of
children on the assumption that they will be referenced very
often.

<h3 class=fn>bool <a name="inherits"></a>QObject::inherits ( const&nbsp;char&nbsp;*&nbsp;clname ) const
</h3>
Returns TRUE if this object is an instance of a class that
inherits <em>clname</em>, and <em>clname</em> inherits QObject; otherwise
returns FALSE.
<p> A class is considered to inherit itself.
<p> Example:
<pre>
        <a href="qtimer.html">QTimer</a> *t = new <a href="qtimer.html">QTimer</a>;         // QTimer inherits QObject
        t-&gt;<a href="#inherits">inherits</a>( "QTimer" );        // returns TRUE
        t-&gt;<a href="#inherits">inherits</a>( "QObject" );       // returns TRUE
        t-&gt;<a href="#inherits">inherits</a>( "QButton" );       // returns FALSE

        // QScrollBar inherits QWidget and QRangeControl
        <a href="qscrollbar.html">QScrollBar</a> *s = new <a href="qscrollbar.html">QScrollBar</a>( 0 );
        s-&gt;<a href="#inherits">inherits</a>( "QWidget" );       // returns TRUE
        s-&gt;<a href="#inherits">inherits</a>( "QRangeControl" ); // returns FALSE
    </pre>
 
<p> (<a href="qrangecontrol.html">QRangeControl</a> is not a QObject.)
<p> <p>See also <a href="#isA">isA</a>() and <a href="#metaObject">metaObject</a>().

<p>Examples: <a href="statistics-example.html#x2783">table/statistics/statistics.cpp</a>, <a href="themes-example.html#x282">themes/metal.cpp</a>, and <a href="themes-example.html#x211">themes/wood.cpp</a>.
<h3 class=fn>void <a name="insertChild"></a>QObject::insertChild ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;obj )<tt> [virtual]</tt>
</h3>
Inserts an object <em>obj</em> into the list of child objects.
<p> <b>Warning:</b> This function cannot be used to make one widget the child
widget of another widget. Child widgets can only be created by
setting the parent widget in the constructor or by calling
<a href="qwidget.html#reparent">QWidget::reparent</a>().
<p> <p>See also <a href="#removeChild">removeChild</a>() and <a href="qwidget.html#reparent">QWidget::reparent</a>().

<h3 class=fn>void <a name="installEventFilter"></a>QObject::installEventFilter ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;filterObj )
</h3>

<p> Installs an event filter <em>filterObj</em> on this object. For example:
<pre>
    monitoredObj-&gt;installEventFilter( filterObj );
    </pre>
 
<p> An event filter is an object that receives all events that are
sent to this object. The filter can either stop the event or
forward it to this object. The event filter <em>filterObj</em> receives
events via its <a href="#eventFilter">eventFilter</a>() function. The eventFilter() function
must return TRUE if the event should be filtered, (i.e. stopped);
otherwise it must return FALSE.
<p> If multiple event filters are installed on a single object, the
filter that was installed last is activated first.
<p> Here's a <tt>KeyPressEater</tt> class that eats the key presses of its
monitored objects:
<pre>
    class KeyPressEater : public QObject
    {
        ...
    protected:
        bool eventFilter( QObject *o, QEvent *e );
    };

    bool KeyPressEater::<a href="#eventFilter">eventFilter</a>( QObject *o, QEvent *e )
    {
        if ( e-&gt;type() == QEvent::KeyPress ) {
            // special processing for key press
            <a href="qkeyevent.html">QKeyEvent</a> *k = (QKeyEvent *)e;
            <a href="qapplication.html#qDebug">qDebug</a>( "Ate key press %d", k-&gt;<a href="qkeyevent.html#key">key</a>() );
            return TRUE; // eat event
        } else {
            // standard event processing
            return FALSE;
        }
    }
    </pre>
 
<p> And here's how to install it on two widgets:
<pre>
        KeyPressEater *keyPressEater = new KeyPressEater( this );
        <a href="qpushbutton.html">QPushButton</a> *pushButton = new <a href="qpushbutton.html">QPushButton</a>( this );
        <a href="qlistview.html">QListView</a> *listView = new <a href="qlistview.html">QListView</a>( this );

        pushButton-&gt;<a href="#installEventFilter">installEventFilter</a>( keyPressEater );
        listView-&gt;<a href="#installEventFilter">installEventFilter</a>( keyPressEater );
    </pre>
 
<p> The <a href="qaccel.html">QAccel</a> class, for example, uses this technique to intercept
accelerator key presses.
<p> <b>Warning:</b> If you delete the receiver object in your <a href="#eventFilter">eventFilter</a>()
function, be sure to return TRUE. If you return FALSE, Qt sends
the event to the deleted object and the program will crash.
<p> <p>See also <a href="#removeEventFilter">removeEventFilter</a>(), <a href="#eventFilter">eventFilter</a>(), and <a href="#event">event</a>().

<h3 class=fn>bool <a name="isA"></a>QObject::isA ( const&nbsp;char&nbsp;*&nbsp;clname ) const
</h3>
Returns TRUE if this object is an instance of the class <em>clname</em>;
otherwise returns FALSE.
<p> Example:
<pre>
    <a href="qtimer.html">QTimer</a> *t = new <a href="qtimer.html">QTimer</a>; // QTimer inherits QObject
    t-&gt;<a href="#isA">isA</a>( "QTimer" );     // returns TRUE
    t-&gt;<a href="#isA">isA</a>( "QObject" );    // returns FALSE
  </pre>
 
<p> <p>See also <a href="#inherits">inherits</a>() and <a href="#metaObject">metaObject</a>().

<h3 class=fn>bool <a name="isWidgetType"></a>QObject::isWidgetType () const
</h3>

<p> Returns TRUE if the object is a widget; otherwise returns FALSE.
<p> Calling this function is equivalent to calling
<a href="#inherits">inherits</a>("QWidget"), except that it is much faster.

<h3 class=fn>void <a name="killTimer"></a>QObject::killTimer ( int&nbsp;id )
</h3>
Kills the timer with timer identifier, <em>id</em>.
<p> The timer identifier is returned by <a href="#startTimer">startTimer</a>() when a timer
event is started.
<p> <p>See also <a href="#timerEvent">timerEvent</a>(), <a href="#startTimer">startTimer</a>(), and <a href="#killTimers">killTimers</a>().

<h3 class=fn>void <a name="killTimers"></a>QObject::killTimers ()
</h3>
Kills all timers that this object has started.
<p> <b>Warning:</b> Using this function can cause hard-to-find bugs: it kills
timers started by sub- and superclasses as well as those started
by you, which is often not what you want. We recommend using a
<a href="qtimer.html">QTimer</a> or perhaps <a href="#killTimer">killTimer</a>().
<p> <p>See also <a href="#timerEvent">timerEvent</a>(), <a href="#startTimer">startTimer</a>(), and <a href="#killTimer">killTimer</a>().

<h3 class=fn><a href="qmetaobject.html">QMetaObject</a>&nbsp;* <a name="metaObject"></a>QObject::metaObject () const<tt> [virtual]</tt>
</h3>

<p> Returns a pointer to the <a href="metaobjects.html#meta-object">meta object</a> of this object.
<p> A meta object contains information about a class that inherits
QObject, e.g. class name, superclass name, properties, signals and
slots. Every class that contains the <a href="metaobjects.html#Q_OBJECT">Q_OBJECT</a> macro will also have
a meta object.
<p> The meta object information is required by the signal/slot
connection mechanism and the property system. The functions <a href="#isA">isA</a>()
and <a href="#inherits">inherits</a>() also make use of the meta object.

<h3 class=fn>const char * <a name="name"></a>QObject::name () const
</h3><p>Returns the name of this object.
See the <a href="qobject.html#name-prop">"name"</a> property for details.
<h3 class=fn>const char * <a name="name-2"></a>QObject::name ( const&nbsp;char&nbsp;*&nbsp;defaultName ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the name of this object, or <em>defaultName</em> if the object
does not have a name.

<h3 class=fn><a href="qcstring.html">QCString</a> <a name="normalizeSignalSlot"></a>QObject::normalizeSignalSlot ( const&nbsp;char&nbsp;*&nbsp;signalSlot )<tt> [static protected]</tt>
</h3>
Normlizes the signal or slot definition <em>signalSlot</em> by removing
unnecessary whitespace.

<h3 class=fn>const&nbsp;<a href="qobjectlist.html">QObjectList</a>&nbsp;* <a name="objectTrees"></a>QObject::objectTrees ()<tt> [static]</tt>
</h3>
Returns a pointer to the list of all object trees (their root
objects), or 0 if there are no objects.
<p> The <a href="qobjectlist.html">QObjectList</a> class is defined in the <a href="qobjectlist-h.html">qobjectlist.h</a> header
file.
<p> The most recent root object created is the <a href="qptrlist.html#first">first</a> object in the list and the first root object added
is the <a href="qptrlist.html#last">last</a> object in the list.
<p> <p>See also <a href="#children">children</a>(), <a href="#parent">parent</a>(), <a href="#insertChild">insertChild</a>(), and <a href="#removeChild">removeChild</a>().

<h3 class=fn><a href="qobject.html">QObject</a>&nbsp;* <a name="parent"></a>QObject::parent () const
</h3>

<p> Returns a pointer to the parent object.
<p> <p>See also <a href="#children">children</a>().

<h3 class=fn><a href="qvariant.html">QVariant</a> <a name="property"></a>QObject::property ( const&nbsp;char&nbsp;*&nbsp;name ) const<tt> [virtual]</tt>
</h3>
Returns the value of the object's <em>name</em> property.
<p> If no such property exists, the returned variant is invalid.
<p> Information about all available properties are provided through
the <a href="#metaObject">metaObject</a>().
<p> <p>See also <a href="#setProperty">setProperty</a>(), <a href="qvariant.html#isValid">QVariant::isValid</a>(), <a href="#metaObject">metaObject</a>(), <a href="qmetaobject.html#propertyNames">QMetaObject::propertyNames</a>(), and <a href="qmetaobject.html#property">QMetaObject::property</a>().

<p>Example: <a href="qaxcontainer-example-qutlook.html#x2729">qutlook/centralwidget.cpp</a>.
<h3 class=fn><a href="qobjectlist.html">QObjectList</a>&nbsp;* <a name="queryList"></a>QObject::queryList ( const&nbsp;char&nbsp;*&nbsp;inheritsClass = 0, const&nbsp;char&nbsp;*&nbsp;objName = 0, bool&nbsp;regexpMatch = TRUE, bool&nbsp;recursiveSearch = TRUE ) const
</h3>
Searches the children and optionally grandchildren of this object,
and returns a list of those objects that are named or that match
<em>objName</em> and inherit <em>inheritsClass</em>. If <em>inheritsClass</em> is 0
(the default), all classes match. If <em>objName</em> is 0 (the
default), all object names match.
<p> If <em>regexpMatch</em> is TRUE (the default), <em>objName</em> is a <a href="qregexp.html#regular-expression">regular expression</a> that the objects's names must match. The syntax is that
of a <a href="qregexp.html">QRegExp</a>. If <em>regexpMatch</em> is FALSE, <em>objName</em> is a string
and object names must match it exactly.
<p> Note that <em>inheritsClass</em> uses single inheritance from QObject,
the way <a href="#inherits">inherits</a>() does. According to inherits(), <a href="qmenubar.html">QMenuBar</a>
inherits <a href="qwidget.html">QWidget</a> but not <a href="qmenudata.html">QMenuData</a>. This does not quite match
reality, but is the best that can be done on the wide variety of
compilers Qt supports.
<p> Finally, if <em>recursiveSearch</em> is TRUE (the default), <a href="#queryList">queryList</a>()
searches <em>n</em>th-generation as well as first-generation children.
<p> If all this seems a bit complex for your needs, the simpler
<a href="#child">child</a>() function may be what you want.
<p> This somewhat contrived example disables all the buttons in this
window:
<pre>
    <a href="qobjectlist.html">QObjectList</a> *l = topLevelWidget()-&gt;queryList( "QButton" );
    QObjectListIt it( *l ); // iterate over the buttons
    QObject *obj;

    while ( (obj = it.current()) != 0 ) {
        // for each found object...
        ++it;
        ((QButton*)obj)-&gt;setEnabled( FALSE );
    }
    delete l; // delete the list, not the objects
    </pre>
 
<p> The <a href="qobjectlist.html">QObjectList</a> class is defined in the <a href="qobjectlist-h.html">qobjectlist.h</a> header
file.
<p> <b>Warning:</b> Delete the list as soon you have finished using it. The
list contains pointers that may become invalid at almost any time
without notice (as soon as the user closes a window you may have
dangling pointers, for example).
<p> <p>See also <a href="#child">child</a>(), <a href="#children">children</a>(), <a href="#parent">parent</a>(), <a href="#inherits">inherits</a>(), <a href="#name-prop">name</a>, and <a href="qregexp.html">QRegExp</a>.

<h3 class=fn>void <a name="removeChild"></a>QObject::removeChild ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;obj )<tt> [virtual]</tt>
</h3>
Removes the child object <em>obj</em> from the list of children.
<p> <b>Warning:</b> This function will not remove a child widget from the
screen. It will only remove it from the parent widget's list of
children.
<p> <p>See also <a href="#insertChild">insertChild</a>() and <a href="qwidget.html#reparent">QWidget::reparent</a>().

<h3 class=fn>void <a name="removeEventFilter"></a>QObject::removeEventFilter ( const&nbsp;<a href="qobject.html">QObject</a>&nbsp;*&nbsp;obj )
</h3>
Removes an event filter object <em>obj</em> from this object. The
request is ignored if such an event filter has not been installed.
<p> All event filters for this object are automatically removed when
this object is destroyed.
<p> It is always safe to remove an event filter, even during event
filter activation (i.e. from the <a href="#eventFilter">eventFilter</a>() function).
<p> <p>See also <a href="#installEventFilter">installEventFilter</a>(), <a href="#eventFilter">eventFilter</a>(), and <a href="#event">event</a>().

<h3 class=fn>const&nbsp;<a href="qobject.html">QObject</a>&nbsp;* <a name="sender"></a>QObject::sender ()<tt> [protected]</tt>
</h3>
Returns a pointer to the object that sent the signal, if called in
a slot activated by a signal; otherwise it returns 0. The pointer
is valid only during the execution of the slot that calls this
function.
<p> The pointer returned by this function becomes invalid if the
sender is destroyed, or if the slot is disconnected from the
sender's signal.
<p> <b>Warning:</b> This function violates the object-oriented principle of
modularity. However, getting access to the sender might be useful
when many signals are connected to a single slot. The sender is
undefined if the slot is called as a normal C++ function.

<h3 class=fn>void <a name="setName"></a>QObject::setName ( const&nbsp;char&nbsp;*&nbsp;name )<tt> [virtual]</tt>
</h3>
Sets the object's name to <em>name</em>.

<h3 class=fn>bool <a name="setProperty"></a>QObject::setProperty ( const&nbsp;char&nbsp;*&nbsp;name, const&nbsp;<a href="qvariant.html">QVariant</a>&nbsp;&amp;&nbsp;value )<tt> [virtual]</tt>
</h3>
Sets the value of the object's <em>name</em> property to <em>value</em>.
<p> Returns TRUE if the operation was successful; otherwise returns
FALSE.
<p> Information about all available properties is provided through the
<a href="#metaObject">metaObject</a>().
<p> <p>See also <a href="#property">property</a>(), <a href="#metaObject">metaObject</a>(), <a href="qmetaobject.html#propertyNames">QMetaObject::propertyNames</a>(), and <a href="qmetaobject.html#property">QMetaObject::property</a>().

<p>Example: <a href="qaxcontainer-example-qutlook.html#x2730">qutlook/centralwidget.cpp</a>.
<h3 class=fn>bool <a name="signalsBlocked"></a>QObject::signalsBlocked () const
</h3>

<p> Returns TRUE if signals are blocked; otherwise returns FALSE.
<p> Signals are not blocked by default.
<p> <p>See also <a href="#blockSignals">blockSignals</a>().

<h3 class=fn>int <a name="startTimer"></a>QObject::startTimer ( int&nbsp;interval )
</h3>
Starts a timer and returns a timer identifier, or returns zero if
it could not start a timer.
<p> A timer event will occur every <em>interval</em> milliseconds until
<a href="#killTimer">killTimer</a>() or <a href="#killTimers">killTimers</a>() is called. If <em>interval</em> is 0, then
the timer event occurs once every time there are no more window
system events to process.
<p> The virtual <a href="#timerEvent">timerEvent</a>() function is called with the <a href="qtimerevent.html">QTimerEvent</a>
event parameter class when a timer event occurs. Reimplement this
function to get timer events.
<p> If multiple timers are running, the <a href="qtimerevent.html#timerId">QTimerEvent::timerId</a>() can be
used to find out which timer was activated.
<p> Example:
<pre>
    class MyObject : public QObject
    {
        Q_OBJECT
    public:
        MyObject( QObject *parent = 0, const char *name = 0 );

    protected:
        void timerEvent( <a href="qtimerevent.html">QTimerEvent</a> * );
    };

    MyObject::MyObject( QObject *parent, const char *name )
        : QObject( parent, name )
    {
        <a href="#startTimer">startTimer</a>( 50 );    // 50-millisecond timer
        <a href="#startTimer">startTimer</a>( 1000 );  // 1-second timer
        <a href="#startTimer">startTimer</a>( 60000 ); // 1-minute timer
    }

    void MyObject::<a href="#timerEvent">timerEvent</a>( <a href="qtimerevent.html">QTimerEvent</a> *e )
    {
        <a href="qapplication.html#qDebug">qDebug</a>( "timer event, id %d", e-&gt;<a href="qtimerevent.html#timerId">timerId</a>() );
    }
    </pre>
 
<p> Note that <a href="qtimer.html">QTimer</a>'s accuracy depends on the underlying operating
system and hardware. Most platforms support an accuracy of 20 ms;
some provide more. If Qt is unable to deliver the requested
number of timer clicks, it will silently discard some.
<p> The QTimer class provides a high-level programming interface with
one-shot timers and timer signals instead of events.
<p> <p>See also <a href="#timerEvent">timerEvent</a>(), <a href="#killTimer">killTimer</a>(), <a href="#killTimers">killTimers</a>(), <a href="qeventloop.html#awake">QEventLoop::awake</a>(), and <a href="qeventloop.html#aboutToBlock">QEventLoop::aboutToBlock</a>().

<h3 class=fn>void <a name="timerEvent"></a>QObject::timerEvent ( <a href="qtimerevent.html">QTimerEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler can be reimplemented in a subclass to receive
timer events for the object.
<p> <a href="qtimer.html">QTimer</a> provides a higher-level interface to the timer
functionality, and also more general information about timers.
<p> <p>See also <a href="#startTimer">startTimer</a>(), <a href="#killTimer">killTimer</a>(), <a href="#killTimers">killTimers</a>(), and <a href="#event">event</a>().

<p>Examples: <a href="biff-example.html#x1959">biff/biff.cpp</a>, <a href="dclock-example.html#x1102">dclock/dclock.cpp</a>, <a href="forever-example.html#x1048">forever/forever.cpp</a>, <a href="grapher-nsplugin-example.html#x2755">grapher/grapher.cpp</a>, <a href="qmag-example.html#x1781">qmag/qmag.cpp</a>, and <a href="xform-example.html#x1232">xform/xform.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="tr"></a>QObject::tr ( const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment )<tt> [static]</tt>
</h3>


<p> Returns a translated version of <em>sourceText</em>, or <em>sourceText</em>
itself if there is no appropriate translated version. The
translation context is QObject with <em>comment</em> (0 by default).
All QObject subclasses using the <a href="metaobjects.html#Q_OBJECT">Q_OBJECT</a> macro automatically have
a reimplementation of this function with the subclass name as
context.
<p> <b>Warning:</b> This method is reentrant only if all translators are
installed <em>before</em> calling this method. Installing or removing
translators while performing translations is not supported. Doing
so will probably result in crashes or other undesirable behavior.
<p> <p>See also <a href="#trUtf8">trUtf8</a>(), <a href="qapplication.html#translate">QApplication::translate</a>(), and <a href="i18n.html">Internationalization with Qt</a>.

<p>Example: <a href="qdialog.html#x2130">network/networkprotocol/view.cpp</a>.
<h3 class=fn><a href="qstring.html">QString</a> <a name="trUtf8"></a>QObject::trUtf8 ( const&nbsp;char&nbsp;*&nbsp;sourceText, const&nbsp;char&nbsp;*&nbsp;comment )<tt> [static]</tt>
</h3>


<p> Returns a translated version of <em>sourceText</em>, or
<a href="qstring.html#fromUtf8">QString::fromUtf8</a>(<em>sourceText</em>) if there is no appropriate
version. It is otherwise identical to <a href="#tr">tr</a>(<em>sourceText</em>, <em>comment</em>).
<p> <b>Warning:</b> This method is reentrant only if all translators are
installed <em>before</em> calling this method. Installing or removing
translators while performing translations is not supported. Doing
so will probably result in crashes or other undesirable behavior.
<p> <p>See also <a href="#tr">tr</a>() and <a href="qapplication.html#translate">QApplication::translate</a>().

<hr><h2>Property Documentation</h2>
<h3 class=fn><a href="qcstring.html">QCString</a> <a name="name-prop"></a>name</h3>
<p>This property holds the name of this object.
<p>You can find an object by name (and type) using <a href="#child">child</a>(). You can
find a set of objects with <a href="#queryList">queryList</a>().
<p> The object name is set by the constructor or by the <a href="#setName">setName</a>()
function. The object name is not very useful in the current
version of Qt, but will become increasingly important in the
future.
<p> If the object does not have a name, the <a href="#name">name</a>() function returns
"unnamed", so printf() (used in <a href="qapplication.html#qDebug">qDebug</a>()) will not be asked to
output a null pointer. If you want a null pointer to be returned
for unnamed objects, you can call name( 0 ).
<p> <pre>
        <a href="qapplication.html#qDebug">qDebug</a>( "MyClass::setPrecision(): (%s) invalid precision %f",
                <a href="#name">name</a>(), newPrecision );
    </pre>
 
<p> <p>See also <a href="#className">className</a>(), <a href="#child">child</a>(), and <a href="#queryList">queryList</a>().

<p>Set this property's value with <a href="#setName">setName</a>() and get this property's value with <a href="#name">name</a>().
<hr><h2>Related Functions</h2>
<h3 class=fn>void * <a name="qt_find_obj_child"></a>qt_find_obj_child ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;type, const&nbsp;char&nbsp;*&nbsp;name )
</h3>

<p> Returns a pointer to the object named <em>name</em> that inherits <em>type</em> and with a given <em>parent</em>.
<p> Returns 0 if there is no such child.
<p> <pre>
        <a href="qlistbox.html">QListBox</a> *c = (QListBox *) <a href="#qt_find_obj_child">qt_find_obj_child</a>( myWidget, "QListBox",
                                                      "my list box" );
        if ( c )
            c-&gt;<a href="qlistbox.html#insertItem">insertItem</a>( "another string" );
    </pre>
 

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
