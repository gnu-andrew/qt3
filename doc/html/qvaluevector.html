<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/doc/qvaluevector.doc:40 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QValueVector Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QValueVector Class Reference</h1>

<p>The QValueVector class is a value-based template class that provides a dynamic array.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qvaluevector-h.html">qvaluevector.h</a>&gt;</tt>
<p><a href="qvaluevector-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>typedef T&nbsp;<a href="#value_type"><b>value_type</b></a></li>
<li class=fn>typedef value_type&nbsp;*&nbsp;<a href="#pointer"><b>pointer</b></a></li>
<li class=fn>typedef const&nbsp;value_type&nbsp;*&nbsp;<a href="#const_pointer"><b>const_pointer</b></a></li>
<li class=fn>typedef value_type&nbsp;*&nbsp;<a href="#iterator"><b>iterator</b></a></li>
<li class=fn>typedef const&nbsp;value_type&nbsp;*&nbsp;<a href="#const_iterator"><b>const_iterator</b></a></li>
<li class=fn>typedef value_type&nbsp;&amp;&nbsp;<a href="#reference"><b>reference</b></a></li>
<li class=fn>typedef const&nbsp;value_type&nbsp;&amp;&nbsp;<a href="#const_reference"><b>const_reference</b></a></li>
<li class=fn>typedef size_t&nbsp;<a href="#size_type"><b>size_type</b></a></li>
<li class=fn>typedef ptrdiff_t&nbsp;<a href="#difference_type"><b>difference_type</b></a></li>
<li class=fn><a href="#QValueVector"><b>QValueVector</b></a> ()</li>
<li class=fn><a href="#QValueVector-2"><b>QValueVector</b></a> ( const&nbsp;QValueVector&lt;T&gt;&nbsp;&amp;&nbsp;v )</li>
<li class=fn><a href="#QValueVector-3"><b>QValueVector</b></a> ( size_type&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;val = T ( ) )</li>
<li class=fn><a href="#QValueVector-4"><b>QValueVector</b></a> ( std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )</li>
<li class=fn><a href="#QValueVector-5"><b>QValueVector</b></a> ( const&nbsp;std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )</li>
<li class=fn><a href="#~QValueVector"><b>~QValueVector</b></a> ()</li>
<li class=fn>QValueVector&lt;T&gt; &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QValueVector&lt;T&gt;&nbsp;&amp;&nbsp;v )</li>
<li class=fn>QValueVector&lt;T&gt; &amp; <a href="#operator-eq-2"><b>operator=</b></a> ( const&nbsp;std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )</li>
<li class=fn>size_type <a href="#size"><b>size</b></a> () const</li>
<li class=fn>bool <a href="#empty"><b>empty</b></a> () const</li>
<li class=fn>size_type <a href="#capacity"><b>capacity</b></a> () const</li>
<li class=fn>iterator <a href="#begin"><b>begin</b></a> ()</li>
<li class=fn>const_iterator <a href="#begin-2"><b>begin</b></a> () const</li>
<li class=fn>const_iterator <a href="#constBegin"><b>constBegin</b></a> () const</li>
<li class=fn>iterator <a href="#end"><b>end</b></a> ()</li>
<li class=fn>const_iterator <a href="#end-2"><b>end</b></a> () const</li>
<li class=fn>const_iterator <a href="#constEnd"><b>constEnd</b></a> () const</li>
<li class=fn>reference <a href="#at"><b>at</b></a> ( size_type&nbsp;i, bool&nbsp;*&nbsp;ok = 0 )</li>
<li class=fn>const_reference <a href="#at-2"><b>at</b></a> ( size_type&nbsp;i, bool&nbsp;*&nbsp;ok = 0 ) const</li>
<li class=fn>reference <a href="#operator[]"><b>operator[]</b></a> ( size_type&nbsp;i )</li>
<li class=fn>const_reference <a href="#operator[]-2"><b>operator[]</b></a> ( size_type&nbsp;i ) const</li>
<li class=fn>reference <a href="#front"><b>front</b></a> ()</li>
<li class=fn>const_reference <a href="#front-2"><b>front</b></a> () const</li>
<li class=fn>reference <a href="#back"><b>back</b></a> ()</li>
<li class=fn>const_reference <a href="#back-2"><b>back</b></a> () const</li>
<li class=fn>void <a href="#push_back"><b>push_back</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>void <a href="#pop_back"><b>pop_back</b></a> ()</li>
<li class=fn>iterator <a href="#insert"><b>insert</b></a> ( iterator&nbsp;pos, const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>iterator <a href="#insert-2"><b>insert</b></a> ( iterator&nbsp;pos, size_type&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
<li class=fn>void <a href="#reserve"><b>reserve</b></a> ( size_type&nbsp;n )</li>
<li class=fn>void <a href="#resize"><b>resize</b></a> ( size_type&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;val = T ( ) )</li>
<li class=fn>void <a href="#clear"><b>clear</b></a> ()</li>
<li class=fn>iterator <a href="#erase"><b>erase</b></a> ( iterator&nbsp;pos )</li>
<li class=fn>iterator <a href="#erase-2"><b>erase</b></a> ( iterator&nbsp;first, iterator&nbsp;last )</li>
<li class=fn>bool <a href="#operator-eq-eq-2"><b>operator==</b></a> ( const&nbsp;QValueVector&lt;T&gt;&nbsp;&amp;&nbsp;x )</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QValueVector&lt;T&gt;&nbsp;&amp;&nbsp;x ) const</li>
<li class=fn>typedef T&nbsp;<a href="#ValueType"><b>ValueType</b></a></li>
<li class=fn>typedef ValueType&nbsp;*&nbsp;<a href="#Iterator"><b>Iterator</b></a></li>
<li class=fn>typedef const&nbsp;ValueType&nbsp;*&nbsp;<a href="#ConstIterator"><b>ConstIterator</b></a></li>
<li class=fn>size_type <a href="#count"><b>count</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>reference <a href="#first"><b>first</b></a> ()</li>
<li class=fn>const_reference <a href="#first-2"><b>first</b></a> () const</li>
<li class=fn>reference <a href="#last"><b>last</b></a> ()</li>
<li class=fn>const_reference <a href="#last-2"><b>last</b></a> () const</li>
<li class=fn>void <a href="#append"><b>append</b></a> ( const&nbsp;T&nbsp;&amp;&nbsp;x )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QValueVector class is a value-based template class that provides a dynamic array.
<p> 




<p> QValueVector is a Qt implementation of an STL-like vector
container. It can be used in your application if the standard <tt>vector</tt> is not available for your target platforms. QValueVector is
part of the <a href="qtl.html">Qt Template Library</a>.
<p> QValueVector&lt;T&gt; defines a template instance to create a vector
of values that all have the class T. QValueVector does not store
pointers to the members of the vector; it holds a copy of every
member. QValueVector is said to be value based; in contrast,
<a href="qptrlist.html">QPtrList</a> and <a href="qdict.html">QDict</a> are pointer based.
<p> QValueVector contains and manages a collection of objects of type
T and provides random access iterators that allow the contained
objects to be addressed. QValueVector owns the contained
elements. For more relaxed ownership semantics, see <a href="qptrcollection.html">QPtrCollection</a>
and friends, which are pointer-based containers.
<p> QValueVector provides good performance if you append or remove
elements from the end of the vector. If you insert or remove
elements from anywhere but the end, performance is very bad. The
reason for this is that elements must to be copied into new
positions.
<p> Some classes cannot be used within a QValueVector: for example,
all classes derived from <a href="qobject.html">QObject</a> and thus all classes that
implement widgets. Only values can be used in a QValueVector. To
qualify as a value the class must provide:
<ul>
<li> a copy constructor;
<li> an assignment operator;
<li> a default constructor, i.e., a constructor that does not take any arguments.
</ul>
<p> Note that C++ defaults to field-by-field assignment operators and
copy constructors if no explicit version is supplied. In many
cases this is sufficient.
<p> QValueVector uses an STL-like syntax to manipulate and address the
objects it contains. See <a href="qtl.html">this document</a> for
more information.
<p> Example:
<pre>
    #include &lt;<a href="qvaluevector-h.html">qvaluevector.h</a>&gt;
    #include &lt;<a href="qstring-h.html">qstring.h</a>&gt;
    #include &lt;stdio.h&gt;

    class Employee
    {
    public:
        Employee(): s(0) {}
        Employee( const <a href="qstring.html">QString</a>&amp; name, int salary )
            : n( name ), s( salary )
        { }

        <a href="qstring.html">QString</a> name()   const          { return n; }
        int     salary() const          { return s; }
        void    setSalary( int salary ) { s = salary; }
    private:
        <a href="qstring.html">QString</a> n;
        int     s;
    };

    int main()
    {
        typedef QValueVector&lt;Employee&gt; EmployeeVector;
        EmployeeVector vec( 3 );  // vector of 3 Employees

        vec[0] = Employee( "Bill", 50000 );
        vec[1] = Employee( "Steve", 80000 );
        vec[2] = Employee( "Ron", 60000 );

        Employee joe( "Joe", 50000 );
        vec.push_back( joe );  // vector expands to accommodate 4 Employees
        joe.setSalary( 70000 );
        
        EmployeeVector::<a href="#iterator">iterator</a> it;
        for( it = vec.begin(); it != vec.end(); ++it )
            printf( "%s earns %d\n", (*it).name().latin1(), (*it).salary() );

        return 0;
    }
    </pre>
 
<p> Program output:
<pre>
        Bill earns 50000
        Steve earns 80000
        Ron earns 60000
        Joe earns 50000
    </pre>
 
<p> As you can see, the most recent change to Joe's salary did not
affect the value in the vector because the vector created a copy
of Joe's entry.
<p> Many Qt functions return const value vectors; to iterate over
these you should make a copy and iterate over the copy.
<p> There are several ways to find items in the vector. The <a href="#begin">begin</a>()
and <a href="#end">end</a>() functions return iterators to the beginning and end of
the vector. The advantage of getting an iterator is that you can
move forward or backward from this position by
incrementing/decrementing the iterator. The iterator returned by
end() points to the element which is one past the last element in
the container. The past-the-end iterator is still associated with
the vector it belongs to, however it is <em>not</em> dereferenceable;
<a href="qsize.html#operator*-4">operator*</a>() will not return a well-defined value. If the vector is
<a href="#empty">empty</a>(), the iterator returned by begin() will equal the iterator
returned by end().
<p> The fastest way to access an element of a vector is by using
operator[]. This function provides random access and will return
a reference to the element located at the specified index. Thus,
you can access every element directly, in constant time, providing
you know the location of the element. It is undefined to access
an element that does not exist (your application will probably
crash). For example:
<p> <pre>
    QValueVector&lt;int&gt; vec1;  // an empty vector
    vec1[10] = 4;  // WARNING: undefined, probably a crash

    QValueVector&lt;QString&gt; vec2(25); // initialize with 25 elements
    vec2[10] = "Dave";  // OK
    </pre>
 
<p> Whenever inserting, removing or referencing elements in a vector,
always make sure you are referring to valid positions. For
example:
<p> <pre>
    void func( QValueVector&lt;int&gt;&amp; vec )
    {
        if ( vec.<a href="#size">size</a>() &gt; 10 ) {
            vec[9] = 99; // OK
        }
    };
    </pre>
 
<p> The iterators provided by vector are random access iterators,
therefore you can use them with many generic algorithms, for
example, algorithms provided by the STL or the <a href="qtl.html">QTL</a>. 
<p> Another way to find an element in the vector is by using the
std::find() or <a href="qtl.html#qFind">qFind()</a> algorithms.
For example:
<p> <pre>
    QValueVector&lt;int&gt; vec;
    ...
    QValueVector&lt;int&gt;::<a href="#const_iterator">const_iterator</a> it = qFind( vec.<a href="#begin">begin</a>(), vec.<a href="#end">end</a>(), 3 );
    if ( it != vector.end() )
        // 'it' points to the found element
    </pre>
 
<p> It is safe to have multiple iterators on the vector at the same
time. Since QValueVector manages memory dynamically, all iterators
can become invalid if a memory reallocation occurs. For example,
if some member of the vector is removed, iterators that point to
the removed element and to all following elements become
invalidated. Inserting into the middle of the vector will
invalidate all iterators. For convenience, the function <a href="#back">back</a>()
returns a reference to the last element in the vector, and <a href="#front">front</a>()
returns a reference to the first element. If the vector is
<a href="#empty">empty</a>(), both back() and front() have undefined behavior (your
application will crash or do unpredictable things). Use back() and
front() with caution, for example:
<p> <pre>
    QValueVector&lt;int&gt; vec( 3 );
    vec.<a href="#push_back">push_back</a>( 1 );
    vec.<a href="#push_back">push_back</a>( 2 );
    vec.<a href="#push_back">push_back</a>( 3 );
    ...
    if ( !vec.<a href="#empty">empty</a>() ) {
        // OK: modify the first element
        int&amp; i = vec.<a href="#front">front</a>();
        i = 18;
    }
    ...
    QValueVector&lt;double&gt; dvec;
    double d = dvec.<a href="#back">back</a>(); // undefined behavior
    </pre>
 
<p> Because QValueVector manages memory dynamically, it is recommended
that you contruct a vector with an initial size. Inserting and
removing elements happens fastest when:
<ul>
<li> Inserting or removing elements happens at the <a href="#end">end</a>() of the
vector;
<li> The vector does not need to allocate additional memory.
</ul>
<p> By creating a QValueVector with a sufficiently large initial size,
there will be less memory allocations. Do not use an initial size
that is too big, since it will still take time to construct all
the empty entries, and the extra space will be wasted if it is
never used.
<p> Because QValueVector is value-based there is no need to be careful
about deleting elements in the vector. The vector holds its own
copies and will free them if the corresponding member or the
vector itself is deleted. You can force the vector to free all of
its items with <a href="#clear">clear</a>().
<p> QValueVector is <a href="shclass.html#shared-implicitly">shared implicitly</a>, which means it can be copied in
constant time. If multiple QValueVector instances share the same
data and one needs to modify its contents, this modifying instance
makes a copy and modifies its private copy; it thus does not
affect the other instances. This is often called "copy on write".
If a QValueVector is being used in a multi-threaded program, you
must protect all access to the vector. See <a href="qmutex.html">QMutex</a>.
<p> There are several ways to insert elements into the vector. The
<a href="#push_back">push_back</a>() function insert elements into the end of the vector,
and is usually fastest. The <a href="#insert">insert</a>() function can be used to add
elements at specific positions within the vector.
<p> Items can be also be removed from the vector in several ways.
There are several variants of the <a href="#erase">erase</a>() function which removes a
specific element, or range of elements, from the vector.
<p> Vectors can be also sorted with various STL algorithms , or it can
be sorted using the <a href="qtl.html">Qt Template Library</a>.
For example with qHeapSort():
<p> Example:
<pre>
    QValueVector&lt;int&gt; v( 4 );
    v.<a href="#push_back">push_back</a>( 5 );
    v.<a href="#push_back">push_back</a>( 8 );
    v.<a href="#push_back">push_back</a>( 3 );
    v.<a href="#push_back">push_back</a>( 4 );
    qHeapSort( v );
    </pre>
 
<p> QValueVector stores its elements in contiguous memory. This means
that you can use a QValueVector in any situation that requires an
array. 
<p>See also <a href="qtl.html">Qt Template Library Classes</a>, <a href="shared.html">Implicitly and Explicitly Shared Classes</a>, and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ConstIterator"></a>QValueVector::ConstIterator</h3> 
The vector's const iterator type. 
<h3 class=fn><a name="Iterator"></a>QValueVector::Iterator</h3> 
The vector's iterator type. 
<h3 class=fn><a name="ValueType"></a>QValueVector::ValueType</h3> 
The type of the object stored in the vector. 
<h3 class=fn><a name="const_iterator"></a>QValueVector::const_iterator</h3> 
The vector's const iterator type. 
<h3 class=fn><a name="const_pointer"></a>QValueVector::const_pointer</h3> 
The const pointer to T type. 
<h3 class=fn><a name="const_reference"></a>QValueVector::const_reference</h3> 
The const reference to T type. 
<h3 class=fn><a name="difference_type"></a>QValueVector::difference_type</h3> 
A signed integral type used to represent the distance between two iterators. 
<h3 class=fn><a name="iterator"></a>QValueVector::iterator</h3> 
The vector's iterator type. 
<h3 class=fn><a name="pointer"></a>QValueVector::pointer</h3> 
The pointer to T type. 
<h3 class=fn><a name="reference"></a>QValueVector::reference</h3> 
The reference to T type. 
<h3 class=fn><a name="size_type"></a>QValueVector::size_type</h3> 
An unsigned integral type, used to represent various sizes. 
<h3 class=fn><a name="value_type"></a>QValueVector::value_type</h3> 
The type of the object stored in the vector. 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QValueVector"></a>QValueVector::QValueVector ()
</h3>

<p> Constructs an empty vector without any elements. To create a
vector which reserves an initial amount of space for elements, use
<tt>QValueVector(size_type n)</tt>. 

<h3 class=fn><a name="QValueVector-2"></a>QValueVector::QValueVector ( const&nbsp;<a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp;&nbsp;v )
</h3>

<p> Constructs a copy of <em>v</em>.
<p> This operation costs O(1) time because QValueVector is <a href="shclass.html#implicitly-shared">implicitly shared</a>.
<p> The first modification to the vector does takes O(n) time, because
the elements must be copied.

<h3 class=fn><a name="QValueVector-3"></a>QValueVector::QValueVector ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;val = T ( ) )
</h3>

<p> Constructs a vector with an initial size of <em>n</em> elements. Each
element is initialized with the value of <em>val</em>.

<h3 class=fn><a name="QValueVector-4"></a>QValueVector::QValueVector ( std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )
</h3>

<p> Constructs a copy of <em>v</em>.

<h3 class=fn><a name="QValueVector-5"></a>QValueVector::QValueVector ( const&nbsp;std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )
</h3>

<p> This operation costs O(n) time because <em>v</em> is copied.

<h3 class=fn><a name="~QValueVector"></a>QValueVector::~QValueVector ()
</h3>

<p> Destroys the vector, destroying all elements and freeing the
allocated memory. References to the values in the vector and all
iterators of this vector become invalidated. Note that it is
impossible for an iterator to check whether or not it is valid:
QValueVector is tuned for performance, not for error checking.

<h3 class=fn>void <a name="append"></a>QValueVector::append ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Appends a copy of <em>x</em> to the end of the vector.
<p> <p>See also <a href="#push_back">push_back</a>() and <a href="#insert">insert</a>().

<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="at"></a>QValueVector::at ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;i, bool&nbsp;*&nbsp;ok = 0 )
</h3>

<p> Returns a reference to the element with index <em>i</em>. If <em>ok</em> is
non-null, and the index <em>i</em> is out of range, *<em>ok</em> is set to
FALSE and the returned reference is undefined. If the index <em>i</em>
is within the range of the vector, and <em>ok</em> is non-null, *<em>ok</em>
is set to TRUE and the returned reference is well defined.

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="at-2"></a>QValueVector::at ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;i, bool&nbsp;*&nbsp;ok = 0 ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const reference to the element with index <em>i</em>. If <em>ok</em>
is non-null, and the index <em>i</em> is out of range, *<em>ok</em> is set to
FALSE and the returned reference is undefined. If the index <em>i</em>
is within the range of the vector, and <em>ok</em> is non-null, *<em>ok</em>
is set to TRUE and the returned reference is well defined.

<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="back"></a>QValueVector::back ()
</h3>

<p> Returns a reference to the last element in the vector. If there is
no last element, this function has undefined behavior. 
<p> <p>See also <a href="#empty">empty</a>() and <a href="#front">front</a>().

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="back-2"></a>QValueVector::back () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const reference to the last element in the vector. If
there is no last element, this function has undefined behavior. 
<p> <p>See also <a href="#empty">empty</a>() and <a href="#front">front</a>().

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="begin"></a>QValueVector::begin ()
</h3>

<p> Returns an iterator pointing to the beginning of the vector. If
the vector is <a href="#empty">empty</a>(), the returned iterator will equal <a href="#end">end</a>().

<h3 class=fn><a href="qvaluevector.html#const_iterator">const_iterator</a> <a name="begin-2"></a>QValueVector::begin () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const iterator pointing to the beginning of the vector.
If the vector is <a href="#empty">empty</a>(), the returned iterator will equal <a href="#end">end</a>().

<h3 class=fn><a href="qvaluevector.html#size_type">size_type</a> <a name="capacity"></a>QValueVector::capacity () const
</h3>

<p> Returns the maximum number of elements that can be stored in the
vector without forcing memory reallocation. If memory reallocation
takes place, some or all iterators may become invalidated.

<h3 class=fn>void <a name="clear"></a>QValueVector::clear ()
</h3>

<p> Removes all the elements from the vector.

<h3 class=fn><a href="qvaluevector.html#const_iterator">const_iterator</a> <a name="constBegin"></a>QValueVector::constBegin () const
</h3>

<p> Returns a const iterator pointing to the beginning of the vector.
If the vector is <a href="#empty">empty</a>(), the returned iterator will equal <a href="#end">end</a>().
<p> <p>See also <a href="#constEnd">constEnd</a>().

<h3 class=fn><a href="qvaluevector.html#const_iterator">const_iterator</a> <a name="constEnd"></a>QValueVector::constEnd () const
</h3>

<p> Returns a const iterator pointing behind the last element of the
vector.
<p> <p>See also <a href="#constBegin">constBegin</a>().

<h3 class=fn><a href="qvaluevector.html#size_type">size_type</a> <a name="count"></a>QValueVector::count () const
</h3>

<p> Returns the number of items in the vector.
<p> <p>See also <a href="#isEmpty">isEmpty</a>().

<h3 class=fn>bool <a name="empty"></a>QValueVector::empty () const
</h3>

<p> Returns TRUE if the vector is empty; otherwise returns FALSE.
Equivalent to <a href="#size">size</a>()==0, only faster.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#isEmpty">isEmpty</a>().
<p> <p>See also <a href="#size">size</a>().

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="end"></a>QValueVector::end ()
</h3>

<p> Returns an iterator pointing behind the last element of the
vector.

<h3 class=fn><a href="qvaluevector.html#const_iterator">const_iterator</a> <a name="end-2"></a>QValueVector::end () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const iterator pointing behind the last element of the
vector.

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="erase"></a>QValueVector::erase ( <a href="qvaluevector.html#iterator">iterator</a>&nbsp;pos )
</h3>

<p> Removes the element at position <em>pos</em> and returns the position of
the next element.

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="erase-2"></a>QValueVector::erase ( <a href="qvaluevector.html#iterator">iterator</a>&nbsp;first, <a href="qvaluevector.html#iterator">iterator</a>&nbsp;last )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Removes all elements from <em>first</em> up to but not including <em>last</em>
and returns the position of the next element.

<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="first"></a>QValueVector::first ()
</h3>

<p> Returns a reference to the first item in the vector. If there is
no first item, this function has undefined behavior.
<p> <p>See also <a href="#empty">empty</a>() and <a href="#last">last</a>().

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="first-2"></a>QValueVector::first () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="front"></a>QValueVector::front ()
</h3>

<p> Returns a reference to the first element in the vector. If there
is no first element, this function has undefined behavior. 
<p> <p>See also <a href="#empty">empty</a>() and <a href="#back">back</a>().

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="front-2"></a>QValueVector::front () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const reference to the first element in the vector. If
there is no first element, this function has undefined behavior. 
<p> <p>See also <a href="#empty">empty</a>() and <a href="#back">back</a>().

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="insert"></a>QValueVector::insert ( <a href="qvaluevector.html#iterator">iterator</a>&nbsp;pos, const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Inserts a copy of <em>x</em> at the position immediately before <em>pos</em>.
<p> <p>See also <a href="#push_back">push_back</a>().

<h3 class=fn><a href="qvaluevector.html#iterator">iterator</a> <a name="insert-2"></a>QValueVector::insert ( <a href="qvaluevector.html#iterator">iterator</a>&nbsp;pos, <a href="qvaluevector.html#size_type">size_type</a>&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Inserts <em>n</em> copies of <em>x</em> immediately before position x.
<p> <p>See also <a href="#push_back">push_back</a>().

<h3 class=fn>bool <a name="isEmpty"></a>QValueVector::isEmpty () const
</h3>

<p> Returns TRUE if the vector is empty; returns FALSE otherwise.
<p> <p>See also <a href="#count">count</a>().

<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="last"></a>QValueVector::last ()
</h3>

<p> Returns a reference to the last item in the vector. If there is no
last item, this function has undefined behavior.
<p> <p>See also <a href="#empty">empty</a>() and <a href="#first">first</a>().

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="last-2"></a>QValueVector::last () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn><a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp; <a name="operator-eq"></a>QValueVector::operator= ( const&nbsp;<a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp;&nbsp;v )
</h3>

<p> Assigns <em>v</em> to this vector and returns a reference to this vector.
<p> All iterators of the current vector become invalidated by this
operation. The cost of such an assignment is O(1) since
QValueVector is <a href="shclass.html#implicitly-shared">implicitly shared</a>.

<h3 class=fn><a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp; <a name="operator-eq-2"></a>QValueVector::operator= ( const&nbsp;std::vector&lt;T&gt;&nbsp;&amp;&nbsp;v )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Assigns <em>v</em> to this vector and returns a reference to this vector.
<p> All iterators of the current vector become invalidated by this
operation. The cost of this assignment is O(n) since <em>v</em> is
copied.

<h3 class=fn>bool <a name="operator-eq-eq"></a>QValueVector::operator== ( const&nbsp;<a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp;&nbsp;x ) const
</h3>

<p> Returns TRUE if each element in this vector equals each
corresponding element in <em>x</em>; otherwise returns FALSE.

<h3 class=fn>bool <a name="operator-eq-eq-2"></a>QValueVector::operator== ( const&nbsp;<a href="qvaluevector.html">QValueVector</a>&lt;T&gt;&nbsp;&amp;&nbsp;x )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns TRUE if each element in this vector equals each
corresponding element in <em>x</em>; otherwise returns FALSE.

<h3 class=fn><a href="qvaluevector.html#reference">reference</a> <a name="operator[]"></a>QValueVector::operator[] ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;i )
</h3>

<p> Returns a reference to the element at index <em>i</em>. If <em>i</em> is out
of range, this function has undefined behavior.
<p> <p>See also <a href="#at">at</a>().

<h3 class=fn><a href="qvaluevector.html#const_reference">const_reference</a> <a name="operator[]-2"></a>QValueVector::operator[] ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;i ) const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const reference to the element at index <em>i</em>. If <em>i</em> is
out of range, this function has undefined behavior.
<p> <p>See also <a href="#at">at</a>().

<h3 class=fn>void <a name="pop_back"></a>QValueVector::pop_back ()
</h3>

<p> Removes the last item from the vector.
<p> This function is provided for STL compatibility.

<h3 class=fn>void <a name="push_back"></a>QValueVector::push_back ( const&nbsp;T&nbsp;&amp;&nbsp;x )
</h3>

<p> Appends a copy of <em>x</em> to the end of the vector. This is the
fastest way to add new elements.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#append">append</a>().
<p> <p>See also <a href="#insert">insert</a>().

<h3 class=fn>void <a name="reserve"></a>QValueVector::reserve ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;n )
</h3>

<p> Increases the vector's capacity. If <em>n</em> is less than or equal to
<a href="#capacity">capacity</a>(), nothing happens. Otherwise, additional memory is
allocated so that capacity() will be increased to a value greater
than or equal to <em>n</em>. All iterators will then become invalidated.
Note that the vector's <a href="#size">size</a>() and the values of existing elements
remain unchanged.

<h3 class=fn>void <a name="resize"></a>QValueVector::resize ( <a href="qvaluevector.html#size_type">size_type</a>&nbsp;n, const&nbsp;T&nbsp;&amp;&nbsp;val = T ( ) )
</h3>

<p> Changes the size of the vector to <em>n</em>. If <em>n</em> is greater than
the current <a href="#size">size</a>(), elements are added to the end and initialized
with the value of <em>val</em>. If <em>n</em> is less than size(), elements
are removed from the end. If <em>n</em> is equal to size() nothing
happens.

<h3 class=fn><a href="qvaluevector.html#size_type">size_type</a> <a name="size"></a>QValueVector::size () const
</h3>

<p> Returns the number of elements in the vector.
<p> This function is provided for STL compatibility. It is equivalent
to <a href="#count">count</a>().
<p> <p>See also <a href="#empty">empty</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
