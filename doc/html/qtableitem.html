<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/table/qtable.cpp:406 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QTableItem Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QTableItem Class Reference<br><small>[<a href="table.html">table module</a>]</small></h1>

<p>The QTableItem class provides the cell content for QTable cells.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qtable-h.html">qtable.h</a>&gt;</tt>
<p>Inherits <a href="qt.html">Qt</a>.
<p>Inherited by <a href="qcombotableitem.html">QComboTableItem</a> and <a href="qchecktableitem.html">QCheckTableItem</a>.
<p><a href="qtableitem-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>enum <a href="#EditType-enum"><b>EditType</b></a> { Never, OnTyping, WhenCurrent, Always }</li>
<li class=fn><a href="#QTableItem"><b>QTableItem</b></a> ( QTable&nbsp;*&nbsp;table, EditType&nbsp;et )</li>
<li class=fn><a href="#QTableItem-2"><b>QTableItem</b></a> ( QTable&nbsp;*&nbsp;table, EditType&nbsp;et, const&nbsp;QString&nbsp;&amp;&nbsp;text )</li>
<li class=fn><a href="#QTableItem-3"><b>QTableItem</b></a> ( QTable&nbsp;*&nbsp;table, EditType&nbsp;et, const&nbsp;QString&nbsp;&amp;&nbsp;text, const&nbsp;QPixmap&nbsp;&amp;&nbsp;p )</li>
<li class=fn>virtual <a href="#~QTableItem"><b>~QTableItem</b></a> ()</li>
<li class=fn>virtual QPixmap <a href="#pixmap"><b>pixmap</b></a> () const</li>
<li class=fn>virtual QString <a href="#text"><b>text</b></a> () const</li>
<li class=fn>virtual void <a href="#setPixmap"><b>setPixmap</b></a> ( const&nbsp;QPixmap&nbsp;&amp;&nbsp;p )</li>
<li class=fn>virtual void <a href="#setText"><b>setText</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;str )</li>
<li class=fn>QTable * <a href="#table"><b>table</b></a> () const</li>
<li class=fn>virtual int <a href="#alignment"><b>alignment</b></a> () const</li>
<li class=fn>virtual void <a href="#setWordWrap"><b>setWordWrap</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#wordWrap"><b>wordWrap</b></a> () const</li>
<li class=fn>EditType <a href="#editType"><b>editType</b></a> () const</li>
<li class=fn>virtual QWidget * <a href="#createEditor"><b>createEditor</b></a> () const</li>
<li class=fn>virtual void <a href="#setContentFromEditor"><b>setContentFromEditor</b></a> ( QWidget&nbsp;*&nbsp;w )</li>
<li class=fn>virtual void <a href="#setReplaceable"><b>setReplaceable</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#isReplaceable"><b>isReplaceable</b></a> () const</li>
<li class=fn>virtual QString <a href="#key"><b>key</b></a> () const</li>
<li class=fn>virtual QSize <a href="#sizeHint"><b>sizeHint</b></a> () const</li>
<li class=fn>virtual void <a href="#setSpan"><b>setSpan</b></a> ( int&nbsp;rs, int&nbsp;cs )</li>
<li class=fn>int <a href="#rowSpan"><b>rowSpan</b></a> () const</li>
<li class=fn>int <a href="#colSpan"><b>colSpan</b></a> () const</li>
<li class=fn>virtual void <a href="#setRow"><b>setRow</b></a> ( int&nbsp;r )</li>
<li class=fn>virtual void <a href="#setCol"><b>setCol</b></a> ( int&nbsp;c )</li>
<li class=fn>int <a href="#row"><b>row</b></a> () const</li>
<li class=fn>int <a href="#col"><b>col</b></a> () const</li>
<li class=fn>virtual void <a href="#paint"><b>paint</b></a> ( QPainter&nbsp;*&nbsp;p, const&nbsp;QColorGroup&nbsp;&amp;&nbsp;cg, const&nbsp;QRect&nbsp;&amp;&nbsp;cr, bool&nbsp;selected )</li>
<li class=fn>virtual void <a href="#setEnabled"><b>setEnabled</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#isEnabled"><b>isEnabled</b></a> () const</li>
<li class=fn>virtual int <a href="#rtti"><b>rtti</b></a> () const</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QTableItem class provides the cell content for <a href="qtable.html">QTable</a> cells.

<p> 

<p> For many applications QTableItems are ideal for presenting and
editing the contents of QTable cells. In situations where you need
to create very large tables you may prefer an alternative approach
to using QTableItems: see the <a href="qtable.html#notes-on-large-tables">notes on large tables</a>.
<p> A QTableItem contains a cell's data, by default, a string and a
pixmap. The table item also holds the cell's display size and how
the data should be aligned. The table item specifies the cell's
<a href="#EditType-enum">EditType</a> and the editor used for in-place editing (by default a
<a href="qlineedit.html">QLineEdit</a>). If you want checkboxes use <a href="qchecktableitem.html">QCheckTableItem</a>, and if
you want comboboxes use <a href="qcombotableitem.html">QComboTableItem</a>. The <a href="#EditType-enum">EditType</a> (set
in the constructor) determines whether the cell's contents may be
edited.
<p> If a pixmap is specified it is displayed to the left of any text.
You can change the text or pixmap with <a href="#setText">setText</a>() and <a href="#setPixmap">setPixmap</a>()
respectively. For text you can use <a href="#setWordWrap">setWordWrap</a>().
<p> When sorting table items the <a href="#key">key</a>() function is used; by default
this returns the table item's <a href="#text">text</a>(). Reimplement key() to
customize how your table items will sort.
<p> Table items are inserted into a table using <a href="qtable.html#setItem">QTable::setItem</a>(). If
you insert an item into a cell that already contains a table item
the original item will be deleted.
<p> Example:
<pre>
    for ( int row = 0; row &lt; table-&gt;numRows(); row++ ) {
        for ( int col = 0; col &lt; table-&gt;numCols(); col++ ) {
            table-&gt;setItem( row, col,
                new QTableItem( table, QTableItem::<a href="#EditType-enum">WhenCurrent</a>, QString::number( row * col ) ) );
        }
    }
    </pre>
 
<p> You can move a table item from one cell to another, in the same or
a different table, using <a href="qtable.html#takeItem">QTable::takeItem</a>() and QTable::setItem()
but see also <a href="qtable.html#swapCells">QTable::swapCells</a>().
<p> Table items can be deleted with delete in the standard way; the
table and cell will be updated accordingly.
<p> Note, that if you have a table item that is not currently in a table
then anything you do to that item other than insert it into a table
will result in undefined behaviour.
<p> Reimplement <a href="#createEditor">createEditor</a>() and <a href="#setContentFromEditor">setContentFromEditor</a>() if you want
to use your own widget instead of a <a href="qlineedit.html">QLineEdit</a> for editing cell
contents. Reimplement <a href="#paint">paint</a>() if you want to display custom
content.
<p> It is important to ensure that your custom widget can accept the
<a href="focus.html#keyboard-focus">keyboard focus</a>, so that the user can use the tab key to navigate the
table as normal. Therefore, if the widget returned by createEditor()
does not itself accept the keyboard focus, it is necessary to
nominate a child widget to do so on its behalf. For example, a
<a href="qhbox.html">QHBox</a> with two child QLineEdit widgets may use one of them to
accept the keyboard focus:
<p> <pre>
    QWidget* MyTableItem::createEditor() const
    {
        <a href="qhbox.html">QHBox</a>* hbox = new <a href="qhbox.html">QHBox</a>( <a href="#table">table</a>()-&gt;viewport() );
        hbox-&gt;<a href="qwidget.html#setFocusProxy">setFocusProxy</a>(new <a href="qlineedit.html">QLineEdit</a>( hbox ));
        new <a href="qlineedit.html">QLineEdit</a>( hbox );
        return hbox;
    }
    </pre>
 
<p> By default, table items may be replaced by new QTableItems
during the lifetime of a <a href="qtable.html">QTable</a>. Therefore, if you create your
own subclass of QTableItem, and you want to ensure that
this does not happen, you must call <a href="#setReplaceable">setReplaceable</a>(FALSE)
in the constructor of your subclass.
<p> <center><img src="qtableitems.png" alt="Table Items"></center> 
<p> <p>See also <a href="qchecktableitem.html">QCheckTableItem</a>, <a href="qcombotableitem.html">QComboTableItem</a>, and <a href="advanced.html">Advanced Widgets</a>.

<p> 
<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="EditType-enum"></a>QTableItem::EditType</h3>

<p> <a name="wheneditable"></a>
This enum is used to define whether a cell is editable or
read-only (in conjunction with other settings), and how the cell
should be displayed.
<ul>
<li><tt>QTableItem::Always</tt> - 
The cell always <em>looks</em> editable.
</ul><p> Using this EditType ensures that the editor created with
<a href="#createEditor">createEditor</a>() (by default a <a href="qlineedit.html">QLineEdit</a>) is always visible. This
has implications for the alignment of the content: the default
editor aligns everything (even numbers) to the left whilst
numerical values in the cell are by default aligned to the right.
<p> If a cell with the edit type <a href="#EditType-enum">Always</a> looks misaligned you could
reimplement createEditor() for these items.
<ul>
<li><tt>QTableItem::WhenCurrent</tt> - 
The cell <em>looks</em> editable only when it has <a href="focus.html#keyboard-focus">keyboard focus</a> (see
<a href="qtable.html#setCurrentCell">QTable::setCurrentCell</a>()).
<li><tt>QTableItem::OnTyping</tt> - 
The cell <em>looks</em> editable only when the user types in it or
double-clicks it. It resembles the <a href="#EditType-enum">WhenCurrent</a> functionality
but is, perhaps, nicer.
</ul><p> The <a href="#EditType-enum">OnTyping</a> edit type is the default when QTableItem objects
are created by the convenience functions <a href="qtable.html#setText">QTable::setText</a>() and
<a href="qtable.html#setPixmap">QTable::setPixmap</a>().
<ul>
<li><tt>QTableItem::Never</tt> - The cell is not editable.
</ul><p> The cell is actually editable only if <a href="qtable.html#isRowReadOnly">QTable::isRowReadOnly</a>() is
FALSE for its row, <a href="qtable.html#isColumnReadOnly">QTable::isColumnReadOnly</a>() is FALSE for its
column, and <a href="qtable.html#isReadOnly">QTable::isReadOnly</a>() is FALSE.
<p> QComboTableItems have an isEditable() property. This property is
used to indicate whether the user may enter their own text or are
restricted to choosing one of the choices in the list.
QComboTableItems may be interacted with only if they are editable
in accordance with their EditType as described above.
<p> 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QTableItem"></a>QTableItem::QTableItem ( <a href="qtable.html">QTable</a>&nbsp;*&nbsp;table, <a href="qtableitem.html#EditType-enum">EditType</a>&nbsp;et )
</h3>
Creates a table item that is a child of table <em>table</em> with no
text. The item has the <a href="#EditType-enum">EditType</a> <em>et</em>.
<p> The table item will use a <a href="qlineedit.html">QLineEdit</a> for its editor, will not
word-wrap and will occupy a single cell. Insert the table item
into a table with <a href="qtable.html#setItem">QTable::setItem</a>().
<p> The table takes ownership of the table item, so a table item
should not be inserted into more than one table at a time.

<h3 class=fn><a name="QTableItem-2"></a>QTableItem::QTableItem ( <a href="qtable.html">QTable</a>&nbsp;*&nbsp;table, <a href="qtableitem.html#EditType-enum">EditType</a>&nbsp;et, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;text )
</h3>
Creates a table item that is a child of table <em>table</em> with text
<em>text</em>. The item has the <a href="#EditType-enum">EditType</a> <em>et</em>.
<p> The table item will use a <a href="qlineedit.html">QLineEdit</a> for its editor, will not
word-wrap and will occupy a single cell. Insert the table item
into a table with <a href="qtable.html#setItem">QTable::setItem</a>().
<p> The table takes ownership of the table item, so a table item
should not be inserted into more than one table at a time.

<h3 class=fn><a name="QTableItem-3"></a>QTableItem::QTableItem ( <a href="qtable.html">QTable</a>&nbsp;*&nbsp;table, <a href="qtableitem.html#EditType-enum">EditType</a>&nbsp;et, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;text, const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;p )
</h3>
Creates a table item that is a child of table <em>table</em> with text
<em>text</em> and pixmap <em>p</em>. The item has the <a href="#EditType-enum">EditType</a> <em>et</em>.
<p> The table item will display the pixmap to the left of the text. It
will use a <a href="qlineedit.html">QLineEdit</a> for editing the text, will not word-wrap and
will occupy a single cell. Insert the table item into a table with
<a href="qtable.html#setItem">QTable::setItem</a>().
<p> The table takes ownership of the table item, so a table item
should not be inserted in more than one table at a time.

<h3 class=fn><a name="~QTableItem"></a>QTableItem::~QTableItem ()<tt> [virtual]</tt>
</h3>
The destructor deletes this item and frees all allocated
resources.
<p> If the table item is in a table (i.e. was inserted with
setItem()), it will be removed from the table and the cell it
occupied.

<h3 class=fn>int <a name="alignment"></a>QTableItem::alignment () const<tt> [virtual]</tt>
</h3>
The alignment function returns how the text contents of the cell
are aligned when drawn. The default implementation aligns numbers
to the right and any other text to the left.
<p> <p>See also <a href="qt.html#AlignmentFlags-enum">Qt::AlignmentFlags</a>.

<h3 class=fn>int <a name="col"></a>QTableItem::col () const
</h3>
Returns the column where the table item is located. If the cell
spans multiple columns, this function returns the left-most
column.
<p> <p>See also <a href="#row">row</a>() and <a href="#setCol">setCol</a>().

<p>Example: <a href="bigtable-example.html#x1293">table/bigtable/main.cpp</a>.
<h3 class=fn>int <a name="colSpan"></a>QTableItem::colSpan () const
</h3>
Returns the column span of the table item, usually 1.
<p> <p>See also <a href="#setSpan">setSpan</a>() and <a href="#rowSpan">rowSpan</a>().

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="createEditor"></a>QTableItem::createEditor () const<tt> [virtual]</tt>
</h3>
This virtual function creates an editor which the user can
interact with to edit the cell's contents. The default
implementation creates a <a href="qlineedit.html">QLineEdit</a>.
<p> If the function returns 0, the cell is read-only.
<p> The returned widget should preferably be invisible, ideally with
<a href="qscrollview.html#viewport">QTable::viewport</a>() as parent.
<p> If you reimplement this function you'll almost certainly need to
reimplement <a href="#setContentFromEditor">setContentFromEditor</a>(), and may need to reimplement
<a href="#sizeHint">sizeHint</a>().
<p> 

<pre>    <a name="x2444"></a>QWidget *ComboItem::<a href="#createEditor">createEditor</a>() const
    {
        // create an editor - a combobox in our case
        ( (ComboItem*)this )-&gt;cb = new <a href="qcombobox.html">QComboBox</a>( <a href="#table">table</a>()-&gt;viewport() );
        QObject::<a href="qobject.html#connect">connect</a>( cb, SIGNAL( activated( int ) ), table(), SLOT( doValueChanged() ) );
        cb-&gt;insertItem( "Yes" );
        cb-&gt;insertItem( "No" );
        // and initialize it
        cb-&gt;setCurrentItem( <a href="#text">text</a>() == "No" ? 1 : 0 );
        return cb;
</pre>
<p> <p>See also <a href="qtable.html#createEditor">QTable::createEditor</a>(), <a href="#setContentFromEditor">setContentFromEditor</a>(), <a href="qscrollview.html#viewport">QTable::viewport</a>(), and <a href="#setReplaceable">setReplaceable</a>().

<p>Example: <a href="qtableitem.html#x2444">table/statistics/statistics.cpp</a>.
<h3 class=fn><a href="qtableitem.html#EditType-enum">EditType</a> <a name="editType"></a>QTableItem::editType () const
</h3>
Returns the table item's edit type.
<p> This is set when the table item is constructed.
<p> <p>See also <a href="#EditType-enum">EditType</a> and <a href="#QTableItem">QTableItem</a>().

<h3 class=fn>bool <a name="isEnabled"></a>QTableItem::isEnabled () const
</h3>
Returns TRUE if the table item is enabled; otherwise returns FALSE.
<p> <p>See also <a href="#setEnabled">setEnabled</a>().

<h3 class=fn>bool <a name="isReplaceable"></a>QTableItem::isReplaceable () const
</h3>
This function returns whether the contents of the cell may be
replaced with the contents of another table item. Regardless of
this setting, table items that span more than one cell may not
have their contents replaced by another table item.
<p> (This differs from <a href="#EditType-enum">EditType</a> because EditType is concerned with
whether the <em>user</em> is able to change the contents of a cell.)
<p> <p>See also <a href="#setReplaceable">setReplaceable</a>() and <a href="#EditType-enum">EditType</a>.

<h3 class=fn><a href="qstring.html">QString</a> <a name="key"></a>QTableItem::key () const<tt> [virtual]</tt>
</h3>
This virtual function returns the key that should be used for
sorting. The default implementation returns the <a href="#text">text</a>() of the
relevant item.
<p> <p>See also <a href="qtable.html#sorting-prop">QTable::sorting</a>.

<h3 class=fn>void <a name="paint"></a>QTableItem::paint ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, const&nbsp;<a href="qcolorgroup.html">QColorGroup</a>&nbsp;&amp;&nbsp;cg, const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;cr, bool&nbsp;selected )<tt> [virtual]</tt>
</h3>
This virtual function is used to paint the contents of an item
using the painter <em>p</em> in the rectangular area <em>cr</em> using the
color group <em>cg</em>.
<p> If <em>selected</em> is TRUE the cell is displayed in a way that
indicates that it is highlighted.
<p> You don't usually need to use this function but if you want to
draw custom content in a cell you will need to reimplement it.
<p> The painter passed to this function is translated so that 0, 0
is the top-left corner of the item that is being painted.
<p> Note that the painter is not clipped by default in order to get
maximum efficiency. If you want clipping, use
<p> <pre>
    p-&gt;setClipRect( <a href="#table">table</a>()-&gt;cellRect(row, col), QPainter::ClipPainter );
    //... your drawing code
    p-&gt;setClipping( FALSE );
    </pre>
 
<p> 
<p>Example: <a href="statistics-example.html#x2786">table/statistics/statistics.cpp</a>.
<h3 class=fn><a href="qpixmap.html">QPixmap</a> <a name="pixmap"></a>QTableItem::pixmap () const<tt> [virtual]</tt>
</h3>
Returns the table item's pixmap or a null pixmap if no pixmap has
been set.
<p> <p>See also <a href="#setPixmap">setPixmap</a>() and <a href="#text">text</a>().

<h3 class=fn>int <a name="row"></a>QTableItem::row () const
</h3>
Returns the row where the table item is located. If the cell spans
multiple rows, this function returns the top-most row.
<p> <p>See also <a href="#col">col</a>() and <a href="#setRow">setRow</a>().

<p>Example: <a href="bigtable-example.html#x1294">table/bigtable/main.cpp</a>.
<h3 class=fn>int <a name="rowSpan"></a>QTableItem::rowSpan () const
</h3>
Returns the row span of the table item, usually 1.
<p> <p>See also <a href="#setSpan">setSpan</a>() and <a href="#colSpan">colSpan</a>().

<h3 class=fn>int <a name="rtti"></a>QTableItem::rtti () const<tt> [virtual]</tt>
</h3>
Returns the Run Time Type Identification value for this table item
which for QTableItems is 0.
<p> When you create subclasses based on QTableItem make sure that each
subclass returns a unique <a href="#rtti">rtti</a>() value. It is advisable to use
values greater than 1000, preferably large random numbers, to
allow for extensions to this class.
<p> <p>See also <a href="qchecktableitem.html#rtti">QCheckTableItem::rtti</a>() and <a href="qcombotableitem.html#rtti">QComboTableItem::rtti</a>().

<p>Reimplemented in <a href="qcombotableitem.html#rtti">QComboTableItem</a> and <a href="qchecktableitem.html#rtti">QCheckTableItem</a>.
<h3 class=fn>void <a name="setCol"></a>QTableItem::setCol ( int&nbsp;c )<tt> [virtual]</tt>
</h3>
Sets column <em>c</em> as the table item's column. Usually you will not
need to call this function.
<p> If the cell spans multiple columns, this function sets the
left-most column and retains the width of the multi-cell table
item.
<p> <p>See also <a href="#col">col</a>(), <a href="#setRow">setRow</a>(), and <a href="#colSpan">colSpan</a>().

<h3 class=fn>void <a name="setContentFromEditor"></a>QTableItem::setContentFromEditor ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;w )<tt> [virtual]</tt>
</h3>
Whenever the content of a cell has been edited by the editor <em>w</em>,
<a href="qtable.html">QTable</a> calls this virtual function to copy the new values into the
QTableItem.
<p> If you reimplement <a href="#createEditor">createEditor</a>() and return something that is not
a <a href="qlineedit.html">QLineEdit</a> you will need to reimplement this function.
<p> 

<pre>    void ComboItem::<a href="#setContentFromEditor">setContentFromEditor</a>( <a href="qwidget.html">QWidget</a> *w )
    {
        // the user changed the value of the combobox, so synchronize the
        // value of the item (its text), with the value of the combobox
        if ( w-&gt;<a href="qobject.html#inherits">inherits</a>( "QComboBox" ) )
            <a href="#setText">setText</a>( ( (QComboBox*)w )-&gt;currentText() );
        else
            QTableItem::<a href="#setContentFromEditor">setContentFromEditor</a>( w );
</pre>
<p> <p>See also <a href="qtable.html#setCellContentFromEditor">QTable::setCellContentFromEditor</a>().

<p>Example: <a href="statistics-example.html#x2787">table/statistics/statistics.cpp</a>.
<h3 class=fn>void <a name="setEnabled"></a>QTableItem::setEnabled ( bool&nbsp;b )<tt> [virtual]</tt>
</h3>
If <em>b</em> is TRUE, the table item is enabled; if <em>b</em> is FALSE the
table item is disabled.
<p> A disabled item doesn't respond to user interaction.
<p> <p>See also <a href="#isEnabled">isEnabled</a>().

<h3 class=fn>void <a name="setPixmap"></a>QTableItem::setPixmap ( const&nbsp;<a href="qpixmap.html">QPixmap</a>&nbsp;&amp;&nbsp;p )<tt> [virtual]</tt>
</h3>
Sets pixmap <em>p</em> to be this item's pixmap.
<p> Note that <a href="#setPixmap">setPixmap</a>() does not update the cell the table item
belongs to. Use <a href="qtable.html#updateCell">QTable::updateCell</a>() to repaint the cell's
contents.
<p> For <a href="qcombotableitem.html">QComboTableItem</a>s and <a href="qchecktableitem.html">QCheckTableItem</a>s this function
has no visible effect.
<p> <p>See also <a href="qtable.html#setPixmap">QTable::setPixmap</a>(), <a href="#pixmap">pixmap</a>(), and <a href="#setText">setText</a>().

<h3 class=fn>void <a name="setReplaceable"></a>QTableItem::setReplaceable ( bool&nbsp;b )<tt> [virtual]</tt>
</h3>
If <em>b</em> is TRUE it is acceptable to replace the contents of the
cell with the contents of another QTableItem. If <em>b</em> is FALSE the
contents of the cell may not be replaced by the contents of
another table item. Table items that span more than one cell may
not have their contents replaced by another table item.
<p> (This differs from <a href="#EditType-enum">EditType</a> because EditType is concerned with
whether the <em>user</em> is able to change the contents of a cell.)
<p> <p>See also <a href="#isReplaceable">isReplaceable</a>().

<h3 class=fn>void <a name="setRow"></a>QTableItem::setRow ( int&nbsp;r )<tt> [virtual]</tt>
</h3>
Sets row <em>r</em> as the table item's row. Usually you do not need to
call this function.
<p> If the cell spans multiple rows, this function sets the top row
and retains the height of the multi-cell table item.
<p> <p>See also <a href="#row">row</a>(), <a href="#setCol">setCol</a>(), and <a href="#rowSpan">rowSpan</a>().

<h3 class=fn>void <a name="setSpan"></a>QTableItem::setSpan ( int&nbsp;rs, int&nbsp;cs )<tt> [virtual]</tt>
</h3>
Changes the extent of the QTableItem so that it spans multiple
cells covering <em>rs</em> rows and <em>cs</em> columns. The top left cell is
the original cell.
<p> <b>Warning:</b> This function only works if the item has already been
inserted into the table using e.g. <a href="qtable.html#setItem">QTable::setItem</a>(). This
function also checks to make sure if <em>rs</em> and <em>cs</em> are within
the bounds of the table and returns without changing the span if
they are not. In addition swapping, inserting or removing rows and
columns that cross QTableItems spanning more than one cell is not
supported.
<p> <p>See also <a href="#rowSpan">rowSpan</a>() and <a href="#colSpan">colSpan</a>().

<h3 class=fn>void <a name="setText"></a>QTableItem::setText ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;str )<tt> [virtual]</tt>
</h3>
Changes the table item's text to <em>str</em>.
<p> Note that <a href="#setText">setText</a>() does not update the cell the table item
belongs to. Use <a href="qtable.html#updateCell">QTable::updateCell</a>() to repaint the cell's
contents.
<p> <p>See also <a href="qtable.html#setText">QTable::setText</a>(), <a href="#text">text</a>(), <a href="#setPixmap">setPixmap</a>(), and <a href="qtable.html#updateCell">QTable::updateCell</a>().

<p>Example: <a href="statistics-example.html#x2788">table/statistics/statistics.cpp</a>.
<h3 class=fn>void <a name="setWordWrap"></a>QTableItem::setWordWrap ( bool&nbsp;b )<tt> [virtual]</tt>
</h3>
If <em>b</em> is TRUE, the cell's text will be wrapped over multiple
lines, when necessary, to fit the width of the cell; otherwise the
text will be written as a single line.
<p> <p>See also <a href="#wordWrap">wordWrap</a>(), <a href="qtable.html#adjustColumn">QTable::adjustColumn</a>(), and <a href="qtable.html#setColumnStretchable">QTable::setColumnStretchable</a>().

<h3 class=fn><a href="qsize.html">QSize</a> <a name="sizeHint"></a>QTableItem::sizeHint () const<tt> [virtual]</tt>
</h3>
This virtual function returns the size a cell needs to show its
entire content.
<p> If you subclass QTableItem you will often need to reimplement this
function.

<h3 class=fn><a href="qtable.html">QTable</a>&nbsp;* <a name="table"></a>QTableItem::table () const
</h3>

<p> Returns the <a href="qtable.html">QTable</a> the table item belongs to.
<p> <p>See also <a href="qtable.html#setItem">QTable::setItem</a>() and <a href="#QTableItem">QTableItem</a>().

<h3 class=fn><a href="qstring.html">QString</a> <a name="text"></a>QTableItem::text () const<tt> [virtual]</tt>
</h3>
Returns the text of the table item or <a href="qstring.html#QString-null">QString::null</a> if there is no
text.
<p> To ensure that the current value of the editor is returned,
<a href="#setContentFromEditor">setContentFromEditor</a>() is called:
<ol type=1>
<li> if the editMode() is <a href="#EditType-enum">Always</a>, or
<li> if editMode() is <em>not</em> <a href="#EditType-enum">Always</a> but the editor of the cell is
active and the editor is not a <a href="qlineedit.html">QLineEdit</a>.
</ol>
<p> This means that <a href="#text">text</a>() returns the original text value of the item
if the editor is a line edit, until the user commits an edit (e.g.
by pressing Enter or Tab) in which case the new text is returned.
For other editors (e.g. a combobox) setContentFromEditor() is
always called so the currently display value is the one returned.
<p> <p>See also <a href="#setText">setText</a>() and <a href="#pixmap">pixmap</a>().

<h3 class=fn>bool <a name="wordWrap"></a>QTableItem::wordWrap () const
</h3>
Returns TRUE if word wrap is enabled for the cell; otherwise
returns FALSE.
<p> <p>See also <a href="#setWordWrap">setWordWrap</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
