<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/network/qftp.cpp:1063 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QFtp Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QFtp Class Reference<br><small>[<a href="network.html">network module</a>]</small></h1>

<p>The QFtp class provides an implementation of the FTP protocol.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qftp-h.html">qftp.h</a>&gt;</tt>
<p>Inherits <a href="qnetworkprotocol.html">QNetworkProtocol</a>.
<p><a href="qftp-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QFtp"><b>QFtp</b></a> ()</li>
<li class=fn><a href="#QFtp-2"><b>QFtp</b></a> ( QObject&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0 )</li>
<li class=fn>virtual <a href="#~QFtp"><b>~QFtp</b></a> ()</li>
<li class=fn>enum <a href="#State-enum"><b>State</b></a> { Unconnected, HostLookup, Connecting, Connected, LoggedIn, Closing }</li>
<li class=fn>enum <a href="#Error-enum"><b>Error</b></a> { NoError, UnknownError, HostNotFound, ConnectionRefused, NotConnected }</li>
<li class=fn>enum <a href="#Command-enum"><b>Command</b></a> { None, ConnectToHost, Login, Close, List, Cd, Get, Put, Remove, Mkdir, Rmdir, Rename, RawCommand }</li>
<li class=fn>int <a href="#connectToHost"><b>connectToHost</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port = 21 )</li>
<li class=fn>int <a href="#login"><b>login</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;user = QString::null, const&nbsp;QString&nbsp;&amp;&nbsp;password = QString::null )</li>
<li class=fn>int <a href="#close"><b>close</b></a> ()</li>
<li class=fn>int <a href="#list"><b>list</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;dir = QString::null )</li>
<li class=fn>int <a href="#cd"><b>cd</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;dir )</li>
<li class=fn>int <a href="#get"><b>get</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;file, QIODevice&nbsp;*&nbsp;dev = 0 )</li>
<li class=fn>int <a href="#put-2"><b>put</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;data, const&nbsp;QString&nbsp;&amp;&nbsp;file )</li>
<li class=fn>int <a href="#put"><b>put</b></a> ( QIODevice&nbsp;*&nbsp;dev, const&nbsp;QString&nbsp;&amp;&nbsp;file )</li>
<li class=fn>int <a href="#remove"><b>remove</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;file )</li>
<li class=fn>int <a href="#mkdir"><b>mkdir</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;dir )</li>
<li class=fn>int <a href="#rmdir"><b>rmdir</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;dir )</li>
<li class=fn>int <a href="#rename"><b>rename</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;oldname, const&nbsp;QString&nbsp;&amp;&nbsp;newname )</li>
<li class=fn>int <a href="#rawCommand"><b>rawCommand</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;command )</li>
<li class=fn>Q_ULONG <a href="#bytesAvailable"><b>bytesAvailable</b></a> () const</li>
<li class=fn>Q_LONG <a href="#readBlock"><b>readBlock</b></a> ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )</li>
<li class=fn>QByteArray <a href="#readAll"><b>readAll</b></a> ()</li>
<li class=fn>int <a href="#currentId"><b>currentId</b></a> () const</li>
<li class=fn>QIODevice * <a href="#currentDevice"><b>currentDevice</b></a> () const</li>
<li class=fn>Command <a href="#currentCommand"><b>currentCommand</b></a> () const</li>
<li class=fn>bool <a href="#hasPendingCommands"><b>hasPendingCommands</b></a> () const</li>
<li class=fn>void <a href="#clearPendingCommands"><b>clearPendingCommands</b></a> ()</li>
<li class=fn>State <a href="#state"><b>state</b></a> () const</li>
<li class=fn>Error <a href="#error"><b>error</b></a> () const</li>
<li class=fn>QString <a href="#errorString"><b>errorString</b></a> () const</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>void <a href="#abort"><b>abort</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#stateChanged"><b>stateChanged</b></a> ( int&nbsp;state )</li>
<li class=fn>void <a href="#listInfo"><b>listInfo</b></a> ( const&nbsp;QUrlInfo&nbsp;&amp;&nbsp;i )</li>
<li class=fn>void <a href="#readyRead"><b>readyRead</b></a> ()</li>
<li class=fn>void <a href="#dataTransferProgress"><b>dataTransferProgress</b></a> ( int&nbsp;done, int&nbsp;total )</li>
<li class=fn>void <a href="#rawCommandReply"><b>rawCommandReply</b></a> ( int&nbsp;replyCode, const&nbsp;QString&nbsp;&amp;&nbsp;detail )</li>
<li class=fn>void <a href="#commandStarted"><b>commandStarted</b></a> ( int&nbsp;id )</li>
<li class=fn>void <a href="#commandFinished"><b>commandFinished</b></a> ( int&nbsp;id, bool&nbsp;error )</li>
<li class=fn>void <a href="#done"><b>done</b></a> ( bool&nbsp;error )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QFtp class provides an implementation of the FTP protocol.

<p> 

<p> This class provides two different interfaces: one is the
<a href="qnetworkprotocol.html">QNetworkProtocol</a> interface that allows you to use FTP through the
<a href="qurloperator.html">QUrlOperator</a> abstraction. The other is a direct interface to FTP
that gives you lower-level access to the FTP protocol for finer
control. Using the direct interface you can also execute arbitrary
FTP commands.
<p> Don't mix the two interfaces, since the behavior is not
well-defined.
<p> If you want to use QFtp with the QNetworkProtocol interface, you
do not use it directly, but rather through a QUrlOperator, for
example:
<p> <pre>
    <a href="qurloperator.html">QUrlOperator</a> op( "ftp://ftp.trolltech.com" );
    op.<a href="qurloperator.html#listChildren">listChildren</a>(); // Asks the server to provide a directory listing
    </pre>
 
<p> This code will only work if the QFtp class is registered; to
register the class, you must call <a href="qurloperator.html#qInitNetworkProtocols">qInitNetworkProtocols</a>() before
using a QUrlOperator with QFtp.
<p> The rest of this descrption describes the direct interface to FTP.
<p> The class works asynchronously, so there are no blocking
functions. If an operation cannot be executed immediately, the
function will still return straight away and the operation will be
scheduled for later execution. The results of scheduled operations
are reported via signals. This approach depends on the event loop
being in operation.
<p> The operations that can be scheduled (they are called "commands"
in the rest of the documentation) are the following:
<a href="#connectToHost">connectToHost</a>(), <a href="#login">login</a>(), <a href="#close">close</a>(), <a href="#list">list</a>(), <a href="#cd">cd</a>(), <a href="#get">get</a>(), <a href="#put">put</a>(),
<a href="#remove">remove</a>(), <a href="#mkdir">mkdir</a>(), <a href="#rmdir">rmdir</a>(), <a href="#rename">rename</a>() and <a href="#rawCommand">rawCommand</a>().
<p> All of these commands return a unique identifier that allows you
to keep track of the command that is currently being executed.
When the execution of a command starts, the <a href="#commandStarted">commandStarted</a>()
signal with the command's identifier is emitted. When the command
is finished, the <a href="#commandFinished">commandFinished</a>() signal is emitted with the
command's identifier and a bool that indicates whether the command
finished with an error.
<p> In some cases, you might want to execute a sequence of commands,
e.g. if you want to connect and login to a FTP server. This is
simply achieved:
<p> <pre>
    QFtp *ftp = new QFtp( this ); // this is an optional QObject parent
    ftp-&gt;<a href="#connectToHost">connectToHost</a>( "ftp.trolltech.com" );
    ftp-&gt;<a href="#login">login</a>();
    </pre>
 
<p> In this case two FTP commands have been scheduled. When the last
scheduled command has finished, a <a href="#done">done</a>() signal is emitted with
a bool argument that tells you whether the sequence finished with
an error.
<p> If an error occurs during the execution of one of the commands in
a sequence of commands, all the pending commands (i.e. scheduled,
but not yet executed commands) are cleared and no signals are
emitted for them.
<p> Some commands, e.g. <a href="#list">list</a>(), emit additional signals to report
their results.
<p> Example: If you want to download the INSTALL file from Trolltech's
FTP server, you would write this:
<p> <pre>
    ftp-&gt;connectToHost( "ftp.trolltech.com" );  // id == 1
    ftp-&gt;login();                               // id == 2
    ftp-&gt;cd( "qt" );                            // id == 3
    ftp-&gt;get( "INSTALL" );                      // id == 4
    ftp-&gt;close();                               // id == 5
    </pre>
 
<p> For this example the following sequence of signals is emitted
(with small variations, depending on network traffic, etc.):
<p> <pre>
    <a href="qnetworkprotocol.html#start">start</a>( 1 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">HostLookup</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connecting</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connected</a> )
    <a href="qnetworkprotocol.html#finished">finished</a>( 1, FALSE )

    <a href="qnetworkprotocol.html#start">start</a>( 2 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">LoggedIn</a> )
    <a href="qnetworkprotocol.html#finished">finished</a>( 2, FALSE )

    <a href="qnetworkprotocol.html#start">start</a>( 3 )
    <a href="qnetworkprotocol.html#finished">finished</a>( 3, FALSE )

    <a href="qnetworkprotocol.html#start">start</a>( 4 )
    <a href="#dataTransferProgress">dataTransferProgress</a>( 0, 3798 )
    <a href="#dataTransferProgress">dataTransferProgress</a>( 2896, 3798 )
    <a href="#readyRead">readyRead</a>()
    <a href="#dataTransferProgress">dataTransferProgress</a>( 3798, 3798 )
    <a href="#readyRead">readyRead</a>()
    <a href="qnetworkprotocol.html#finished">finished</a>( 4, FALSE )

    <a href="qnetworkprotocol.html#start">start</a>( 5 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Closing</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Unconnected</a> )
    <a href="qnetworkprotocol.html#finished">finished</a>( 5, FALSE )

    <a href="#done">done</a>( FALSE )
    </pre>
 
<p> The <a href="#dataTransferProgress">dataTransferProgress</a>() signal in the above example is useful
if you want to show a <a href="qprogressbar.html">progressbar</a> to
inform the user about the progress of the download. The
<a href="#readyRead">readyRead</a>() signal tells you that there is data ready to be read.
The amount of data can be queried then with the <a href="#bytesAvailable">bytesAvailable</a>()
function and it can be read with the <a href="#readBlock">readBlock</a>() or <a href="#readAll">readAll</a>()
function.
<p> If the login fails for the above example, the signals would look
like this:
<p> <pre>
    <a href="qnetworkprotocol.html#start">start</a>( 1 )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">HostLookup</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connecting</a> )
    <a href="#stateChanged">stateChanged</a>( <a href="#State-enum">Connected</a> )
    <a href="qnetworkprotocol.html#finished">finished</a>( 1, FALSE )

    <a href="qnetworkprotocol.html#start">start</a>( 2 )
    <a href="qnetworkprotocol.html#finished">finished</a>( 2, TRUE )

    <a href="#done">done</a>( TRUE )
    </pre>
 
<p> You can then get details about the error with the <a href="#error">error</a>() and
<a href="#errorString">errorString</a>() functions.
<p> The functions <a href="#currentId">currentId</a>() and <a href="#currentCommand">currentCommand</a>() provide more
information about the currently executing command.
<p> The functions <a href="#hasPendingCommands">hasPendingCommands</a>() and <a href="#clearPendingCommands">clearPendingCommands</a>()
allow you to query and clear the list of pending commands.
<p> The safest and easiest way to use the FTP protocol is to use
<a href="qurloperator.html">QUrlOperator</a>() or the FTP commands described above. If you are an
experienced network programmer and want to have complete control
you can use <a href="#rawCommand">rawCommand</a>() to execute arbitrary FTP commands.
<p> <p>See also <a href="network.html">Qt Network Documentation</a>, <a href="qnetworkprotocol.html">QNetworkProtocol</a>, <a href="qurloperator.html">QUrlOperator</a>, <a href="qhttp.html">QHttp</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="Command-enum"></a>QFtp::Command</h3>

<p> This enum is used as the return value for the <a href="#currentCommand">currentCommand</a>() function.
This allows you to perform specific actions for particular
commands, e.g. in a FTP client, you might want to clear the
directory view when a <a href="#list">list</a>() command is started; in this case you
can simply check in the slot connected to the <a href="qnetworkprotocol.html#start">start</a>() signal if
the currentCommand() is <a href="#Command-enum">List</a>.
<ul>
<li><tt>QFtp::None</tt> - No command is being executed.
<li><tt>QFtp::ConnectToHost</tt> - <a href="#connectToHost">connectToHost</a>() is being executed.
<li><tt>QFtp::Login</tt> - <a href="#login">login</a>() is being executed.
<li><tt>QFtp::Close</tt> - <a href="#close">close</a>() is being executed.
<li><tt>QFtp::List</tt> - list() is being executed.
<li><tt>QFtp::Cd</tt> - <a href="#cd">cd</a>() is being executed.
<li><tt>QFtp::Get</tt> - <a href="#get">get</a>() is being executed.
<li><tt>QFtp::Put</tt> - <a href="#put">put</a>() is being executed.
<li><tt>QFtp::Remove</tt> - <a href="#remove">remove</a>() is being executed.
<li><tt>QFtp::Mkdir</tt> - <a href="#mkdir">mkdir</a>() is being executed.
<li><tt>QFtp::Rmdir</tt> - <a href="#rmdir">rmdir</a>() is being executed.
<li><tt>QFtp::Rename</tt> - <a href="#rename">rename</a>() is being executed.
<li><tt>QFtp::RawCommand</tt> - <a href="#rawCommand">rawCommand</a>() is being executed.
</ul><p> <p>See also <a href="#currentCommand">currentCommand</a>().

<h3 class=fn><a name="Error-enum"></a>QFtp::Error</h3>

<p> This enum identifies the error that occurred.
<ul>
<li><tt>QFtp::NoError</tt> - No error occurred.
<li><tt>QFtp::HostNotFound</tt> - The host name lookup failed.
<li><tt>QFtp::ConnectionRefused</tt> - The server refused the connection.
<li><tt>QFtp::NotConnected</tt> - Tried to send a command, but there is no connection to
a server.
<li><tt>QFtp::UnknownError</tt> - An error other than those specified above
occurred.
</ul><p> <p>See also <a href="#error">error</a>().

<h3 class=fn><a name="State-enum"></a>QFtp::State</h3>

<p> This enum defines the connection state:
<ul>
<li><tt>QFtp::Unconnected</tt> - There is no connection to the host.
<li><tt>QFtp::HostLookup</tt> - A host name lookup is in progress.
<li><tt>QFtp::Connecting</tt> - An attempt to connect to the host is in progress.
<li><tt>QFtp::Connected</tt> - Connection to the host has been achieved.
<li><tt>QFtp::LoggedIn</tt> - Connection and user login have been achieved.
<li><tt>QFtp::Closing</tt> - The connection is closing down, but it is not yet
closed. (The state will be <a href="#State-enum">Unconnected</a> when the connection is
closed.)
</ul><p> <p>See also <a href="#stateChanged">stateChanged</a>() and <a href="#state">state</a>().

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QFtp"></a>QFtp::QFtp ()
</h3>
Constructs a QFtp object.

<h3 class=fn><a name="QFtp-2"></a>QFtp::QFtp ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;parent, const&nbsp;char&nbsp;*&nbsp;name = 0 )
</h3>
Constructs a QFtp object. The <em>parent</em> and <em>name</em> parameters
are passed to the <a href="qobject.html">QObject</a> constructor.

<h3 class=fn><a name="~QFtp"></a>QFtp::~QFtp ()<tt> [virtual]</tt>
</h3>
Destructor.

<h3 class=fn>void <a name="abort"></a>QFtp::abort ()<tt> [slot]</tt>
</h3>
Aborts the current command and deletes all scheduled commands.
<p> If there is an unfinished command (i.e. a command for which the
<a href="#commandStarted">commandStarted</a>() signal has been emitted, but for which the
<a href="#commandFinished">commandFinished</a>() signal has not been emitted), this function
sends an <tt>ABORT</tt> command to the server. When the server replies
that the command is aborted, the commandFinished() signal with the
<tt>error</tt> argument set to <tt>TRUE</tt> is emitted for the command. Due
to timing issues, it is possible that the command had already
finished before the abort request reached the server, in which
case, the commandFinished() signal is emitted with the <tt>error</tt>
argument set to <tt>FALSE</tt>.
<p> For all other commands that are affected by the <a href="#abort">abort</a>(), no
signals are emitted.
<p> If you don't start further FTP commands directly after the
abort(), there won't be any scheduled commands and the <a href="#done">done</a>()
signal is emitted.
<p> <b>Warning:</b> Some FTP servers, for example the BSD FTP daemon (version
0.3), wrongly return a positive reply even when an abort has
occurred. For these servers the commandFinished() signal has its
error flag set to <tt>FALSE</tt>, even though the command did not
complete successfully.
<p> <p>See also <a href="#clearPendingCommands">clearPendingCommands</a>().

<p>Example: <a href="ftpclient-example.html#x744">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>Q_ULONG <a name="bytesAvailable"></a>QFtp::bytesAvailable () const
</h3>
Returns the number of bytes that can be read from the data socket
at the moment.
<p> <p>See also <a href="#get">get</a>(), <a href="#readyRead">readyRead</a>(), <a href="#readBlock">readBlock</a>(), and <a href="#readAll">readAll</a>().

<h3 class=fn>int <a name="cd"></a>QFtp::cd ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;dir )
</h3>
Changes the working directory of the server to <em>dir</em>.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x745">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="clearPendingCommands"></a>QFtp::clearPendingCommands ()
</h3>
Deletes all pending commands from the list of scheduled commands.
This does not affect the command that is being executed. If you
want to stop this this as well, use <a href="#abort">abort</a>().
<p> <p>See also <a href="#hasPendingCommands">hasPendingCommands</a>() and <a href="#abort">abort</a>().

<h3 class=fn>int <a name="close"></a>QFtp::close ()
</h3>
Closes the connection to the FTP server.
<p> The <a href="#stateChanged">stateChanged</a>() signal is emitted when the state of the
connecting process changes, e.g. to <a href="#State-enum">Closing</a>, then <a href="#State-enum">Unconnected</a>.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#stateChanged">stateChanged</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x746">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="commandFinished"></a>QFtp::commandFinished ( int&nbsp;id, bool&nbsp;error )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when processing the command identified by
<em>id</em> has finished. <em>error</em> is TRUE if an error occurred during
the processing; otherwise <em>error</em> is FALSE.
<p> <p>See also <a href="#commandStarted">commandStarted</a>(), <a href="#done">done</a>(), <a href="#error">error</a>(), and <a href="#errorString">errorString</a>().

<p>Example: <a href="ftpclient-example.html#x747">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="commandStarted"></a>QFtp::commandStarted ( int&nbsp;id )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when processing the command identified by
<em>id</em> starts.
<p> <p>See also <a href="#commandFinished">commandFinished</a>() and <a href="#done">done</a>().

<p>Example: <a href="ftpclient-example.html#x748">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="connectToHost"></a>QFtp::connectToHost ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;host, Q_UINT16&nbsp;port = 21 )
</h3>
Connects to the FTP server <em>host</em> using port <em>port</em>.
<p> The <a href="#stateChanged">stateChanged</a>() signal is emitted when the state of the
connecting process changes, e.g. to <a href="#State-enum">HostLookup</a>, then <a href="#State-enum">Connecting</a>, then <a href="#State-enum">Connected</a>.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#stateChanged">stateChanged</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x749">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn><a href="qftp.html#Command-enum">Command</a> <a name="currentCommand"></a>QFtp::currentCommand () const
</h3>
Returns the command type of the FTP command being executed or <a href="#Command-enum">None</a> if there is no command being executed.
<p> <p>See also <a href="#currentId">currentId</a>().

<p>Example: <a href="ftpclient-example.html#x750">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn><a href="qiodevice.html">QIODevice</a>&nbsp;* <a name="currentDevice"></a>QFtp::currentDevice () const
</h3>
Returns the <a href="qiodevice.html">QIODevice</a> pointer that is used by the FTP command to read data
from or store data to. If there is no current FTP command being executed or
if the command does not use an IO device, this function returns 0.
<p> This function can be used to delete the QIODevice in the slot connected to
the <a href="#commandFinished">commandFinished</a>() signal.
<p> <p>See also <a href="#get">get</a>() and <a href="#put">put</a>().

<p>Example: <a href="ftpclient-example.html#x751">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="currentId"></a>QFtp::currentId () const
</h3>
Returns the identifier of the FTP command that is being executed
or 0 if there is no command being executed.
<p> <p>See also <a href="#currentCommand">currentCommand</a>().

<h3 class=fn>void <a name="dataTransferProgress"></a>QFtp::dataTransferProgress ( int&nbsp;done, int&nbsp;total )<tt> [signal]</tt>
</h3>

<p> This signal is emitted in response to a <a href="#get">get</a>() or <a href="#put">put</a>() request to
indicate the current progress of the download or upload.
<p> <em>done</em> is the amount of data that has already been transferred
and <em>total</em> is the total amount of data to be read or written. It
is possible that the QFtp class is not able to determine the total
amount of data that should be transferred, in which case <em>total</em>
is 0. (If you connect this signal to a <a href="qprogressbar.html">QProgressBar</a>, the progress
bar shows a busy indicator if the total is 0).
<p> <b>Warning:</b> <em>done</em> and <em>total</em> are not necessarily the size in
bytes, since for large files these values might need to be
"scaled" to avoid overflow.
<p> <p>See also <a href="#get">get</a>(), <a href="#put">put</a>(), and <a href="qprogressbar.html#progress-prop">QProgressBar::progress</a>.

<p>Example: <a href="ftpclient-example.html#x752">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="done"></a>QFtp::done ( bool&nbsp;error )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the last pending command has finished;
(it is emitted after the last command's <a href="#commandFinished">commandFinished</a>() signal).
<em>error</em> is TRUE if an error occurred during the processing;
otherwise <em>error</em> is FALSE.
<p> <p>See also <a href="#commandFinished">commandFinished</a>(), <a href="#error">error</a>(), and <a href="#errorString">errorString</a>().

<p>Example: <a href="ftpclient-example.html#x753">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn><a href="qftp.html#Error-enum">Error</a> <a name="error"></a>QFtp::error () const
</h3>
Returns the last error that occurred. This is useful to find out
what when wrong when receiving a <a href="#commandFinished">commandFinished</a>() or a <a href="#done">done</a>()
signal with the <tt>error</tt> argument set to <tt>TRUE</tt>.
<p> If you start a new command, the error status is reset to <a href="#Error-enum">NoError</a>.

<h3 class=fn><a href="qstring.html">QString</a> <a name="errorString"></a>QFtp::errorString () const
</h3>
Returns a human-readable description of the last error that
occurred. This is useful for presenting a error message to the
user when receiving a <a href="#commandFinished">commandFinished</a>() or a <a href="#done">done</a>() signal with
the <tt>error</tt> argument set to <tt>TRUE</tt>.
<p> The error string is often (but not always) the reply from the
server, so it is not always possible to translate the string. If
the message comes from Qt, the string has already passed through
<a href="qobject.html#tr">tr</a>().

<p>Example: <a href="ftpclient-example.html#x754">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="get"></a>QFtp::get ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;file, <a href="qiodevice.html">QIODevice</a>&nbsp;*&nbsp;dev = 0 )
</h3>
Downloads the file <em>file</em> from the server.
<p> If <em>dev</em> is 0, then the <a href="#readyRead">readyRead</a>() signal is emitted when there
is data available to read. You can then read the data with the
<a href="#readBlock">readBlock</a>() or <a href="#readAll">readAll</a>() functions.
<p> If <em>dev</em> is not 0, the data is written directly to the device <em>dev</em>. Make sure that the <em>dev</em> pointer is valid for the duration
of the operation (it is safe to delete it when the
<a href="#commandFinished">commandFinished</a>() signal is emitted). In this case the readyRead()
signal is <em>not</em> emitted and you cannot read data with the
readBlock() or readAll() functions.
<p> If you don't read the data immediately it becomes available, i.e.
when the readyRead() signal is emitted, it is still available
until the next command is started.
<p> For example, if you want to present the data to the user as soon
as there is something available, connect to the readyRead() signal
and read the data immediately. On the other hand, if you only want
to work with the complete data, you can connect to the
commandFinished() signal and read the data when the <a href="#get">get</a>() command
is finished.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and commandFinished().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the <a href="#commandFinished">commandFinished</a>() signal is
emitted.
<p> <p>See also <a href="#readyRead">readyRead</a>(), <a href="#dataTransferProgress">dataTransferProgress</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x755">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>bool <a name="hasPendingCommands"></a>QFtp::hasPendingCommands () const
</h3>
Returns TRUE if there are any commands scheduled that have not yet
been executed; otherwise returns FALSE.
<p> The command that is being executed is <em>not</em> considered as a
scheduled command.
<p> <p>See also <a href="#clearPendingCommands">clearPendingCommands</a>(), <a href="#currentId">currentId</a>(), and <a href="#currentCommand">currentCommand</a>().

<h3 class=fn>int <a name="list"></a>QFtp::list ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;dir = QString::null )
</h3>
Lists the contents of directory <em>dir</em> on the FTP server. If <em>dir</em> is empty, it lists the contents of the current directory.
<p> The <a href="#listInfo">listInfo</a>() signal is emitted for each directory entry found.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#listInfo">listInfo</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x756">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="listInfo"></a>QFtp::listInfo ( const&nbsp;<a href="qurlinfo.html">QUrlInfo</a>&nbsp;&amp;&nbsp;i )<tt> [signal]</tt>
</h3>

<p> This signal is emitted for each directory entry the <a href="#list">list</a>() command
finds. The details of the entry are stored in <em>i</em>.
<p> <p>See also <a href="#list">list</a>().

<p>Example: <a href="ftpclient-example.html#x757">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="login"></a>QFtp::login ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;user = QString::null, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;password = QString::null )
</h3>
Logs in to the FTP server with the username <em>user</em> and the
password <em>password</em>.
<p> The <a href="#stateChanged">stateChanged</a>() signal is emitted when the state of the
connecting process changes, e.g. to <a href="#State-enum">LoggedIn</a>.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x758">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="mkdir"></a>QFtp::mkdir ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;dir )
</h3>
Creates a directory called <em>dir</em> on the server.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<h3 class=fn>int <a name="put"></a>QFtp::put ( <a href="qiodevice.html">QIODevice</a>&nbsp;*&nbsp;dev, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;file )
</h3>
Reads the data from the IO device <em>dev</em>, and writes it to the
file called <em>file</em> on the server. The data is read in chunks from
the IO device, so this overload allows you to transmit large
amounts of data without the need to read all the data into memory
at once.
<p> Make sure that the <em>dev</em> pointer is valid for the duration of the
operation (it is safe to delete it when the <a href="#commandFinished">commandFinished</a>() is
emitted).

<p>Example: <a href="ftpclient-example.html#x759">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="put-2"></a>QFtp::put ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;data, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;file )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes the data <em>data</em> to the file called <em>file</em> on the server.
The progress of the upload is reported by the
<a href="#dataTransferProgress">dataTransferProgress</a>() signal.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#dataTransferProgress">dataTransferProgress</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<h3 class=fn>int <a name="rawCommand"></a>QFtp::rawCommand ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;command )
</h3>
Sends the raw FTP command <em>command</em> to the FTP server. This is
useful for low-level FTP access. If the operation you wish to
perform has an equivalent QFtp function, we recommend using the
function instead of raw FTP commands since the functions are
easier and safer.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#rawCommandReply">rawCommandReply</a>(), <a href="#commandStarted">commandStarted</a>(), and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x760">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="rawCommandReply"></a>QFtp::rawCommandReply ( int&nbsp;replyCode, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;detail )<tt> [signal]</tt>
</h3>

<p> This signal is emitted in response to the <a href="#rawCommand">rawCommand</a>() function.
<em>replyCode</em> is the 3 digit reply code and <em>detail</em> is the text
that follows the reply code.
<p> <p>See also <a href="#rawCommand">rawCommand</a>().

<p>Example: <a href="ftpclient-example.html#x761">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn><a href="qbytearray.html">QByteArray</a> <a name="readAll"></a>QFtp::readAll ()
</h3>
Reads all the bytes available from the data socket and returns
them.
<p> <p>See also <a href="#get">get</a>(), <a href="#readyRead">readyRead</a>(), <a href="#bytesAvailable">bytesAvailable</a>(), and <a href="#readBlock">readBlock</a>().

<h3 class=fn>Q_LONG <a name="readBlock"></a>QFtp::readBlock ( char&nbsp;*&nbsp;data, Q_ULONG&nbsp;maxlen )
</h3>
Reads <em>maxlen</em> bytes from the data socket into <em>data</em> and
returns the number of bytes read. Returns -1 if an error occurred.
<p> <p>See also <a href="#get">get</a>(), <a href="#readyRead">readyRead</a>(), <a href="#bytesAvailable">bytesAvailable</a>(), and <a href="#readAll">readAll</a>().

<h3 class=fn>void <a name="readyRead"></a>QFtp::readyRead ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted in response to a <a href="#get">get</a>() command when there
is new data to read.
<p> If you specify a device as the second argument in the get()
command, this signal is <em>not</em> emitted; instead the data is
written directly to the device.
<p> You can read the data with the <a href="#readAll">readAll</a>() or <a href="#readBlock">readBlock</a>() functions.
<p> This signal is useful if you want to process the data in chunks as
soon as it becomes available. If you are only interested in the
complete data, just connect to the <a href="#commandFinished">commandFinished</a>() signal and
read the data then instead.
<p> <p>See also <a href="#get">get</a>(), <a href="#readBlock">readBlock</a>(), <a href="#readAll">readAll</a>(), and <a href="#bytesAvailable">bytesAvailable</a>().

<h3 class=fn>int <a name="remove"></a>QFtp::remove ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;file )
</h3>
Deletes the file called <em>file</em> from the server.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<p>Example: <a href="ftpclient-example.html#x762">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>int <a name="rename"></a>QFtp::rename ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;oldname, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;newname )
</h3>
Renames the file called <em>oldname</em> to <em>newname</em> on the server.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<h3 class=fn>int <a name="rmdir"></a>QFtp::rmdir ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;dir )
</h3>
Removes the directory called <em>dir</em> from the server.
<p> The function does not block and returns immediately. The command
is scheduled, and its execution is performed asynchronously. The
function returns a unique identifier which is passed by
<a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().
<p> When the command is started the commandStarted() signal is
emitted. When it is finished the commandFinished() signal is
emitted.
<p> <p>See also <a href="#commandStarted">commandStarted</a>() and <a href="#commandFinished">commandFinished</a>().

<h3 class=fn><a href="qftp.html#State-enum">State</a> <a name="state"></a>QFtp::state () const
</h3>
Returns the current state of the object. When the state changes,
the <a href="#stateChanged">stateChanged</a>() signal is emitted.
<p> <p>See also <a href="#State-enum">State</a> and <a href="#stateChanged">stateChanged</a>().

<p>Example: <a href="ftpclient-example.html#x763">network/ftpclient/ftpmainwindow.ui.h</a>.
<h3 class=fn>void <a name="stateChanged"></a>QFtp::stateChanged ( int&nbsp;state )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when the state of the connection changes.
The argument <em>state</em> is the new state of the connection; it is
one of the <a href="#State-enum">State</a> values.
<p> It is usually emitted in response to a <a href="#connectToHost">connectToHost</a>() or <a href="#close">close</a>()
command, but it can also be emitted "spontaneously", e.g. when the
server closes the connection unexpectedly.
<p> <p>See also <a href="#connectToHost">connectToHost</a>(), <a href="#close">close</a>(), <a href="#state">state</a>(), and <a href="#State-enum">State</a>.

<p>Example: <a href="ftpclient-example.html#x764">network/ftpclient/ftpmainwindow.ui.h</a>.
<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
