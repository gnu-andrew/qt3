<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/doc/qmemarray.doc:41 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QMemArray Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QMemArray Class Reference</h1>

<p>The QMemArray class is a template class that provides arrays of simple types.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qmemarray-h.html">qmemarray.h</a>&gt;</tt>
<p>Inherited by <a href="qbytearray.html">QByteArray</a> and <a href="qpointarray.html">QPointArray</a>.
<p><a href="qmemarray-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>typedef type&nbsp;*&nbsp;<a href="#Iterator"><b>Iterator</b></a></li>
<li class=fn>typedef const&nbsp;type&nbsp;*&nbsp;<a href="#ConstIterator"><b>ConstIterator</b></a></li>
<li class=fn><a href="#QMemArray-2"><b>QMemArray</b></a> ()</li>
<li class=fn><a href="#QMemArray-3"><b>QMemArray</b></a> ( int&nbsp;size )</li>
<li class=fn><a href="#QMemArray-4"><b>QMemArray</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a )</li>
<li class=fn><a href="#~QMemArray"><b>~QMemArray</b></a> ()</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#operator-eq"><b>operator=</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a )</li>
<li class=fn>type * <a href="#data"><b>data</b></a> () const</li>
<li class=fn>uint <a href="#nrefs"><b>nrefs</b></a> () const</li>
<li class=fn>uint <a href="#size"><b>size</b></a> () const</li>
<li class=fn>uint <a href="#count"><b>count</b></a> () const</li>
<li class=fn>bool <a href="#isEmpty"><b>isEmpty</b></a> () const</li>
<li class=fn>bool <a href="#isNull"><b>isNull</b></a> () const</li>
<li class=fn>bool <a href="#resize-2"><b>resize</b></a> ( uint&nbsp;size )</li>
<li class=fn>bool <a href="#resize"><b>resize</b></a> ( uint&nbsp;size, Optimization&nbsp;optim )</li>
<li class=fn>bool <a href="#truncate"><b>truncate</b></a> ( uint&nbsp;pos )</li>
<li class=fn>bool <a href="#fill"><b>fill</b></a> ( const&nbsp;type&nbsp;&amp;&nbsp;v, int&nbsp;size = -1 )</li>
<li class=fn>virtual void <a href="#detach"><b>detach</b></a> ()</li>
<li class=fn>QMemArray&lt;type&gt; <a href="#copy"><b>copy</b></a> () const</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#assign"><b>assign</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a )</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#assign-2"><b>assign</b></a> ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#duplicate"><b>duplicate</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a )</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#duplicate-2"><b>duplicate</b></a> ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )</li>
<li class=fn>QMemArray&lt;type&gt; &amp; <a href="#setRawData"><b>setRawData</b></a> ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )</li>
<li class=fn>void <a href="#resetRawData"><b>resetRawData</b></a> ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )</li>
<li class=fn>int <a href="#find"><b>find</b></a> ( const&nbsp;type&nbsp;&amp;&nbsp;v, uint&nbsp;index = 0 ) const</li>
<li class=fn>int <a href="#contains"><b>contains</b></a> ( const&nbsp;type&nbsp;&amp;&nbsp;v ) const</li>
<li class=fn>void <a href="#sort"><b>sort</b></a> ()</li>
<li class=fn>int <a href="#bsearch"><b>bsearch</b></a> ( const&nbsp;type&nbsp;&amp;&nbsp;v ) const</li>
<li class=fn>type &amp; <a href="#operator[]"><b>operator[]</b></a> ( int&nbsp;index ) const</li>
<li class=fn>type &amp; <a href="#at"><b>at</b></a> ( uint&nbsp;index ) const</li>
<li class=fn><a href="#operator-const-type-*"><b>operator const type *</b></a> () const</li>
<li class=fn>bool <a href="#operator-eq-eq"><b>operator==</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a ) const</li>
<li class=fn>bool <a href="#operator!-eq"><b>operator!=</b></a> ( const&nbsp;QMemArray&lt;type&gt;&nbsp;&amp;&nbsp;a ) const</li>
<li class=fn>Iterator <a href="#begin"><b>begin</b></a> ()</li>
<li class=fn>Iterator <a href="#end"><b>end</b></a> ()</li>
<li class=fn>ConstIterator <a href="#begin-2"><b>begin</b></a> () const</li>
<li class=fn>ConstIterator <a href="#end-2"><b>end</b></a> () const</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn><a href="#QMemArray"><b>QMemArray</b></a> ( int, int )</li>
</ul>
<h2>Related Functions</h2>
<ul>
<li class=fn>Q_UINT16 <a href="#qChecksum"><b>qChecksum</b></a> ( const&nbsp;char&nbsp;*&nbsp;data, uint&nbsp;len )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, const&nbsp;QByteArray&nbsp;&amp;&nbsp;a )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( QDataStream&nbsp;&amp;&nbsp;s, QByteArray&nbsp;&amp;&nbsp;a )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



The QMemArray class is a template class that provides arrays of simple types.
<p> 
<p> QMemArray is implemented as a template class. Define a template
instance QMemArray&lt;X&gt; to create an array that contains X items.
<p> QMemArray stores the array elements directly in the array. It can
only deal with simple types (i.e. C++ types, structs, and classes
that have no constructors, destructors, or virtual functions).
QMemArray uses bitwise operations to copy and compare array
elements. 
<p> The <a href="qptrvector.html">QPtrVector</a> collection class is also a kind of array. Like most
<a href="collection.html">collection classes</a>, it uses pointers
to the contained items.
<p> QMemArray uses <a href="shclass.html">explicit sharing</a> with a
reference count. If more than one array shares common data and one
of the arrays is modified, all the arrays are modified.
<p> The benefit of sharing is that a program does not need to duplicate
data when it is not required, which results in lower memory use
and less copying of data.
<p> An alternative to QMemArray is <a href="qvaluevector.html">QValueVector</a>. The QValueVector class
also provides an array of objects, but can deal with objects that
have constructors (specifically a copy constructor and a default
constructor). QValueVector provides an STL-compatible syntax and is
<a href="shclass.html">implicitly shared</a>.
<p> Example:
<pre>
    #include &lt;<a href="qmemarray-h.html">qmemarray.h</a>&gt;
    #include &lt;stdio.h&gt;

    QMemArray&lt;int&gt; fib( int num ) // returns fibonacci array
    {
        <a href="qapplication.html#Q_ASSERT">Q_ASSERT</a>( num &gt; 2 );
        QMemArray&lt;int&gt; f( num ); // array of ints

        f[0] = f[1] = 1;
        for ( int i = 2; i &lt; num; i++ )
            f[i] = f[i-1] + f[i-2];

        return f;
    }

    int main()
    {
        QMemArray&lt;int&gt; a = fib( 6 ); // get first 6 fibonaccis
        for ( int i = 0; i &lt; a.<a href="#size">size</a>(); i++ )
            <a href="qapplication.html#qDebug">qDebug</a>( "%d: %d", i, a[i] );

        <a href="qapplication.html#qDebug">qDebug</a>( "1 is found %d times", a.<a href="#contains">contains</a>(1) );
        <a href="qapplication.html#qDebug">qDebug</a>( "5 is found at index %d", a.<a href="#find">find</a>(5) );

        return 0;
    }
    </pre>
 
<p> Program output:
<pre>
    0: 1
    1: 1
    2: 2
    3: 3
    4: 5
    5: 8
    1 is found 2 times
    5 is found at index 4
    </pre>
 
<p> Note concerning the use of QMemArray for manipulating structs or
classes: Compilers will often pad the size of structs of odd sizes
up to the nearest word boundary. This will then be the size
QMemArray will use for its bitwise element comparisons. Because
the remaining bytes will typically be uninitialized, this can
cause <a href="#find">find</a>() etc. to fail to find the element. Example:
<p> <pre>
    // MyStruct may be padded to 4 or 8 bytes
    struct MyStruct
    {
        short i; // 2 bytes
        char c;  // 1 byte
    };

    QMemArray&lt;MyStruct&gt; a(1);
    a[0].i = 5;
    a[0].c = 't';

    MyStruct x;
    x.i = '5';
    x.c = 't';
    int i = a.<a href="#find">find</a>( x ); // may return -1 if the pad bytes differ
    </pre>
 
<p> To work around this, make sure that you use a struct where
sizeof() returns the same as the sum of the sizes of the members
either by changing the types of the struct members or by adding
dummy members.
<p> QMemArray data can be traversed by iterators (see <a href="#begin">begin</a>() and
<a href="#end">end</a>()). The number of items is returned by <a href="#count">count</a>(). The array can
be resized with <a href="#resize">resize</a>() and filled using <a href="#fill">fill</a>().
<p> You can make a <a href="shclass.html#shallow-copy">shallow copy</a> of the array with <a href="#assign">assign</a>() (or
<a href="#operator-eq">operator=</a>()) and a <a href="shclass.html#deep-copy">deep copy</a> with <a href="#duplicate">duplicate</a>().
<p> Search for values in the array with <a href="#find">find</a>() and <a href="#contains">contains</a>(). For
sorted arrays (see <a href="#sort">sort</a>()) you can search using <a href="#bsearch">bsearch</a>().
<p> You can set the data directly using <a href="#setRawData">setRawData</a>() and
<a href="#resetRawData">resetRawData</a>(), although this requires care.
<p> <p>See also <a href="shclass.html">Shared Classes</a> and <a href="tools.html">Non-GUI Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ConstIterator"></a>QMemArray::ConstIterator</h3> 
A const QMemArray iterator.
<p>See also <a href="#begin">begin</a>() and <a href="#end">end</a>().

<h3 class=fn><a name="Iterator"></a>QMemArray::Iterator</h3> 
A QMemArray iterator.
<p>See also <a href="#begin">begin</a>() and <a href="#end">end</a>().

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QMemArray"></a>QMemArray::QMemArray ( int, int )<tt> [protected]</tt>
</h3>

<p> Constructs an array <em>without allocating</em> array space. The
arguments should be (0, 0). Use at your own risk.

<h3 class=fn><a name="QMemArray-2"></a>QMemArray::QMemArray ()
</h3>

<p> Constructs a null array.
<p> <p>See also <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QMemArray-3"></a>QMemArray::QMemArray ( int&nbsp;size )
</h3>

<p> Constructs an array with room for <em>size</em> elements. Makes a null
array if <em>size</em> == 0.
<p> The elements are left uninitialized.
<p> <p>See also <a href="#resize">resize</a>() and <a href="#isNull">isNull</a>().

<h3 class=fn><a name="QMemArray-4"></a>QMemArray::QMemArray ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a )
</h3>

<p> Constructs a <a href="shclass.html#shallow-copy">shallow copy</a> of <em>a</em>.
<p> <p>See also <a href="#assign">assign</a>().

<h3 class=fn><a name="~QMemArray"></a>QMemArray::~QMemArray ()
</h3>

<p> Dereferences the array data and deletes it if this was the last
reference.

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="assign"></a>QMemArray::assign ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a )
</h3>

<p> <a href="shclass.html#shallow-copy">Shallow copy</a>. Dereferences the current array and references the
data contained in <em>a</em> instead. Returns a reference to this array.
<p> <p>See also <a href="#operator-eq">operator=</a>().

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="assign-2"></a>QMemArray::assign ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <a href="shclass.html#shallow-copy">Shallow copy</a>. Dereferences the current array and references the
array data <em>data</em>, which contains <em>size</em> elements. Returns a
reference to this array.
<p> Do not delete <em>data</em> later; QMemArray will call free() on it
at the right time.

<h3 class=fn>type &amp; <a name="at"></a>QMemArray::at ( uint&nbsp;index ) const
</h3>

<p> Returns a reference to the element at position <em>index</em> in the array.
<p> This can be used to both read and set an element.
<p> <p>See also <a href="#operator[]">operator[]</a>().

<h3 class=fn><a href="qmemarray.html#Iterator">Iterator</a> <a name="begin"></a>QMemArray::begin ()
</h3>

<p> Returns an iterator pointing at the beginning of this array. This
iterator can be used in the same way as the iterators of
<a href="qvaluelist.html">QValueList</a> and <a href="qmap.html">QMap</a>, for example.

<h3 class=fn><a href="qmemarray.html#ConstIterator">ConstIterator</a> <a name="begin-2"></a>QMemArray::begin () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const iterator pointing at the beginning of this array.
This iterator can be used in the same way as the iterators of
<a href="qvaluelist.html">QValueList</a> and <a href="qmap.html">QMap</a>, for example.

<h3 class=fn>int <a name="bsearch"></a>QMemArray::bsearch ( const&nbsp;type&nbsp;&amp;&nbsp;v ) const
</h3>

<p> In a sorted array (as sorted by <a href="#sort">sort</a>()), finds the first
occurrence of <em>v</em> by using a binary search. For a sorted
array this is generally much faster than <a href="#find">find</a>(), which does
a linear search.
<p> Returns the position of <em>v</em>, or -1 if <em>v</em> could not be found.
<p> <p>See also <a href="#sort">sort</a>() and <a href="#find">find</a>().

<h3 class=fn>int <a name="contains"></a>QMemArray::contains ( const&nbsp;type&nbsp;&amp;&nbsp;v ) const
</h3>

<p> Returns the number of times <em>v</em> occurs in the array.
<p> <p>See also <a href="#find">find</a>().

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt; <a name="copy"></a>QMemArray::copy () const
</h3>

<p> Returns a <a href="shclass.html#deep-copy">deep copy</a> of this array.
<p> <p>See also <a href="#detach">detach</a>() and <a href="#duplicate">duplicate</a>().

<h3 class=fn>uint <a name="count"></a>QMemArray::count () const
</h3>

<p> Returns the same as <a href="#size">size</a>().
<p> <p>See also <a href="#size">size</a>().

<p>Example: <a href="scribble-example.html#x913">scribble/scribble.cpp</a>.
<h3 class=fn>type * <a name="data"></a>QMemArray::data () const
</h3>

<p> Returns a pointer to the actual array data.
<p> The array is a null array if <a href="#data">data</a>() == 0 (null pointer).
<p> <p>See also <a href="#isNull">isNull</a>().

<p>Examples: <a href="fileiconview-example.html#x855">fileiconview/qfileiconview.cpp</a> and <a href="networkprotocol-example.html#x671">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="detach"></a>QMemArray::detach ()<tt> [virtual]</tt>
</h3>

<p> Detaches this array from shared array data; i.e. it makes a
private, <a href="shclass.html#deep-copy">deep copy</a> of the data.
<p> Copying will be performed only if the <a href="#nrefs">reference
    count</a> is greater than one.
<p> <p>See also <a href="#copy">copy</a>().

<p>Reimplemented in <a href="qbitarray.html#detach">QBitArray</a>.
<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="duplicate"></a>QMemArray::duplicate ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a )
</h3>

<p> <a href="shclass.html#deep-copy">Deep copy</a>. Dereferences the current array and obtains a copy of
the data contained in <em>a</em> instead. Returns a reference to this
array.
<p> <p>See also <a href="#copy">copy</a>().

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="duplicate-2"></a>QMemArray::duplicate ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> <a href="shclass.html#deep-copy">Deep copy</a>. Dereferences the current array and obtains a copy of
the array data <em>data</em> instead. Returns a reference to this array.
The size of the array is given by <em>size</em>.
<p> <p>See also <a href="#copy">copy</a>().

<h3 class=fn><a href="qmemarray.html#Iterator">Iterator</a> <a name="end"></a>QMemArray::end ()
</h3>

<p> Returns an iterator pointing behind the last element of this
array. This iterator can be used in the same way as the iterators
of <a href="qvaluelist.html">QValueList</a> and <a href="qmap.html">QMap</a>, for example.

<h3 class=fn><a href="qmemarray.html#ConstIterator">ConstIterator</a> <a name="end-2"></a>QMemArray::end () const
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns a const iterator pointing behind the last element of this
array. This iterator can be used in the same way as the iterators
of <a href="qvaluelist.html">QValueList</a> and <a href="qmap.html">QMap</a>, for example. 

<h3 class=fn>bool <a name="fill"></a>QMemArray::fill ( const&nbsp;type&nbsp;&amp;&nbsp;v, int&nbsp;size = -1 )
</h3>

<p> Fills the array with the value <em>v</em>. If <em>size</em> is specified as
different from -1, then the array will be resized before being
filled.
<p> Returns TRUE if successful, i.e. if <em>size</em> is -1, or <em>size</em> is
!= -1 and the memory can be allocated; otherwise returns FALSE.
<p> <p>See also <a href="#resize">resize</a>().

<h3 class=fn>int <a name="find"></a>QMemArray::find ( const&nbsp;type&nbsp;&amp;&nbsp;v, uint&nbsp;index = 0 ) const
</h3>

<p> Finds the first occurrence of <em>v</em>, starting at position <em>index</em>.
<p> Returns the position of <em>v</em>, or -1 if <em>v</em> could not be found.
<p> <p>See also <a href="#contains">contains</a>().

<h3 class=fn>bool <a name="isEmpty"></a>QMemArray::isEmpty () const
</h3>

<p> Returns TRUE if the array is empty; otherwise returns FALSE.
<p> <a href="#isEmpty">isEmpty</a>() is equivalent to <a href="#isNull">isNull</a>() for QMemArray (unlike
<a href="qstring.html">QString</a>).

<h3 class=fn>bool <a name="isNull"></a>QMemArray::isNull () const
</h3>

<p> Returns TRUE if the array is null; otherwise returns FALSE.
<p> A null array has <a href="#size">size</a>() == 0 and <a href="#data">data</a>() == 0.

<h3 class=fn>uint <a name="nrefs"></a>QMemArray::nrefs () const
</h3>

<p> Returns the reference count for the shared array data. This
reference count is always greater than zero.

<h3 class=fn><a name="operator-const-type-*"></a>QMemArray::operator const type * () const
</h3>

<p> Cast operator. Returns a pointer to the array.
<p> <p>See also <a href="#data">data</a>().

<h3 class=fn>bool <a name="operator!-eq"></a>QMemArray::operator!= ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a ) const
</h3>

<p> Returns TRUE if this array is different from <em>a</em>; otherwise
returns FALSE.
<p> The two arrays are compared bitwise.
<p> <p>See also <a href="#operator-eq-eq">operator==</a>().

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="operator-eq"></a>QMemArray::operator= ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a )
</h3>

<p> Assigns a <a href="shclass.html#shallow-copy">shallow copy</a> of <em>a</em> to this array and returns a
reference to this array.
<p> Equivalent to <a href="#assign">assign</a>( a ).

<h3 class=fn>bool <a name="operator-eq-eq"></a>QMemArray::operator== ( const&nbsp;<a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp;&nbsp;a ) const
</h3>

<p> Returns TRUE if this array is equal to <em>a</em>; otherwise returns
FALSE.
<p> The two arrays are compared bitwise.
<p> <p>See also <a href="#operator!-eq">operator!=</a>().

<h3 class=fn>type &amp; <a name="operator[]"></a>QMemArray::operator[] ( int&nbsp;index ) const
</h3>

<p> Returns a reference to the element at position <em>index</em> in the
array.
<p> This can be used to both read and set an element. Equivalent to
<a href="#at">at</a>().
<p> <p>See also <a href="#at">at</a>().

<h3 class=fn>void <a name="resetRawData"></a>QMemArray::resetRawData ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )
</h3>

<p> Removes internal references to the raw data that was set using
<a href="#setRawData">setRawData</a>(). This means that QMemArray no longer has access to
the <em>data</em>, so you are free to manipulate <em>data</em> as you wish.
You can now use the QMemArray without affecting the original <em>data</em>, for example by calling setRawData() with a pointer to some
other data.
<p> The arguments must be the <em>data</em> and length, <em>size</em>, that were
passed to setRawData(). This is for consistency checking.
<p> <p>See also <a href="#setRawData">setRawData</a>().

<h3 class=fn>bool <a name="resize"></a>QMemArray::resize ( uint&nbsp;size, Optimization&nbsp;optim )
</h3>

<p> Resizes (expands or shrinks) the array to <em>size</em> elements. The
array becomes a null array if <em>size</em> == 0.
<p> Returns TRUE if successful, or FALSE if the memory cannot be
allocated.
<p> New elements are not initialized.
<p> <em>optim</em> is either <tt>QGArray::MemOptim</tt> (the default) or
<tt>QGArray::SpeedOptim</tt>.
<p> <b>Note:</b> By default, <tt>SpeedOptim</tt> is not available for general
use since it is only available if Qt is built in a particular
configuration.
<p> <p>See also <a href="#size">size</a>().

<p>Example: <a href="fileiconview-example.html#x856">fileiconview/qfileiconview.cpp</a>.
<h3 class=fn>bool <a name="resize-2"></a>QMemArray::resize ( uint&nbsp;size )
</h3>

<p> This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Resizes (expands or shrinks) the array to <em>size</em> elements. The
array becomes a null array if <em>size</em> == 0.
<p> Returns TRUE if successful, i.e. if the memory can be allocated;
otherwise returns FALSE.
<p> New elements are not initialized.
<p> <p>See also <a href="#size">size</a>().

<h3 class=fn><a href="qmemarray.html">QMemArray</a>&lt;type&gt;&nbsp;&amp; <a name="setRawData"></a>QMemArray::setRawData ( const&nbsp;type&nbsp;*&nbsp;data, uint&nbsp;size )
</h3>

<p> Sets raw data and returns a reference to the array.
<p> Dereferences the current array and sets the new array data to <em>data</em> and the new array size to <em>size</em>. Do not attempt to resize
or re-assign the array data when raw data has been set. Call
<a href="#resetRawData">resetRawData</a>(<em>data</em>, <em>size</em>) to reset the array.
<p> Setting raw data is useful because it sets QMemArray data without
allocating memory or copying data.
<p> Example I (intended use):
<pre>
    static char bindata[] = { 231, 1, 44, ... };
    <a href="qbytearray.html">QByteArray</a>  a;
    a.<a href="#setRawData">setRawData</a>( bindata, sizeof(bindata) );   // a points to bindata
    <a href="qdatastream.html">QDataStream</a> s( a, <a href="qfile.html#open">IO_ReadOnly</a> );            // open on a's data
    s &gt;&gt; &lt;something&gt;;                           // read raw bindata
    a.<a href="#resetRawData">resetRawData</a>( bindata, sizeof(bindata) ); // finished
    </pre>
 
<p> Example II (you don't want to do this):
<pre>
    static char bindata[] = { 231, 1, 44, ... };
    <a href="qbytearray.html">QByteArray</a>  a, b;
    a.<a href="#setRawData">setRawData</a>( bindata, sizeof(bindata) );   // a points to bindata
    a.<a href="#resize">resize</a>( 8 );                              // will crash
    b = a;                                      // will crash
    a[2] = 123;                                 // might crash
    // forget to resetRawData: will crash
    </pre>
 
<p> <b>Warning:</b> If you do not call <a href="#resetRawData">resetRawData</a>(), QMemArray will attempt
to deallocate or reallocate the raw data, which might not be too
good. Be careful.
<p> <p>See also <a href="#resetRawData">resetRawData</a>().

<h3 class=fn>uint <a name="size"></a>QMemArray::size () const
</h3>

<p> Returns the size of the array (maximum number of elements).
<p> The array is a null array if <a href="#size">size</a>() == 0.
<p> <p>See also <a href="#isNull">isNull</a>() and <a href="#resize">resize</a>().

<h3 class=fn>void <a name="sort"></a>QMemArray::sort ()
</h3>

<p> Sorts the array elements in ascending order, using bitwise
comparison (memcmp()).
<p> <p>See also <a href="#bsearch">bsearch</a>().

<h3 class=fn>bool <a name="truncate"></a>QMemArray::truncate ( uint&nbsp;pos )
</h3>

<p> Truncates the array at position <em>pos</em>.
<p> Returns TRUE if successful, i.e. if the memory can be allocated;
otherwise returns FALSE.
<p> Equivalent to <a href="#resize">resize</a>(<em>pos</em>).
<p> <p>See also <a href="#resize">resize</a>().

<hr><h2>Related Functions</h2>
<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt"></a>operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;a )
</h3>

<p> Writes byte array <em>a</em> to the stream <em>s</em> and returns a reference
to the stream.
<p> <p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a>&nbsp;&amp;&nbsp;s, <a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;a )
</h3>

<p> Reads a byte array into <em>a</em> from the stream <em>s</em> and returns a
reference to the stream.
<p> <p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.

<h3 class=fn>Q_UINT16 <a name="qChecksum"></a>qChecksum ( const&nbsp;char&nbsp;*&nbsp;data, uint&nbsp;len )
</h3>

<p> Returns the CRC-16 checksum of <em>len</em> bytes starting at <em>data</em>.
<p> The checksum is independent of the byte order (endianness).

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
