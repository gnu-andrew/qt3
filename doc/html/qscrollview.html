<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/widgets/qscrollview.cpp:347 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QScrollView Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QScrollView Class Reference</h1>

<p>The QScrollView widget provides a scrolling area with on-demand scroll bars.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qscrollview-h.html">qscrollview.h</a>&gt;</tt>
<p>Inherits <a href="qframe.html">QFrame</a>.
<p>Inherited by <a href="qcanvasview.html">QCanvasView</a>, <a href="qtable.html">QTable</a>, <a href="qgridview.html">QGridView</a>, <a href="qiconview.html">QIconView</a>, <a href="qlistbox.html">QListBox</a>, <a href="qlistview.html">QListView</a>, and <a href="qtextedit.html">QTextEdit</a>.
<p><a href="qscrollview-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QScrollView"><b>QScrollView</b></a> ( QWidget&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, WFlags&nbsp;f = 0 )</li>
<li class=fn><a href="#~QScrollView"><b>~QScrollView</b></a> ()</li>
<li class=fn>enum <a href="#ResizePolicy-enum"><b>ResizePolicy</b></a> { Default, Manual, AutoOne, AutoOneFit }</li>
<li class=fn>virtual void <a href="#setResizePolicy"><b>setResizePolicy</b></a> ( ResizePolicy )</li>
<li class=fn>ResizePolicy <a href="#resizePolicy"><b>resizePolicy</b></a> () const</li>
<li class=fn>void <a href="#removeChild"><b>removeChild</b></a> ( QWidget&nbsp;*&nbsp;child )</li>
<li class=fn>virtual void <a href="#addChild"><b>addChild</b></a> ( QWidget&nbsp;*&nbsp;child, int&nbsp;x = 0, int&nbsp;y = 0 )</li>
<li class=fn>virtual void <a href="#moveChild"><b>moveChild</b></a> ( QWidget&nbsp;*&nbsp;child, int&nbsp;x, int&nbsp;y )</li>
<li class=fn>int <a href="#childX"><b>childX</b></a> ( QWidget&nbsp;*&nbsp;child )</li>
<li class=fn>int <a href="#childY"><b>childY</b></a> ( QWidget&nbsp;*&nbsp;child )</li>
<li class=fn>bool childIsVisible ( QWidget&nbsp;*&nbsp;child ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>void showChild ( QWidget&nbsp;*&nbsp;child, bool&nbsp;y = TRUE ) &nbsp;<em>(obsolete)</em></li>
<li class=fn>enum <a href="#ScrollBarMode-enum"><b>ScrollBarMode</b></a> { Auto, AlwaysOff, AlwaysOn }</li>
<li class=fn>ScrollBarMode <a href="#vScrollBarMode"><b>vScrollBarMode</b></a> () const</li>
<li class=fn>virtual void <a href="#setVScrollBarMode"><b>setVScrollBarMode</b></a> ( ScrollBarMode )</li>
<li class=fn>ScrollBarMode <a href="#hScrollBarMode"><b>hScrollBarMode</b></a> () const</li>
<li class=fn>virtual void <a href="#setHScrollBarMode"><b>setHScrollBarMode</b></a> ( ScrollBarMode )</li>
<li class=fn>QWidget * <a href="#cornerWidget"><b>cornerWidget</b></a> () const</li>
<li class=fn>virtual void <a href="#setCornerWidget"><b>setCornerWidget</b></a> ( QWidget&nbsp;*&nbsp;corner )</li>
<li class=fn>QScrollBar * <a href="#horizontalScrollBar"><b>horizontalScrollBar</b></a> () const</li>
<li class=fn>QScrollBar * <a href="#verticalScrollBar"><b>verticalScrollBar</b></a> () const</li>
<li class=fn>QWidget * <a href="#viewport"><b>viewport</b></a> () const</li>
<li class=fn>QWidget * <a href="#clipper"><b>clipper</b></a> () const</li>
<li class=fn>int <a href="#visibleWidth"><b>visibleWidth</b></a> () const</li>
<li class=fn>int <a href="#visibleHeight"><b>visibleHeight</b></a> () const</li>
<li class=fn>int <a href="#contentsWidth"><b>contentsWidth</b></a> () const</li>
<li class=fn>int <a href="#contentsHeight"><b>contentsHeight</b></a> () const</li>
<li class=fn>int <a href="#contentsX"><b>contentsX</b></a> () const</li>
<li class=fn>int <a href="#contentsY"><b>contentsY</b></a> () const</li>
<li class=fn>void <a href="#updateContents"><b>updateContents</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#updateContents-2"><b>updateContents</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r )</li>
<li class=fn>void <a href="#updateContents-3"><b>updateContents</b></a> ()</li>
<li class=fn>void <a href="#repaintContents"><b>repaintContents</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, bool&nbsp;erase = TRUE )</li>
<li class=fn>void <a href="#repaintContents-2"><b>repaintContents</b></a> ( const&nbsp;QRect&nbsp;&amp;&nbsp;r, bool&nbsp;erase = TRUE )</li>
<li class=fn>void <a href="#repaintContents-3"><b>repaintContents</b></a> ( bool&nbsp;erase = TRUE )</li>
<li class=fn>void <a href="#contentsToViewport"><b>contentsToViewport</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;&amp;&nbsp;vx, int&nbsp;&amp;&nbsp;vy ) const</li>
<li class=fn>void <a href="#viewportToContents"><b>viewportToContents</b></a> ( int&nbsp;vx, int&nbsp;vy, int&nbsp;&amp;&nbsp;x, int&nbsp;&amp;&nbsp;y ) const</li>
<li class=fn>QPoint <a href="#contentsToViewport-2"><b>contentsToViewport</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;p ) const</li>
<li class=fn>QPoint <a href="#viewportToContents-2"><b>viewportToContents</b></a> ( const&nbsp;QPoint&nbsp;&amp;&nbsp;vp ) const</li>
<li class=fn>void <a href="#enableClipper"><b>enableClipper</b></a> ( bool&nbsp;y )</li>
<li class=fn>void <a href="#setStaticBackground"><b>setStaticBackground</b></a> ( bool&nbsp;y )</li>
<li class=fn>bool <a href="#hasStaticBackground"><b>hasStaticBackground</b></a> () const</li>
<li class=fn>QSize <a href="#viewportSize"><b>viewportSize</b></a> ( int&nbsp;x, int&nbsp;y ) const</li>
<li class=fn>bool <a href="#isHorizontalSliderPressed"><b>isHorizontalSliderPressed</b></a> ()</li>
<li class=fn>bool <a href="#isVerticalSliderPressed"><b>isVerticalSliderPressed</b></a> ()</li>
<li class=fn>virtual void <a href="#setDragAutoScroll"><b>setDragAutoScroll</b></a> ( bool&nbsp;b )</li>
<li class=fn>bool <a href="#dragAutoScroll"><b>dragAutoScroll</b></a> () const</li>
</ul>
<h2>Public Slots</h2>
<ul>
<li class=fn>virtual void <a href="#resizeContents"><b>resizeContents</b></a> ( int&nbsp;w, int&nbsp;h )</li>
<li class=fn>void <a href="#scrollBy"><b>scrollBy</b></a> ( int&nbsp;dx, int&nbsp;dy )</li>
<li class=fn>virtual void <a href="#setContentsPos"><b>setContentsPos</b></a> ( int&nbsp;x, int&nbsp;y )</li>
<li class=fn>void <a href="#ensureVisible"><b>ensureVisible</b></a> ( int&nbsp;x, int&nbsp;y )</li>
<li class=fn>void <a href="#ensureVisible-2"><b>ensureVisible</b></a> ( int&nbsp;x, int&nbsp;y, int&nbsp;xmargin, int&nbsp;ymargin )</li>
<li class=fn>void <a href="#center"><b>center</b></a> ( int&nbsp;x, int&nbsp;y )</li>
<li class=fn>void <a href="#center-2"><b>center</b></a> ( int&nbsp;x, int&nbsp;y, float&nbsp;xmargin, float&nbsp;ymargin )</li>
<li class=fn>void <a href="#updateScrollBars"><b>updateScrollBars</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#contentsMoving"><b>contentsMoving</b></a> ( int&nbsp;x, int&nbsp;y )</li>
<li class=fn>void <a href="#horizontalSliderPressed"><b>horizontalSliderPressed</b></a> ()</li>
<li class=fn>void <a href="#horizontalSliderReleased"><b>horizontalSliderReleased</b></a> ()</li>
<li class=fn>void <a href="#verticalSliderPressed"><b>verticalSliderPressed</b></a> ()</li>
<li class=fn>void <a href="#verticalSliderReleased"><b>verticalSliderReleased</b></a> ()</li>
</ul>
<h2>Properties</h2>
<ul>
<li class=fn>int <a href="#contentsHeight-prop"><b>contentsHeight</b></a>&nbsp;- the height of the contents area &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#contentsWidth-prop"><b>contentsWidth</b></a>&nbsp;- the width of the contents area &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#contentsX-prop"><b>contentsX</b></a>&nbsp;- the X coordinate of the contents that are at the left edge of the viewport &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#contentsY-prop"><b>contentsY</b></a>&nbsp;- the Y coordinate of the contents that are at the top edge of the viewport &nbsp;<em>(read only)</em></li>
<li class=fn>bool <a href="#dragAutoScroll-prop"><b>dragAutoScroll</b></a>&nbsp;- whether autoscrolling in drag move events is enabled</li>
<li class=fn>ScrollBarMode <a href="#hScrollBarMode-prop"><b>hScrollBarMode</b></a>&nbsp;- the mode for the horizontal scroll bar</li>
<li class=fn>ResizePolicy <a href="#resizePolicy-prop"><b>resizePolicy</b></a>&nbsp;- the resize policy</li>
<li class=fn>ScrollBarMode <a href="#vScrollBarMode-prop"><b>vScrollBarMode</b></a>&nbsp;- the mode for the vertical scroll bar</li>
<li class=fn>int <a href="#visibleHeight-prop"><b>visibleHeight</b></a>&nbsp;- the vertical amount of the content that is visible &nbsp;<em>(read only)</em></li>
<li class=fn>int <a href="#visibleWidth-prop"><b>visibleWidth</b></a>&nbsp;- the horizontal amount of the content that is visible &nbsp;<em>(read only)</em></li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>virtual void <a href="#drawContents"><b>drawContents</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;clipx, int&nbsp;clipy, int&nbsp;clipw, int&nbsp;cliph )</li>
<li class=fn>virtual void <a href="#drawContentsOffset"><b>drawContentsOffset</b></a> ( QPainter&nbsp;*&nbsp;p, int&nbsp;offsetx, int&nbsp;offsety, int&nbsp;clipx, int&nbsp;clipy, int&nbsp;clipw, int&nbsp;cliph )</li>
<li class=fn>virtual void <a href="#contentsMousePressEvent"><b>contentsMousePressEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsMouseReleaseEvent"><b>contentsMouseReleaseEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsMouseDoubleClickEvent"><b>contentsMouseDoubleClickEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsMouseMoveEvent"><b>contentsMouseMoveEvent</b></a> ( QMouseEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsDragEnterEvent"><b>contentsDragEnterEvent</b></a> ( QDragEnterEvent * )</li>
<li class=fn>virtual void <a href="#contentsDragMoveEvent"><b>contentsDragMoveEvent</b></a> ( QDragMoveEvent * )</li>
<li class=fn>virtual void <a href="#contentsDragLeaveEvent"><b>contentsDragLeaveEvent</b></a> ( QDragLeaveEvent * )</li>
<li class=fn>virtual void <a href="#contentsDropEvent"><b>contentsDropEvent</b></a> ( QDropEvent * )</li>
<li class=fn>virtual void <a href="#contentsWheelEvent"><b>contentsWheelEvent</b></a> ( QWheelEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#contentsContextMenuEvent"><b>contentsContextMenuEvent</b></a> ( QContextMenuEvent&nbsp;*&nbsp;e )</li>
<li class=fn>virtual void <a href="#viewportPaintEvent"><b>viewportPaintEvent</b></a> ( QPaintEvent&nbsp;*&nbsp;pe )</li>
<li class=fn>virtual void <a href="#viewportResizeEvent"><b>viewportResizeEvent</b></a> ( QResizeEvent * )</li>
<li class=fn>virtual void <a href="#setMargins"><b>setMargins</b></a> ( int&nbsp;left, int&nbsp;top, int&nbsp;right, int&nbsp;bottom )</li>
<li class=fn>int <a href="#leftMargin"><b>leftMargin</b></a> () const</li>
<li class=fn>int <a href="#topMargin"><b>topMargin</b></a> () const</li>
<li class=fn>int <a href="#rightMargin"><b>rightMargin</b></a> () const</li>
<li class=fn>int <a href="#bottomMargin"><b>bottomMargin</b></a> () const</li>
<li class=fn>virtual void <a href="#setHBarGeometry"><b>setHBarGeometry</b></a> ( QScrollBar&nbsp;&amp;&nbsp;hbar, int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>virtual void <a href="#setVBarGeometry"><b>setVBarGeometry</b></a> ( QScrollBar&nbsp;&amp;&nbsp;vbar, int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )</li>
<li class=fn>virtual bool <a href="#eventFilter"><b>eventFilter</b></a> ( QObject&nbsp;*&nbsp;obj, QEvent&nbsp;*&nbsp;e )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QScrollView widget provides a scrolling area with on-demand scroll bars.
<p> 

<p> The QScrollView is a large canvas - potentially larger than the
coordinate system normally supported by the underlying window
system. This is important because it is quite easy to go beyond
these limitations (e.g. many web pages are more than 32000 pixels
high). Additionally, the QScrollView can have QWidgets positioned
on it that scroll around with the drawn content. These sub-widgets
can also have positions outside the normal coordinate range (but
they are still limited in size).
<p> To provide content for the widget, inherit from QScrollView,
reimplement <a href="#drawContents">drawContents</a>() and use <a href="#resizeContents">resizeContents</a>() to set the
size of the viewed area. Use <a href="#addChild">addChild</a>() and <a href="#moveChild">moveChild</a>() to
position widgets on the view.
<p> To use QScrollView effectively it is important to understand its
widget structure in the three styles of use: a single large child
widget, a large panning area with some widgets and a large panning
area with many widgets.
<p> <h3> Using One Big Widget
</h3>
<a name="1"></a><p> <center><img src="qscrollview-vp2.png"></center> 
<p> The first, simplest usage of QScrollView (depicted above), is
appropriate for scrolling areas that are never more than about
4000 pixels in either dimension (this is about the maximum
reliable size on X11 servers). In this usage, you just make one
large child in the QScrollView. The child should be a child of the
<a href="#viewport">viewport</a>() of the scrollview and be added with addChild():
<pre>
        QScrollView* sv = new QScrollView(...);
        <a href="qvbox.html">QVBox</a>* big_box = new <a href="qvbox.html">QVBox</a>(sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(big_box);
    </pre>
 
You can go on to add arbitrary child widgets to the single child
in the scrollview as you would with any widget:
<pre>
        <a href="qlabel.html">QLabel</a>* child1 = new <a href="qlabel.html">QLabel</a>("CHILD", big_box);
        <a href="qlabel.html">QLabel</a>* child2 = new <a href="qlabel.html">QLabel</a>("CHILD", big_box);
        <a href="qlabel.html">QLabel</a>* child3 = new <a href="qlabel.html">QLabel</a>("CHILD", big_box);
        ...
    </pre>
 
<p> Here the QScrollView has four children: the viewport(), the
<a href="#verticalScrollBar">verticalScrollBar</a>(), the <a href="#horizontalScrollBar">horizontalScrollBar</a>() and a small
<a href="#cornerWidget">cornerWidget</a>(). The <a href="#viewport">viewport</a>() has one child: the big <a href="qvbox.html">QVBox</a>. The
QVBox has the three <a href="qlabel.html">QLabel</a> objects as child widgets. When the view
is scrolled, the QVBox is moved; its children move with it as
child widgets normally do.
<p> <h3> Using a Very Big View with Some Widgets
</h3>
<a name="1-1"></a><p> <center><img src="qscrollview-vp.png"></center> 
<p> The second usage of QScrollView (depicted above) is appropriate
when few, if any, widgets are on a very large scrolling area that
is potentially larger than 4000 pixels in either dimension. In
this usage you call <a href="#resizeContents">resizeContents</a>() to set the size of the area
and reimplement <a href="#drawContents">drawContents</a>() to paint the contents. You may also
add some widgets by making them children of the viewport() and
adding them with <a href="#addChild">addChild</a>() (this is the same as the process for
the single large widget in the previous example):
<pre>
        QScrollView* sv = new QScrollView(...);
        <a href="qlabel.html">QLabel</a>* child1 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child1);
        <a href="qlabel.html">QLabel</a>* child2 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child2);
        <a href="qlabel.html">QLabel</a>* child3 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child3);
    </pre>
 
Here, the QScrollView has the same four children: the <a href="#viewport">viewport</a>(),
the <a href="#verticalScrollBar">verticalScrollBar</a>(), the <a href="#horizontalScrollBar">horizontalScrollBar</a>() and a small
<a href="#cornerWidget">cornerWidget</a>(). The viewport() has the three <a href="qlabel.html">QLabel</a> objects as
child widgets. When the view is scrolled, the scrollview moves the
child widgets individually.
<p> <h3> Using a Very Big View with Many Widgets
</h3>
<a name="1-2"></a><p> <a name="enableclipper"></a>
<center><img src="qscrollview-cl.png"></center> 
<p> The final usage of QScrollView (depicted above) is appropriate
when many widgets are on a very large scrolling area that is
potentially larger than 4000 pixels in either dimension. In this
usage you call <a href="#resizeContents">resizeContents</a>() to set the size of the area and
reimplement <a href="#drawContents">drawContents</a>() to paint the contents. You then call
<a href="#enableClipper">enableClipper</a>(TRUE) and add widgets, again by making them children
of the <a href="#viewport">viewport</a>(), and adding them with <a href="#addChild">addChild</a>():
<pre>
        QScrollView* sv = new QScrollView(...);
        sv-&gt;<a href="#enableClipper">enableClipper</a>(TRUE);
        <a href="qlabel.html">QLabel</a>* child1 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child1);
        <a href="qlabel.html">QLabel</a>* child2 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child2);
        <a href="qlabel.html">QLabel</a>* child3 = new <a href="qlabel.html">QLabel</a>("CHILD", sv-&gt;<a href="#viewport">viewport</a>());
        sv-&gt;<a href="#addChild">addChild</a>(child3);
    </pre>
 
<p> Here, the QScrollView has four children:  the <a href="#clipper">clipper</a>() (not the
viewport() this time), the <a href="#verticalScrollBar">verticalScrollBar</a>(), the
<a href="#horizontalScrollBar">horizontalScrollBar</a>() and a small <a href="#cornerWidget">cornerWidget</a>(). The clipper()
has one child: the <a href="#viewport">viewport</a>(). The viewport() has the same three
labels as child widgets. When the view is scrolled the viewport()
is moved; its children move with it as child widgets normally do.
<p> <a name="allviews"></a>
<h3> Details Relevant for All Views
</h3>
<a name="1-3"></a><p> Normally you will use the first or third method if you want any
child widgets in the view.
<p> Note that the widget you see in the scrolled area is the
viewport() widget, not the QScrollView itself. So to turn mouse
tracking on, for example, use viewport()->setMouseTracking(TRUE).
<p> To enable drag-and-drop, you would <a href="qwidget.html#setAcceptDrops">setAcceptDrops</a>(TRUE) on the
QScrollView (because drag-and-drop events propagate to the
parent). But to work out the logical position in the view, you
would need to map the drop co-ordinate from being relative to the
QScrollView to being relative to the contents; use the function
<a href="#viewportToContents">viewportToContents</a>() for this.
<p> To handle mouse events on the scrolling area, subclass scrollview
as you would subclass other widgets, but rather than
reimplementing <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), reimplement
<a href="#contentsMousePressEvent">contentsMousePressEvent</a>() instead. The contents specific event
handlers provide translated events in the coordinate system of the
scrollview. If you reimplement mousePressEvent(), you'll get
called only when part of the QScrollView is clicked: and the only
such part is the "corner" (if you don't set a <a href="#cornerWidget">cornerWidget</a>()) and
the frame; everything else is covered up by the viewport, clipper
or scroll bars.
<p> When you construct a QScrollView, some of the widget flags apply
to the <a href="#viewport">viewport</a>() instead of being sent to the <a href="qwidget.html">QWidget</a> constructor
for the QScrollView. This applies to <a href="qt.html#WidgetFlags-enum">WNoAutoErase</a>, <a href="qt.html#WidgetFlags-enum">WStaticContents</a>, and <a href="qt.html#WidgetFlags-enum">WPaintClever</a>. See <a href="qt.html#WidgetFlags-enum">Qt::WidgetFlags</a> for
documentation about these flags. Here are some examples:
<p> <ul>
<p> <li> An image-manipulation widget would use <tt>WNoAutoErase|WStaticContents</tt> because the widget draws all pixels
itself, and when its size increases, it only needs a paint event
for the new part because the old part remains unchanged.
<p> <li> A scrolling game widget in which the background scrolls as the
characters move might use <a href="qt.html#WidgetFlags-enum">WNoAutoErase</a> (in addition to <a href="qt.html#WidgetFlags-enum">WStaticContents</a>) so that the window system background does not
flash in and out during scrolling.
<p> <li> A word processing widget might use <a href="qt.html#WidgetFlags-enum">WNoAutoErase</a> and repaint
itself line by line to get a less-flickery resizing. If the widget
is in a mode in which no text justification can take place, it
might use <a href="qt.html#WidgetFlags-enum">WStaticContents</a> too, so that it would only get a
repaint for the newly visible parts.
<p> </ul>
<p> Child widgets may be moved using <a href="#addChild">addChild</a>() or <a href="#moveChild">moveChild</a>(). Use
<a href="#childX">childX</a>() and <a href="#childY">childY</a>() to get the position of a child widget.
<p> A widget may be placed in the corner between the vertical and
horizontal scrollbars with <a href="#setCornerWidget">setCornerWidget</a>(). You can get access
to the scrollbars using <a href="#horizontalScrollBar">horizontalScrollBar</a>() and
<a href="#verticalScrollBar">verticalScrollBar</a>(), and to the viewport with <a href="#viewport">viewport</a>(). The
scroll view can be scrolled using <a href="#scrollBy">scrollBy</a>(), <a href="#ensureVisible">ensureVisible</a>(),
<a href="#setContentsPos">setContentsPos</a>() or <a href="#center">center</a>().
<p> The visible area is given by <a href="#visibleWidth">visibleWidth</a>() and <a href="#visibleHeight">visibleHeight</a>(),
and the contents area by <a href="#contentsWidth">contentsWidth</a>() and <a href="#contentsHeight">contentsHeight</a>(). The
contents may be repainted using one of the <a href="#repaintContents">repaintContents</a>() or
<a href="#updateContents">updateContents</a>() functions.
<p> Coordinate conversion is provided by <a href="#contentsToViewport">contentsToViewport</a>() and
<a href="#viewportToContents">viewportToContents</a>().
<p> The <a href="#contentsMoving">contentsMoving</a>() signal is emitted just before the contents
are moved to a new position.
<p> <b>Warning:</b> QScrollView currently does not erase the background when
resized, i.e. you must always clear the background manually in
scrollview subclasses. This will change in a future version of Qt
and we recommend specifying the WNoAutoErase flag explicitly.
<p> <img src=qscrollview-m.png> <img src=qscrollview-w.png>
<p>See also <a href="abstractwidgets.html">Abstract Widget Classes</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ResizePolicy-enum"></a>QScrollView::ResizePolicy</h3>

<p> This enum type is used to control a QScrollView's reaction to
resize events.
<ul>
<li><tt>QScrollView::Default</tt> - the QScrollView selects one of the other settings
automatically when it has to. In this version of Qt, QScrollView
changes to <a href="#ResizePolicy-enum">Manual</a> if you resize the contents with
<a href="#resizeContents">resizeContents</a>() and to <a href="#ResizePolicy-enum">AutoOne</a> if a child is added.
<li><tt>QScrollView::Manual</tt> - the contents stays the size set by resizeContents().
<li><tt>QScrollView::AutoOne</tt> - if there is only one child widget the contents stays
the size of that widget. Otherwise the behavior is undefined.
<li><tt>QScrollView::AutoOneFit</tt> - if there is only one child widget the contents stays
the size of that widget's <a href="qwidget.html#sizeHint">sizeHint</a>(). If the scrollview is resized
larger than the child's sizeHint(), the child will be resized to
fit. If there is more than one child, the behavior is undefined.
</ul><p> 
<h3 class=fn><a name="ScrollBarMode-enum"></a>QScrollView::ScrollBarMode</h3>

<p> This enum type describes the various modes of QScrollView's scroll
bars.
<ul>
<li><tt>QScrollView::Auto</tt> - QScrollView shows a scroll bar when the content is
too large to fit and not otherwise. This is the default.
<li><tt>QScrollView::AlwaysOff</tt> - QScrollView never shows a scroll bar.
<li><tt>QScrollView::AlwaysOn</tt> - QScrollView always shows a scroll bar.
</ul><p> (The modes for the horizontal and vertical scroll bars are
independent.)

<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QScrollView"></a>QScrollView::QScrollView ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;parent = 0, const&nbsp;char&nbsp;*&nbsp;name = 0, WFlags&nbsp;f = 0 )
</h3>
Constructs a QScrollView called <em>name</em> with parent <em>parent</em> and
widget flags <em>f</em>.
<p> The widget flags <a href="qt.html#WidgetFlags-enum">WStaticContents</a>, <a href="qt.html#WidgetFlags-enum">WNoAutoErase</a> and <a href="qt.html#WidgetFlags-enum">WPaintClever</a> are propagated to the <a href="#viewport">viewport</a>() widget. The other
widget flags are propagated to the parent constructor as usual.

<h3 class=fn><a name="~QScrollView"></a>QScrollView::~QScrollView ()
</h3>
Destroys the QScrollView. Any children added with <a href="#addChild">addChild</a>() will
be deleted.

<h3 class=fn>void <a name="addChild"></a>QScrollView::addChild ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child, int&nbsp;x = 0, int&nbsp;y = 0 )<tt> [virtual]</tt>
</h3>
Inserts the widget, <em>child</em>, into the scrolled area positioned at
(<em>x</em>, <em>y</em>). The position defaults to (0, 0). If the child is
already in the view, it is just moved.
<p> You may want to call <a href="#enableClipper">enableClipper</a>(TRUE) if you add a large number
of widgets.

<p>Example: <a href="scrollview-example.html#x645">scrollview/scrollview.cpp</a>.
<h3 class=fn>int <a name="bottomMargin"></a>QScrollView::bottomMargin () const<tt> [protected]</tt>
</h3>
Returns the bottom margin.
<p> <p>See also <a href="#setMargins">setMargins</a>().

<h3 class=fn>void <a name="center"></a>QScrollView::center ( int&nbsp;x, int&nbsp;y )<tt> [slot]</tt>
</h3>
Scrolls the content so that the point <em>(x, y)</em> is in the center
of visible area.

<p>Example: <a href="scrollview-example.html#x646">scrollview/scrollview.cpp</a>.
<h3 class=fn>void <a name="center-2"></a>QScrollView::center ( int&nbsp;x, int&nbsp;y, float&nbsp;xmargin, float&nbsp;ymargin )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Scrolls the content so that the point <em>(x, y)</em> is visible with
the <em>xmargin</em> and <em>ymargin</em> margins (as fractions of visible
the area).
<p> For example:
<ul>
<li> Margin 0.0 allows (x, y) to be on the edge of the visible area.
<li> Margin 0.5 ensures that (x, y) is in middle 50% of the visible area.
<li> Margin 1.0 ensures that (x, y) is in the center of the the visible area.
</ul>

<h3 class=fn>bool <a name="childIsVisible"></a>QScrollView::childIsVisible ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child )
</h3> 
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns TRUE if <em>child</em> is visible. This is equivalent
to child->isVisible().

<h3 class=fn>int <a name="childX"></a>QScrollView::childX ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child )
</h3>
Returns the X position of the given <em>child</em> widget. Use this
rather than <a href="qwidget.html#x">QWidget::x</a>() for widgets added to the view.
<p> This function returns 0 if <em>child</em> has not been added to the view.

<h3 class=fn>int <a name="childY"></a>QScrollView::childY ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child )
</h3>
Returns the Y position of the given <em>child</em> widget. Use this
rather than <a href="qwidget.html#y">QWidget::y</a>() for widgets added to the view.
<p> This function returns 0 if <em>child</em> has not been added to the view.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="clipper"></a>QScrollView::clipper () const
</h3>
Returns the clipper widget. Contents in the scrollview are
ultimately clipped to be inside the clipper widget.
<p> You should not need to use this function.
<p> <p>See also <a href="#visibleWidth-prop">visibleWidth</a> and <a href="#visibleHeight-prop">visibleHeight</a>.

<h3 class=fn>void <a name="contentsContextMenuEvent"></a>QScrollView::contentsContextMenuEvent ( <a href="qcontextmenuevent.html">QContextMenuEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#contextMenuEvent">contextMenuEvent</a>() in <em>e</em>: the mouse position is translated to
be a point on the contents.

<p>Example: <a href="tutorial2-06.html#x2584">chart/canvasview.cpp</a>.
<h3 class=fn>void <a name="contentsDragEnterEvent"></a>QScrollView::contentsDragEnterEvent ( <a href="qdragenterevent.html">QDragEnterEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#dragEnterEvent">dragEnterEvent</a>(): the drag position is translated to be a point
on the contents.

<p>Reimplemented in <a href="qtable.html#contentsDragEnterEvent">QTable</a>.
<h3 class=fn>void <a name="contentsDragLeaveEvent"></a>QScrollView::contentsDragLeaveEvent ( <a href="qdragleaveevent.html">QDragLeaveEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#dragLeaveEvent">dragLeaveEvent</a>(): the drag position is translated to be a point
on the contents.

<p>Reimplemented in <a href="qtable.html#contentsDragLeaveEvent">QTable</a>.
<h3 class=fn>void <a name="contentsDragMoveEvent"></a>QScrollView::contentsDragMoveEvent ( <a href="qdragmoveevent.html">QDragMoveEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#dragMoveEvent">dragMoveEvent</a>(): the drag position is translated to be a point on
the contents.

<p>Reimplemented in <a href="qtable.html#contentsDragMoveEvent">QTable</a>.
<h3 class=fn>void <a name="contentsDropEvent"></a>QScrollView::contentsDropEvent ( <a href="qdropevent.html">QDropEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#dropEvent">dropEvent</a>(): the drop position is translated to be a point on the
contents.

<p>Reimplemented in <a href="qtable.html#contentsDropEvent">QTable</a>.
<h3 class=fn>int <a name="contentsHeight"></a>QScrollView::contentsHeight () const
</h3><p>Returns the height of the contents area.
See the <a href="qscrollview.html#contentsHeight-prop">"contentsHeight"</a> property for details.
<h3 class=fn>void <a name="contentsMouseDoubleClickEvent"></a>QScrollView::contentsMouseDoubleClickEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(): the click position in <em>e</em> is translated to be a
point on the contents.
<p> The default implementation generates a normal mouse press event.

<p>Reimplemented in <a href="qlistview.html#contentsMouseDoubleClickEvent">QListView</a>.
<h3 class=fn>void <a name="contentsMouseMoveEvent"></a>QScrollView::contentsMouseMoveEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(): the mouse position in <em>e</em> is translated to be a point
on the contents.

<p>Examples: <a href="canvas-example.html#x2950">canvas/canvas.cpp</a> and <a href="tutorial2-06.html#x2585">chart/canvasview.cpp</a>.
<p>Reimplemented in <a href="qlistview.html#contentsMouseMoveEvent">QListView</a>.
<h3 class=fn>void <a name="contentsMousePressEvent"></a>QScrollView::contentsMousePressEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#mousePressEvent">mousePressEvent</a>(): the press position in <em>e</em> is translated to be a point
on the contents.

<p>Examples: <a href="canvas-example.html#x2951">canvas/canvas.cpp</a> and <a href="tutorial2-06.html#x2586">chart/canvasview.cpp</a>.
<p>Reimplemented in <a href="qlistview.html#contentsMousePressEvent">QListView</a>.
<h3 class=fn>void <a name="contentsMouseReleaseEvent"></a>QScrollView::contentsMouseReleaseEvent ( <a href="qmouseevent.html">QMouseEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(): the release position in <em>e</em> is translated to be a
point on the contents.

<p>Reimplemented in <a href="qlistview.html#contentsMouseReleaseEvent">QListView</a>.
<h3 class=fn>void <a name="contentsMoving"></a>QScrollView::contentsMoving ( int&nbsp;x, int&nbsp;y )<tt> [signal]</tt>
</h3>

<p> This signal is emitted just before the contents are moved to
position <em>(x, y)</em>.
<p> <p>See also <a href="#contentsX-prop">contentsX</a> and <a href="#contentsY-prop">contentsY</a>.

<h3 class=fn>void <a name="contentsToViewport"></a>QScrollView::contentsToViewport ( int&nbsp;x, int&nbsp;y, int&nbsp;&amp;&nbsp;vx, int&nbsp;&amp;&nbsp;vy ) const
</h3>
Translates a point (<em>x</em>, <em>y</em>) in the contents to a point (<em>vx</em>,
<em>vy</em>) on the <a href="#viewport">viewport</a>() widget.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="contentsToViewport-2"></a>QScrollView::contentsToViewport ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;p ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the point <em>p</em> translated to a point on the <a href="#viewport">viewport</a>()
widget.

<h3 class=fn>void <a name="contentsWheelEvent"></a>QScrollView::contentsWheelEvent ( <a href="qwheelevent.html">QWheelEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event handler is called whenever the QScrollView receives a
<a href="qwidget.html#wheelEvent">wheelEvent</a>() in <em>e</em>: the mouse position is translated to be a
point on the contents.

<h3 class=fn>int <a name="contentsWidth"></a>QScrollView::contentsWidth () const
</h3><p>Returns the width of the contents area.
See the <a href="qscrollview.html#contentsWidth-prop">"contentsWidth"</a> property for details.
<h3 class=fn>int <a name="contentsX"></a>QScrollView::contentsX () const
</h3><p>Returns the X coordinate of the contents that are at the left edge of the viewport.
See the <a href="qscrollview.html#contentsX-prop">"contentsX"</a> property for details.
<h3 class=fn>int <a name="contentsY"></a>QScrollView::contentsY () const
</h3><p>Returns the Y coordinate of the contents that are at the top edge of the viewport.
See the <a href="qscrollview.html#contentsY-prop">"contentsY"</a> property for details.
<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="cornerWidget"></a>QScrollView::cornerWidget () const
</h3>
Returns the widget in the corner between the two scroll bars.
<p> By default, no corner widget is present.

<p>Example: <a href="scrollview-example.html#x647">scrollview/scrollview.cpp</a>.
<h3 class=fn>bool <a name="dragAutoScroll"></a>QScrollView::dragAutoScroll () const
</h3><p>Returns TRUE if autoscrolling in drag move events is enabled; otherwise returns FALSE.
See the <a href="qscrollview.html#dragAutoScroll-prop">"dragAutoScroll"</a> property for details.
<h3 class=fn>void <a name="drawContents"></a>QScrollView::drawContents ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;clipx, int&nbsp;clipy, int&nbsp;clipw, int&nbsp;cliph )<tt> [virtual protected]</tt>
</h3>

<p> Reimplement this function if you are viewing a drawing area rather
than a widget.
<p> The function should draw the rectangle (<em>clipx</em>, <em>clipy</em>, <em>clipw</em>, <em>cliph</em>) of the contents using painter <em>p</em>. The clip
rectangle is in the scrollview's coordinates.
<p> For example:
<pre>
    {
        // Fill a 40000 by 50000 rectangle at (100000,150000)

        // Calculate the coordinates...
        int x1 = 100000, y1 = 150000;
        int x2 = x1+40000-1, y2 = y1+50000-1;

        // Clip the coordinates so X/Windows will not have problems...
        if (x1 &lt; clipx) x1=clipx;
        if (y1 &lt; clipy) y1=clipy;
        if (x2 &gt; clipx+clipw-1) x2=clipx+clipw-1;
        if (y2 &gt; clipy+cliph-1) y2=clipy+cliph-1;

        // Paint using the small coordinates...
        if ( x2 &gt;= x1 &amp;&amp; y2 &gt;= y1 )
            p-&gt;fillRect(x1, y1, x2-x1+1, y2-y1+1, red);
    }
    </pre>
 
<p> The clip rectangle and translation of the painter <em>p</em> is already
set appropriately.

<p>Example: <a href="qdir-example.html#x1837">qdir/qdir.cpp</a>.
<p>Reimplemented in <a href="qcanvasview.html#drawContents">QCanvasView</a> and <a href="qtable.html#drawContents">QTable</a>.
<h3 class=fn>void <a name="drawContentsOffset"></a>QScrollView::drawContentsOffset ( <a href="qpainter.html">QPainter</a>&nbsp;*&nbsp;p, int&nbsp;offsetx, int&nbsp;offsety, int&nbsp;clipx, int&nbsp;clipy, int&nbsp;clipw, int&nbsp;cliph )<tt> [virtual protected]</tt>
</h3>
For backward-compatibility only. It is easier to use
<a href="#drawContents">drawContents</a>(<a href="qpainter.html">QPainter</a>*,int,int,int,int).
<p> The default implementation translates the painter appropriately
and calls drawContents(QPainter*,int,int,int,int). See
drawContents() for an explanation of the parameters <em>p</em>, <em>offsetx</em>, <em>offsety</em>, <em>clipx</em>, <em>clipy</em>, <em>clipw</em> and <em>cliph</em>.

<p>Reimplemented in <a href="qlistview.html#drawContentsOffset">QListView</a>.
<h3 class=fn>void <a name="enableClipper"></a>QScrollView::enableClipper ( bool&nbsp;y )
</h3>
When a large numbers of child widgets are in a scrollview,
especially if they are close together, the scrolling performance
can suffer greatly. If <em>y</em> is TRUE the scrollview will use an
extra widget to group child widgets.
<p> Note that you may only call <a href="#enableClipper">enableClipper</a>() prior to adding
widgets.
<p> For a full discussion, see this class's <a href="#enableclipper">detailed description</a>.

<p>Example: <a href="scrollview-example.html#x648">scrollview/scrollview.cpp</a>.
<h3 class=fn>void <a name="ensureVisible"></a>QScrollView::ensureVisible ( int&nbsp;x, int&nbsp;y )<tt> [slot]</tt>
</h3>
Scrolls the content so that the point <em>(x, y)</em> is visible with at
least 50-pixel margins (if possible, otherwise centered).

<h3 class=fn>void <a name="ensureVisible-2"></a>QScrollView::ensureVisible ( int&nbsp;x, int&nbsp;y, int&nbsp;xmargin, int&nbsp;ymargin )<tt> [slot]</tt>
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Scrolls the content so that the point <em>(x, y)</em> is visible with at
least the <em>xmargin</em> and <em>ymargin</em> margins (if possible,
otherwise centered).

<h3 class=fn>bool <a name="eventFilter"></a>QScrollView::eventFilter ( <a href="qobject.html">QObject</a>&nbsp;*&nbsp;obj, <a href="qevent.html">QEvent</a>&nbsp;*&nbsp;e )<tt> [virtual protected]</tt>
</h3>
This event filter ensures the scroll bars are updated when a
single contents widget is resized, shown, hidden or destroyed; it
passes mouse events to the QScrollView. The event is in <em>e</em> and
the object is in <em>obj</em>.

<p>Reimplemented from <a href="qobject.html#eventFilter">QObject</a>.
<p>Reimplemented in <a href="qlistview.html#eventFilter">QListView</a>.
<h3 class=fn><a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> <a name="hScrollBarMode"></a>QScrollView::hScrollBarMode () const
</h3><p>Returns the mode for the horizontal scroll bar.
See the <a href="qscrollview.html#hScrollBarMode-prop">"hScrollBarMode"</a> property for details.
<h3 class=fn>bool <a name="hasStaticBackground"></a>QScrollView::hasStaticBackground () const
</h3>
Returns TRUE if QScrollView uses a static background; otherwise
returns FALSE.
<p> <p>See also <a href="#setStaticBackground">setStaticBackground</a>().

<h3 class=fn><a href="qscrollbar.html">QScrollBar</a>&nbsp;* <a name="horizontalScrollBar"></a>QScrollView::horizontalScrollBar () const
</h3>
Returns the component horizontal scroll bar. It is made available
to allow accelerators, autoscrolling, etc.
<p> It should not be used for other purposes.
<p> This function never returns 0.

<h3 class=fn>void <a name="horizontalSliderPressed"></a>QScrollView::horizontalSliderPressed ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever the user presses the horizontal slider.

<h3 class=fn>void <a name="horizontalSliderReleased"></a>QScrollView::horizontalSliderReleased ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever the user releases the horizontal slider.

<h3 class=fn>bool <a name="isHorizontalSliderPressed"></a>QScrollView::isHorizontalSliderPressed ()
</h3>
Returns TRUE if horizontal slider is pressed by user; otherwise returns FALSE.

<h3 class=fn>bool <a name="isVerticalSliderPressed"></a>QScrollView::isVerticalSliderPressed ()
</h3>
Returns TRUE if vertical slider is pressed by user; otherwise returns FALSE.

<h3 class=fn>int <a name="leftMargin"></a>QScrollView::leftMargin () const<tt> [protected]</tt>
</h3>
Returns the left margin.
<p> <p>See also <a href="#setMargins">setMargins</a>().

<h3 class=fn>void <a name="moveChild"></a>QScrollView::moveChild ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child, int&nbsp;x, int&nbsp;y )<tt> [virtual]</tt>
</h3>
Repositions the <em>child</em> widget to (<em>x</em>, <em>y</em>). This function is
the same as <a href="#addChild">addChild</a>().

<h3 class=fn>void <a name="removeChild"></a>QScrollView::removeChild ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child )
</h3>
Removes the <em>child</em> widget from the scrolled area. Note that this
happens automatically if the <em>child</em> is deleted.

<h3 class=fn>void <a name="repaintContents"></a>QScrollView::repaintContents ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h, bool&nbsp;erase = TRUE )
</h3>
Calls <a href="qwidget.html#repaint">repaint</a>() on a rectangle defined by <em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>,
translated appropriately. If the rectangle is not visible, nothing
is repainted. If <em>erase</em> is TRUE the background is cleared using
the background color.
<p> <p>See also <a href="#updateContents">updateContents</a>().

<h3 class=fn>void <a name="repaintContents-2"></a>QScrollView::repaintContents ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r, bool&nbsp;erase = TRUE )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Repaints the contents of rectangle <em>r</em>. If <em>erase</em> is TRUE the
background is cleared using the background color.

<h3 class=fn>void <a name="repaintContents-3"></a>QScrollView::repaintContents ( bool&nbsp;erase = TRUE )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Repaints the contents. If <em>erase</em> is TRUE the background is
cleared using the background color.

<h3 class=fn>void <a name="resizeContents"></a>QScrollView::resizeContents ( int&nbsp;w, int&nbsp;h )<tt> [virtual slot]</tt>
</h3>
Sets the size of the contents area to <em>w</em> pixels wide and <em>h</em>
pixels high and updates the viewport accordingly.

<h3 class=fn><a href="qscrollview.html#ResizePolicy-enum">ResizePolicy</a> <a name="resizePolicy"></a>QScrollView::resizePolicy () const
</h3><p>Returns the resize policy.
See the <a href="qscrollview.html#resizePolicy-prop">"resizePolicy"</a> property for details.
<h3 class=fn>int <a name="rightMargin"></a>QScrollView::rightMargin () const<tt> [protected]</tt>
</h3>
Returns the right margin.
<p> <p>See also <a href="#setMargins">setMargins</a>().

<h3 class=fn>void <a name="scrollBy"></a>QScrollView::scrollBy ( int&nbsp;dx, int&nbsp;dy )<tt> [slot]</tt>
</h3>
Scrolls the content by <em>dx</em> to the left and <em>dy</em> upwards.

<h3 class=fn>void <a name="setContentsPos"></a>QScrollView::setContentsPos ( int&nbsp;x, int&nbsp;y )<tt> [virtual slot]</tt>
</h3>
Scrolls the content so that the point <em>(x, y)</em> is in the top-left
corner.

<p>Example: <a href="process-example.html#x102">process/process.cpp</a>.
<h3 class=fn>void <a name="setCornerWidget"></a>QScrollView::setCornerWidget ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;corner )<tt> [virtual]</tt>
</h3>
Sets the widget in the <em>corner</em> between the two scroll bars.
<p> You will probably also want to set at least one of the scroll bar
modes to <a href="#ScrollBarMode-enum">AlwaysOn</a>.
<p> Passing 0 shows no widget in the corner.
<p> Any previous <em>corner</em> widget is hidden.
<p> You may call <a href="#setCornerWidget">setCornerWidget</a>() with the same widget at different
times.
<p> All widgets set here will be deleted by the QScrollView when it is
destroyed unless you separately reparent the widget after setting
some other corner widget (or 0).
<p> Any <em>newly</em> set widget should have no current parent.
<p> By default, no corner widget is present.
<p> <p>See also <a href="#vScrollBarMode-prop">vScrollBarMode</a> and <a href="#hScrollBarMode-prop">hScrollBarMode</a>.

<p>Example: <a href="scrollview-example.html#x651">scrollview/scrollview.cpp</a>.
<h3 class=fn>void <a name="setDragAutoScroll"></a>QScrollView::setDragAutoScroll ( bool&nbsp;b )<tt> [virtual]</tt>
</h3><p>Sets whether autoscrolling in drag move events is enabled to <em>b</em>.
See the <a href="qscrollview.html#dragAutoScroll-prop">"dragAutoScroll"</a> property for details.
<h3 class=fn>void <a name="setHBarGeometry"></a>QScrollView::setHBarGeometry ( <a href="qscrollbar.html">QScrollBar</a>&nbsp;&amp;&nbsp;hbar, int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )<tt> [virtual protected]</tt>
</h3>
Called when the horizontal scroll bar geometry changes. This is
provided as a protected function so that subclasses can do
interesting things such as providing extra buttons in some of the
space normally used by the scroll bars.
<p> The default implementation simply gives all the space to <em>hbar</em>.
The new geometry is given by <em>x</em>, <em>y</em>, <em>w</em> and <em>h</em>.
<p> <p>See also <a href="#setVBarGeometry">setVBarGeometry</a>().

<h3 class=fn>void <a name="setHScrollBarMode"></a>QScrollView::setHScrollBarMode ( <a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> )<tt> [virtual]</tt>
</h3><p>Sets the mode for the horizontal scroll bar.
See the <a href="qscrollview.html#hScrollBarMode-prop">"hScrollBarMode"</a> property for details.
<h3 class=fn>void <a name="setMargins"></a>QScrollView::setMargins ( int&nbsp;left, int&nbsp;top, int&nbsp;right, int&nbsp;bottom )<tt> [virtual protected]</tt>
</h3>
Sets the margins around the scrolling area to <em>left</em>, <em>top</em>, <em>right</em> and <em>bottom</em>. This is useful for applications such as
spreadsheets with "locked" rows and columns. The marginal space is
<em>inside</em> the <a href="qframe.html#frameRect">frameRect</a>() and is left blank; reimplement
<a href="qframe.html#drawFrame">drawFrame</a>() or put widgets in the unused area.
<p> By default all margins are zero.
<p> <p>See also <a href="qframe.html#frameChanged">frameChanged</a>().

<h3 class=fn>void <a name="setResizePolicy"></a>QScrollView::setResizePolicy ( <a href="qscrollview.html#ResizePolicy-enum">ResizePolicy</a> )<tt> [virtual]</tt>
</h3><p>Sets the resize policy.
See the <a href="qscrollview.html#resizePolicy-prop">"resizePolicy"</a> property for details.
<h3 class=fn>void <a name="setStaticBackground"></a>QScrollView::setStaticBackground ( bool&nbsp;y )
</h3>
Sets the scrollview to have a static background if <em>y</em> is TRUE,
or a scrolling background if <em>y</em> is FALSE. By default, the
background is scrolling.
<p> Be aware that this mode is quite slow, as a full repaint of the
visible area has to be triggered on every contents move.
<p> <p>See also <a href="#hasStaticBackground">hasStaticBackground</a>().

<h3 class=fn>void <a name="setVBarGeometry"></a>QScrollView::setVBarGeometry ( <a href="qscrollbar.html">QScrollBar</a>&nbsp;&amp;&nbsp;vbar, int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )<tt> [virtual protected]</tt>
</h3>
Called when the vertical scroll bar geometry changes. This is
provided as a protected function so that subclasses can do
interesting things such as providing extra buttons in some of the
space normally used by the scroll bars.
<p> The default implementation simply gives all the space to <em>vbar</em>.
The new geometry is given by <em>x</em>, <em>y</em>, <em>w</em> and <em>h</em>.
<p> <p>See also <a href="#setHBarGeometry">setHBarGeometry</a>().

<h3 class=fn>void <a name="setVScrollBarMode"></a>QScrollView::setVScrollBarMode ( <a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> )<tt> [virtual]</tt>
</h3><p>Sets the mode for the vertical scroll bar.
See the <a href="qscrollview.html#vScrollBarMode-prop">"vScrollBarMode"</a> property for details.
<h3 class=fn>void <a name="showChild"></a>QScrollView::showChild ( <a href="qwidget.html">QWidget</a>&nbsp;*&nbsp;child, bool&nbsp;y = TRUE )
</h3> 
<b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Sets the visibility of <em>child</em>. Equivalent to
<a href="qwidget.html#show">QWidget::show</a>() or <a href="qwidget.html#hide">QWidget::hide</a>().

<h3 class=fn>int <a name="topMargin"></a>QScrollView::topMargin () const<tt> [protected]</tt>
</h3>
Returns the top margin.
<p> <p>See also <a href="#setMargins">setMargins</a>().

<h3 class=fn>void <a name="updateContents"></a>QScrollView::updateContents ( int&nbsp;x, int&nbsp;y, int&nbsp;w, int&nbsp;h )
</h3>
Calls <a href="qwidget.html#update">update</a>() on a rectangle defined by <em>x</em>, <em>y</em>, <em>w</em>, <em>h</em>,
translated appropriately. If the rectangle is not visible, nothing
is repainted.
<p> <p>See also <a href="#repaintContents">repaintContents</a>().

<h3 class=fn>void <a name="updateContents-2"></a>QScrollView::updateContents ( const&nbsp;<a href="qrect.html">QRect</a>&nbsp;&amp;&nbsp;r )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Updates the contents in rectangle <em>r</em>

<h3 class=fn>void <a name="updateContents-3"></a>QScrollView::updateContents ()
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> 
<h3 class=fn>void <a name="updateScrollBars"></a>QScrollView::updateScrollBars ()<tt> [slot]</tt>
</h3>
Updates scroll bars: all possibilities are considered. You should
never need to call this in your code.

<h3 class=fn><a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> <a name="vScrollBarMode"></a>QScrollView::vScrollBarMode () const
</h3><p>Returns the mode for the vertical scroll bar.
See the <a href="qscrollview.html#vScrollBarMode-prop">"vScrollBarMode"</a> property for details.
<h3 class=fn><a href="qscrollbar.html">QScrollBar</a>&nbsp;* <a name="verticalScrollBar"></a>QScrollView::verticalScrollBar () const
</h3>
Returns the component vertical scroll bar. It is made available to
allow accelerators, autoscrolling, etc.
<p> It should not be used for other purposes.
<p> This function never returns 0.

<h3 class=fn>void <a name="verticalSliderPressed"></a>QScrollView::verticalSliderPressed ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever the user presses the vertical slider.

<h3 class=fn>void <a name="verticalSliderReleased"></a>QScrollView::verticalSliderReleased ()<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever the user releases the vertical slider.

<h3 class=fn><a href="qwidget.html">QWidget</a>&nbsp;* <a name="viewport"></a>QScrollView::viewport () const
</h3>
Returns the viewport widget of the scrollview. This is the widget
containing the contents widget or which is the drawing area.

<p>Examples: <a href="helpsystem-example.html#x2683">helpsystem/tooltip.cpp</a> and <a href="scrollview-example.html#x655">scrollview/scrollview.cpp</a>.
<h3 class=fn>void <a name="viewportPaintEvent"></a>QScrollView::viewportPaintEvent ( <a href="qpaintevent.html">QPaintEvent</a>&nbsp;*&nbsp;pe )<tt> [virtual protected]</tt>
</h3>
This is a low-level painting routine that draws the viewport
contents. Reimplement this if <a href="#drawContents">drawContents</a>() is too high-level
(for example, if you don't want to open a <a href="qpainter.html">QPainter</a> on the
viewport). The paint event is passed in <em>pe</em>.

<h3 class=fn>void <a name="viewportResizeEvent"></a>QScrollView::viewportResizeEvent ( <a href="qresizeevent.html">QResizeEvent</a>&nbsp;* )<tt> [virtual protected]</tt>
</h3>
To provide simple processing of events on the contents, this
function receives all resize events sent to the viewport.
<p> <p>See also <a href="qwidget.html#resizeEvent">QWidget::resizeEvent</a>().

<p>Example: <a href="tutorial2-06.html#x2587">chart/canvasview.cpp</a>.
<h3 class=fn><a href="qsize.html">QSize</a> <a name="viewportSize"></a>QScrollView::viewportSize ( int&nbsp;x, int&nbsp;y ) const
</h3>
Returns the viewport size for size (<em>x</em>, <em>y</em>).
<p> The viewport size depends on <em>(x, y)</em> (the size of the contents),
the size of this widget and the modes of the horizontal and
vertical scroll bars.
<p> This function permits widgets that can trade vertical and
horizontal space for each other to control scroll bar appearance
better. For example, a word processor or web browser can control
the width of the right margin accurately, whether or not there
needs to be a vertical scroll bar.

<h3 class=fn>void <a name="viewportToContents"></a>QScrollView::viewportToContents ( int&nbsp;vx, int&nbsp;vy, int&nbsp;&amp;&nbsp;x, int&nbsp;&amp;&nbsp;y ) const
</h3>
Translates a point (<em>vx</em>, <em>vy</em>) on the <a href="#viewport">viewport</a>() widget to a
point (<em>x</em>, <em>y</em>) in the contents.

<h3 class=fn><a href="qpoint.html">QPoint</a> <a name="viewportToContents-2"></a>QScrollView::viewportToContents ( const&nbsp;<a href="qpoint.html">QPoint</a>&nbsp;&amp;&nbsp;vp ) const
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Returns the point on the viewport <em>vp</em> translated to a point in
the contents.

<h3 class=fn>int <a name="visibleHeight"></a>QScrollView::visibleHeight () const
</h3><p>Returns the vertical amount of the content that is visible.
See the <a href="qscrollview.html#visibleHeight-prop">"visibleHeight"</a> property for details.
<h3 class=fn>int <a name="visibleWidth"></a>QScrollView::visibleWidth () const
</h3><p>Returns the horizontal amount of the content that is visible.
See the <a href="qscrollview.html#visibleWidth-prop">"visibleWidth"</a> property for details.
<hr><h2>Property Documentation</h2>
<h3 class=fn>int <a name="contentsHeight-prop"></a>contentsHeight</h3>
<p>This property holds the height of the contents area.
<p>
<p>Get this property's value with <a href="#contentsHeight">contentsHeight</a>().
<h3 class=fn>int <a name="contentsWidth-prop"></a>contentsWidth</h3>
<p>This property holds the width of the contents area.
<p>
<p>Get this property's value with <a href="#contentsWidth">contentsWidth</a>().
<h3 class=fn>int <a name="contentsX-prop"></a>contentsX</h3>
<p>This property holds the X coordinate of the contents that are at the left edge of the viewport.
<p>
<p>Get this property's value with <a href="#contentsX">contentsX</a>().
<h3 class=fn>int <a name="contentsY-prop"></a>contentsY</h3>
<p>This property holds the Y coordinate of the contents that are at the top edge of the viewport.
<p>
<p>Get this property's value with <a href="#contentsY">contentsY</a>().
<h3 class=fn>bool <a name="dragAutoScroll-prop"></a>dragAutoScroll</h3>
<p>This property holds whether autoscrolling in drag move events is enabled.
<p>If this property is set to TRUE (the default), the QScrollView
automatically scrolls the contents in drag move events if the user
moves the cursor close to a border of the view. Of course this
works only if the viewport accepts drops. Specifying FALSE
disables this autoscroll feature.
<p> <b>Warning:</b> Enabling this property might not be enough to
effectively turn on autoscrolling. If you put a custom widget in
the QScrollView, you might need to call QDragEvent::ignore() on
the event in the <a href="qwidget.html#dragEnterEvent">dragEnterEvent</a>() and <a href="qwidget.html#dragMoveEvent">dragMoveEvent</a>()
reimplementations.

<p>Set this property's value with <a href="#setDragAutoScroll">setDragAutoScroll</a>() and get this property's value with <a href="#dragAutoScroll">dragAutoScroll</a>().
<h3 class=fn><a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> <a name="hScrollBarMode-prop"></a>hScrollBarMode</h3>
<p>This property holds the mode for the horizontal scroll bar.
<p>The default mode is <a href="#ScrollBarMode-enum">QScrollView::Auto</a>.
<p> <p>See also <a href="#vScrollBarMode-prop">vScrollBarMode</a>.

<p>Set this property's value with <a href="#setHScrollBarMode">setHScrollBarMode</a>() and get this property's value with <a href="#hScrollBarMode">hScrollBarMode</a>().
<h3 class=fn><a href="qscrollview.html#ResizePolicy-enum">ResizePolicy</a> <a name="resizePolicy-prop"></a>resizePolicy</h3>
<p>This property holds the resize policy.
<p>The default is <a href="#ResizePolicy-enum">Default</a>.
<p> <p>See also <a href="#ResizePolicy-enum">ResizePolicy</a>.

<p>Set this property's value with <a href="#setResizePolicy">setResizePolicy</a>() and get this property's value with <a href="#resizePolicy">resizePolicy</a>().
<h3 class=fn><a href="qscrollview.html#ScrollBarMode-enum">ScrollBarMode</a> <a name="vScrollBarMode-prop"></a>vScrollBarMode</h3>
<p>This property holds the mode for the vertical scroll bar.
<p>The default mode is <a href="#ScrollBarMode-enum">QScrollView::Auto</a>.
<p> <p>See also <a href="#hScrollBarMode-prop">hScrollBarMode</a>.

<p>Set this property's value with <a href="#setVScrollBarMode">setVScrollBarMode</a>() and get this property's value with <a href="#vScrollBarMode">vScrollBarMode</a>().
<h3 class=fn>int <a name="visibleHeight-prop"></a>visibleHeight</h3>
<p>This property holds the vertical amount of the content that is visible.
<p>
<p>Get this property's value with <a href="#visibleHeight">visibleHeight</a>().
<h3 class=fn>int <a name="visibleWidth-prop"></a>visibleWidth</h3>
<p>This property holds the horizontal amount of the content that is visible.
<p>
<p>Get this property's value with <a href="#visibleWidth">visibleWidth</a>().
<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
