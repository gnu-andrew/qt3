<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/kernel/qnetworkprotocol.cpp:98 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QNetworkProtocol Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QNetworkProtocol Class Reference<br><small>[<a href="network.html">network module</a>]</small></h1>

<p>The QNetworkProtocol class provides a common API for network protocols.
<a href="#details">More...</a>
<p><tt>#include &lt;<a href="qnetworkprotocol-h.html">qnetworkprotocol.h</a>&gt;</tt>
<p>Inherits <a href="qobject.html">QObject</a>.
<p>Inherited by <a href="qftp.html">QFtp</a>, <a href="qhttp.html">QHttp</a>, and <a href="qlocalfs.html">QLocalFs</a>.
<p><a href="qnetworkprotocol-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn>enum <a href="#State-enum"><b>State</b></a> { StWaiting = 0, StInProgress, StDone, StFailed, StStopped }</li>
<li class=fn>enum <a href="#Operation-enum"><b>Operation</b></a> { OpListChildren = 1, OpMkDir = 2, OpMkdir = OpMkDir, OpRemove = 4, OpRename = 8, OpGet = 32, OpPut = 64 }</li>
<li class=fn>enum <a href="#ConnectionState-enum"><b>ConnectionState</b></a> { ConHostFound, ConConnected, ConClosed }</li>
<li class=fn>enum <a href="#Error-enum"><b>Error</b></a> { NoError = 0, ErrValid, ErrUnknownProtocol, ErrUnsupported, ErrParse, ErrLoginIncorrect, ErrHostNotFound, ErrListChildren, ErrListChlidren = ErrListChildren, ErrMkDir, ErrMkdir = ErrMkDir, ErrRemove, ErrRename, ErrGet, ErrPut, ErrFileNotExisting, ErrPermissionDenied }</li>
<li class=fn><a href="#QNetworkProtocol"><b>QNetworkProtocol</b></a> ()</li>
<li class=fn>virtual <a href="#~QNetworkProtocol"><b>~QNetworkProtocol</b></a> ()</li>
<li class=fn>virtual void <a href="#setUrl"><b>setUrl</b></a> ( QUrlOperator&nbsp;*&nbsp;u )</li>
<li class=fn>virtual void <a href="#setAutoDelete"><b>setAutoDelete</b></a> ( bool&nbsp;b, int&nbsp;i = 10000 )</li>
<li class=fn>bool <a href="#autoDelete"><b>autoDelete</b></a> () const</li>
<li class=fn>virtual int <a href="#supportedOperations"><b>supportedOperations</b></a> () const</li>
<li class=fn>virtual void <a href="#addOperation"><b>addOperation</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>QUrlOperator * <a href="#url"><b>url</b></a> () const</li>
<li class=fn>QNetworkOperation * <a href="#operationInProgress"><b>operationInProgress</b></a> () const</li>
<li class=fn>virtual void <a href="#clearOperationQueue"><b>clearOperationQueue</b></a> ()</li>
<li class=fn>virtual void <a href="#stop"><b>stop</b></a> ()</li>
</ul>
<h2>Signals</h2>
<ul>
<li class=fn>void <a href="#data"><b>data</b></a> ( const&nbsp;QByteArray&nbsp;&amp;&nbsp;data, QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#connectionStateChanged"><b>connectionStateChanged</b></a> ( int&nbsp;state, const&nbsp;QString&nbsp;&amp;&nbsp;data )</li>
<li class=fn>void <a href="#finished"><b>finished</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#start"><b>start</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#newChildren"><b>newChildren</b></a> ( const&nbsp;QValueList&lt;QUrlInfo&gt;&nbsp;&amp;&nbsp;i, QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#newChild"><b>newChild</b></a> ( const&nbsp;QUrlInfo&nbsp;&amp;&nbsp;i, QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#createdDirectory"><b>createdDirectory</b></a> ( const&nbsp;QUrlInfo&nbsp;&amp;&nbsp;i, QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#removed"><b>removed</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#itemChanged"><b>itemChanged</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>void <a href="#dataTransferProgress"><b>dataTransferProgress</b></a> ( int&nbsp;bytesDone, int&nbsp;bytesTotal, QNetworkOperation&nbsp;*&nbsp;op )</li>
</ul>
<h2>Static Public Members</h2>
<ul>
<li class=fn>void <a href="#registerNetworkProtocol"><b>registerNetworkProtocol</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;protocol, QNetworkProtocolFactoryBase&nbsp;*&nbsp;protocolFactory )</li>
<li class=fn>QNetworkProtocol * <a href="#getNetworkProtocol"><b>getNetworkProtocol</b></a> ( const&nbsp;QString&nbsp;&amp;&nbsp;protocol )</li>
<li class=fn>bool <a href="#hasOnlyLocalFileSystem"><b>hasOnlyLocalFileSystem</b></a> ()</li>
</ul>
<h2>Protected Members</h2>
<ul>
<li class=fn>virtual void <a href="#operationListChildren"><b>operationListChildren</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual void <a href="#operationMkDir"><b>operationMkDir</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual void <a href="#operationRemove"><b>operationRemove</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual void <a href="#operationRename"><b>operationRename</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual void <a href="#operationGet"><b>operationGet</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual void <a href="#operationPut"><b>operationPut</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
<li class=fn>virtual bool <a href="#checkConnection"><b>checkConnection</b></a> ( QNetworkOperation&nbsp;*&nbsp;op )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>


The QNetworkProtocol class provides a common API for network protocols.

<p> 



<p> This is a base class which should be used for network protocols
implementations that can then be used in Qt (e.g. in the file
dialog) together with the <a href="qurloperator.html">QUrlOperator</a>.
<p> The easiest way to implement a new network protocol is to
reimplement the operation*() methods, e.g. <a href="#operationGet">operationGet</a>(), etc.
Only the supported operations should be reimplemented. To specify
which operations are supported, also reimplement
<a href="#supportedOperations">supportedOperations</a>() and return an int that is OR'd together
using the supported operations from the <a href="#Operation-enum">QNetworkProtocol::Operation</a> enum.
<p> When you implement a network protocol this way, it is important to
emit the correct signals. Also, always emit the <a href="#finished">finished</a>() signal
when an operation is done (on success <em>and</em> on failure). Qt
relies on correctly emitted finished() signals.
<p> For a detailed description of the Qt Network Architecture and how
to implement and use network protocols in Qt, see the <a href="network.html">Qt Network Documentation</a>.
<p>See also <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ConnectionState-enum"></a>QNetworkProtocol::ConnectionState</h3>

<p> When the connection state of a network protocol changes it emits
the signal <a href="#connectionStateChanged">connectionStateChanged</a>(). The first argument is one of
the following values:
<ul>
<li><tt>QNetworkProtocol::ConHostFound</tt> - Host has been found.
<li><tt>QNetworkProtocol::ConConnected</tt> - Connection to the host has been established.
<li><tt>QNetworkProtocol::ConClosed</tt> - Connection has been closed.
</ul>
<h3 class=fn><a name="Error-enum"></a>QNetworkProtocol::Error</h3>

<p> When an operation fails (finishes unsuccessfully), the
<a href="qnetworkoperation.html">QNetworkOperation</a> of the operation returns an error code which has
one of the following values:
<ul>
<li><tt>QNetworkProtocol::NoError</tt> - No error occurred.
<li><tt>QNetworkProtocol::ErrValid</tt> - The URL you are operating on is not valid.
<li><tt>QNetworkProtocol::ErrUnknownProtocol</tt> - There is no protocol implementation
available for the protocol of the URL you are operating on (e.g.
if the protocol is http and no http implementation has been
registered).
<li><tt>QNetworkProtocol::ErrUnsupported</tt> - The operation is not supported by the
protocol.
<li><tt>QNetworkProtocol::ErrParse</tt> - The URL could not be parsed correctly.
<li><tt>QNetworkProtocol::ErrLoginIncorrect</tt> - You needed to login but the username
or password is wrong.
<li><tt>QNetworkProtocol::ErrHostNotFound</tt> - The specified host (in the URL) couldn't
be found.
<li><tt>QNetworkProtocol::ErrListChildren</tt> - An error occurred while listing the
children (files).
<li><tt>QNetworkProtocol::ErrMkDir</tt> - An error occurred when creating a directory.
<li><tt>QNetworkProtocol::ErrRemove</tt> - An error occurred when removing a child (file).
<li><tt>QNetworkProtocol::ErrRename</tt> - An error occurred when renaming a child (file).
<li><tt>QNetworkProtocol::ErrGet</tt> - An error occurred while getting (retrieving) data.
<li><tt>QNetworkProtocol::ErrPut</tt> - An error occurred while putting (uploading) data.
<li><tt>QNetworkProtocol::ErrFileNotExisting</tt> - A file which is needed by the operation
doesn't exist.
<li><tt>QNetworkProtocol::ErrPermissionDenied</tt> - Permission for doing the operation has
been denied.
</ul><p> You should also use these error codes when implementing custom
network protocols. If this is not possible, you can define your own
error codes by using integer values that don't conflict with any
of these values.

<h3 class=fn><a name="Operation-enum"></a>QNetworkProtocol::Operation</h3>

<p> This enum lists the possible operations that a network protocol
can support. <a href="#supportedOperations">supportedOperations</a>() returns an int of these that is
OR'd together. Also, the type() of a <a href="qnetworkoperation.html">QNetworkOperation</a> is always
one of these values.
<ul>
<li><tt>QNetworkProtocol::OpListChildren</tt> - List the children of a URL, e.g. of a directory.
<li><tt>QNetworkProtocol::OpMkDir</tt> - Create a directory.
<li><tt>QNetworkProtocol::OpRemove</tt> - Remove a child (e.g. a file).
<li><tt>QNetworkProtocol::OpRename</tt> - Rename a child (e.g. a file).
<li><tt>QNetworkProtocol::OpGet</tt> - Get data from a location.
<li><tt>QNetworkProtocol::OpPut</tt> - Put data to a location.
</ul>
<h3 class=fn><a name="State-enum"></a>QNetworkProtocol::State</h3>

<p> This enum contains the state that a <a href="qnetworkoperation.html">QNetworkOperation</a> can have.
<ul>
<li><tt>QNetworkProtocol::StWaiting</tt> - The operation is in the QNetworkProtocol's queue
waiting to be prcessed.
<li><tt>QNetworkProtocol::StInProgress</tt> - The operation is being processed.
<li><tt>QNetworkProtocol::StDone</tt> - The operation has been processed succesfully.
<li><tt>QNetworkProtocol::StFailed</tt> - The operation has been processed but an error occurred.
<li><tt>QNetworkProtocol::StStopped</tt> - The operation has been processed but has been
stopped before it finished, and is waiting to be processed.
</ul><p> 
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QNetworkProtocol"></a>QNetworkProtocol::QNetworkProtocol ()
</h3>
Constructor of the network protocol base class. Does some
initialization and connecting of signals and slots.

<h3 class=fn><a name="~QNetworkProtocol"></a>QNetworkProtocol::~QNetworkProtocol ()<tt> [virtual]</tt>
</h3>
Destructor.

<h3 class=fn>void <a name="addOperation"></a>QNetworkProtocol::addOperation ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual]</tt>
</h3>
Adds the operation <em>op</em> to the operation queue. The operation
will be processed as soon as possible. This method returns
immediately.

<h3 class=fn>bool <a name="autoDelete"></a>QNetworkProtocol::autoDelete () const
</h3>
Returns TRUE if auto-deleting is enabled; otherwise returns FALSE.
<p> <p>See also <a href="#setAutoDelete">QNetworkProtocol::setAutoDelete</a>().

<h3 class=fn>bool <a name="checkConnection"></a>QNetworkProtocol::checkConnection ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
For processing operations the network protocol base class calls
this method quite often. This should be reimplemented by new
network protocols. It should return TRUE if the connection is OK
(open); otherwise it should return FALSE. If the connection is not
open the protocol should open it.
<p> If the connection can't be opened (e.g. because you already tried
but the host couldn't be found), set the state of <em>op</em> to
QNetworkProtocol::StFailed and emit the <a href="#finished">finished</a>() signal with
this <a href="qnetworkoperation.html">QNetworkOperation</a> as argument.
<p> <em>op</em> is the operation that needs an open connection.

<p>Example: <a href="networkprotocol-example.html#x673">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="clearOperationQueue"></a>QNetworkProtocol::clearOperationQueue ()<tt> [virtual]</tt>
</h3>
Clears the operation queue.

<h3 class=fn>void <a name="connectionStateChanged"></a>QNetworkProtocol::connectionStateChanged ( int&nbsp;state, const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;data )<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever the state of the connection of the
network protocol is changed. <em>state</em> describes the new state,
which is one of, <a href="#ConnectionState-enum">ConHostFound</a>, <a href="#ConnectionState-enum">ConConnected</a> or <a href="#ConnectionState-enum">ConClosed</a>.
<em>data</em> is a message text.

<h3 class=fn>void <a name="createdDirectory"></a>QNetworkProtocol::createdDirectory ( const&nbsp;<a href="qurlinfo.html">QUrlInfo</a>&nbsp;&amp;&nbsp;i, <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when mkdir() has been succesful and the
directory has been created. <em>i</em> holds the information about the
new directory. <em>op</em> is the pointer to the operation object which
contains all the information about the operation, including the
state, etc. Using op->arg( 0 ), you can get the file name of the
new directory.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn>void <a name="data"></a>QNetworkProtocol::data ( const&nbsp;<a href="qbytearray.html">QByteArray</a>&nbsp;&amp;&nbsp;data, <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when new <em>data</em> has been received after
calling get() or put(). <em>op</em> holds the name of the file from
which data is retrieved or uploaded in its first argument, and the
(raw) data in its second argument. You can get them with
op->arg( 0 ) and op->rawArg( 1 ). <em>op</em> is the pointer to the
operation object, which contains all the information about the
operation, including the state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a> (which is used by the network
protocol) emit its corresponding signal.

<h3 class=fn>void <a name="dataTransferProgress"></a>QNetworkProtocol::dataTransferProgress ( int&nbsp;bytesDone, int&nbsp;bytesTotal, <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted during the transfer of data (using put() or
get()). <em>bytesDone</em> is how many bytes of <em>bytesTotal</em> have been
transferred. <em>bytesTotal</em> may be -1, which means that the total
number of bytes is not known. <em>op</em> is the pointer to the
operation object which contains all the information about the
operation, including the state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn>void <a name="finished"></a>QNetworkProtocol::finished ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when an operation finishes. This signal is
always emitted, for both success and failure. <em>op</em> is the pointer
to the operation object which contains all the information about
the operation, including the state, etc. Check the state and error
code of the operation object to determine whether or not the
operation was successful.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn><a href="qnetworkprotocol.html">QNetworkProtocol</a>&nbsp;* <a name="getNetworkProtocol"></a>QNetworkProtocol::getNetworkProtocol ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;protocol )<tt> [static]</tt>
</h3>
Static method to get a new instance of the network protocol <em>protocol</em>. For example, if you need to do some FTP operations, do
the following:
<pre>
    <a href="qftp.html">QFtp</a> *ftp = QNetworkProtocol::<a href="#getNetworkProtocol">getNetworkProtocol</a>( "ftp" );
    </pre>
 
This returns a pointer to a new instance of an ftp implementation
or null if no protocol for ftp was registered. The ownership of
the pointer is transferred to you, so you must delete it if you
don't need it anymore.
<p> Normally you should not work directly with network protocols, so
you will not need to call this method yourself. Instead, use
<a href="qurloperator.html">QUrlOperator</a>, which makes working with network protocols much more
convenient.
<p> <p>See also <a href="qurloperator.html">QUrlOperator</a>.

<h3 class=fn>bool <a name="hasOnlyLocalFileSystem"></a>QNetworkProtocol::hasOnlyLocalFileSystem ()<tt> [static]</tt>
</h3>
Returns TRUE if the only protocol registered is for working on the
local filesystem; returns FALSE if other network protocols are
also registered.

<h3 class=fn>void <a name="itemChanged"></a>QNetworkProtocol::itemChanged ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted whenever a file which is a child of this
URL has been changed, e.g. by successfully calling rename(). <em>op</em>
holds the original and the new file names in the first and second
arguments, accessible with op->arg( 0 ) and op->arg( 1 )
respectively. <em>op</em> is the pointer to the operation object which
contains all the information about the operation, including the
state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn>void <a name="newChild"></a>QNetworkProtocol::newChild ( const&nbsp;<a href="qurlinfo.html">QUrlInfo</a>&nbsp;&amp;&nbsp;i, <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted if a new child (file) has been read.
QNetworkProtocol automatically connects it to a slot which creates
a list of <a href="qurlinfo.html">QUrlInfo</a> objects (with just one QUrlInfo <em>i</em>) and emits
the <a href="#newChildren">newChildren</a>() signal with this list. <em>op</em> is the pointer to
the operation object which contains all the information about the
operation that has finished, including the state, etc.
<p> This is just a convenience signal useful for implementing your own
network protocol. In all other cases connect to the newChildren()
signal with its list of QUrlInfo objects.

<h3 class=fn>void <a name="newChildren"></a>QNetworkProtocol::newChildren ( const&nbsp;<a href="qvaluelist.html">QValueList</a>&lt;QUrlInfo&gt;&nbsp;&amp;&nbsp;i, <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted after listChildren() was called and new
children (files) have been read from the list of files. <em>i</em> holds
the information about the new children. <em>op</em> is the pointer to
the operation object which contains all the information about the
operation, including the state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.
<p> When implementing your own network protocol and reading children,
you usually don't read one child at once, but rather a list of
them. That's why this signal takes a list of <a href="qurlinfo.html">QUrlInfo</a> objects. If
you prefer to read just one child at a time you can use the
convenience signal <a href="#newChild">newChild</a>(), which takes a single QUrlInfo
object.

<h3 class=fn>void <a name="operationGet"></a>QNetworkProtocol::operationGet ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new network protocol, this method should be
reimplemented if the protocol supports getting data; this method
should then process the <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which describes in
detail how to reimplement this method. You may also want to look
at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<p>Example: <a href="networkprotocol-example.html#x674">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;* <a name="operationInProgress"></a>QNetworkProtocol::operationInProgress () const
</h3>
Returns the operation, which is being processed, or 0 of no
operation is being processed at the moment.

<h3 class=fn>void <a name="operationListChildren"></a>QNetworkProtocol::operationListChildren ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new network protocol, this method should be
reimplemented if the protocol supports listing children (files);
this method should then process this <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which describes in
detail how to reimplement this method. You may also want to look
at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<p>Example: <a href="networkprotocol-example.html#x675">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn>void <a name="operationMkDir"></a>QNetworkProtocol::operationMkDir ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new network protocol, this method should be
reimplemented if the protocol supports making directories; this
method should then process this <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which describes in
detail how to reimplement this method. You may also want to look
at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<h3 class=fn>void <a name="operationPut"></a>QNetworkProtocol::operationPut ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new network protocol, this method should be
reimplemented if the protocol supports putting (uploading) data;
this method should then process the <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which describes in
detail how to reimplement this method. You may also want to look
at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<h3 class=fn>void <a name="operationRemove"></a>QNetworkProtocol::operationRemove ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new network protocol, this method should be
reimplemented if the protocol supports removing children (files);
this method should then process this <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which is describes
in detail how to reimplement this method. You may also want to
look at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<h3 class=fn>void <a name="operationRename"></a>QNetworkProtocol::operationRename ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [virtual protected]</tt>
</h3>
When implementing a new newtork protocol, this method should be
reimplemented if the protocol supports renaming children (files);
this method should then process this <a href="qnetworkoperation.html">QNetworkOperation</a>.
<p> When you reimplement this method it's very important that you emit
the correct signals at the correct time (especially the <a href="#finished">finished</a>()
signal after processing an operation). Take a look at the <a href="network.html">Qt Network Documentation</a> which describes in
detail how to reimplement this method. You may also want to look
at the example implementation in
examples/network/networkprotocol/nntp.cpp.
<p> <em>op</em> is the pointer to the operation object which contains all
the information on the operation that has finished, including the
state, etc.

<h3 class=fn>void <a name="registerNetworkProtocol"></a>QNetworkProtocol::registerNetworkProtocol ( const&nbsp;<a href="qstring.html">QString</a>&nbsp;&amp;&nbsp;protocol, QNetworkProtocolFactoryBase&nbsp;*&nbsp;protocolFactory )<tt> [static]</tt>
</h3>
Static method to register a network protocol for Qt. For example,
if you have an implementation of NNTP (called Nntp) which is
derived from QNetworkProtocol, call:
<pre>
    QNetworkProtocol::<a href="#registerNetworkProtocol">registerNetworkProtocol</a>( "nntp", new QNetworkProtocolFactory&lt;Nntp&gt; );
    </pre>
 
after which your implementation is registered for future nntp
operations.
<p> The name of the protocol is given in <em>protocol</em> and a pointer to
the protocol factory is given in <em>protocolFactory</em>.

<h3 class=fn>void <a name="removed"></a>QNetworkProtocol::removed ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> This signal is emitted when remove() has been succesful and the
file has been removed. <em>op</em> holds the file name of the removed
file in the first argument, accessible with op->arg( 0 ). <em>op</em> is
the pointer to the operation object which contains all the
information about the operation, including the state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn>void <a name="setAutoDelete"></a>QNetworkProtocol::setAutoDelete ( bool&nbsp;b, int&nbsp;i = 10000 )<tt> [virtual]</tt>
</h3>
Because it's sometimes hard to take care of removing network
protocol instances, QNetworkProtocol provides an auto-delete
mechanism. If you set <em>b</em> to TRUE, the network protocol instance
is removed after it has been inactive for <em>i</em> milliseconds (i.e.
<em>i</em> milliseconds after the last operation has been processed).
If you set <em>b</em> to FALSE the auto-delete mechanism is switched
off.
<p> If you switch on auto-delete, the QNetworkProtocol also deletes
its <a href="qurloperator.html">QUrlOperator</a>.

<h3 class=fn>void <a name="setUrl"></a>QNetworkProtocol::setUrl ( <a href="qurloperator.html">QUrlOperator</a>&nbsp;*&nbsp;u )<tt> [virtual]</tt>
</h3>
Sets the <a href="qurloperator.html">QUrlOperator</a>, on which the protocol works, to <em>u</em>.
<p> <p>See also <a href="qurloperator.html">QUrlOperator</a>.

<h3 class=fn>void <a name="start"></a>QNetworkProtocol::start ( <a href="qnetworkoperation.html">QNetworkOperation</a>&nbsp;*&nbsp;op )<tt> [signal]</tt>
</h3>

<p> Some operations (such as listChildren()) emit this signal when
they start processing the operation. <em>op</em> is the pointer to the
operation object which contains all the information about the
operation, including the state, etc.
<p> When a protocol emits this signal, QNetworkProtocol is smart
enough to let the <a href="qurloperator.html">QUrlOperator</a>, which is used by the network
protocol, emit its corresponding signal.

<h3 class=fn>void <a name="stop"></a>QNetworkProtocol::stop ()<tt> [virtual]</tt>
</h3>
Stops the current operation that is being processed and clears all
waiting operations.

<h3 class=fn>int <a name="supportedOperations"></a>QNetworkProtocol::supportedOperations () const<tt> [virtual]</tt>
</h3>
Returns an int that is OR'd together using the enum values of
<a href="#Operation-enum">QNetworkProtocol::Operation</a>, which describes which operations
are supported by the network protocol. Should be reimplemented by
new network protocols.

<p>Example: <a href="networkprotocol-example.html#x676">network/networkprotocol/nntp.cpp</a>.
<h3 class=fn><a href="qurloperator.html">QUrlOperator</a>&nbsp;* <a name="url"></a>QNetworkProtocol::url () const
</h3>
Returns the <a href="qurloperator.html">QUrlOperator</a> on which the protocol works.

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
