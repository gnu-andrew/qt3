<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- /home/espenr/tmp/qt-3.3.8-espenr-2499/qt-x11-free-3.3.8/src/tools/qdatastream.cpp:51 -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>QDataStream Class</title>
<style type="text/css"><!--
fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
body { background: #ffffff; color: black; }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr bgcolor="#E5E5E5">
<td valign=center>
 <a href="index.html">
<font color="#004faf">Home</font></a>
 | <a href="classes.html">
<font color="#004faf">All&nbsp;Classes</font></a>
 | <a href="mainclasses.html">
<font color="#004faf">Main&nbsp;Classes</font></a>
 | <a href="annotated.html">
<font color="#004faf">Annotated</font></a>
 | <a href="groups.html">
<font color="#004faf">Grouped&nbsp;Classes</font></a>
 | <a href="functions.html">
<font color="#004faf">Functions</font></a>
</td>
<td align="right" valign="center"><img src="logo32.png" align="right" width="64" height="32" border="0"></td></tr></table><h1 align=center>QDataStream Class Reference</h1>

<p>The QDataStream class provides serialization of binary data
to a QIODevice.
<a href="#details">More...</a>
<p>All the functions in this class are <a href="threads.html#reentrant">reentrant</a> when Qt is built with thread support.</p>
<p><tt>#include &lt;<a href="qdatastream-h.html">qdatastream.h</a>&gt;</tt>
<p><a href="qdatastream-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li class=fn><a href="#QDataStream"><b>QDataStream</b></a> ()</li>
<li class=fn><a href="#QDataStream-2"><b>QDataStream</b></a> ( QIODevice&nbsp;*&nbsp;d )</li>
<li class=fn><a href="#QDataStream-3"><b>QDataStream</b></a> ( QByteArray&nbsp;a, int&nbsp;mode )</li>
<li class=fn>virtual <a href="#~QDataStream"><b>~QDataStream</b></a> ()</li>
<li class=fn>QIODevice * <a href="#device"><b>device</b></a> () const</li>
<li class=fn>void <a href="#setDevice"><b>setDevice</b></a> ( QIODevice&nbsp;*&nbsp;d )</li>
<li class=fn>void <a href="#unsetDevice"><b>unsetDevice</b></a> ()</li>
<li class=fn>bool <a href="#atEnd"><b>atEnd</b></a> () const</li>
<li class=fn>bool eof () const &nbsp;<em>(obsolete)</em></li>
<li class=fn>enum <a href="#ByteOrder-enum"><b>ByteOrder</b></a> { BigEndian, LittleEndian }</li>
<li class=fn>int <a href="#byteOrder"><b>byteOrder</b></a> () const</li>
<li class=fn>void <a href="#setByteOrder"><b>setByteOrder</b></a> ( int&nbsp;bo )</li>
<li class=fn>bool <a href="#isPrintableData"><b>isPrintableData</b></a> () const</li>
<li class=fn>void <a href="#setPrintableData"><b>setPrintableData</b></a> ( bool&nbsp;enable )</li>
<li class=fn>int <a href="#version"><b>version</b></a> () const</li>
<li class=fn>void <a href="#setVersion"><b>setVersion</b></a> ( int&nbsp;v )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt"><b>operator&gt;&gt;</b></a> ( Q_INT8&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-2"><b>operator&gt;&gt;</b></a> ( Q_UINT8&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-3"><b>operator&gt;&gt;</b></a> ( Q_INT16&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-4"><b>operator&gt;&gt;</b></a> ( Q_UINT16&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-5"><b>operator&gt;&gt;</b></a> ( Q_INT32&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-6"><b>operator&gt;&gt;</b></a> ( Q_UINT32&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-7"><b>operator&gt;&gt;</b></a> ( Q_INT64&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-8"><b>operator&gt;&gt;</b></a> ( Q_UINT64&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-9"><b>operator&gt;&gt;</b></a> ( Q_LONG&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-a"><b>operator&gt;&gt;</b></a> ( Q_ULONG&nbsp;&amp;&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-b"><b>operator&gt;&gt;</b></a> ( float&nbsp;&amp;&nbsp;f )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-c"><b>operator&gt;&gt;</b></a> ( double&nbsp;&amp;&nbsp;f )</li>
<li class=fn>QDataStream &amp; <a href="#operator-gt-gt-d"><b>operator&gt;&gt;</b></a> ( char&nbsp;*&amp;&nbsp;s )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt"><b>operator&lt;&lt;</b></a> ( Q_INT8&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-2"><b>operator&lt;&lt;</b></a> ( Q_UINT8&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-3"><b>operator&lt;&lt;</b></a> ( Q_INT16&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-4"><b>operator&lt;&lt;</b></a> ( Q_UINT16&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-5"><b>operator&lt;&lt;</b></a> ( Q_INT32&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-6"><b>operator&lt;&lt;</b></a> ( Q_UINT32&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-7"><b>operator&lt;&lt;</b></a> ( Q_INT64&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-8"><b>operator&lt;&lt;</b></a> ( Q_UINT64&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-9"><b>operator&lt;&lt;</b></a> ( Q_LONG&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-a"><b>operator&lt;&lt;</b></a> ( Q_ULONG&nbsp;i )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-b"><b>operator&lt;&lt;</b></a> ( float&nbsp;f )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-c"><b>operator&lt;&lt;</b></a> ( double&nbsp;f )</li>
<li class=fn>QDataStream &amp; <a href="#operator-lt-lt-d"><b>operator&lt;&lt;</b></a> ( const&nbsp;char&nbsp;*&nbsp;s )</li>
<li class=fn>QDataStream &amp; <a href="#readBytes"><b>readBytes</b></a> ( char&nbsp;*&amp;&nbsp;s, uint&nbsp;&amp;&nbsp;l )</li>
<li class=fn>QDataStream &amp; <a href="#readRawBytes"><b>readRawBytes</b></a> ( char&nbsp;*&nbsp;s, uint&nbsp;len )</li>
<li class=fn>QDataStream &amp; <a href="#writeBytes"><b>writeBytes</b></a> ( const&nbsp;char&nbsp;*&nbsp;s, uint&nbsp;len )</li>
<li class=fn>QDataStream &amp; <a href="#writeRawBytes"><b>writeRawBytes</b></a> ( const&nbsp;char&nbsp;*&nbsp;s, uint&nbsp;len )</li>
</ul>
<hr><a name="details"></a><h2>Detailed Description</h2>



The QDataStream class provides serialization of binary data
to a <a href="qiodevice.html">QIODevice</a>.
<p> 
<p> A data stream is a binary stream of encoded information which is
100% independent of the host computer's operating system, CPU or
byte order. For example, a data stream that is written by a PC
under Windows can be read by a Sun SPARC running Solaris.
<p> You can also use a data stream to read/write <a href="#raw">raw
    unencoded binary data</a>. If you want a "parsing" input
stream, see <a href="qtextstream.html">QTextStream</a>.
<p> The QDataStream class implements the serialization of C++'s basic
data types, like <tt>char</tt>, <tt>short</tt>, <tt>int</tt>, <tt>char*</tt>, etc.
Serialization of more complex data is accomplished by breaking up
the data into primitive units.
<p> A data stream cooperates closely with a QIODevice. A QIODevice
represents an input/output medium one can read data from and write
data to. The <a href="qfile.html">QFile</a> class is an example of an IO device.
<p> Example (write binary data to a stream):
<pre>
    <a href="qfile.html">QFile</a> file( "file.dat" );
    file.<a href="qfile.html#open">open</a>( <a href="qfile.html#open">IO_WriteOnly</a> );
    QDataStream stream( &amp;file ); // we will serialize the data into the file
    stream &lt;&lt; "the answer is";   // serialize a string
    stream &lt;&lt; (Q_INT32)42;       // serialize an integer
    </pre>
 
<p> Example (read binary data from a stream):
<pre>
    <a href="qfile.html">QFile</a> file( "file.dat" );
    file.<a href="qfile.html#open">open</a>( <a href="qfile.html#open">IO_ReadOnly</a> );
    QDataStream stream( &amp;file );  // read the data serialized from the file
    <a href="qstring.html">QString</a> str;
    Q_INT32 a;
    stream &gt;&gt; str &gt;&gt; a;           // extract "the answer is" and 42
    </pre>
 
<p> Each item written to the stream is written in a predefined binary
format that varies depending on the item's type. Supported Qt
types include <a href="qbrush.html">QBrush</a>, <a href="qcolor.html">QColor</a>, <a href="qdatetime.html">QDateTime</a>, <a href="qfont.html">QFont</a>, <a href="qpixmap.html">QPixmap</a>, <a href="qstring.html">QString</a>,
<a href="qvariant.html">QVariant</a> and many others. For the complete list of all Qt types
supporting data streaming see the <a href="datastreamformat.html">Format of the QDataStream operators</a>.
<p> For integers it is best to always cast to a Qt integer type for
writing, and to read back into the same Qt integer type. This
ensures that you get integers of the size you want and insulates
you from compiler and platform differences.
<p> To take one example, a <tt>char*</tt> string is written as a 32-bit
integer equal to the length of the string including the NUL byte
('&#92;0'), followed by all the characters of the string including the
NUL byte. When reading a <tt>char*</tt> string, 4 bytes are read to
create the 32-bit length value, then that many characters for the
<tt>char*</tt> string including the NUL are read.
<p> The initial IODevice is usually set in the constructor, but can be
changed with <a href="#setDevice">setDevice</a>(). If you've reached the end of the data
(or if there is no IODevice set) <a href="#atEnd">atEnd</a>() will return TRUE.
<p> If you want the data to be compatible with an earlier version of
Qt use <a href="#setVersion">setVersion</a>().
<p> If you want the data to be human-readable, e.g. for debugging, you
can set the data stream into printable data mode with
<a href="#setPrintableData">setPrintableData</a>(). The data is then written slower, in a bloated
but human readable format.
<p> If you are producing a new binary data format, such as a file
format for documents created by your application, you could use a
QDataStream to write the data in a portable format. Typically, you
would write a brief header containing a magic string and a version
number to give yourself room for future expansion. For example:
<p> <pre>
    <a href="qfile.html">QFile</a> file( "file.xxx" );
    file.<a href="qfile.html#open">open</a>( IO_WriteOnly );
    QDataStream stream( &amp;file );

    // Write a header with a "magic number" and a version
    stream &lt;&lt; (Q_UINT32)0xA0B0C0D0;
    stream &lt;&lt; (Q_INT32)123;

    // Write the data
    stream &lt;&lt; [lots of interesting data]
    </pre>
 
<p> Then read it in with:
<p> <pre>
    <a href="qfile.html">QFile</a> file( "file.xxx" );
    file.<a href="qfile.html#open">open</a>( IO_ReadOnly );
    QDataStream stream( &amp;file );

    // Read and check the header
    Q_UINT32 magic;
    stream &gt;&gt; magic;
    if ( magic != 0xA0B0C0D0 )
        return XXX_BAD_FILE_FORMAT;

    // Read the version
    Q_INT32 version;
    stream &gt;&gt; version;
    if ( version &lt; 100 )
        return XXX_BAD_FILE_TOO_OLD;
    if ( version &gt; 123 )
        return XXX_BAD_FILE_TOO_NEW;
    if ( version &lt;= 110 )
        stream.<a href="#setVersion">setVersion</a>(1);

    // Read the data
    stream &gt;&gt; [lots of interesting data];
    if ( version &gt; 120 )
        stream &gt;&gt; [data new in XXX version 1.2];
    stream &gt;&gt; [other interesting data];
    </pre>
 
<p> You can select which byte order to use when serializing data. The
default setting is big endian (MSB first). Changing it to little
endian breaks the portability (unless the reader also changes to
little endian). We recommend keeping this setting unless you have
special requirements.
<p> <a name="raw"></a>
<h3> Reading and writing raw binary data
</h3>
<a name="1"></a><p> You may wish to read/write your own raw binary data to/from the
data stream directly. Data may be read from the stream into a
preallocated char* using <a href="#readRawBytes">readRawBytes</a>(). Similarly data can be
written to the stream using <a href="#writeRawBytes">writeRawBytes</a>(). Notice that any
encoding/decoding of the data must be done by you.
<p> A similar pair of functions is <a href="#readBytes">readBytes</a>() and <a href="#writeBytes">writeBytes</a>(). These
differ from their <em>raw</em> counterparts as follows: readBytes()
reads a Q_UINT32 which is taken to be the length of the data to be
read, then that number of bytes is read into the preallocated
char*; writeBytes() writes a Q_UINT32 containing the length of the
data, followed by the data. Notice that any encoding/decoding of
the data (apart from the length Q_UINT32) must be done by you.
<p> <p>See also <a href="qtextstream.html">QTextStream</a>, <a href="qvariant.html">QVariant</a>, and <a href="io.html">Input/Output and Networking</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class=fn><a name="ByteOrder-enum"></a>QDataStream::ByteOrder</h3>

<p> The byte order used for reading/writing the data.
<ul>
<li><tt>QDataStream::BigEndian</tt> - the default
<li><tt>QDataStream::LittleEndian</tt>
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class=fn><a name="QDataStream"></a>QDataStream::QDataStream ()
</h3>
Constructs a data stream that has no IO device.
<p> <p>See also <a href="#setDevice">setDevice</a>().

<h3 class=fn><a name="QDataStream-2"></a>QDataStream::QDataStream ( <a href="qiodevice.html">QIODevice</a>&nbsp;*&nbsp;d )
</h3>
Constructs a data stream that uses the IO device <em>d</em>.
<p> <b>Warning:</b> If you use <a href="qsocket.html">QSocket</a> or <a href="qsocketdevice.html">QSocketDevice</a> as the IO device <em>d</em>
for reading data, you must make sure that enough data is available
on the socket for the operation to successfully proceed;
QDataStream does not have any means to handle or recover from
short-reads.
<p> <p>See also <a href="#setDevice">setDevice</a>() and <a href="#device">device</a>().

<h3 class=fn><a name="QDataStream-3"></a>QDataStream::QDataStream ( <a href="qbytearray.html">QByteArray</a>&nbsp;a, int&nbsp;mode )
</h3>
Constructs a data stream that operates on a byte array, <em>a</em>,
through an internal <a href="qbuffer.html">QBuffer</a> device. The <em>mode</em> is a
<a href="qiodevice.html#mode">QIODevice::mode</a>(), usually either <a href="qfile.html#open">IO_ReadOnly</a> or <a href="qfile.html#open">IO_WriteOnly</a>.
<p> Example:
<pre>
    static char bindata[] = { 231, 1, 44, ... };
    <a href="qbytearray.html">QByteArray</a> a;
    a.<a href="qmemarray.html#setRawData">setRawData</a>( bindata, sizeof(bindata) );   // a points to bindata
    QDataStream stream( a, <a href="qfile.html#open">IO_ReadOnly</a> );       // open on a's data
    stream &gt;&gt; [something];                      // read raw bindata
    a.<a href="qmemarray.html#resetRawData">resetRawData</a>( bindata, sizeof(bindata) ); // finished
    </pre>
 
<p> The <a href="qmemarray.html#setRawData">QByteArray::setRawData</a>() function is not for the inexperienced.

<h3 class=fn><a name="~QDataStream"></a>QDataStream::~QDataStream ()<tt> [virtual]</tt>
</h3>
Destroys the data stream.
<p> The destructor will not affect the current IO device, unless it is
an internal IO device processing a <a href="qbytearray.html">QByteArray</a> passed in the <em>constructor</em>, in which case the internal IO device is destroyed.

<h3 class=fn>bool <a name="atEnd"></a>QDataStream::atEnd () const
</h3>

<p> Returns TRUE if the IO device has reached the end position (end of
the stream or file) or if there is no IO device set; otherwise
returns FALSE, i.e. if the current position of the IO device is
before the end position.
<p> <p>See also <a href="qiodevice.html#atEnd">QIODevice::atEnd</a>().

<h3 class=fn>int <a name="byteOrder"></a>QDataStream::byteOrder () const
</h3>

<p> Returns the current byte order setting -- either <a href="#ByteOrder-enum">BigEndian</a> or
<a href="#ByteOrder-enum">LittleEndian</a>.
<p> <p>See also <a href="#setByteOrder">setByteOrder</a>().

<h3 class=fn><a href="qiodevice.html">QIODevice</a>&nbsp;* <a name="device"></a>QDataStream::device () const
</h3>

<p> Returns the IO device currently set.
<p> <p>See also <a href="#setDevice">setDevice</a>() and <a href="#unsetDevice">unsetDevice</a>().

<h3 class=fn>bool <a name="eof"></a>QDataStream::eof () const
</h3>
<p> <b>This function is obsolete.</b> It is provided to keep old source working. We strongly advise against using it in new code.
<p> Returns TRUE if the IO device has reached the end position (end of
stream or file) or if there is no IO device set.
<p> Returns FALSE if the current position of the read/write head of the IO
device is somewhere before the end position.
<p> <p>See also <a href="qiodevice.html#atEnd">QIODevice::atEnd</a>().

<h3 class=fn>bool <a name="isPrintableData"></a>QDataStream::isPrintableData () const
</h3>

<p> Returns TRUE if the printable data flag has been set; otherwise
returns FALSE.
<p> <p>See also <a href="#setPrintableData">setPrintableData</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt"></a>QDataStream::operator&lt;&lt; ( Q_INT8&nbsp;i )
</h3>
Writes a signed byte, <em>i</em>, to the stream and returns a reference
to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-2"></a>QDataStream::operator&lt;&lt; ( Q_UINT8&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes an unsigned byte, <em>i</em>, to the stream and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-3"></a>QDataStream::operator&lt;&lt; ( Q_INT16&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a signed 16-bit integer, <em>i</em>, to the stream and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-4"></a>QDataStream::operator&lt;&lt; ( Q_UINT16&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes an unsigned 16-bit integer, <em>i</em>, to the stream and returns
a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-5"></a>QDataStream::operator&lt;&lt; ( Q_INT32&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a signed 32-bit integer, <em>i</em>, to the stream and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-6"></a>QDataStream::operator&lt;&lt; ( Q_UINT32&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes an unsigned integer, <em>i</em>, to the stream as a 32-bit
unsigned integer (Q_UINT32). Returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-7"></a>QDataStream::operator&lt;&lt; ( Q_INT64&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a signed 64-bit integer, <em>i</em>, to the stream and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-8"></a>QDataStream::operator&lt;&lt; ( Q_UINT64&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes an unsigned 64-bit integer, <em>i</em>, to the stream and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-9"></a>QDataStream::operator&lt;&lt; ( Q_LONG&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a signed integer <em>i</em>, of the system's word length, to the
stream and returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-a"></a>QDataStream::operator&lt;&lt; ( Q_ULONG&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes an unsigned integer <em>i</em>, of the system's word length, to
the stream and returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-b"></a>QDataStream::operator&lt;&lt; ( float&nbsp;f )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a 32-bit floating point number, <em>f</em>, to the stream using
the standard IEEE754 format. Returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-c"></a>QDataStream::operator&lt;&lt; ( double&nbsp;f )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes a 64-bit floating point number, <em>f</em>, to the stream using
the standard IEEE754 format. Returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-lt-lt-d"></a>QDataStream::operator&lt;&lt; ( const&nbsp;char&nbsp;*&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Writes the '&#92;0'-terminated string <em>s</em> to the stream and returns a
reference to the stream.
<p> The string is serialized using <a href="#writeBytes">writeBytes</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt"></a>QDataStream::operator&gt;&gt; ( Q_INT8&nbsp;&amp;&nbsp;i )
</h3>
Reads a signed byte from the stream into <em>i</em>, and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-2"></a>QDataStream::operator&gt;&gt; ( Q_UINT8&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads an unsigned byte from the stream into <em>i</em>, and returns a
reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-3"></a>QDataStream::operator&gt;&gt; ( Q_INT16&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a signed 16-bit integer from the stream into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-4"></a>QDataStream::operator&gt;&gt; ( Q_UINT16&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads an unsigned 16-bit integer from the stream into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-5"></a>QDataStream::operator&gt;&gt; ( Q_INT32&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a signed 32-bit integer from the stream into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-6"></a>QDataStream::operator&gt;&gt; ( Q_UINT32&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads an unsigned 32-bit integer from the stream into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-7"></a>QDataStream::operator&gt;&gt; ( Q_INT64&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a signed 64-bit integer from the stream into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-8"></a>QDataStream::operator&gt;&gt; ( Q_UINT64&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads an unsigned 64-bit integer from the stream, into <em>i</em>, and
returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-9"></a>QDataStream::operator&gt;&gt; ( Q_LONG&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a signed integer of the system's word length from the stream
into <em>i</em>, and returns a reference to the stream.
<p> 
<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-a"></a>QDataStream::operator&gt;&gt; ( Q_ULONG&nbsp;&amp;&nbsp;i )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads an unsigned integer of the system's word length from the
stream, into <em>i</em>, and returns a reference to the stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-b"></a>QDataStream::operator&gt;&gt; ( float&nbsp;&amp;&nbsp;f )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a 32-bit floating point number from the stream into <em>f</em>,
using the standard IEEE754 format. Returns a reference to the
stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-c"></a>QDataStream::operator&gt;&gt; ( double&nbsp;&amp;&nbsp;f )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads a 64-bit floating point number from the stream into <em>f</em>,
using the standard IEEE754 format. Returns a reference to the
stream.

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="operator-gt-gt-d"></a>QDataStream::operator&gt;&gt; ( char&nbsp;*&amp;&nbsp;s )
</h3>
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
<p> Reads the '&#92;0'-terminated string <em>s</em> from the stream and returns
a reference to the stream.
<p> Space for the string is allocated using <tt>new</tt> -- the caller must
destroy it with delete[].

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="readBytes"></a>QDataStream::readBytes ( char&nbsp;*&amp;&nbsp;s, uint&nbsp;&amp;&nbsp;l )
</h3>
Reads the buffer <em>s</em> from the stream and returns a reference to
the stream.
<p> The buffer <em>s</em> is allocated using <tt>new</tt>. Destroy it with the <tt>delete[]</tt> operator. If the length is zero or <em>s</em> cannot be
allocated, <em>s</em> is set to 0.
<p> The <em>l</em> parameter will be set to the length of the buffer.
<p> The serialization format is a Q_UINT32 length specifier first,
then <em>l</em> bytes of data. Note that the data is <em>not</em> encoded.
<p> <p>See also <a href="#readRawBytes">readRawBytes</a>() and <a href="#writeBytes">writeBytes</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="readRawBytes"></a>QDataStream::readRawBytes ( char&nbsp;*&nbsp;s, uint&nbsp;len )
</h3>
Reads <em>len</em> bytes from the stream into <em>s</em> and returns a
reference to the stream.
<p> The buffer <em>s</em> must be preallocated. The data is <em>not</em> encoded.
<p> <p>See also <a href="#readBytes">readBytes</a>(), <a href="qiodevice.html#readBlock">QIODevice::readBlock</a>(), and <a href="#writeRawBytes">writeRawBytes</a>().

<h3 class=fn>void <a name="setByteOrder"></a>QDataStream::setByteOrder ( int&nbsp;bo )
</h3>
Sets the serialization byte order to <em>bo</em>.
<p> The <em>bo</em> parameter can be <a href="#ByteOrder-enum">QDataStream::BigEndian</a> or <a href="#ByteOrder-enum">QDataStream::LittleEndian</a>.
<p> The default setting is big endian. We recommend leaving this
setting unless you have special requirements.
<p> <p>See also <a href="#byteOrder">byteOrder</a>().

<h3 class=fn>void <a name="setDevice"></a>QDataStream::setDevice ( <a href="qiodevice.html">QIODevice</a>&nbsp;*&nbsp;d )
</h3>
void <a href="#setDevice">QDataStream::setDevice</a>(<a href="qiodevice.html">QIODevice</a> *d )
<p> Sets the IO device to <em>d</em>.
<p> <p>See also <a href="#device">device</a>() and <a href="#unsetDevice">unsetDevice</a>().

<h3 class=fn>void <a name="setPrintableData"></a>QDataStream::setPrintableData ( bool&nbsp;enable )
</h3>

<p> If <em>enable</em> is TRUE, data will be output in a human readable
format. If <em>enable</em> is FALSE, data will be output in a binary
format.
<p> If <em>enable</em> is TRUE, the write functions will generate output
that consists of printable characters (7 bit ASCII). This output
will typically be a lot larger than the default binary output, and
consequently slower to write.
<p> We recommend only enabling printable data for debugging purposes.

<h3 class=fn>void <a name="setVersion"></a>QDataStream::setVersion ( int&nbsp;v )
</h3>

<p> Sets the version number of the data serialization format to <em>v</em>.
<p> You don't need to set a version if you are using the current
version of Qt.
<p> In order to accommodate new functionality, the datastream
serialization format of some Qt classes has changed in some
versions of Qt. If you want to read data that was created by an
earlier version of Qt, or write data that can be read by a program
that was compiled with an earlier version of Qt, use this function
to modify the serialization format of QDataStream.
<p> <center><table cellpadding="4" cellspacing="2" border="0">
<tr bgcolor="#a2c511"> <th valign="top">Qt Version         <th valign="top">QDataStream Version
<tr bgcolor="#f0f0f0"> <td valign="top">Qt 3.3                <td valign="top" colspan="1" rowspan="1"> 6
<tr bgcolor="#d0d0d0"> <td valign="top">Qt 3.2                <td valign="top" colspan="1" rowspan="1"> 5
<tr bgcolor="#f0f0f0"> <td valign="top">Qt 3.1                <td valign="top" colspan="1" rowspan="1"> 5
<tr bgcolor="#d0d0d0"> <td valign="top">Qt 3.0                <td valign="top" colspan="1" rowspan="1"> 4
<tr bgcolor="#f0f0f0"> <td valign="top">Qt 2.1.x and Qt 2.2.x <td valign="top" colspan="1" rowspan="1"> 3
<tr bgcolor="#d0d0d0"> <td valign="top">Qt 2.0.x              <td valign="top" colspan="1" rowspan="1"> 2
<tr bgcolor="#f0f0f0"> <td valign="top">Qt 1.x                <td valign="top" colspan="1" rowspan="1"> 1
</table></center>
<p> <p>See also <a href="#version">version</a>().

<h3 class=fn>void <a name="unsetDevice"></a>QDataStream::unsetDevice ()
</h3>
Unsets the IO device. This is the same as calling <a href="#setDevice">setDevice</a>( 0 ).
<p> <p>See also <a href="#device">device</a>() and <a href="#setDevice">setDevice</a>().

<h3 class=fn>int <a name="version"></a>QDataStream::version () const
</h3>

<p> Returns the version number of the data serialization format. In Qt
3.1, this number is 5.
<p> <p>See also <a href="#setVersion">setVersion</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="writeBytes"></a>QDataStream::writeBytes ( const&nbsp;char&nbsp;*&nbsp;s, uint&nbsp;len )
</h3>
Writes the length specifier <em>len</em> and the buffer <em>s</em> to the
stream and returns a reference to the stream.
<p> The <em>len</em> is serialized as a Q_UINT32, followed by <em>len</em> bytes
from <em>s</em>. Note that the data is <em>not</em> encoded.
<p> <p>See also <a href="#writeRawBytes">writeRawBytes</a>() and <a href="#readBytes">readBytes</a>().

<h3 class=fn><a href="qdatastream.html">QDataStream</a>&nbsp;&amp; <a name="writeRawBytes"></a>QDataStream::writeRawBytes ( const&nbsp;char&nbsp;*&nbsp;s, uint&nbsp;len )
</h3>
Writes <em>len</em> bytes from <em>s</em> to the stream and returns a
reference to the stream. The data is <em>not</em> encoded.
<p> <p>See also <a href="#writeBytes">writeBytes</a>(), <a href="qiodevice.html#writeBlock">QIODevice::writeBlock</a>(), and <a href="#readRawBytes">readRawBytes</a>().

<!-- eof -->
<hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>.
Copyright &copy; 1995-2007
<a href="http://www.trolltech.com/">Trolltech</a>. All Rights Reserved.<p><address><hr><div align=center>
<table width=100% cellspacing=0 border=0><tr>
<td>Copyright &copy; 2007
<a href="troll.html">Trolltech</a><td align=center><a href="trademarks.html">Trademarks</a>
<td align=right><div align=right>Qt 3.3.8</div>
</table></div></address></body>
</html>
