'\" t
.TH QVariant 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QVariant \- Acts like a union for the most common Qt data types
.SH SYNOPSIS
\fC#include <qvariant.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBType\fR { Invalid, Map, List, String, StringList, Font, Pixmap, Brush, Rect, Size, Color, Palette, ColorGroup, IconSet, Point, Image, Int, UInt, Bool, Double, CString, PointArray, Region, Bitmap, Cursor, SizePolicy, Date, Time, DateTime, ByteArray, BitArray, KeySequence, Pen, LongLong, ULongLong }"
.br
.ti -1c
.BI "\fBQVariant\fR ()"
.br
.ti -1c
.BI "\fB~QVariant\fR ()"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QVariant & p )"
.br
.ti -1c
.BI "\fBQVariant\fR ( QDataStream & s )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QString & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QCString & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const char * val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QStringList & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QFont & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPixmap & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QImage & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QBrush & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPoint & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QRect & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QSize & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QColor & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPalette & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QColorGroup & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QIconSet & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPointArray & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QRegion & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QBitmap & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QCursor & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QDate & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QTime & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QDateTime & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QByteArray & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QBitArray & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QKeySequence & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPen & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QValueList<QVariant> & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( const QMap<QString, QVariant> & val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( int val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( uint val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( Q_LLONG val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( Q_ULLONG val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( bool val, int )"
.br
.ti -1c
.BI "\fBQVariant\fR ( double val )"
.br
.ti -1c
.BI "\fBQVariant\fR ( QSizePolicy val )"
.br
.ti -1c
.BI "QVariant & \fBoperator=\fR ( const QVariant & variant )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QVariant & v ) const"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QVariant & v ) const"
.br
.ti -1c
.BI "Type \fBtype\fR () const"
.br
.ti -1c
.BI "const char * \fBtypeName\fR () const"
.br
.ti -1c
.BI "bool \fBcanCast\fR ( Type t ) const"
.br
.ti -1c
.BI "bool \fBcast\fR ( Type t )"
.br
.ti -1c
.BI "bool \fBisValid\fR () const"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "void \fBclear\fR ()"
.br
.ti -1c
.BI "const QString \fBtoString\fR () const"
.br
.ti -1c
.BI "const QCString \fBtoCString\fR () const"
.br
.ti -1c
.BI "const QStringList \fBtoStringList\fR () const"
.br
.ti -1c
.BI "const QFont \fBtoFont\fR () const"
.br
.ti -1c
.BI "const QPixmap \fBtoPixmap\fR () const"
.br
.ti -1c
.BI "const QImage \fBtoImage\fR () const"
.br
.ti -1c
.BI "const QBrush \fBtoBrush\fR () const"
.br
.ti -1c
.BI "const QPoint \fBtoPoint\fR () const"
.br
.ti -1c
.BI "const QRect \fBtoRect\fR () const"
.br
.ti -1c
.BI "const QSize \fBtoSize\fR () const"
.br
.ti -1c
.BI "const QColor \fBtoColor\fR () const"
.br
.ti -1c
.BI "const QPalette \fBtoPalette\fR () const"
.br
.ti -1c
.BI "const QColorGroup \fBtoColorGroup\fR () const"
.br
.ti -1c
.BI "const QIconSet \fBtoIconSet\fR () const"
.br
.ti -1c
.BI "const QPointArray \fBtoPointArray\fR () const"
.br
.ti -1c
.BI "const QBitmap \fBtoBitmap\fR () const"
.br
.ti -1c
.BI "const QRegion \fBtoRegion\fR () const"
.br
.ti -1c
.BI "const QCursor \fBtoCursor\fR () const"
.br
.ti -1c
.BI "const QDate \fBtoDate\fR () const"
.br
.ti -1c
.BI "const QTime \fBtoTime\fR () const"
.br
.ti -1c
.BI "const QDateTime \fBtoDateTime\fR () const"
.br
.ti -1c
.BI "const QByteArray \fBtoByteArray\fR () const"
.br
.ti -1c
.BI "const QBitArray \fBtoBitArray\fR () const"
.br
.ti -1c
.BI "const QKeySequence \fBtoKeySequence\fR () const"
.br
.ti -1c
.BI "const QPen \fBtoPen\fR () const"
.br
.ti -1c
.BI "int \fBtoInt\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "uint \fBtoUInt\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "Q_LLONG \fBtoLongLong\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "Q_ULLONG \fBtoULongLong\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "bool \fBtoBool\fR () const"
.br
.ti -1c
.BI "double \fBtoDouble\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "const QValueList<QVariant> \fBtoList\fR () const"
.br
.ti -1c
.BI "const QMap<QString, QVariant> \fBtoMap\fR () const"
.br
.ti -1c
.BI "QSizePolicy \fBtoSizePolicy\fR () const"
.br
.ti -1c
.BI "QValueListConstIterator<QString> stringListBegin () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QValueListConstIterator<QString> stringListEnd () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QValueListConstIterator<QVariant> listBegin () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QValueListConstIterator<QVariant> listEnd () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> mapBegin () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> mapEnd () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> mapFind ( const QString & key ) const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QString & \fBasString\fR ()"
.br
.ti -1c
.BI "QCString & \fBasCString\fR ()"
.br
.ti -1c
.BI "QStringList & \fBasStringList\fR ()"
.br
.ti -1c
.BI "QFont & \fBasFont\fR ()"
.br
.ti -1c
.BI "QPixmap & \fBasPixmap\fR ()"
.br
.ti -1c
.BI "QImage & \fBasImage\fR ()"
.br
.ti -1c
.BI "QBrush & \fBasBrush\fR ()"
.br
.ti -1c
.BI "QPoint & \fBasPoint\fR ()"
.br
.ti -1c
.BI "QRect & \fBasRect\fR ()"
.br
.ti -1c
.BI "QSize & \fBasSize\fR ()"
.br
.ti -1c
.BI "QColor & \fBasColor\fR ()"
.br
.ti -1c
.BI "QPalette & \fBasPalette\fR ()"
.br
.ti -1c
.BI "QColorGroup & \fBasColorGroup\fR ()"
.br
.ti -1c
.BI "QIconSet & \fBasIconSet\fR ()"
.br
.ti -1c
.BI "QPointArray & \fBasPointArray\fR ()"
.br
.ti -1c
.BI "QBitmap & \fBasBitmap\fR ()"
.br
.ti -1c
.BI "QRegion & \fBasRegion\fR ()"
.br
.ti -1c
.BI "QCursor & \fBasCursor\fR ()"
.br
.ti -1c
.BI "QDate & \fBasDate\fR ()"
.br
.ti -1c
.BI "QTime & \fBasTime\fR ()"
.br
.ti -1c
.BI "QDateTime & \fBasDateTime\fR ()"
.br
.ti -1c
.BI "QByteArray & \fBasByteArray\fR ()"
.br
.ti -1c
.BI "QBitArray & \fBasBitArray\fR ()"
.br
.ti -1c
.BI "QKeySequence & \fBasKeySequence\fR ()"
.br
.ti -1c
.BI "QPen & \fBasPen\fR ()"
.br
.ti -1c
.BI "int & \fBasInt\fR ()"
.br
.ti -1c
.BI "uint & \fBasUInt\fR ()"
.br
.ti -1c
.BI "Q_LLONG & \fBasLongLong\fR ()"
.br
.ti -1c
.BI "Q_ULLONG & \fBasULongLong\fR ()"
.br
.ti -1c
.BI "bool & \fBasBool\fR ()"
.br
.ti -1c
.BI "double & \fBasDouble\fR ()"
.br
.ti -1c
.BI "QValueList<QVariant> & \fBasList\fR ()"
.br
.ti -1c
.BI "QMap<QString, QVariant> & \fBasMap\fR ()"
.br
.ti -1c
.BI "QSizePolicy & \fBasSizePolicy\fR ()"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "const char * \fBtypeToName\fR ( Type typ )"
.br
.ti -1c
.BI "Type \fBnameToType\fR ( const char * name )"
.br
.in -1c
.SH DESCRIPTION
The QVariant class acts like a union for the most common Qt data types.
.PP
Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. Without QVariant, this would be a problem for QObject::property() and for database work, etc.
.PP
A QVariant object holds a single value of a single type() at a time. (Some type()s are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using one of the asT() functions, e.g. asSize(), get its value using one of the toT() functions, e.g. toSize(), and check whether the type can be converted to a particular type using canCast().
.PP
The methods named toT() (for any supported T, see the Type documentation for a list) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type (see the function documentation for details).
.PP
Note that three data types supported by QVariant are explicitly shared, namely QImage, QPointArray, and QCString, and in these cases the toT() methods return a shallow copy. In almost all cases you must make a deep copy of the returned values before modifying them.
.PP
The asT() functions are not const. They do conversion like the toT() methods, set the variant to hold the converted value, and return a reference to the new contents of the variant.
.PP
Here is some example code to demonstrate the use of QVariant:
.PP
.nf
.br
    QDataStream out(...);
.br
    QVariant v(123);          // The variant now contains an int
.br
    int x = v.toInt();        // x = 123
.br
    out << v;                 // Writes a type tag and an int to out
.br
    v = QVariant("hello");    // The variant now contains a QCString
.br
    v = QVariant(tr("hello"));// The variant now contains a QString
.br
    int y = v.toInt();        // y = 0 since v cannot be converted to an int
.br
    QString s = v.toString(); // s = tr("hello")  (see QObject::tr())
.br
    out << v;                 // Writes a type tag and a QString to out
.br
    ...
.br
    QDataStream in(...);      // (opening the previously written stream)
.br
    in >> v;                  // Reads an Int variant
.br
    int z = v.toInt();        // z = 123
.br
    qDebug("Type is %s",      // prints "Type is int"
.br
            v.typeName());
.br
    v.asInt() += 100;         // The variant now hold the value 223.
.br
    v = QVariant( QStringList() );
.br
    v.asStringList().append( "Hello" );
.br
.fi
.PP
You can even store QValueList<QVariant>s and QMap<QString,QVariant>s in a variant, so you can easily construct arbitrarily complex data structures of arbitrary types. This is very powerful and versatile, but may prove less memory and speed efficient than storing specific types in standard data structures.
.PP
QVariant also supports the notion of NULL values, where you have a defined type with no value set.
.PP
.nf
.br
    QVariant x, y( QString() ), z( QString("") );
.br
    x.asInt();
.br
    // x.isNull() == TRUE, y.isNull() == TRUE, z.isNull() == FALSE
.br
.fi
.PP
See the Collection Classes.
.PP
See also Miscellaneous Classes and Object Model.
.SS "Member Type Documentation"
.SH "QVariant::Type"
This enum type defines the types of variable that a QVariant can contain.
.TP
\fCQVariant::Invalid\fR - no type
.TP
\fCQVariant::BitArray\fR - a QBitArray
.TP
\fCQVariant::ByteArray\fR - a QByteArray
.TP
\fCQVariant::Bitmap\fR - a QBitmap
.TP
\fCQVariant::Bool\fR - a bool
.TP
\fCQVariant::Brush\fR - a QBrush
.TP
\fCQVariant::Color\fR - a QColor
.TP
\fCQVariant::ColorGroup\fR - a QColorGroup
.TP
\fCQVariant::Cursor\fR - a QCursor
.TP
\fCQVariant::Date\fR - a QDate
.TP
\fCQVariant::DateTime\fR - a QDateTime
.TP
\fCQVariant::Double\fR - a double
.TP
\fCQVariant::Font\fR - a QFont
.TP
\fCQVariant::IconSet\fR - a QIconSet
.TP
\fCQVariant::Image\fR - a QImage
.TP
\fCQVariant::Int\fR - an int
.TP
\fCQVariant::KeySequence\fR - a QKeySequence
.TP
\fCQVariant::List\fR - a QValueList<QVariant>
.TP
\fCQVariant::LongLong\fR - a long long
.TP
\fCQVariant::ULongLong\fR - an unsigned long long
.TP
\fCQVariant::Map\fR - a QMap<QString,QVariant>
.TP
\fCQVariant::Palette\fR - a QPalette
.TP
\fCQVariant::Pen\fR - a QPen
.TP
\fCQVariant::Pixmap\fR - a QPixmap
.TP
\fCQVariant::Point\fR - a QPoint
.TP
\fCQVariant::PointArray\fR - a QPointArray
.TP
\fCQVariant::Rect\fR - a QRect
.TP
\fCQVariant::Region\fR - a QRegion
.TP
\fCQVariant::Size\fR - a QSize
.TP
\fCQVariant::SizePolicy\fR - a QSizePolicy
.TP
\fCQVariant::String\fR - a QString
.TP
\fCQVariant::CString\fR - a QCString
.TP
\fCQVariant::StringList\fR - a QStringList
.TP
\fCQVariant::Time\fR - a QTime
.TP
\fCQVariant::UInt\fR - an unsigned int
.PP
Note that Qt's definition of bool depends on the compiler. qglobal.h has the system-dependent definition of bool.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QVariant::QVariant ()"
Constructs an invalid variant.
.SH "QVariant::QVariant ( bool val, int )"
Constructs a new variant with a boolean value, \fIval\fR. The integer argument is a dummy, necessary for compatibility with some compilers.
.SH "QVariant::QVariant ( double val )"
Constructs a new variant with a floating point value, \fIval\fR.
.SH "QVariant::QVariant ( QSizePolicy val )"
Constructs a new variant with a size policy value, \fIval\fR.
.SH "QVariant::QVariant ( const QVariant & p )"
Constructs a copy of the variant, \fIp\fR, passed as the argument to this constructor. Usually this is a deep copy, but a shallow copy is made if the stored data type is explicitly shared, as e.g. QImage is.
.SH "QVariant::QVariant ( QDataStream & s )"
Reads the variant from the data stream, \fIs\fR.
.SH "QVariant::QVariant ( const QString & val )"
Constructs a new variant with a string value, \fIval\fR.
.SH "QVariant::QVariant ( const QCString & val )"
Constructs a new variant with a C-string value, \fIval\fR.
.PP
If you want to modify the QCString after you've passed it to this constructor, we recommend passing a deep copy (see QCString::copy()).
.SH "QVariant::QVariant ( const char * val )"
Constructs a new variant with a C-string value of \fIval\fR if \fIval\fR is non-null. The variant creates a deep copy of \fIval\fR.
.PP
If \fIval\fR is null, the resulting variant has type Invalid.
.SH "QVariant::QVariant ( const QStringList & val )"
Constructs a new variant with a string list value, \fIval\fR.
.SH "QVariant::QVariant ( const QFont & val )"
Constructs a new variant with a font value, \fIval\fR.
.SH "QVariant::QVariant ( const QPixmap & val )"
Constructs a new variant with a pixmap value, \fIval\fR.
.SH "QVariant::QVariant ( const QImage & val )"
Constructs a new variant with an image value, \fIval\fR.
.PP
Because QImage is explicitly shared, you may need to pass a deep copy to the variant using QImage::copy(), e.g. if you intend changing the image you've passed later on.
.SH "QVariant::QVariant ( const QBrush & val )"
Constructs a new variant with a brush value, \fIval\fR.
.SH "QVariant::QVariant ( const QPoint & val )"
Constructs a new variant with a point value, \fIval\fR.
.SH "QVariant::QVariant ( const QRect & val )"
Constructs a new variant with a rect value, \fIval\fR.
.SH "QVariant::QVariant ( const QSize & val )"
Constructs a new variant with a size value, \fIval\fR.
.SH "QVariant::QVariant ( const QColor & val )"
Constructs a new variant with a color value, \fIval\fR.
.SH "QVariant::QVariant ( const QPalette & val )"
Constructs a new variant with a color palette value, \fIval\fR.
.SH "QVariant::QVariant ( const QColorGroup & val )"
Constructs a new variant with a color group value, \fIval\fR.
.SH "QVariant::QVariant ( const QIconSet & val )"
Constructs a new variant with an icon set value, \fIval\fR.
.SH "QVariant::QVariant ( const QPointArray & val )"
Constructs a new variant with a point array value, \fIval\fR.
.PP
Because QPointArray is explicitly shared, you may need to pass a deep copy to the variant using QPointArray::copy(), e.g. if you intend changing the point array you've passed later on.
.SH "QVariant::QVariant ( const QRegion & val )"
Constructs a new variant with a region value, \fIval\fR.
.SH "QVariant::QVariant ( const QBitmap & val )"
Constructs a new variant with a bitmap value, \fIval\fR.
.SH "QVariant::QVariant ( const QCursor & val )"
Constructs a new variant with a cursor value, \fIval\fR.
.SH "QVariant::QVariant ( const QDate & val )"
Constructs a new variant with a date value, \fIval\fR.
.SH "QVariant::QVariant ( const QTime & val )"
Constructs a new variant with a time value, \fIval\fR.
.SH "QVariant::QVariant ( const QDateTime & val )"
Constructs a new variant with a date/time value, \fIval\fR.
.SH "QVariant::QVariant ( const QByteArray & val )"
Constructs a new variant with a bytearray value, \fIval\fR.
.SH "QVariant::QVariant ( const QBitArray & val )"
Constructs a new variant with a bitarray value, \fIval\fR.
.SH "QVariant::QVariant ( const QKeySequence & val )"
Constructs a new variant with a key sequence value, \fIval\fR.
.SH "QVariant::QVariant ( const QPen & val )"
Constructs a new variant with a pen value, \fIval\fR.
.SH "QVariant::QVariant ( const QValueList<QVariant> & val )"
Constructs a new variant with a list value, \fIval\fR.
.SH "QVariant::QVariant ( const QMap<QString, QVariant> & val )"
Constructs a new variant with a map of QVariants, \fIval\fR.
.SH "QVariant::QVariant ( int val )"
Constructs a new variant with an integer value, \fIval\fR.
.SH "QVariant::QVariant ( uint val )"
Constructs a new variant with an unsigned integer value, \fIval\fR.
.SH "QVariant::QVariant ( Q_LLONG val )"
Constructs a new variant with a long long integer value, \fIval\fR.
.SH "QVariant::QVariant ( Q_ULLONG val )"
Constructs a new variant with an unsigned long long integer value, \fIval\fR.
.SH "QVariant::~QVariant ()"
Destroys the QVariant and the contained object.
.PP
Note that subclasses that reimplement clear() should reimplement the destructor to call clear(). This destructor calls clear(), but because it is the destructor, QVariant::clear() is called rather than a subclass's clear().
.SH "QBitArray & QVariant::asBitArray ()"
Tries to convert the variant to hold a QBitArray value. If that is not possible then the variant is set to an empty bitarray.
.PP
Returns a reference to the stored bitarray.
.PP
See also toBitArray().
.SH "QBitmap & QVariant::asBitmap ()"
Tries to convert the variant to hold a bitmap value. If that is not possible the variant is set to a null bitmap.
.PP
Returns a reference to the stored bitmap.
.PP
See also toBitmap().
.SH "bool & QVariant::asBool ()"
Returns the variant's value as bool reference.
.SH "QBrush & QVariant::asBrush ()"
Tries to convert the variant to hold a brush value. If that is not possible the variant is set to a default black brush.
.PP
Returns a reference to the stored brush.
.PP
See also toBrush().
.SH "QByteArray & QVariant::asByteArray ()"
Tries to convert the variant to hold a QByteArray value. If that is not possible then the variant is set to an empty bytearray.
.PP
Returns a reference to the stored bytearray.
.PP
See also toByteArray().
.SH "QCString & QVariant::asCString ()"
Tries to convert the variant to hold a string value. If that is not possible the variant is set to an empty string.
.PP
Returns a reference to the stored string.
.PP
See also toCString().
.SH "QColor & QVariant::asColor ()"
Tries to convert the variant to hold a QColor value. If that is not possible the variant is set to an invalid color.
.PP
Returns a reference to the stored color.
.PP
See also toColor() and QColor::isValid().
.SH "QColorGroup & QVariant::asColorGroup ()"
Tries to convert the variant to hold a QColorGroup value. If that is not possible the variant is set to a color group of all black colors.
.PP
Returns a reference to the stored color group.
.PP
See also toColorGroup().
.SH "QCursor & QVariant::asCursor ()"
Tries to convert the variant to hold a QCursor value. If that is not possible the variant is set to a default arrow cursor.
.PP
Returns a reference to the stored cursor.
.PP
See also toCursor().
.SH "QDate & QVariant::asDate ()"
Tries to convert the variant to hold a QDate value. If that is not possible then the variant is set to an invalid date.
.PP
Returns a reference to the stored date.
.PP
See also toDate().
.SH "QDateTime & QVariant::asDateTime ()"
Tries to convert the variant to hold a QDateTime value. If that is not possible then the variant is set to an invalid date/time.
.PP
Returns a reference to the stored date/time.
.PP
See also toDateTime().
.SH "double & QVariant::asDouble ()"
Returns the variant's value as double reference.
.SH "QFont & QVariant::asFont ()"
Tries to convert the variant to hold a QFont. If that is not possible the variant is set to the application's default font.
.PP
Returns a reference to the stored font.
.PP
See also toFont().
.SH "QIconSet & QVariant::asIconSet ()"
Tries to convert the variant to hold a QIconSet value. If that is not possible the variant is set to an empty iconset.
.PP
Returns a reference to the stored iconset.
.PP
See also toIconSet().
.SH "QImage & QVariant::asImage ()"
Tries to convert the variant to hold an image value. If that is not possible the variant is set to a null image.
.PP
Returns a reference to the stored image.
.PP
See also toImage().
.SH "int & QVariant::asInt ()"
Returns the variant's value as int reference.
.SH "QKeySequence & QVariant::asKeySequence ()"
Tries to convert the variant to hold a QKeySequence value. If that is not possible then the variant is set to an empty key sequence.
.PP
Returns a reference to the stored key sequence.
.PP
See also toKeySequence().
.SH "QValueList<QVariant> & QVariant::asList ()"
Returns the variant's value as variant list reference.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QValueList<QVariant> list = myVariant.asList();
.br
    QValueList<QVariant>::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.SH "Q_LLONG & QVariant::asLongLong ()"
Returns the variant's value as long long reference.
.SH "QMap<QString, QVariant> & QVariant::asMap ()"
Returns the variant's value as variant map reference.
.PP
Note that if you want to iterate over the map, you should iterate over a copy, e.g.
.PP
.nf
.br
    QMap<QString, QVariant> map = myVariant.asMap();
.br
    QMap<QString, QVariant>::Iterator it = map.begin();
.br
    while( it != map.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.SH "QPalette & QVariant::asPalette ()"
Tries to convert the variant to hold a QPalette value. If that is not possible the variant is set to a palette of black colors.
.PP
Returns a reference to the stored palette.
.PP
See also toString().
.SH "QPen & QVariant::asPen ()"
Tries to convert the variant to hold a QPen value. If that is not possible then the variant is set to an empty pen.
.PP
Returns a reference to the stored pen.
.PP
See also toPen().
.SH "QPixmap & QVariant::asPixmap ()"
Tries to convert the variant to hold a pixmap value. If that is not possible the variant is set to a null pixmap.
.PP
Returns a reference to the stored pixmap.
.PP
See also toPixmap().
.SH "QPoint & QVariant::asPoint ()"
Tries to convert the variant to hold a point value. If that is not possible the variant is set to a (0, 0) point.
.PP
Returns a reference to the stored point.
.PP
See also toPoint().
.SH "QPointArray & QVariant::asPointArray ()"
Tries to convert the variant to hold a QPointArray value. If that is not possible the variant is set to an empty point array.
.PP
Returns a reference to the stored point array.
.PP
See also toPointArray().
.SH "QRect & QVariant::asRect ()"
Tries to convert the variant to hold a rectangle value. If that is not possible the variant is set to an empty rectangle.
.PP
Returns a reference to the stored rectangle.
.PP
See also toRect().
.SH "QRegion & QVariant::asRegion ()"
Tries to convert the variant to hold a QRegion value. If that is not possible the variant is set to a null region.
.PP
Returns a reference to the stored region.
.PP
See also toRegion().
.SH "QSize & QVariant::asSize ()"
Tries to convert the variant to hold a QSize value. If that is not possible the variant is set to an invalid size.
.PP
Returns a reference to the stored size.
.PP
See also toSize() and QSize::isValid().
.SH "QSizePolicy & QVariant::asSizePolicy ()"
Tries to convert the variant to hold a QSizePolicy value. If that fails, the variant is set to an arbitrary (valid) size policy.
.SH "QString & QVariant::asString ()"
Tries to convert the variant to hold a string value. If that is not possible the variant is set to an empty string.
.PP
Returns a reference to the stored string.
.PP
See also toString().
.SH "QStringList & QVariant::asStringList ()"
Tries to convert the variant to hold a QStringList value. If that is not possible the variant is set to an empty string list.
.PP
Returns a reference to the stored string list.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myVariant.asStringList();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also toStringList().
.SH "QTime & QVariant::asTime ()"
Tries to convert the variant to hold a QTime value. If that is not possible then the variant is set to an invalid time.
.PP
Returns a reference to the stored time.
.PP
See also toTime().
.SH "uint & QVariant::asUInt ()"
Returns the variant's value as unsigned int reference.
.SH "Q_ULLONG & QVariant::asULongLong ()"
Returns the variant's value as unsigned long long reference.
.SH "bool QVariant::canCast ( Type t ) const"
Returns TRUE if the variant's type can be cast to the requested type, \fIt\fR. Such casting is done automatically when calling the toInt(), toBool(), ... or asInt(), asBool(), ... methods.
.PP
The following casts are done automatically: <center>.nf
.TS
l - l. Type Automatically Cast To Bool Double, Int, UInt, LongLong, ULongLong, String, CString, ByteArray Color String. CString. ByteArray Date String, CString, ByteArray, DateTime DateTime String, CString, ByteArray, Date, Time Double String, CString, ByteArray, Int, Bool, UInt, LongLong, ULongLong Font String, CString, ByteArray Int String, CString, ByteArray, Double, Bool, UInt, LongLong, ULongLong, KeySequence LongLong String, CString, ByteArray, Double, Bool, UInt, LongLong, ULongLong, KeySequence ULongLong String, CString, ByteArray, Double, Bool, UInt, LongLong, ULongLong, KeySequence List StringList (if the list contains only strings or something that can be cast to a string) String CString, ByteArray, CString, Int, UInt, Bool, Double, Date, Time, DateTime, KeySequence, Font, Color CString String, ByteArray, Int, UInt, Bool, Double, Date, ULongLong, LongLong ByteArray String, CString, Int, UInt, Bool, Double, Date, ULongLong, LongLong StringList List Time String Int String, CString, ByteArray, Double, Bool, UInt, LongLong, ULongLong, KeySequence KeySequence
.TE
.fi
</center>
.SH "bool QVariant::cast ( Type t )"
Casts the variant to the requested type. If the cast cannot be done, the variant is set to the default value of the requested type (e.g. an empty string if the requested type \fIt\fR is QVariant::String, an empty point array if the requested type \fIt\fR is QVariant::PointArray, etc). Returns TRUE if the current type of the variant was successfully cast; otherwise returns FALSE.
.PP
See also canCast().
.SH "void QVariant::clear ()"
Convert this variant to type Invalid and free up any resources used.
.SH "bool QVariant::isNull () const"
Returns TRUE if this is a NULL variant, FALSE otherwise.
.SH "bool QVariant::isValid () const"
Returns TRUE if the storage type of this variant is not QVariant::Invalid; otherwise returns FALSE.
.SH "QValueListConstIterator<QVariant> QVariant::listBegin () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns an iterator to the first item in the list if the variant's type is appropriate; otherwise returns a null iterator.
.SH "QValueListConstIterator<QVariant> QVariant::listEnd () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the end iterator for the list if the variant's type is appropriate; otherwise returns a null iterator.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapBegin () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns an iterator to the first item in the map, if the variant's type is appropriate; otherwise returns a null iterator.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapEnd () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the end iterator for the map, if the variant's type is appropriate; otherwise returns a null iterator.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapFind ( const QString & key ) const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns an iterator to the item in the map with \fIkey\fR as key, if the variant's type is appropriate and \fIkey\fR is a valid key; otherwise returns a null iterator.
.SH "Type QVariant::nameToType ( const char * name )\fC [static]\fR"
Converts the string representation of the storage type given in \fIname\fR, to its enum representation.
.PP
If the string representation cannot be converted to any enum representation, the variant is set to Invalid.
.SH "bool QVariant::operator!= ( const QVariant & v ) const"
Compares this QVariant with \fIv\fR and returns TRUE if they are not equal; otherwise returns FALSE.
.SH "QVariant & QVariant::operator= ( const QVariant & variant )"
Assigns the value of the variant \fIvariant\fR to this variant.
.PP
This is a deep copy of the variant, but note that if the variant holds an explicitly shared type such as QImage, a shallow copy is performed.
.SH "bool QVariant::operator== ( const QVariant & v ) const"
Compares this QVariant with \fIv\fR and returns TRUE if they are equal; otherwise returns FALSE.
.SH "QValueListConstIterator<QString> QVariant::stringListBegin () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns an iterator to the first string in the list if the variant's type is StringList; otherwise returns a null iterator.
.SH "QValueListConstIterator<QString> QVariant::stringListEnd () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the end iterator for the list if the variant's type is StringList; otherwise returns a null iterator.
.SH "const QBitArray QVariant::toBitArray () const"
Returns the variant as a QBitArray if the variant has type() BitArray; otherwise returns an empty bitarray.
.PP
See also asBitArray().
.SH "const QBitmap QVariant::toBitmap () const"
Returns the variant as a QBitmap if the variant has type() Bitmap; otherwise returns a null QBitmap.
.PP
See also asBitmap().
.SH "bool QVariant::toBool () const"
Returns the variant as a bool if the variant can be cast to Bool; otherWise returns FALSE.
.PP
Returns TRUE if the variant has a numeric type and its value is non-zero, or if the variant has type String, ByteArray or CString and its lower-case content is not empty, "0" or "false"; otherwise returns FALSE.
.PP
See also asBool() and canCast().
.SH "const QBrush QVariant::toBrush () const"
Returns the variant as a QBrush if the variant has type() Brush; otherwise returns a default brush (with all black colors).
.PP
See also asBrush().
.SH "const QByteArray QVariant::toByteArray () const"
Returns the variant as a QByteArray if the variant can be cast to a ByteArray; otherwise returns an empty bytearray.
.PP
See also asByteArray() and canCast().
.SH "const QCString QVariant::toCString () const"
Returns the variant as a QCString if the variant can be cast to a CString; otherwise returns 0.
.PP
See also asCString() and canCast().
.SH "const QColor QVariant::toColor () const"
Returns the variant as a QColor if the variant can be cast to Color; otherwise returns an invalid color.
.PP
See also asColor() and canCast().
.SH "const QColorGroup QVariant::toColorGroup () const"
Returns the variant as a QColorGroup if the variant has type() ColorGroup; otherwise returns a completely black color group.
.PP
See also asColorGroup().
.SH "const QCursor QVariant::toCursor () const"
Returns the variant as a QCursor if the variant has type() Cursor; otherwise returns the default arrow cursor.
.PP
See also asCursor().
.SH "const QDate QVariant::toDate () const"
Returns the variant as a QDate if the variant can be cast to Date; otherwise returns an invalid date.
.PP
Note that if the type() is String, CString or ByteArray an invalid date will be returned if the string cannot be parsed as a Qt::ISODate format date.
.PP
See also asDate() and canCast().
.SH "const QDateTime QVariant::toDateTime () const"
Returns the variant as a QDateTime if the variant can be cast to DateTime; otherwise returns an invalid QDateTime.
.PP
Note that if the type() is String, CString or ByteArray an invalid QDateTime will be returned if the string cannot be parsed as a Qt::ISODate format date/time.
.PP
See also asDateTime().
.SH "double QVariant::toDouble ( bool * ok = 0 ) const"
Returns the variant as a double if the variant can be cast to Double; otherwise returns 0.0.
.PP
If \fIok\fR is non-null: \fI*ok\fR is set to TRUE if the value could be converted to a double; otherwise \fI*ok\fR is set to FALSE.
.PP
See also asDouble() and canCast().
.SH "const QFont QVariant::toFont () const"
Returns the variant as a QFont if the variant can be cast to Font; otherwise returns the application's default font.
.PP
See also asFont() and canCast().
.SH "const QIconSet QVariant::toIconSet () const"
Returns the variant as a QIconSet if the variant has type() IconSet; otherwise returns an icon set of null pixmaps.
.PP
See also asIconSet().
.SH "const QImage QVariant::toImage () const"
Returns the variant as a QImage if the variant has type() Image; otherwise returns a null image.
.PP
See also asImage().
.SH "int QVariant::toInt ( bool * ok = 0 ) const"
Returns the variant as an int if the variant can be cast to Int; otherwise returns 0.
.PP
If \fIok\fR is non-null: \fI*ok\fR is set to TRUE if the value could be converted to an int; otherwise \fI*ok\fR is set to FALSE.
.PP
See also asInt() and canCast().
.SH "const QKeySequence QVariant::toKeySequence () const"
Returns the variant as a QKeySequence if the variant can be cast to a KeySequence; otherwise returns an empty key sequence.
.PP
See also asKeySequence() and canCast().
.SH "const QValueList<QVariant> QVariant::toList () const"
Returns the variant as a QValueList<QVariant> if the variant has type() List or StringList; otherwise returns an empty list.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QValueList<QVariant> list = myVariant.toList();
.br
    QValueList<QVariant>::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also asList().
.SH "Q_LLONG QVariant::toLongLong ( bool * ok = 0 ) const"
Returns the variant as a long long int if the variant can be cast to LongLong; otherwise returns 0.
.PP
If \fIok\fR is non-null: \fI*ok\fR is set to TRUE if the value could be converted to an int; otherwise \fI*ok\fR is set to FALSE.
.PP
See also asLongLong() and canCast().
.SH "const QMap<QString, QVariant> QVariant::toMap () const"
Returns the variant as a QMap<QString,QVariant> if the variant has type() Map; otherwise returns an empty map.
.PP
Note that if you want to iterate over the map, you should iterate over a copy, e.g.
.PP
.nf
.br
    QMap<QString, QVariant> map = myVariant.toMap();
.br
    QMap<QString, QVariant>::Iterator it = map.begin();
.br
    while( it != map.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also asMap().
.SH "const QPalette QVariant::toPalette () const"
Returns the variant as a QPalette if the variant has type() Palette; otherwise returns a completely black palette.
.PP
See also asPalette().
.SH "const QPen QVariant::toPen () const"
Returns the variant as a QPen if the variant has type() Pen; otherwise returns an empty QPen.
.PP
See also asPen().
.SH "const QPixmap QVariant::toPixmap () const"
Returns the variant as a QPixmap if the variant has type() Pixmap; otherwise returns a null pixmap.
.PP
See also asPixmap().
.SH "const QPoint QVariant::toPoint () const"
Returns the variant as a QPoint if the variant has type() Point; otherwise returns a point (0, 0).
.PP
See also asPoint().
.SH "const QPointArray QVariant::toPointArray () const"
Returns the variant as a QPointArray if the variant has type() PointArray; otherwise returns an empty QPointArray.
.PP
See also asPointArray().
.SH "const QRect QVariant::toRect () const"
Returns the variant as a QRect if the variant has type() Rect; otherwise returns an empty rectangle.
.PP
See also asRect().
.SH "const QRegion QVariant::toRegion () const"
Returns the variant as a QRegion if the variant has type() Region; otherwise returns an empty QRegion.
.PP
See also asRegion().
.SH "const QSize QVariant::toSize () const"
Returns the variant as a QSize if the variant has type() Size; otherwise returns an invalid size.
.PP
See also asSize().
.SH "QSizePolicy QVariant::toSizePolicy () const"
Returns the variant as a QSizePolicy if the variant has type() SizePolicy; otherwise returns an undefined (but legal) size policy.
.SH "const QString QVariant::toString () const"
Returns the variant as a QString if the variant can be cast to String, otherwise returns QString::null.
.PP
See also asString() and canCast().
.SH "const QStringList QVariant::toStringList () const"
Returns the variant as a QStringList if the variant has type() StringList or List of a type that can be converted to QString; otherwise returns an empty list.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myVariant.toStringList();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also asStringList().
.SH "const QTime QVariant::toTime () const"
Returns the variant as a QTime if the variant can be cast to Time; otherwise returns an invalid date.
.PP
Note that if the type() is String, CString or ByteArray an invalid time will be returned if the string cannot be parsed as a Qt::ISODate format time.
.PP
See also asTime().
.SH "uint QVariant::toUInt ( bool * ok = 0 ) const"
Returns the variant as an unsigned int if the variant can be cast to UInt; otherwise returns 0.
.PP
If \fIok\fR is non-null: \fI*ok\fR is set to TRUE if the value could be converted to an unsigned int; otherwise \fI*ok\fR is set to FALSE.
.PP
See also asUInt() and canCast().
.SH "Q_ULLONG QVariant::toULongLong ( bool * ok = 0 ) const"
Returns the variant as as an unsigned long long int if the variant can be cast to ULongLong; otherwise returns 0.
.PP
If \fIok\fR is non-null: \fI*ok\fR is set to TRUE if the value could be converted to an int; otherwise \fI*ok\fR is set to FALSE.
.PP
See also asULongLong() and canCast().
.SH "Type QVariant::type () const"
Returns the storage type of the value stored in the variant. Usually it's best to test with canCast() whether the variant can deliver the data type you are interested in.
.SH "const char * QVariant::typeName () const"
Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data: for example, "QFont", "QString", or "QValueList<QVariant>". An Invalid variant returns 0.
.SH "const char * QVariant::typeToName ( Type typ )\fC [static]\fR"
Converts the enum representation of the storage type, \fItyp\fR, to
its string representation.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qvariant.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qvariant.3qt) and the Qt
version (3.3.8).
