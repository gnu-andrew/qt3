'\" t
.TH QPainter 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QPainter \- Does low-level painting e.g. on widgets
.SH SYNOPSIS
\fC#include <qpainter.h>\fR
.PP
Inherits Qt.
.PP
Inherited by QDirectPainter.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBCoordinateMode\fR { CoordDevice, CoordPainter }"
.br
.ti -1c
.BI "\fBQPainter\fR ()"
.br
.ti -1c
.BI "\fBQPainter\fR ( const QPaintDevice * pd, bool unclipped = FALSE )"
.br
.ti -1c
.BI "\fBQPainter\fR ( const QPaintDevice * pd, const QWidget * copyAttributes, bool unclipped = FALSE )"
.br
.ti -1c
.BI "\fB~QPainter\fR ()"
.br
.ti -1c
.BI "bool \fBbegin\fR ( const QPaintDevice * pd, bool unclipped = FALSE )"
.br
.ti -1c
.BI "bool \fBbegin\fR ( const QPaintDevice * pd, const QWidget * copyAttributes, bool unclipped = FALSE )"
.br
.ti -1c
.BI "bool \fBend\fR ()"
.br
.ti -1c
.BI "QPaintDevice * \fBdevice\fR () const"
.br
.ti -1c
.BI "bool \fBisActive\fR () const"
.br
.ti -1c
.BI "void \fBflush\fR ( const QRegion & region, CoordinateMode cm = CoordDevice )"
.br
.ti -1c
.BI "void \fBflush\fR ()"
.br
.ti -1c
.BI "void \fBsave\fR ()"
.br
.ti -1c
.BI "void \fBrestore\fR ()"
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR () const"
.br
.ti -1c
.BI "QFontInfo \fBfontInfo\fR () const"
.br
.ti -1c
.BI "const QFont & \fBfont\fR () const"
.br
.ti -1c
.BI "void \fBsetFont\fR ( const QFont & font )"
.br
.ti -1c
.BI "const QPen & \fBpen\fR () const"
.br
.ti -1c
.BI "void \fBsetPen\fR ( const QPen & pen )"
.br
.ti -1c
.BI "void \fBsetPen\fR ( PenStyle style )"
.br
.ti -1c
.BI "void \fBsetPen\fR ( const QColor & color )"
.br
.ti -1c
.BI "const QBrush & \fBbrush\fR () const"
.br
.ti -1c
.BI "void \fBsetBrush\fR ( const QBrush & brush )"
.br
.ti -1c
.BI "void \fBsetBrush\fR ( BrushStyle style )"
.br
.ti -1c
.BI "void \fBsetBrush\fR ( const QColor & color )"
.br
.ti -1c
.BI "QPoint pos () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "const QColor & \fBbackgroundColor\fR () const"
.br
.ti -1c
.BI "void \fBsetBackgroundColor\fR ( const QColor & c )"
.br
.ti -1c
.BI "BGMode \fBbackgroundMode\fR () const"
.br
.ti -1c
.BI "void \fBsetBackgroundMode\fR ( BGMode m )"
.br
.ti -1c
.BI "RasterOp \fBrasterOp\fR () const"
.br
.ti -1c
.BI "void \fBsetRasterOp\fR ( RasterOp r )"
.br
.ti -1c
.BI "const QPoint & \fBbrushOrigin\fR () const"
.br
.ti -1c
.BI "void \fBsetBrushOrigin\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBsetBrushOrigin\fR ( const QPoint & p )"
.br
.ti -1c
.BI "bool \fBhasViewXForm\fR () const"
.br
.ti -1c
.BI "bool \fBhasWorldXForm\fR () const"
.br
.ti -1c
.BI "void \fBsetViewXForm\fR ( bool enable )"
.br
.ti -1c
.BI "QRect \fBwindow\fR () const"
.br
.ti -1c
.BI "void \fBsetWindow\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBsetWindow\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "QRect \fBviewport\fR () const"
.br
.ti -1c
.BI "void \fBsetViewport\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBsetViewport\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBsetWorldXForm\fR ( bool enable )"
.br
.ti -1c
.BI "const QWMatrix & \fBworldMatrix\fR () const"
.br
.ti -1c
.BI "void \fBsetWorldMatrix\fR ( const QWMatrix & m, bool combine = FALSE )"
.br
.ti -1c
.BI "void saveWorldMatrix ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void restoreWorldMatrix ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBscale\fR ( double sx, double sy )"
.br
.ti -1c
.BI "void \fBshear\fR ( double sh, double sv )"
.br
.ti -1c
.BI "void \fBrotate\fR ( double a )"
.br
.ti -1c
.BI "void \fBtranslate\fR ( double dx, double dy )"
.br
.ti -1c
.BI "void \fBresetXForm\fR ()"
.br
.ti -1c
.BI "QPoint \fBxForm\fR ( const QPoint & pv ) const"
.br
.ti -1c
.BI "QRect \fBxForm\fR ( const QRect & rv ) const"
.br
.ti -1c
.BI "QPointArray \fBxForm\fR ( const QPointArray & av ) const"
.br
.ti -1c
.BI "QPointArray \fBxForm\fR ( const QPointArray & av, int index, int npoints ) const"
.br
.ti -1c
.BI "QPoint \fBxFormDev\fR ( const QPoint & pd ) const"
.br
.ti -1c
.BI "QRect \fBxFormDev\fR ( const QRect & rd ) const"
.br
.ti -1c
.BI "QPointArray \fBxFormDev\fR ( const QPointArray & ad ) const"
.br
.ti -1c
.BI "QPointArray \fBxFormDev\fR ( const QPointArray & ad, int index, int npoints ) const"
.br
.ti -1c
.BI "void \fBsetClipping\fR ( bool enable )"
.br
.ti -1c
.BI "bool \fBhasClipping\fR () const"
.br
.ti -1c
.BI "QRegion \fBclipRegion\fR ( CoordinateMode m = CoordDevice ) const"
.br
.ti -1c
.BI "void \fBsetClipRect\fR ( const QRect & r, CoordinateMode m = CoordDevice )"
.br
.ti -1c
.BI "void \fBsetClipRect\fR ( int x, int y, int w, int h, CoordinateMode m = CoordDevice )"
.br
.ti -1c
.BI "void \fBsetClipRegion\fR ( const QRegion & rgn, CoordinateMode m = CoordDevice )"
.br
.ti -1c
.BI "void \fBdrawPoint\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBdrawPoint\fR ( const QPoint & p )"
.br
.ti -1c
.BI "void \fBdrawPoints\fR ( const QPointArray & a, int index = 0, int npoints = -1 )"
.br
.ti -1c
.BI "void moveTo ( int x, int y )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void moveTo ( const QPoint & p )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void lineTo ( int x, int y )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void lineTo ( const QPoint & p )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBdrawLine\fR ( int x1, int y1, int x2, int y2 )"
.br
.ti -1c
.BI "void \fBdrawLine\fR ( const QPoint & p1, const QPoint & p2 )"
.br
.ti -1c
.BI "void \fBdrawRect\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBdrawRect\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( int x, int y, int w, int h, const QColor & bgColor )"
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( const QRect & r, const QColor & bgColor )"
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( int x, int y, int w, int h, int xRnd = 25, int yRnd = 25 )"
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( const QRect & r, int xRnd = 25, int yRnd = 25 )"
.br
.ti -1c
.BI "void \fBdrawEllipse\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBdrawEllipse\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBdrawArc\fR ( int x, int y, int w, int h, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawArc\fR ( const QRect & r, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawPie\fR ( int x, int y, int w, int h, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawPie\fR ( const QRect & r, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawChord\fR ( int x, int y, int w, int h, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawChord\fR ( const QRect & r, int a, int alen )"
.br
.ti -1c
.BI "void \fBdrawLineSegments\fR ( const QPointArray & a, int index = 0, int nlines = -1 )"
.br
.ti -1c
.BI "void \fBdrawPolyline\fR ( const QPointArray & a, int index = 0, int npoints = -1 )"
.br
.ti -1c
.BI "void \fBdrawPolygon\fR ( const QPointArray & a, bool winding = FALSE, int index = 0, int npoints = -1 )"
.br
.ti -1c
.BI "void \fBdrawConvexPolygon\fR ( const QPointArray & pa, int index = 0, int npoints = -1 )"
.br
.ti -1c
.BI "void \fBdrawCubicBezier\fR ( const QPointArray & a, int index = 0 )"
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( int x, int y, const QPixmap & pixmap, int sx = 0, int sy = 0, int sw = -1, int sh = -1 )"
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( const QPoint & p, const QPixmap & pm, const QRect & sr )"
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( const QPoint & p, const QPixmap & pm )"
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( const QRect & r, const QPixmap & pm )"
.br
.ti -1c
.BI "void \fBdrawImage\fR ( int x, int y, const QImage & image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, int conversionFlags = 0 )"
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint &, const QImage &, const QRect & sr, int conversionFlags = 0 )"
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint & p, const QImage & i, int conversion_flags = 0 )"
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QRect & r, const QImage & i )"
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( int x, int y, int w, int h, const QPixmap & pixmap, int sx = 0, int sy = 0 )"
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( const QRect & r, const QPixmap & pm, const QPoint & sp )"
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( const QRect & r, const QPixmap & pm )"
.br
.ti -1c
.BI "void drawPicture ( const QPicture & pic )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBdrawPicture\fR ( int x, int y, const QPicture & pic )"
.br
.ti -1c
.BI "void \fBdrawPicture\fR ( const QPoint & p, const QPicture & pic )"
.br
.ti -1c
.BI "void \fBfillRect\fR ( int x, int y, int w, int h, const QBrush & brush )"
.br
.ti -1c
.BI "void \fBfillRect\fR ( const QRect & r, const QBrush & brush )"
.br
.ti -1c
.BI "void \fBeraseRect\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBeraseRect\fR ( const QRect & r )"
.br
.ti -1c
.BI "enum \fBTextDirection\fR { Auto, RTL, LTR }"
.br
.ti -1c
.BI "void \fBdrawText\fR ( int x, int y, const QString &, int len = -1, TextDirection dir = Auto )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QPoint &, const QString &, int len = -1, TextDirection dir = Auto )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( int x, int y, const QString &, int pos, int len, TextDirection dir = Auto )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QPoint & p, const QString &, int pos, int len, TextDirection dir = Auto )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( int x, int y, int w, int h, int flags, const QString &, int len = -1, QRect * br = 0, QTextParag ** internal = 0 )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QRect & r, int tf, const QString & str, int len = -1, QRect * brect = 0, QTextParag ** internal = 0 )"
.br
.ti -1c
.BI "QRect \fBboundingRect\fR ( int x, int y, int w, int h, int flags, const QString &, int len = -1, QTextParag ** intern = 0 )"
.br
.ti -1c
.BI "QRect \fBboundingRect\fR ( const QRect & r, int flags, const QString & str, int len = -1, QTextParag ** internal = 0 )"
.br
.ti -1c
.BI "int \fBtabStops\fR () const"
.br
.ti -1c
.BI "void \fBsetTabStops\fR ( int ts )"
.br
.ti -1c
.BI "int * \fBtabArray\fR () const"
.br
.ti -1c
.BI "void \fBsetTabArray\fR ( int * ta )"
.br
.ti -1c
.BI "HDC \fBhandle\fR () const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "void \fBredirect\fR ( QPaintDevice * pdev, QPaintDevice * replacement )"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "void \fBqDrawShadeLine\fR ( QPainter * p, int x1, int y1, int x2, int y2, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth )"
.br
.ti -1c
.BI "void \fBqDrawShadeRect\fR ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth, const QBrush * fill )"
.br
.ti -1c
.BI "void \fBqDrawShadePanel\fR ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, const QBrush * fill )"
.br
.ti -1c
.BI "void \fBqDrawWinButton\fR ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill )"
.br
.ti -1c
.BI "void \fBqDrawWinPanel\fR ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill )"
.br
.ti -1c
.BI "void \fBqDrawPlainRect\fR ( QPainter * p, int x, int y, int w, int h, const QColor & c, int lineWidth, const QBrush * fill )"
.br
.in -1c
.SH DESCRIPTION
The QPainter class does low-level painting e.g. on widgets.
.PP
The painter provides highly optimized functions to do most of the drawing GUI programs require. QPainter can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a "natural" coordinate system, but it can also do view and world transformation.
.PP
The typical use of a painter is:
.TP
Construct a painter.
.TP
Set a pen, a brush etc.
.TP
Draw.
.TP
Destroy the painter.
.PP
Mostly, all this is done inside a paint event. (In fact, 99% of all QPainter use is in a reimplementation of QWidget::paintEvent(), and the painter is heavily optimized for such use.) Here's one very simple example:
.PP
.nf
.br
    void SimpleExampleWidget::paintEvent()
.br
    {
.br
        QPainter paint( this );
.br
        paint.setPen( Qt::blue );
.br
        paint.drawText( rect(), AlignCenter, "The Text" );
.br
    }
.br
.fi
.PP
Usage is simple, and there are many settings you can use:
.IP
.TP
font() is the currently set font. If you set a font that isn't available, Qt finds a close match. In fact font() returns what you set using setFont() and fontInfo() returns the font actually being used (which may be the same).
.IP
.TP
brush() is the currently set brush; the color or pattern that's used for filling e.g. circles.
.IP
.TP
pen() is the currently set pen; the color or stipple that's used for drawing lines or boundaries.
.IP
.TP
backgroundMode() is \fCOpaque\fR or \fCTransparent\fR, i.e. whether backgroundColor() is used or not.
.IP
.TP
backgroundColor() only applies when backgroundMode() is Opaque and pen() is a stipple. In that case, it describes the color of the background pixels in the stipple.
.IP
.TP
rasterOp() is how pixels drawn interact with the pixels already there.
.IP
.TP
brushOrigin() is the origin of the tiled brushes, normally the origin of the window.
.IP
.TP
viewport(), window(), worldMatrix() and many more make up the painter's coordinate transformation system. See The Coordinate System for an explanation of this, or see below for a very brief overview of the functions.
.IP
.TP
hasClipping() is whether the painter clips at all. (The paint device clips, too.) If the painter clips, it clips to clipRegion().
.IP
.TP
pos() is the current position, set by moveTo() and used by lineTo().
.IP
.PP
Note that some of these settings mirror settings in some paint devices, e.g. QWidget::font(). QPainter::begin() (or the QPainter constructor) copies these attributes from the paint device. Calling, for example, QWidget::setFont() doesn't take effect until the next time a painter begins painting on it.
.PP
save() saves all of these settings on an internal stack, restore() pops them back.
.PP
The core functionality of QPainter is drawing, and there are functions to draw most primitives: drawPoint(), drawPoints(), drawLine(), drawRect(), drawWinFocusRect(), drawRoundRect(), drawEllipse(), drawArc(), drawPie(), drawChord(), drawLineSegments(), drawPolyline(), drawPolygon(), drawConvexPolygon() and drawCubicBezier(). All of these functions take integer coordinates; there are no floating-point versions since we want drawing to be as fast as possible.
.PP
There are functions to draw pixmaps/images, namely drawPixmap(), drawImage() and drawTiledPixmap(). drawPixmap() and drawImage() produce the same result, except that drawPixmap() is faster on-screen and drawImage() faster and sometimes better on QPrinter and QPicture.
.PP
Text drawing is done using drawText(), and when you need fine-grained positioning, boundingRect() tells you where a given drawText() command would draw.
.PP
There is a drawPicture() function that draws the contents of an entire QPicture using this painter. drawPicture() is the only function that disregards all the painter's settings: the QPicture has its own settings.
.PP
Normally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformation. See The Coordinate System for a more general overview and a simple example.
.PP
The most common functions used are scale(), rotate(), translate() and shear(), all of which operate on the worldMatrix(). setWorldMatrix() can replace or add to the currently set worldMatrix().
.PP
setViewport() sets the rectangle on which QPainter operates. The default is the entire device, which is usually fine, except on printers. setWindow() sets the coordinate system, that is, the rectangle that maps to viewport(). What's drawn inside the window() ends up being inside the viewport(). The window's default is the same as the viewport, and if you don't use the transformations, they are optimized away, gaining another little bit of speed.
.PP
After all the coordinate transformation is done, QPainter can clip the drawing to an arbitrary rectangle or region. hasClipping() is TRUE if QPainter clips, and clipRegion() returns the clip region. You can set it using either setClipRegion() or setClipRect(). Note that the clipping can be slow. It's all system-dependent, but as a rule of thumb, you can assume that drawing speed is inversely proportional to the number of rectangles in the clip region.
.PP
After QPainter's clipping, the paint device may also clip. For example, most widgets clip away the pixels used by child widgets, and most printers clip away an area near the edges of the paper. This additional clipping is not reflected by the return value of clipRegion() or hasClipping().
.PP
QPainter also includes some less-used functions that are very useful on those occasions when they're needed.
.PP
isActive() indicates whether the painter is active. begin() (and the most usual constructor) makes it active. end() (and the destructor) deactivates it. If the painter is active, device() returns the paint device on which the painter paints.
.PP
Sometimes it is desirable to make someone else paint on an unusual QPaintDevice. QPainter supports a static function to do this, redirect(). We recommend not using it, but for some hacks it's perfect.
.PP
setTabStops() and setTabArray() can change where the tab stops are, but these are very seldomly used.
.PP
\fBWarning:\fR Note that QPainter does not attempt to work around coordinate limitations in the underlying window system. Some platforms may behave incorrectly with coordinates as small as +/-4000.
.PP
See also QPaintDevice, QWidget, QPixmap, QPrinter, QPicture, Application Walkthrough, Coordinate System Overview, Graphics Classes, and Image Processing Classes.
.SS "Member Type Documentation"
.SH "QPainter::CoordinateMode"
.TP
\fCQPainter::CoordDevice\fR
.TP
\fCQPainter::CoordPainter\fR
.PP
See also clipRegion().
.SH "QPainter::TextDirection"
.TP
\fCQPainter::Auto\fR
.TP
\fCQPainter::RTL\fR - right to left
.TP
\fCQPainter::LTR\fR - left to right
.PP
See also drawText().
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QPainter::QPainter ()"
Constructs a painter.
.PP
Notice that all painter settings (setPen, setBrush etc.) are reset to default values when begin() is called.
.PP
See also begin() and end().
.SH "QPainter::QPainter ( const QPaintDevice * pd, bool unclipped = FALSE )"
Constructs a painter that begins painting the paint device \fIpd\fR immediately. Depending on the underlying graphic system the painter will paint over children of the paintdevice if \fIunclipped\fR is TRUE.
.PP
This constructor is convenient for short-lived painters, e.g. in a paint event and should be used only once. The constructor calls begin() for you and the QPainter destructor automatically calls end().
.PP
Here's an example using begin() and end():
.PP
.nf
.br
        void MyWidget::paintEvent( QPaintEvent * )
.br
        {
.br
            QPainter p;
.br
            p.begin( this );
.br
            p.drawLine( ... );  // drawing code
.br
            p.end();
.br
        }
.br
.fi
.PP
The same example using this constructor:
.PP
.nf
.br
        void MyWidget::paintEvent( QPaintEvent * )
.br
        {
.br
            QPainter p( this );
.br
            p.drawLine( ... );  // drawing code
.br
        }
.br
.fi
.PP
Since the constructor cannot provide feedback when the initialization of the painter failed you should rather use begin() and end() to paint on external devices, e.g. printers.
.PP
See also begin() and end().
.SH "QPainter::QPainter ( const QPaintDevice * pd, const QWidget * copyAttributes, bool unclipped = FALSE )"
Constructs a painter that begins painting the paint device \fIpd\fR immediately, with the default arguments taken from \fIcopyAttributes\fR. The painter will paint over children of the paint device if \fIunclipped\fR is TRUE (although this is not supported on all platforms).
.PP
See also begin().
.SH "QPainter::~QPainter ()"
Destroys the painter.
.SH "const QColor & QPainter::backgroundColor () const"
Returns the current background color.
.PP
See also setBackgroundColor() and QColor.
.SH "BGMode QPainter::backgroundMode () const"
Returns the current background mode.
.PP
See also setBackgroundMode() and BGMode.
.SH "bool QPainter::begin ( const QPaintDevice * pd, bool unclipped = FALSE )"
Begins painting the paint device \fIpd\fR and returns TRUE if successful; otherwise returns FALSE. If \fIunclipped\fR is TRUE, the painting will not be clipped at the paint device's boundaries, (although this is not supported by all platforms).
.PP
The errors that can occur are serious problems, such as these:
.PP
.nf
.br
        p->begin( 0 ); // impossible - paint device cannot be 0
.br
.br
        QPixmap pm( 0, 0 );
.br
        p->begin( pm ); // impossible - pm.isNull();
.br
.br
        p->begin( myWidget );
.br
        p2->begin( myWidget ); // impossible - only one painter at a time
.br
.fi
.PP
Note that most of the time, you can use one of the constructors instead of begin(), and that end() is automatically done at destruction.
.PP
\fBWarning:\fR A paint device can only be painted by one painter at a time.
.PP
See also end() and flush().
.PP
Examples:
.)l aclock/aclock.cpp, desktop/desktop.cpp, drawdemo/drawdemo.cpp, hello/hello.cpp, picture/picture.cpp, t10/cannon.cpp, and xform/xform.cpp.
.SH "bool QPainter::begin ( const QPaintDevice * pd, const QWidget * copyAttributes, bool unclipped = FALSE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This version opens the painter on a paint device \fIpd\fR and sets the initial pen, background color and font from \fIcopyAttributes\fR, painting over the paint device's children when \fIunclipped\fR is TRUE. This is equivalent to:
.PP
.nf
.br
        QPainter p;
.br
        p.begin( pd );
.br
        p.setPen( copyAttributes->foregroundColor() );
.br
        p.setBackgroundColor( copyAttributes->backgroundColor() );
.br
        p.setFont( copyAttributes->font() );
.br
.fi
.PP
This begin function is convenient for double buffering. When you draw in a pixmap instead of directly in a widget (to later bitBlt the pixmap into the widget) you will need to set the widget's font etc. This function does exactly that.
.PP
Example:
.PP
.nf
.br
        void MyWidget::paintEvent( QPaintEvent * )
.br
        {
.br
            QPixmap pm(size());
.br
            QPainter p;
.br
            p.begin(&pm, this);
.br
            // ... potentially flickering paint operation ...
.br
            p.end();
.br
            bitBlt(this, 0, 0, &pm);
.br
        }
.br
.fi
.PP
See also end().
.SH "QRect QPainter::boundingRect ( int x, int y, int w, int h, int flags, const QString &, int len = -1, QTextParag ** intern = 0 )"
Returns the bounding rectangle of the aligned text that would be printed with the corresponding drawText() function using the first \fIlen\fR characters of the string if \fIlen\fR is > -1, or the whole of the string if \fIlen\fR is -1. The drawing, and hence the bounding rectangle, is constrained to the rectangle that begins at point \fI(x, y)\fR with width \fIw\fR and hight \fIh\fR, or to the rectangle required to draw the text, whichever is the larger.
.PP
The \fIflags\fR argument is the bitwise OR of the following flags: <center>.nf
.TS
l - l. Flag Meaning AlignAuto aligns according to the language, usually left. AlignLeft aligns to the left border. AlignRight aligns to the right border. AlignHCenter aligns horizontally centered. AlignTop aligns to the top border. AlignBottom aligns to the bottom border. AlignVCenter aligns vertically centered. AlignCenter (== AlignHCenter | AlignVCenter). SingleLine ignores newline characters in the text. ExpandTabs expands tabs. ShowPrefix interprets "&x" as " WordBreak
.TE
.fi
</center>
.PP
Horizontal alignment defaults to AlignLeft and vertical alignment defaults to AlignTop.
.PP
If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.
.PP
The \fIintern\fR parameter should not be used.
.PP
See also Qt::TextFlags.
.SH "QRect QPainter::boundingRect ( const QRect & r, int flags, const QString & str, int len = -1, QTextParag ** internal = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the bounding rectangle of the aligned text that would be printed with the corresponding drawText() function using the first \fIlen\fR characters from \fIstr\fR if \fIlen\fR is > -1, or the whole of \fIstr\fR if \fIlen\fR is -1. The drawing, and hence the bounding rectangle, is constrained to the rectangle \fIr\fR, or to the rectangle required to draw the text, whichever is the larger.
.PP
The \fIinternal\fR parameter should not be used.
.PP
See also drawText(), fontMetrics(), QFontMetrics::boundingRect(), and Qt::TextFlags.
.SH "const QBrush & QPainter::brush () const"
Returns the painter's current brush.
.PP
See also QPainter::setBrush().
.PP
Examples:
.)l themes/metal.cpp and themes/wood.cpp.
.SH "const QPoint & QPainter::brushOrigin () const"
Returns the brush origin currently set.
.PP
See also setBrushOrigin().
.SH "QRegion QPainter::clipRegion ( CoordinateMode m = CoordDevice ) const"
Returns the currently set clip region. Note that the clip region is given in physical device coordinates and \fInot\fR subject to any coordinate transformation if \fIm\fR is equal to CoordDevice (the default). If \fIm\fR equals CoordPainter the returned region is in model coordinates.
.PP
See also setClipRegion(), setClipRect(), setClipping(), and QPainter::CoordinateMode.
.PP
Example: themes/wood.cpp.
.SH "QPaintDevice * QPainter::device () const"
Returns the paint device on which this painter is currently painting, or 0 if the painter is not active.
.PP
See also QPaintDevice::paintingActive().
.PP
Examples:
.)l action/application.cpp, application/application.cpp, helpviewer/helpwindow.cpp, listboxcombo/listboxcombo.cpp, and mdi/application.cpp.
.SH "void QPainter::drawArc ( int x, int y, int w, int h, int a, int alen )"
Draws an arc defined by the rectangle \fI(x, y, w, h)\fR, the start angle \fIa\fR and the arc length \fIalen\fR.
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.
.PP
Example:
.PP
.nf
.br
        QPainter p( myWidget );
.br
        p.drawArc( 10,10, 70,100, 100*16, 160*16 ); // draws a "(" arc
.br
.fi
.PP
See also drawPie() and drawChord().
.SH "void QPainter::drawArc ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the arc that fits inside the rectangle \fIr\fR with start angle \fIa\fR and arc length \fIalen\fR.
.SH "void QPainter::drawChord ( int x, int y, int w, int h, int a, int alen )"
Draws a chord defined by the rectangle \fI(x, y, w, h)\fR, the start angle \fIa\fR and the arc length \fIalen\fR.
.PP
The chord is filled with the current brush().
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.
.PP
See also drawArc() and drawPie().
.SH "void QPainter::drawChord ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a chord that fits inside the rectangle \fIr\fR with start angle \fIa\fR and arc length \fIalen\fR.
.SH "void QPainter::drawConvexPolygon ( const QPointArray & pa, int index = 0, int npoints = -1 )"
Draws the convex polygon defined by the \fInpoints\fR points in \fIpa\fR starting at \fIpa[index]\fR (\fIindex\fR defaults to 0).
.PP
If the supplied polygon is not convex, the results are undefined.
.PP
On some platforms (e.g. X Window), this is faster than drawPolygon().
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.PP
Example: aclock/aclock.cpp.
.SH "void QPainter::drawCubicBezier ( const QPointArray & a, int index = 0 )"
Draws a cubic Bezier curve defined by the control points in \fIa\fR, starting at \fIa[index]\fR (\fIindex\fR defaults to 0).
.PP
Control points after \fIa[index + 3]\fR are ignored. Nothing happens if there aren't enough control points.
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.SH "void QPainter::drawEllipse ( int x, int y, int w, int h )"
Draws an ellipse with center at \fI(x + w/2, y + h/2)\fR and size \fI(w, h)\fR.
.PP
Examples:
.)l drawdemo/drawdemo.cpp, multiple/ax2.h, picture/picture.cpp, and tictac/tictac.cpp.
.SH "void QPainter::drawEllipse ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the ellipse that fits inside rectangle \fIr\fR.
.SH "void QPainter::drawImage ( int x, int y, const QImage & image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, int conversionFlags = 0 )"
Draws at (\fIx\fR, \fIy\fR) the \fIsw\fR by \fIsh\fR area of pixels from (\fIsx\fR, \fIsy\fR) in \fIimage\fR, using \fIconversionFlags\fR if the image needs to be converted to a pixmap. The default value for \fIconversionFlags\fR is 0; see convertFromImage() for information about what other values do.
.PP
This function may convert \fIimage\fR to a pixmap and then draw it, if device() is a QPixmap or a QWidget, or else draw it directly, if device() is a QPrinter or QPicture.
.PP
Currently alpha masks of the image are ignored when painting on a QPrinter.
.PP
See also drawPixmap() and QPixmap::convertFromImage().
.PP
Example: canvas/canvas.cpp.
.SH "void QPainter::drawImage ( const QPoint &, const QImage &, const QRect & sr, int conversionFlags = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the rectangle \fIsr\fR from the image at the given point.
.SH "void QPainter::drawImage ( const QPoint & p, const QImage & i, int conversion_flags = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the image \fIi\fR at point \fIp\fR.
.PP
If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \fIconversion_flags\fR to specify how you'd prefer this to happen.
.PP
See also Qt::ImageConversionFlags.
.SH "void QPainter::drawImage ( const QRect & r, const QImage & i )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the image \fIi\fR into the rectangle \fIr\fR. The image will be scaled to fit the rectangle if image and rectangle dimensions differ.
.SH "void QPainter::drawLine ( int x1, int y1, int x2, int y2 )"
Draws a line from (\fIx1\fR, \fIy1\fR) to (\fIx2\fR, \fIy2\fR) and sets the current pen position to (\fIx2\fR, \fIy2\fR).
.PP
See also pen().
.PP
Examples:
.)l aclock/aclock.cpp, drawlines/connect.cpp, progress/progress.cpp, splitter/splitter.cpp, themes/metal.cpp, and themes/wood.cpp.
.SH "void QPainter::drawLine ( const QPoint & p1, const QPoint & p2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a line from point \fIp1\fR to point \fIp2\fR.
.SH "void QPainter::drawLineSegments ( const QPointArray & a, int index = 0, int nlines = -1 )"
Draws \fInlines\fR separate lines from points defined in \fIa\fR, starting at \fIa[index]\fR (\fIindex\fR defaults to 0). If \fInlines\fR is -1 (the default) all points until the end of the array are used (i.e. (a.size()-index)/2 lines are drawn).
.PP
Draws the 1st line from \fIa[index]\fR to \fIa[index+1]\fR. Draws the 2nd line from \fIa[index+2]\fR to \fIa[index+3]\fR etc.
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.PP
See also drawPolyline(), drawPolygon(), and QPen.
.SH "void QPainter::drawPicture ( int x, int y, const QPicture & pic )"
Replays the picture \fIpic\fR translated by (\fIx\fR, \fIy\fR).
.PP
This function does exactly the same as QPicture::play() when called with (\fIx\fR, \fIy\fR) = (0, 0).
.PP
Examples:
.)l picture/picture.cpp and xform/xform.cpp.
.SH "void QPainter::drawPicture ( const QPicture & pic )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Use one of the other QPainter::drawPicture() functions with a (0, 0) offset instead.
.SH "void QPainter::drawPicture ( const QPoint & p, const QPicture & pic )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws picture \fIpic\fR at point \fIp\fR.
.SH "void QPainter::drawPie ( int x, int y, int w, int h, int a, int alen )"
Draws a pie defined by the rectangle \fI(x, y, w, h)\fR, the start angle \fIa\fR and the arc length \fIalen\fR.
.PP
The pie is filled with the current brush().
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.
.PP
See also drawArc() and drawChord().
.PP
Examples:
.)l drawdemo/drawdemo.cpp, grapher/grapher.cpp, t10/cannon.cpp, and t9/cannon.cpp.
.SH "void QPainter::drawPie ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a pie segment that fits inside the rectangle \fIr\fR with start angle \fIa\fR and arc length \fIalen\fR.
.SH "void QPainter::drawPixmap ( int x, int y, const QPixmap & pixmap, int sx = 0, int sy = 0, int sw = -1, int sh = -1 )"
Draws a pixmap at \fI(x, y)\fR by copying a part of \fIpixmap\fR into the paint device.
.PP
\fI(x, y)\fR specifies the top-left point in the paint device that is to be drawn onto. \fI(sx, sy)\fR specifies the top-left point in \fIpixmap\fR that is to be drawn. The default is (0, 0).
.PP
\fI(sw, sh)\fR specifies the size of the pixmap that is to be drawn. The default, (-1, -1), means all the way to the bottom right of the pixmap.
.PP
Currently the mask of the pixmap or it's alpha channel are ignored when painting on a QPrinter.
.PP
See also bitBlt() and QPixmap::setMask().
.PP
Examples:
.)l grapher/grapher.cpp, picture/picture.cpp, qdir/qdir.cpp, qmag/qmag.cpp, showimg/showimg.cpp, t10/cannon.cpp, and xform/xform.cpp.
.SH "void QPainter::drawPixmap ( const QPoint & p, const QPixmap & pm, const QRect & sr )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the rectangle \fIsr\fR of pixmap \fIpm\fR with its origin at point \fIp\fR.
.SH "void QPainter::drawPixmap ( const QPoint & p, const QPixmap & pm )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the pixmap \fIpm\fR with its origin at point \fIp\fR.
.SH "void QPainter::drawPixmap ( const QRect & r, const QPixmap & pm )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the pixmap \fIpm\fR into the rectangle \fIr\fR. The pixmap is scaled to fit the rectangle, if image and rectangle size disagree.
.SH "void QPainter::drawPoint ( int x, int y )"
Draws/plots a single point at \fI(x, y)\fR using the current pen.
.PP
See also QPen.
.PP
Examples:
.)l desktop/desktop.cpp and drawlines/connect.cpp.
.SH "void QPainter::drawPoint ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the point \fIp\fR.
.SH "void QPainter::drawPoints ( const QPointArray & a, int index = 0, int npoints = -1 )"
Draws/plots an array of points, \fIa\fR, using the current pen.
.PP
If \fIindex\fR is non-zero (the default is zero) only points from \fIindex\fR are drawn. If \fInpoints\fR is negative (the default) the rest of the points from \fIindex\fR are drawn. If \fInpoints\fR is zero or greater, \fInpoints\fR points are drawn.
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.SH "void QPainter::drawPolygon ( const QPointArray & a, bool winding = FALSE, int index = 0, int npoints = -1 )"
Draws the polygon defined by the \fInpoints\fR points in \fIa\fR starting at \fIa[index]\fR. (\fIindex\fR defaults to 0.)
.PP
If \fInpoints\fR is -1 (the default) all points until the end of the array are used (i.e. a.size()-index line segments define the polygon).
.PP
The first point is always connected to the last point.
.PP
The polygon is filled with the current brush(). If \fIwinding\fR is TRUE, the polygon is filled using the winding fill algorithm. If \fIwinding\fR is FALSE, the polygon is filled using the even-odd (alternative) fill algorithm.
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.PP
See also drawLineSegments(), drawPolyline(), and QPen.
.PP
Examples:
.)l desktop/desktop.cpp and picture/picture.cpp.
.SH "void QPainter::drawPolyline ( const QPointArray & a, int index = 0, int npoints = -1 )"
Draws the polyline defined by the \fInpoints\fR points in \fIa\fR starting at \fIa[index]\fR. (\fIindex\fR defaults to 0.)
.PP
If \fInpoints\fR is -1 (the default) all points until the end of the array are used (i.e. a.size()-index-1 line segments are drawn).
.PP
\fBWarning:\fR On X11, coordinates that do not fit into 16-bit signed values are truncated. This limitation is expected to go away in Qt 4.
.PP
See also drawLineSegments(), drawPolygon(), and QPen.
.PP
Examples:
.)l scribble/scribble.cpp and themes/metal.cpp.
.SH "void QPainter::drawRect ( int x, int y, int w, int h )"
Draws a rectangle with upper left corner at \fI(x, y)\fR and with width \fIw\fR and height \fIh\fR.
.PP
See also QPen and drawRoundRect().
.PP
Examples:
.)l drawdemo/drawdemo.cpp, picture/picture.cpp, t10/cannon.cpp, t11/cannon.cpp, t9/cannon.cpp, tooltip/tooltip.cpp, and trivial/trivial.cpp.
.SH "void QPainter::drawRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the rectangle \fIr\fR.
.SH "void QPainter::drawRoundRect ( int x, int y, int w, int h, int xRnd = 25, int yRnd = 25 )"
Draws a rectangle with rounded corners at \fI(x, y)\fR, with width \fIw\fR and height \fIh\fR.
.PP
The \fIxRnd\fR and \fIyRnd\fR arguments specify how rounded the corners should be. 0 is angled corners, 99 is maximum roundedness.
.PP
The width and height include all of the drawn lines.
.PP
See also drawRect() and QPen.
.PP
Examples:
.)l drawdemo/drawdemo.cpp and themes/wood.cpp.
.SH "void QPainter::drawRoundRect ( const QRect & r, int xRnd = 25, int yRnd = 25 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a rounded rectangle \fIr\fR, rounding to the x position \fIxRnd\fR and the y position \fIyRnd\fR on each corner.
.SH "void QPainter::drawText ( const QPoint & p, const QString &, int pos, int len, TextDirection dir = Auto )"
Draws the text from position \fIpos\fR, at point \fIp\fR. If \fIlen\fR is -1 the entire string is drawn, otherwise just the first \fIlen\fR characters. The text's direction is specified by \fIdir\fR.
.PP
Note that the meaning of \fIy\fR is not the same for the two drawText() varieties. For overloads that take a simple \fIx\fR, \fIy\fR pair (or a point), the \fIy\fR value is the text's baseline; for overloads that take a rectangle, \fIrect.y()\fR is the top of the rectangle and the text is aligned within that rectangle in accordance with the alignment flags.
.PP
See also QPainter::TextDirection.
.PP
Examples:
.)l desktop/desktop.cpp, drawdemo/drawdemo.cpp, grapher/grapher.cpp, picture/picture.cpp, progress/progress.cpp, t8/cannon.cpp, and trivial/trivial.cpp.
.SH "void QPainter::drawText ( int x, int y, const QString &, int len = -1, TextDirection dir = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the given text at position \fIx\fR, \fIy\fR. If \fIlen\fR is -1 (the default) all the text is drawn, otherwise the first \fIlen\fR characters are drawn. The text's direction is given by \fIdir\fR.
.PP
See also QPainter::TextDirection.
.SH "void QPainter::drawText ( const QPoint &, const QString &, int len = -1, TextDirection dir = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the text at the given point.
.PP
See also QPainter::TextDirection.
.SH "void QPainter::drawText ( int x, int y, const QString &, int pos, int len, TextDirection dir = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the text from position \fIpos\fR, at point \fI(x, y)\fR. If \fIlen\fR is -1 the entire string is drawn, otherwise just the first \fIlen\fR characters. The text's direction is specified by \fIdir\fR.
.SH "void QPainter::drawText ( int x, int y, int w, int h, int flags, const QString &, int len = -1, QRect * br = 0, QTextParag ** internal = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the given text within the rectangle starting at \fIx\fR, \fIy\fR, with width \fIw\fR and height \fIh\fR. If \fIlen\fR is -1 (the default) all the text is drawn, otherwise the first \fIlen\fR characters are drawn. The text's flags that are given in the \fIflags\fR parameter are Qt::AlignmentFlags and Qt::TextFlags OR'd together. \fIbr\fR (if not null) is set to the actual bounding rectangle of the output. The \fIinternal\fR parameter is for internal use only.
.SH "void QPainter::drawText ( const QRect & r, int tf, const QString & str, int len = -1, QRect * brect = 0, QTextParag ** internal = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws at most \fIlen\fR characters from \fIstr\fR in the rectangle \fIr\fR.
.PP
This function draws formatted text. The \fItf\fR text format is really of type Qt::AlignmentFlags and Qt::TextFlags OR'd together.
.PP
Horizontal alignment defaults to AlignAuto and vertical alignment defaults to AlignTop.
.PP
\fIbrect\fR (if not null) is set to the actual bounding rectangle of the output. \fIinternal\fR is, yes, internal.
.PP
See also boundingRect().
.SH "void QPainter::drawTiledPixmap ( int x, int y, int w, int h, const QPixmap & pixmap, int sx = 0, int sy = 0 )"
Draws a tiled \fIpixmap\fR in the specified rectangle.
.PP
\fI(x, y)\fR specifies the top-left point in the paint device that is to be drawn onto; with the width and height given by \fIw\fR and \fIh\fR. \fI(sx, sy)\fR specifies the top-left point in \fIpixmap\fR that is to be drawn. The default is (0, 0).
.PP
Calling drawTiledPixmap() is similar to calling drawPixmap() several times to fill (tile) an area with a pixmap, but is potentially much more efficient depending on the underlying window system.
.PP
See also drawPixmap().
.SH "void QPainter::drawTiledPixmap ( const QRect & r, const QPixmap & pm, const QPoint & sp )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a tiled pixmap, \fIpm\fR, inside rectangle \fIr\fR with its origin at point \fIsp\fR.
.SH "void QPainter::drawTiledPixmap ( const QRect & r, const QPixmap & pm )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a tiled pixmap, \fIpm\fR, inside rectangle \fIr\fR.
.SH "void QPainter::drawWinFocusRect ( int x, int y, int w, int h, const QColor & bgColor )"
Draws a Windows focus rectangle with upper left corner at (\fIx\fR, \fIy\fR) and with width \fIw\fR and height \fIh\fR using a pen color that contrasts with \fIbgColor\fR.
.PP
This function draws a stippled rectangle (XOR is not used) that is used to indicate keyboard focus (when the QApplication::style() is \fCWindowStyle\fR).
.PP
The pen color used to draw the rectangle is either white or black depending on the color of \fIbgColor\fR (see QColor::gray()).
.PP
\fBWarning:\fR This function draws nothing if the coordinate system has been rotated or sheared.
.PP
See also drawRect() and QApplication::style().
.SH "void QPainter::drawWinFocusRect ( int x, int y, int w, int h )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a Windows focus rectangle with upper left corner at (\fIx\fR, \fIy\fR) and with width \fIw\fR and height \fIh\fR.
.PP
This function draws a stippled XOR rectangle that is used to indicate keyboard focus (when QApplication::style() is \fCWindowStyle\fR).
.PP
\fBWarning:\fR This function draws nothing if the coordinate system has been rotated or sheared.
.PP
See also drawRect() and QApplication::style().
.SH "void QPainter::drawWinFocusRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws rectangle \fIr\fR as a window focus rectangle.
.SH "void QPainter::drawWinFocusRect ( const QRect & r, const QColor & bgColor )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws rectangle \fIr\fR as a window focus rectangle using background color \fIbgColor\fR.
.SH "bool QPainter::end ()"
Ends painting. Any resources used while painting are released.
.PP
Note that while you mostly don't need to call end(), the destructor will do it, there is at least one common case when it is needed, namely double buffering.
.PP
.nf
.br
        QPainter p( myPixmap, this )
.br
        // ...
.br
        p.end(); // stops drawing on myPixmap
.br
        p.begin( this );
.br
        p.drawPixmap( 0, 0, myPixmap );
.br
.fi
.PP
Since you can't draw a QPixmap while it is being painted, it is necessary to close the active painter.
.PP
See also begin() and isActive().
.PP
Examples:
.)l aclock/aclock.cpp, desktop/desktop.cpp, hello/hello.cpp, picture/picture.cpp, scribble/scribble.cpp, t10/cannon.cpp, and xform/xform.cpp.
.SH "void QPainter::eraseRect ( int x, int y, int w, int h )"
Erases the area inside \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR. Equivalent to \fCfillRect( x, y, w, h, backgroundColor() )\fR.
.PP
Examples:
.)l listboxcombo/listboxcombo.cpp and showimg/showimg.cpp.
.SH "void QPainter::eraseRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Erases the area inside the rectangle \fIr\fR.
.SH "void QPainter::fillRect ( int x, int y, int w, int h, const QBrush & brush )"
Fills the rectangle \fI(x, y, w, h)\fR with the \fIbrush\fR.
.PP
You can specify a QColor as \fIbrush\fR, since there is a QBrush constructor that takes a QColor argument and creates a solid pattern brush.
.PP
See also drawRect().
.PP
Examples:
.)l listboxcombo/listboxcombo.cpp, multiple/ax1.h, progress/progress.cpp, qdir/qdir.cpp, qfd/fontdisplayer.cpp, themes/metal.cpp, and themes/wood.cpp.
.SH "void QPainter::fillRect ( const QRect & r, const QBrush & brush )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Fills the rectangle \fIr\fR using brush \fIbrush\fR.
.SH "void QPainter::flush ( const QRegion & region, CoordinateMode cm = CoordDevice )"
Flushes any buffered drawing operations inside the region \fIregion\fR using clipping mode \fIcm\fR.
.PP
The flush may update the whole device if the platform does not support flushing to a specified region.
.PP
See also CoordinateMode.
.SH "void QPainter::flush ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Flushes any buffered drawing operations.
.SH "const QFont & QPainter::font () const"
Returns the currently set painter font.
.PP
See also setFont() and QFont.
.PP
Example: fileiconview/qfileiconview.cpp.
.SH "QFontInfo QPainter::fontInfo () const"
Returns the font info for the painter, if the painter is active. It is not possible to obtain font information for an inactive painter, so the return value is undefined if the painter is not active.
.PP
See also fontMetrics() and isActive().
.SH "QFontMetrics QPainter::fontMetrics () const"
Returns the font metrics for the painter, if the painter is active. It is not possible to obtain metrics for an inactive painter, so the return value is undefined if the painter is not active.
.PP
See also fontInfo() and isActive().
.PP
Examples:
.)l action/application.cpp, application/application.cpp, desktop/desktop.cpp, drawdemo/drawdemo.cpp, helpviewer/helpwindow.cpp, mdi/application.cpp, and qwerty/qwerty.cpp.
.SH "HDC QPainter::handle () const"
Returns the platform-dependent handle used for drawing. Using this function is not portable.
.SH "bool QPainter::hasClipping () const"
Returns TRUE if clipping has been set; otherwise returns FALSE.
.PP
See also setClipping().
.PP
Example: themes/wood.cpp.
.SH "bool QPainter::hasViewXForm () const"
Returns TRUE if view transformation is enabled; otherwise returns FALSE.
.PP
See also setViewXForm() and xForm().
.SH "bool QPainter::hasWorldXForm () const"
Returns TRUE if world transformation is enabled; otherwise returns FALSE.
.PP
See also setWorldXForm().
.SH "bool QPainter::isActive () const"
Returns TRUE if the painter is active painting, i.e. begin() has been called and end() has not yet been called; otherwise returns FALSE.
.PP
See also QPaintDevice::paintingActive().
.PP
Examples:
.)l desktop/desktop.cpp and helpviewer/helpwindow.cpp.
.SH "void QPainter::lineTo ( int x, int y )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Use drawLine() instead.
.PP
Draws a line from the current pen position to \fI(x, y)\fR and sets \fI(x, y)\fR to be the new current pen position.
.PP
See also QPen, moveTo(), drawLine(), and pos().
.SH "void QPainter::lineTo ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws a line to the point \fIp\fR.
.SH "void QPainter::moveTo ( int x, int y )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Sets the current pen position to \fI(x, y)\fR
.PP
See also lineTo() and pos().
.SH "void QPainter::moveTo ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Moves to the point \fIp\fR.
.SH "const QPen & QPainter::pen () const"
Returns the painter's current pen.
.PP
See also setPen().
.PP
Examples:
.)l multiple/ax2.h, progress/progress.cpp, and themes/wood.cpp.
.SH "QPoint QPainter::pos () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the current position of the pen.
.PP
See also moveTo().
.SH "RasterOp QPainter::rasterOp () const"
Returns the current raster operation.
.PP
See also setRasterOp() and RasterOp.
.SH "void QPainter::redirect ( QPaintDevice * pdev, QPaintDevice * replacement )\fC [static]\fR"
Redirects all paint commands for a paint device, \fIpdev\fR, to another paint device, \fIreplacement\fR, unless \fIreplacement\fR is 0. If \fIreplacement\fR is 0, the redirection for \fIpdev\fR is removed.
.PP
In general, you'll probably find calling QPixmap::grabWidget() or QPixmap::grabWindow() is an easier solution.
.SH "void QPainter::resetXForm ()"
Resets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldMatrix(), setViewport() and setWindow().
.PP
See also worldMatrix(), viewport(), and window().
.SH "void QPainter::restore ()"
Restores the current painter state (pops a saved state off the stack).
.PP
See also save().
.PP
Example: aclock/aclock.cpp.
.SH "void QPainter::restoreWorldMatrix ()"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
We recommend using restore() instead.
.SH "void QPainter::rotate ( double a )"
Rotates the coordinate system \fIa\fR degrees counterclockwise.
.PP
See also translate(), scale(), shear(), resetXForm(), setWorldMatrix(), and xForm().
.PP
Examples:
.)l aclock/aclock.cpp, t10/cannon.cpp, and t9/cannon.cpp.
.SH "void QPainter::save ()"
Saves the current painter state (pushes the state onto a stack). A save() must be followed by a corresponding restore(). end() unwinds the stack.
.PP
See also restore().
.PP
Example: aclock/aclock.cpp.
.SH "void QPainter::saveWorldMatrix ()"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
We recommend using save() instead.
.SH "void QPainter::scale ( double sx, double sy )"
Scales the coordinate system by \fI(sx, sy)\fR.
.PP
See also translate(), shear(), rotate(), resetXForm(), setWorldMatrix(), and xForm().
.PP
Example: xform/xform.cpp.
.SH "void QPainter::setBackgroundColor ( const QColor & c )"
Sets the background color of the painter to \fIc\fR.
.PP
The background color is the color that is filled in when drawing opaque text, stippled lines and bitmaps. The background color has no effect in transparent background mode (which is the default).
.PP
See also backgroundColor(), setBackgroundMode(), and BackgroundMode.
.SH "void QPainter::setBackgroundMode ( BGMode m )"
Sets the background mode of the painter to \fIm\fR, which must be either TransparentMode (the default) or OpaqueMode.
.PP
Transparent mode draws stippled lines and text without setting the background pixels. Opaque mode fills these space with the current background color.
.PP
Note that in order to draw a bitmap or pixmap transparently, you must use QPixmap::setMask().
.PP
See also backgroundMode() and setBackgroundColor().
.PP
Example: picture/picture.cpp.
.SH "void QPainter::setBrush ( BrushStyle style )"
Sets the painter's brush to black color and the specified \fIstyle\fR.
.PP
See also brush() and QBrush.
.PP
Examples:
.)l aclock/aclock.cpp, drawdemo/drawdemo.cpp, picture/picture.cpp, t10/cannon.cpp, t9/cannon.cpp, themes/wood.cpp, and tooltip/tooltip.cpp.
.SH "void QPainter::setBrush ( const QBrush & brush )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's brush to \fIbrush\fR.
.PP
The \fIbrush\fR defines how shapes are filled.
.PP
See also brush().
.SH "void QPainter::setBrush ( const QColor & color )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's brush to have style SolidPattern and the specified \fIcolor\fR.
.PP
See also brush() and QBrush.
.SH "void QPainter::setBrushOrigin ( int x, int y )"
Sets the brush origin to \fI(x, y)\fR.
.PP
The brush origin specifies the (0, 0) coordinate of the painter's brush. This setting only applies to pattern brushes and pixmap brushes.
.PP
See also brushOrigin().
.SH "void QPainter::setBrushOrigin ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the brush origin to point \fIp\fR.
.SH "void QPainter::setClipRect ( int x, int y, int w, int h, CoordinateMode m = CoordDevice )"
Sets the clip region to the rectangle \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR and enables clipping. The clip mode is set to \fIm\fR.
.PP
If \fIm\fR is CoordDevice (the default), the coordinates given for the clip region are taken to be physical device coordinates and are \fInot\fR subject to any coordinate transformations. If \fIm\fR is CoordPainter, the coordinates given for the clip region are taken to be model coordinates.
.PP
See also setClipRegion(), clipRegion(), setClipping(), and QPainter::CoordinateMode.
.PP
Examples:
.)l grapher/grapher.cpp, progress/progress.cpp, showimg/showimg.cpp, splitter/splitter.cpp, and trivial/trivial.cpp.
.SH "void QPainter::setClipRect ( const QRect & r, CoordinateMode m = CoordDevice )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the clip region to the rectangle \fIr\fR and enables clipping. The clip mode is set to \fIm\fR.
.PP
See also CoordinateMode.
.SH "void QPainter::setClipRegion ( const QRegion & rgn, CoordinateMode m = CoordDevice )"
Sets the clip region to \fIrgn\fR and enables clipping. The clip mode is set to \fIm\fR.
.PP
Note that the clip region is given in physical device coordinates and \fInot\fR subject to any coordinate transformation.
.PP
See also setClipRect(), clipRegion(), setClipping(), and CoordinateMode.
.PP
Examples:
.)l qfd/fontdisplayer.cpp and themes/wood.cpp.
.SH "void QPainter::setClipping ( bool enable )"
Enables clipping if \fIenable\fR is TRUE, or disables clipping if \fIenable\fR is FALSE.
.PP
See also hasClipping(), setClipRect(), and setClipRegion().
.PP
Example: themes/wood.cpp.
.SH "void QPainter::setFont ( const QFont & font )"
Sets the painter's font to \fIfont\fR.
.PP
This font is used by subsequent drawText() functions. The text color is the same as the pen color.
.PP
See also font() and drawText().
.PP
Examples:
.)l drawdemo/drawdemo.cpp, grapher/grapher.cpp, hello/hello.cpp, picture/picture.cpp, qwerty/qwerty.cpp, t13/cannon.cpp, and xform/xform.cpp.
.SH "void QPainter::setPen ( const QPen & pen )"
Sets a new painter pen.
.PP
The \fIpen\fR defines how to draw lines and outlines, and it also defines the text color.
.PP
See also pen().
.PP
Examples:
.)l desktop/desktop.cpp, drawdemo/drawdemo.cpp, multiple/ax2.h, progress/progress.cpp, t9/cannon.cpp, themes/metal.cpp, and themes/wood.cpp.
.SH "void QPainter::setPen ( PenStyle style )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's pen to have style \fIstyle\fR, width 0 and black color.
.PP
See also pen() and QPen.
.SH "void QPainter::setPen ( const QColor & color )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's pen to have style SolidLine, width 0 and the specified \fIcolor\fR.
.PP
See also pen() and QPen.
.SH "void QPainter::setRasterOp ( RasterOp r )"
Sets the raster operation to \fIr\fR. The default is CopyROP.
.PP
See also rasterOp() and Qt::RasterOp.
.SH "void QPainter::setTabArray ( int * ta )"
Sets the tab stop array to \fIta\fR. This puts tab stops at \fIta[0]\fR, \fIta[1]\fR and so on. The array is null-terminated.
.PP
If both a tab array and a tab top size is set, the tab array wins.
.PP
See also tabArray(), setTabStops(), drawText(), and fontMetrics().
.SH "void QPainter::setTabStops ( int ts )"
Set the tab stop width to \fIts\fR, i.e. locates tab stops at \fIts\fR, 2*\fIts\fR, 3*\fIts\fR and so on.
.PP
Tab stops are used when drawing formatted text with ExpandTabs set. This fixed tab stop value is used only if no tab array is set (which is the default case).
.PP
A value of 0 (the default) implies a tabstop setting of 8 times the width of the character 'x' in the font currently set on the painter.
.PP
See also tabStops(), setTabArray(), drawText(), and fontMetrics().
.SH "void QPainter::setViewXForm ( bool enable )"
Enables view transformations if \fIenable\fR is TRUE, or disables view transformations if \fIenable\fR is FALSE.
.PP
See also hasViewXForm(), setWindow(), setViewport(), setWorldMatrix(), setWorldXForm(), and xForm().
.SH "void QPainter::setViewport ( int x, int y, int w, int h )"
Sets the viewport rectangle view transformation for the painter and enables view transformation.
.PP
The viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system and is specified by the \fIx\fR, \fIy\fR, \fIw\fR width and \fIh\fR height parameters. Its sister, the window(), specifies the logical coordinate system.
.PP
The default viewport rectangle is the same as the device's rectangle. See the Coordinate System Overview for an overview of coordinate transformation.
.PP
See also viewport(), setWindow(), setViewXForm(), setWorldMatrix(), setWorldXForm(), and xForm().
.PP
Example: aclock/aclock.cpp.
.SH "void QPainter::setViewport ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's viewport to rectangle \fIr\fR.
.SH "void QPainter::setWindow ( int x, int y, int w, int h )"
Sets the window rectangle view transformation for the painter and enables view transformation.
.PP
The window rectangle is part of the view transformation. The window specifies the logical coordinate system and is specified by the \fIx\fR, \fIy\fR, \fIw\fR width and \fIh\fR height parameters. Its sister, the viewport(), specifies the device coordinate system.
.PP
The default window rectangle is the same as the device's rectangle. See the Coordinate System Overview for an overview of coordinate transformation.
.PP
See also window(), setViewport(), setViewXForm(), setWorldMatrix(), and setWorldXForm().
.PP
Examples:
.)l aclock/aclock.cpp and drawdemo/drawdemo.cpp.
.SH "void QPainter::setWindow ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the painter's window to rectangle \fIr\fR.
.SH "void QPainter::setWorldMatrix ( const QWMatrix & m, bool combine = FALSE )"
Sets the world transformation matrix to \fIm\fR and enables world transformation.
.PP
If \fIcombine\fR is TRUE, then \fIm\fR is combined with the current transformation matrix, otherwise \fIm\fR replaces the current transformation matrix.
.PP
If \fIm\fR is the identity matrix and \fIcombine\fR is FALSE, this function calls setWorldXForm(FALSE). (The identity matrix is the matrix where QWMatrix::m11() and QWMatrix::m22() are 1.0 and the rest are 0.0.)
.PP
World transformations are applied after the view transformations (i.e. window and viewport).
.PP
The following functions can transform the coordinate system without using a QWMatrix:
.TP
translate()
.TP
scale()
.TP
shear()
.TP
rotate()
.PP
They operate on the painter's worldMatrix() and are implemented like this:
.PP
.nf
.br
        void QPainter::rotate( double a )
.br
        {
.br
            QWMatrix m;
.br
            m.rotate( a );
.br
            setWorldMatrix( m, TRUE );
.br
        }
.br
.fi
.PP
Note that you should always use \fIcombine\fR when you are drawing into a QPicture. Otherwise it may not be possible to replay the picture with additional transformations. Using translate(), scale(), etc., is safe.
.PP
For a brief overview of coordinate transformation, see the Coordinate System Overview.
.PP
See also worldMatrix(), setWorldXForm(), setWindow(), setViewport(), setViewXForm(), xForm(), and QWMatrix.
.PP
Examples:
.)l drawdemo/drawdemo.cpp and xform/xform.cpp.
.SH "void QPainter::setWorldXForm ( bool enable )"
Enables world transformations if \fIenable\fR is TRUE, or disables world transformations if \fIenable\fR is FALSE. The world transformation matrix is not changed.
.PP
See also setWorldMatrix(), setWindow(), setViewport(), setViewXForm(), and xForm().
.SH "void QPainter::shear ( double sh, double sv )"
Shears the coordinate system by \fI(sh, sv)\fR.
.PP
See also translate(), scale(), rotate(), resetXForm(), setWorldMatrix(), and xForm().
.SH "int * QPainter::tabArray () const"
Returns the currently set tab stop array.
.PP
See also setTabArray().
.SH "int QPainter::tabStops () const"
Returns the tab stop setting.
.PP
See also setTabStops().
.SH "void QPainter::translate ( double dx, double dy )"
Translates the coordinate system by \fI(dx, dy)\fR. After this call, \fI(dx, dy)\fR is added to points.
.PP
For example, the following code draws the same point twice:
.PP
.nf
.br
        void MyWidget::paintEvent()
.br
        {
.br
            QPainter paint( this );
.br
.br
            paint.drawPoint( 0, 0 );
.br
.br
            paint.translate( 100.0, 40.0 );
.br
            paint.drawPoint( -100, -40 );
.br
        }
.br
.fi
.PP
See also scale(), shear(), rotate(), resetXForm(), setWorldMatrix(), and xForm().
.PP
Examples:
.)l action/application.cpp, application/application.cpp, t10/cannon.cpp, t9/cannon.cpp, themes/metal.cpp, themes/wood.cpp, and xform/xform.cpp.
.SH "QRect QPainter::viewport () const"
Returns the viewport rectangle.
.PP
See also setViewport() and setViewXForm().
.PP
Example: aclock/aclock.cpp.
.SH "QRect QPainter::window () const"
Returns the window rectangle.
.PP
See also setWindow() and setViewXForm().
.SH "const QWMatrix & QPainter::worldMatrix () const"
Returns the world transformation matrix.
.PP
See also setWorldMatrix().
.SH "QPoint QPainter::xForm ( const QPoint & pv ) const"
Returns the point \fIpv\fR transformed from model coordinates to device coordinates.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QRect QPainter::xForm ( const QRect & rv ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the rectangle \fIrv\fR transformed from model coordinates to device coordinates.
.PP
If world transformation is enabled and rotation or shearing has been specified, then the bounding rectangle is returned.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QPointArray QPainter::xForm ( const QPointArray & av ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point array \fIav\fR transformed from model coordinates to device coordinates.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QPointArray QPainter::xForm ( const QPointArray & av, int index, int npoints ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point array \fIav\fR transformed from model coordinates to device coordinates. The \fIindex\fR is the first point in the array and \fInpoints\fR denotes the number of points to be transformed. If \fInpoints\fR is negative, all points from \fIav[index]\fR until the last point in the array are transformed.
.PP
The returned point array consists of the number of points that were transformed.
.PP
Example:
.PP
.nf
.br
        QPointArray a(10);
.br
        QPointArray b;
.br
        b = painter.xForm(a, 2, 4);  // b.size() == 4
.br
        b = painter.xForm(a, 2, -1); // b.size() == 8
.br
.fi
.PP
See also xFormDev() and QWMatrix::map().
.SH "QRect QPainter::xFormDev ( const QRect & rd ) const"
Returns the rectangle \fIrd\fR transformed from device coordinates to model coordinates.
.PP
If world transformation is enabled and rotation or shearing is used, then the bounding rectangle is returned.
.PP
See also xForm() and QWMatrix::map().
.SH "QPoint QPainter::xFormDev ( const QPoint & pd ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point \fIpd\fR transformed from device coordinates to model coordinates.
.PP
See also xForm() and QWMatrix::map().
.SH "QPointArray QPainter::xFormDev ( const QPointArray & ad ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point array \fIad\fR transformed from device coordinates to model coordinates.
.PP
See also xForm() and QWMatrix::map().
.SH "QPointArray QPainter::xFormDev ( const QPointArray & ad, int index, int npoints ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point array \fIad\fR transformed from device coordinates to model coordinates. The \fIindex\fR is the first point in the array and \fInpoints\fR denotes the number of points to be transformed. If \fInpoints\fR is negative, all points from \fIad[index]\fR until the last point in the array are transformed.
.PP
The returned point array consists of the number of points that were transformed.
.PP
Example:
.PP
.nf
.br
        QPointArray a(10);
.br
        QPointArray b;
.br
        b = painter.xFormDev(a, 1, 3);  // b.size() == 3
.br
        b = painter.xFormDev(a, 1, -1); // b.size() == 9
.br
.fi
.PP
See also xForm() and QWMatrix::map().
.SH RELATED FUNCTION DOCUMENTATION
.SH "void qDrawPlainRect ( QPainter * p, int x, int y, int w, int h, const QColor & c, int lineWidth, const QBrush * fill )"
\fC#include <qdrawutil.h>\fR
.PP
Draws the plain rectangle specified by (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) using the painter \fIp\fR.
.PP
The color argument \fIc\fR specifies the line color.
.PP
The \fIlineWidth\fR argument specifies the line width.
.PP
The rectangle's interior is filled with the \fIfill\fR brush unless \fIfill\fR is 0.
.PP
If you want to use a QFrame widget instead, you can make it display a plain rectangle, for example \fCQFrame::setFrameStyle( QFrame::Box | QFrame::Plain )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeRect() and QStyle::drawPrimitive().
.SH "void qDrawShadeLine ( QPainter * p, int x1, int y1, int x2, int y2, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth )"
\fC#include <qdrawutil.h>\fR
.PP
Draws a horizontal (\fIy1\fR == \fIy2\fR) or vertical (\fIx1\fR == \fIx2\fR) shaded line using the painter \fIp\fR.
.PP
Nothing is drawn if \fIy1\fR != \fIy2\fR and \fIx1\fR != \fIx2\fR (i.e. the line is neither horizontal nor vertical).
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The line appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width for each of the lines. It is not the total line width.
.PP
The \fImidLineWidth\fR argument specifies the width of a middle line drawn in the QColorGroup::mid() color.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded line, for example \fCQFrame::setFrameStyle( QFrame::HLine | QFrame::Sunken )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeRect(), qDrawShadePanel(), and QStyle::drawPrimitive().
.SH "void qDrawShadePanel ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, const QBrush * fill )"
\fC#include <qdrawutil.h>\fR
.PP
Draws the shaded panel specified by (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) using the painter \fIp\fR.
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The panel appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width.
.PP
The panel's interior is filled with the \fIfill\fR brush unless \fIfill\fR is 0.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded panel, for example \fCQFrame::setFrameStyle( QFrame::Panel | QFrame::Sunken )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect(), and QStyle::drawPrimitive().
.SH "void qDrawShadeRect ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth, const QBrush * fill )"
\fC#include <qdrawutil.h>\fR
.PP
Draws the shaded rectangle specified by (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) using the painter \fIp\fR.
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The rectangle appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width for each of the lines. It is not the total line width.
.PP
The \fImidLineWidth\fR argument specifies the width of a middle line drawn in the QColorGroup::mid() color.
.PP
The rectangle's interior is filled with the \fIfill\fR brush unless \fIfill\fR is 0.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded rectangle, for example \fCQFrame::setFrameStyle( QFrame::Box | QFrame::Raised )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), QStyle::drawItem(), QStyle::drawControl(), and QStyle::drawComplexControl().
.SH "void qDrawWinButton ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill )"
\fC#include <qdrawutil.h>\fR
.PP
Draws the Windows-style button specified by (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) using the painter \fIp\fR.
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The button appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The line width is 2 pixels.
.PP
The button's interior is filled with the \fI*fill\fR brush unless \fIfill\fR is 0.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawWinPanel() and QStyle::drawControl().
.SH "void qDrawWinPanel ( QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill )"
\fC#include <qdrawutil.h>\fR
.PP
Draws the Windows-style panel specified by (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) using the painter \fIp\fR.
.PP
The color group argument \fIg\fR specifies the shading colors.
.PP
The panel appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The line width is 2 pixels.
.PP
The button's interior is filled with the \fIfill\fR brush unless \fIfill\fR is 0.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded panel, for example \fCQFrame::setFrameStyle( QFrame::WinPanel | QFrame::Raised )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadePanel(), qDrawWinButton(), and QStyle::drawPrimitive().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qpainter.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qpainter.3qt) and the Qt
version (3.3.8).
