'\" t
.TH QImage 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QImage \- Hardware-independent pixmap representation with direct access to the pixel data
.SH SYNOPSIS
\fC#include <qimage.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBEndian\fR { IgnoreEndian, BigEndian, LittleEndian }"
.br
.ti -1c
.BI "\fBQImage\fR ()"
.br
.ti -1c
.BI "\fBQImage\fR ( int w, int h, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
.br
.ti -1c
.BI "\fBQImage\fR ( const QSize & size, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
.br
.ti -1c
.BI "\fBQImage\fR ( const QString & fileName, const char * format = 0 )"
.br
.ti -1c
.BI "\fBQImage\fR ( const char * const xpm[] )"
.br
.ti -1c
.BI "\fBQImage\fR ( const QByteArray & array )"
.br
.ti -1c
.BI "\fBQImage\fR ( uchar * yourdata, int w, int h, int depth, QRgb * colortable, int numColors, Endian bitOrder )"
.br
.ti -1c
.BI "\fBQImage\fR ( uchar * yourdata, int w, int h, int depth, int bpl, QRgb * colortable, int numColors, Endian bitOrder )"
.br
.ti -1c
.BI "\fBQImage\fR ( const QImage & image )"
.br
.ti -1c
.BI "\fB~QImage\fR ()"
.br
.ti -1c
.BI "QImage & \fBoperator=\fR ( const QImage & image )"
.br
.ti -1c
.BI "QImage & \fBoperator=\fR ( const QPixmap & pixmap )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QImage & i ) const"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QImage & i ) const"
.br
.ti -1c
.BI "void \fBdetach\fR ()"
.br
.ti -1c
.BI "QImage \fBcopy\fR () const"
.br
.ti -1c
.BI "QImage \fBcopy\fR ( int x, int y, int w, int h, int conversion_flags = 0 ) const"
.br
.ti -1c
.BI "QImage \fBcopy\fR ( const QRect & r ) const"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "int \fBwidth\fR () const"
.br
.ti -1c
.BI "int \fBheight\fR () const"
.br
.ti -1c
.BI "QSize \fBsize\fR () const"
.br
.ti -1c
.BI "QRect \fBrect\fR () const"
.br
.ti -1c
.BI "int \fBdepth\fR () const"
.br
.ti -1c
.BI "int \fBnumColors\fR () const"
.br
.ti -1c
.BI "Endian \fBbitOrder\fR () const"
.br
.ti -1c
.BI "QRgb \fBcolor\fR ( int i ) const"
.br
.ti -1c
.BI "void \fBsetColor\fR ( int i, QRgb c )"
.br
.ti -1c
.BI "void \fBsetNumColors\fR ( int numColors )"
.br
.ti -1c
.BI "bool \fBhasAlphaBuffer\fR () const"
.br
.ti -1c
.BI "void \fBsetAlphaBuffer\fR ( bool enable )"
.br
.ti -1c
.BI "bool \fBallGray\fR () const"
.br
.ti -1c
.BI "bool \fBisGrayscale\fR () const"
.br
.ti -1c
.BI "uchar * \fBbits\fR () const"
.br
.ti -1c
.BI "uchar * \fBscanLine\fR ( int i ) const"
.br
.ti -1c
.BI "uchar ** \fBjumpTable\fR () const"
.br
.ti -1c
.BI "QRgb * \fBcolorTable\fR () const"
.br
.ti -1c
.BI "int \fBnumBytes\fR () const"
.br
.ti -1c
.BI "int \fBbytesPerLine\fR () const"
.br
.ti -1c
.BI "bool \fBcreate\fR ( int width, int height, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
.br
.ti -1c
.BI "bool \fBcreate\fR ( const QSize &, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
.br
.ti -1c
.BI "void \fBreset\fR ()"
.br
.ti -1c
.BI "void \fBfill\fR ( uint pixel )"
.br
.ti -1c
.BI "void \fBinvertPixels\fR ( bool invertAlpha = TRUE )"
.br
.ti -1c
.BI "QImage \fBconvertDepth\fR ( int depth ) const"
.br
.ti -1c
.BI "QImage \fBconvertDepthWithPalette\fR ( int d, QRgb * palette, int palette_count, int conversion_flags = 0 ) const"
.br
.ti -1c
.BI "QImage \fBconvertDepth\fR ( int depth, int conversion_flags ) const"
.br
.ti -1c
.BI "QImage \fBconvertBitOrder\fR ( Endian bitOrder ) const"
.br
.ti -1c
.BI "enum \fBScaleMode\fR { ScaleFree, ScaleMin, ScaleMax }"
.br
.ti -1c
.BI "QImage \fBsmoothScale\fR ( int w, int h, ScaleMode mode = ScaleFree ) const"
.br
.ti -1c
.BI "QImage \fBsmoothScale\fR ( const QSize & s, ScaleMode mode = ScaleFree ) const"
.br
.ti -1c
.BI "QImage \fBscale\fR ( int w, int h, ScaleMode mode = ScaleFree ) const"
.br
.ti -1c
.BI "QImage \fBscale\fR ( const QSize & s, ScaleMode mode = ScaleFree ) const"
.br
.ti -1c
.BI "QImage \fBscaleWidth\fR ( int w ) const"
.br
.ti -1c
.BI "QImage \fBscaleHeight\fR ( int h ) const"
.br
.ti -1c
.BI "QImage \fBxForm\fR ( const QWMatrix & matrix ) const"
.br
.ti -1c
.BI "QImage \fBcreateAlphaMask\fR ( int conversion_flags = 0 ) const"
.br
.ti -1c
.BI "QImage \fBcreateHeuristicMask\fR ( bool clipTight = TRUE ) const"
.br
.ti -1c
.BI "QImage \fBmirror\fR () const"
.br
.ti -1c
.BI "QImage \fBmirror\fR ( bool horizontal, bool vertical ) const"
.br
.ti -1c
.BI "QImage \fBswapRGB\fR () const"
.br
.ti -1c
.BI "bool \fBload\fR ( const QString & fileName, const char * format = 0 )"
.br
.ti -1c
.BI "bool \fBloadFromData\fR ( const uchar * buf, uint len, const char * format = 0 )"
.br
.ti -1c
.BI "bool \fBloadFromData\fR ( QByteArray buf, const char * format = 0 )"
.br
.ti -1c
.BI "bool \fBsave\fR ( const QString & fileName, const char * format, int quality = -1 ) const"
.br
.ti -1c
.BI "bool \fBsave\fR ( QIODevice * device, const char * format, int quality = -1 ) const"
.br
.ti -1c
.BI "bool \fBvalid\fR ( int x, int y ) const"
.br
.ti -1c
.BI "int \fBpixelIndex\fR ( int x, int y ) const"
.br
.ti -1c
.BI "QRgb \fBpixel\fR ( int x, int y ) const"
.br
.ti -1c
.BI "void \fBsetPixel\fR ( int x, int y, uint index_or_rgb )"
.br
.ti -1c
.BI "int \fBdotsPerMeterX\fR () const"
.br
.ti -1c
.BI "int \fBdotsPerMeterY\fR () const"
.br
.ti -1c
.BI "void \fBsetDotsPerMeterX\fR ( int x )"
.br
.ti -1c
.BI "void \fBsetDotsPerMeterY\fR ( int y )"
.br
.ti -1c
.BI "QPoint \fBoffset\fR () const"
.br
.ti -1c
.BI "void \fBsetOffset\fR ( const QPoint & p )"
.br
.ti -1c
.BI "QValueList<QImageTextKeyLang> \fBtextList\fR () const"
.br
.ti -1c
.BI "QStringList \fBtextLanguages\fR () const"
.br
.ti -1c
.BI "QStringList \fBtextKeys\fR () const"
.br
.ti -1c
.BI "QString \fBtext\fR ( const char * key, const char * lang = 0 ) const"
.br
.ti -1c
.BI "QString \fBtext\fR ( const QImageTextKeyLang & kl ) const"
.br
.ti -1c
.BI "void \fBsetText\fR ( const char * key, const char * lang, const QString & s )"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QImage \fBfromMimeSource\fR ( const QString & abs_name )"
.br
.ti -1c
.BI "Endian \fBsystemBitOrder\fR ()"
.br
.ti -1c
.BI "Endian \fBsystemByteOrder\fR ()"
.br
.ti -1c
.BI "const char * \fBimageFormat\fR ( const QString & fileName )"
.br
.ti -1c
.BI "QStrList \fBinputFormats\fR ()"
.br
.ti -1c
.BI "QStrList \fBoutputFormats\fR ()"
.br
.ti -1c
.BI "QStringList \fBinputFormatList\fR ()"
.br
.ti -1c
.BI "QStringList \fBoutputFormatList\fR ()"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QImage & image )"
.br
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QImage & image )"
.br
.ti -1c
.BI "void \fBbitBlt\fR ( QImage * dst, int dx, int dy, const QImage * src, int sx, int sy, int sw, int sh, int conversion_flags )"
.br
.in -1c
.SH DESCRIPTION
The QImage class provides a hardware-independent pixmap representation with direct access to the pixel data.
.PP
It is one of the two classes Qt provides for dealing with images, the other being QPixmap. QImage is designed and optimized for I/O and for direct pixel access/manipulation. QPixmap is designed and optimized for drawing. There are (slow) functions to convert between QImage and QPixmap: QPixmap::convertToImage() and QPixmap::convertFromImage().
.PP
An image has the parameters width, height and depth (bits per pixel, bpp), a color table and the actual pixels. QImage supports 1-bpp, 8-bpp and 32-bpp image data. 1-bpp and 8-bpp images use a color lookup table; the pixel value is a color table index.
.PP
32-bpp images encode an RGB value in 24 bits and ignore the color table. The most significant byte is used for the alpha buffer.
.PP
An entry in the color table is an RGB triplet encoded as a \fCuint\fR. Use the qRed(), qGreen() and qBlue() functions (qcolor.h) to access the components, and qRgb to make an RGB triplet (see the QColor class documentation).
.PP
1-bpp (monochrome) images have a color table with a most two colors. There are two different formats: big endian (MSB first) or little endian (LSB first) bit order. To access a single bit you will must do some bit shifts:
.PP
.nf
.br
    QImage image;
.br
    // sets bit at (x,y) to 1
.br
    if ( image.bitOrder() == QImage::LittleEndian )
.br
        *(image.scanLine(y) + (x >> 3)) |= 1 << (x & 7);
.br
    else
.br
        *(image.scanLine(y) + (x >> 3)) |= 1 << (7 - (x & 7));
.br
.fi
.PP
If this looks complicated, it might be a good idea to convert the 1-bpp image to an 8-bpp image using convertDepth().
.PP
8-bpp images are much easier to work with than 1-bpp images because they have a single byte per pixel:
.PP
.nf
.br
    QImage image;
.br
    // set entry 19 in the color table to yellow
.br
    image.setColor( 19, qRgb(255,255,0) );
.br
    // set 8 bit pixel at (x,y) to value yellow (in color table)
.br
    *(image.scanLine(y) + x) = 19;
.br
.fi
.PP
32-bpp images ignore the color table; instead, each pixel contains the RGB triplet. 24 bits contain the RGB value; the most significant byte is reserved for the alpha buffer.
.PP
.nf
.br
    QImage image;
.br
    // sets 32 bit pixel at (x,y) to yellow.
.br
    uint *p = (uint *)image.scanLine(y) + x;
.br
    *p = qRgb(255,255,0);
.br
.fi
.PP
On Qt/Embedded, scanlines are aligned to the pixel depth and may be padded to any degree, while on all other platforms, the scanlines are 32-bit aligned for all depths. The constructor taking a \fCuchar*\fR argument always expects 32-bit aligned data. On Qt/Embedded, an additional constructor allows the number of bytes-per-line to be specified.
.PP
QImage supports a variety of methods for getting information about the image, for example, colorTable(), allGray(), isGrayscale(), bitOrder(), bytesPerLine(), depth(), dotsPerMeterX() and dotsPerMeterY(), hasAlphaBuffer(), numBytes(), numColors(), and width() and height().
.PP
Pixel colors are retrieved with pixel() and set with setPixel().
.PP
QImage also supports a number of functions for creating a new image that is a transformed version of the original. For example, copy(), convertBitOrder(), convertDepth(), createAlphaMask(), createHeuristicMask(), mirror(), scale(), smoothScale(), swapRGB() and xForm(). There are also functions for changing attributes of an image in-place, for example, setAlphaBuffer(), setColor(), setDotsPerMeterX() and setDotsPerMeterY() and setNumColors().
.PP
Images can be loaded and saved in the supported formats. Images are saved to a file with save(). Images are loaded from a file with load() (or in the constructor) or from an array of data with loadFromData(). The lists of supported formats are available from inputFormatList() and outputFormatList().
.PP
Strings of text may be added to images using setText().
.PP
The QImage class uses explicit sharing, similar to that used by QMemArray.
.PP
New image formats can be added as plugins.
.PP
See also QImageIO, QPixmap, Shared Classes, Graphics Classes, Image Processing Classes, and Implicitly and Explicitly Shared Classes.
.SS "Member Type Documentation"
.SH "QImage::Endian"
This enum type is used to describe the endianness of the CPU and graphics hardware.
.TP
\fCQImage::IgnoreEndian\fR - Endianness does not matter. Useful for some operations that are independent of endianness.
.TP
\fCQImage::BigEndian\fR - Network byte order, as on SPARC and Motorola CPUs.
.TP
\fCQImage::LittleEndian\fR - PC/Alpha byte order.
.SH "QImage::ScaleMode"
The functions scale() and smoothScale() use different modes for scaling the image. The purpose of these modes is to retain the ratio of the image if this is required.
.PP
<center>
.ce 1
.B "[Image Omitted]"
.PP
</center> 
.TP
\fCQImage::ScaleFree\fR - The image is scaled freely: the resulting image fits exactly into the specified size; the ratio will not necessarily be preserved.
.TP
\fCQImage::ScaleMin\fR - The ratio of the image is preserved and the resulting image is guaranteed to fit into the specified size (it is as large as possible within these constraints) - the image might be smaller than the requested size.
.TP
\fCQImage::ScaleMax\fR - The ratio of the image is preserved and the resulting image fills the whole specified rectangle (it is as small as possible within these constraints) - the image might be larger than the requested size.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QImage::QImage ()"
Constructs a null image.
.PP
See also isNull().
.SH "QImage::QImage ( int w, int h, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
Constructs an image with \fIw\fR width, \fIh\fR height, \fIdepth\fR bits per pixel, \fInumColors\fR colors and bit order \fIbitOrder\fR.
.PP
Using this constructor is the same as first constructing a null image and then calling the create() function.
.PP
See also create().
.SH "QImage::QImage ( const QSize & size, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
Constructs an image with size \fIsize\fR pixels, depth \fIdepth\fR bits, \fInumColors\fR and \fIbitOrder\fR endianness.
.PP
Using this constructor is the same as first constructing a null image and then calling the create() function.
.PP
See also create().
.SH "QImage::QImage ( const QString & fileName, const char * format = 0 )"
Constructs an image and tries to load the image from the file \fIfileName\fR.
.PP
If \fIformat\fR is specified, the loader attempts to read the image using the specified format. If \fIformat\fR is not specified (which is the default), the loader reads a few bytes from the header to guess the file format.
.PP
If the loading of the image failed, this object is a null image.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also load(), isNull(), and QImageIO.
.SH "QImage::QImage ( const char * const xpm[] )"
Constructs an image from \fIxpm\fR, which must be a valid XPM image.
.PP
Errors are silently ignored.
.PP
Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:
.PP
.nf
.br
        static const char * const start_xpm[]={
.br
            "16 15 8 1",
.br
            "a c #cec6bd",
.br
        ....
.br
.fi
.PP
The extra \fCconst\fR makes the entire definition read-only, which is slightly more efficient (e.g. when the code is in a shared library) and ROMable when the application is to be stored in ROM.
.SH "QImage::QImage ( const QByteArray & array )"
Constructs an image from the binary data \fIarray\fR. It tries to guess the file format.
.PP
If the loading of the image failed, this object is a null image.
.PP
See also loadFromData(), isNull(), and imageFormat().
.SH "QImage::QImage ( uchar * yourdata, int w, int h, int depth, QRgb * colortable, int numColors, Endian bitOrder )"
Constructs an image \fIw\fR pixels wide, \fIh\fR pixels high with a color depth of \fIdepth\fR, that uses an existing memory buffer, \fIyourdata\fR. The buffer must remain valid throughout the life of the QImage. The image does not delete the buffer at destruction.
.PP
If \fIcolortable\fR is 0, a color table sufficient for \fInumColors\fR will be allocated (and destructed later).
.PP
Note that \fIyourdata\fR must be 32-bit aligned.
.PP
The endianness is given in \fIbitOrder\fR.
.SH "QImage::QImage ( uchar * yourdata, int w, int h, int depth, int bpl, QRgb * colortable, int numColors, Endian bitOrder )"
Constructs an image that uses an existing memory buffer. The buffer must remain valid for the life of the QImage. The image does not delete the buffer at destruction. The buffer is passed as \fIyourdata\fR. The image's width is \fIw\fR and its height is \fIh\fR. The color depth is \fIdepth\fR. \fIbpl\fR specifies the number of bytes per line.
.PP
If \fIcolortable\fR is 0, a color table sufficient for \fInumColors\fR will be allocated (and destructed later).
.PP
The endianness is specified by \fIbitOrder\fR.
.PP
\fBWarning:\fR This constructor is only available on Qt/Embedded.
.SH "QImage::QImage ( const QImage & image )"
Constructs a shallow copy of \fIimage\fR.
.SH "QImage::~QImage ()"
Destroys the image and cleans up.
.SH "bool QImage::allGray () const"
Returns TRUE if all the colors in the image are shades of gray (i.e. their red, green and blue components are equal); otherwise returns FALSE.
.PP
This function is slow for large 16-bit (Qt/Embedded only) and 32-bit images.
.PP
See also isGrayscale().
.SH "Endian QImage::bitOrder () const"
Returns the bit order for the image.
.PP
If it is a 1-bpp image, this function returns either QImage::BigEndian or QImage::LittleEndian.
.PP
If it is not a 1-bpp image, this function returns QImage::IgnoreEndian.
.PP
See also depth().
.SH "uchar * QImage::bits () const"
Returns a pointer to the first pixel data. This is equivalent to scanLine(0).
.PP
See also numBytes(), scanLine(), and jumpTable().
.PP
Example: opengl/texture/gltexobj.cpp.
.SH "int QImage::bytesPerLine () const"
Returns the number of bytes per image scanline. This is equivalent to numBytes()/height().
.PP
See also numBytes() and scanLine().
.SH "QRgb QImage::color ( int i ) const"
Returns the color in the color table at index \fIi\fR. The first color is at index 0.
.PP
A color value is an RGB triplet. Use the qRed(), qGreen() and qBlue() functions (defined in qcolor.h) to get the color value components.
.PP
See also setColor(), numColors(), and QColor.
.PP
Example: themes/wood.cpp.
.SH "QRgb * QImage::colorTable () const"
Returns a pointer to the color table.
.PP
See also numColors().
.SH "QImage QImage::convertBitOrder ( Endian bitOrder ) const"
Converts the bit order of the image to \fIbitOrder\fR and returns the converted image. The original image is not changed.
.PP
Returns \fC*this\fR if the \fIbitOrder\fR is equal to the image bit order, or a null image if this image cannot be converted.
.PP
See also bitOrder(), systemBitOrder(), and isNull().
.SH "QImage QImage::convertDepth ( int depth, int conversion_flags ) const"
Converts the depth (bpp) of the image to \fIdepth\fR and returns the converted image. The original image is not changed.
.PP
The \fIdepth\fR argument must be 1, 8, 16 (Qt/Embedded only) or 32.
.PP
Returns \fC*this\fR if \fIdepth\fR is equal to the image depth, or a null image if this image cannot be converted.
.PP
If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \fIconversion_flags\fR to specify how you'd prefer this to happen.
.PP
See also Qt::ImageConversionFlags, depth(), and isNull().
.SH "QImage QImage::convertDepth ( int depth ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QImage QImage::convertDepthWithPalette ( int d, QRgb * palette, int palette_count, int conversion_flags = 0 ) const"
Returns an image with depth \fId\fR, using the \fIpalette_count\fR colors pointed to by \fIpalette\fR. If \fId\fR is 1 or 8, the returned image will have its color table ordered the same as \fIpalette\fR.
.PP
If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \fIconversion_flags\fR to specify how you'd prefer this to happen.
.PP
Note: currently no closest-color search is made. If colors are found that are not in the palette, the palette may not be used at all. This result should not be considered valid because it may change in future implementations.
.PP
Currently inefficient for non-32-bit images.
.PP
See also Qt::ImageConversionFlags.
.SH "QImage QImage::copy () const"
Returns a deep copy of the image.
.PP
See also detach().
.SH "QImage QImage::copy ( int x, int y, int w, int h, int conversion_flags = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a deep copy of a sub-area of the image.
.PP
The returned image is always \fIw\fR by \fIh\fR pixels in size, and is copied from position \fIx\fR, \fIy\fR in this image. In areas beyond this image pixels are filled with pixel 0.
.PP
If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \fIconversion_flags\fR to specify how you'd prefer this to happen.
.PP
See also bitBlt() and Qt::ImageConversionFlags.
.SH "QImage QImage::copy ( const QRect & r ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a deep copy of a sub-area of the image.
.PP
The returned image always has the size of the rectangle \fIr\fR. In areas beyond this image pixels are filled with pixel 0.
.SH "bool QImage::create ( int width, int height, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
Sets the image \fIwidth\fR, \fIheight\fR, \fIdepth\fR, its number of colors (in \fInumColors\fR), and bit order. Returns TRUE if successful, or FALSE if the parameters are incorrect or if memory cannot be allocated.
.PP
The \fIwidth\fR and \fIheight\fR is limited to 32767. \fIdepth\fR must be 1, 8, or 32. If \fIdepth\fR is 1, \fIbitOrder\fR must be set to either QImage::LittleEndian or QImage::BigEndian. For other depths \fIbitOrder\fR must be QImage::IgnoreEndian.
.PP
This function allocates a color table and a buffer for the image data. The image data is not initialized.
.PP
The image buffer is allocated as a single block that consists of a table of scanline pointers (jumpTable()) and the image data (bits()).
.PP
See also fill(), width(), height(), depth(), numColors(), bitOrder(), jumpTable(), scanLine(), bits(), bytesPerLine(), and numBytes().
.SH "bool QImage::create ( const QSize &, int depth, int numColors = 0, Endian bitOrder = IgnoreEndian )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QImage QImage::createAlphaMask ( int conversion_flags = 0 ) const"
Builds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if alpha buffer mode is disabled.
.PP
See QPixmap::convertFromImage() for a description of the \fIconversion_flags\fR argument.
.PP
The returned image has little-endian bit order, which you can convert to big-endianness using convertBitOrder().
.PP
See also createHeuristicMask(), hasAlphaBuffer(), and setAlphaBuffer().
.SH "QImage QImage::createHeuristicMask ( bool clipTight = TRUE ) const"
Creates and returns a 1-bpp heuristic mask for this image. It works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.
.PP
The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.
.PP
The returned image has little-endian bit order, which you can convert to big-endianness using convertBitOrder().
.PP
If \fIclipTight\fR is TRUE the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.
.PP
This function disregards the alpha buffer.
.PP
See also createAlphaMask().
.SH "int QImage::depth () const"
Returns the depth of the image.
.PP
The image depth is the number of bits used to encode a single pixel, also called bits per pixel (bpp) or bit planes of an image.
.PP
The supported depths are 1, 8, 16 (Qt/Embedded only) and 32.
.PP
See also convertDepth().
.SH "void QImage::detach ()"
Detaches from shared image data and makes sure that this image is the only one referring to the data.
.PP
If multiple images share common data, this image makes a copy of the data and detaches itself from the sharing mechanism. Nothing is done if there is just a single reference.
.PP
See also copy().
.PP
Example: themes/wood.cpp.
.SH "int QImage::dotsPerMeterX () const"
Returns the number of pixels that fit horizontally in a physical meter. This and dotsPerMeterY() define the intended scale and aspect ratio of the image.
.PP
See also setDotsPerMeterX().
.SH "int QImage::dotsPerMeterY () const"
Returns the number of pixels that fit vertically in a physical meter. This and dotsPerMeterX() define the intended scale and aspect ratio of the image.
.PP
See also setDotsPerMeterY().
.SH "void QImage::fill ( uint pixel )"
Fills the entire image with the pixel value \fIpixel\fR.
.PP
If the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2), etc., the image is filled with 0s. If you say fill(1), fill(3), etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used.
.PP
If the depth is 32 and the image has no alpha buffer, the \fIpixel\fR value is written to each pixel in the image. If the image has an alpha buffer, only the 24 RGB bits are set and the upper 8 bits (alpha value) are left unchanged.
.PP
Note: QImage::pixel() returns the color of the pixel at the given coordinates; QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use QImage::pixel() to use a color from an existing image or QColor::rgb() to use a specific color.
.PP
See also invertPixels(), depth(), hasAlphaBuffer(), and create().
.SH "QImage QImage::fromMimeSource ( const QString & abs_name )\fC [static]\fR"
Convenience function. Gets the data associated with the absolute name \fIabs_name\fR from the default mime source factory and decodes it to an image.
.PP
See also QMimeSourceFactory, QImage::fromMimeSource(), and QImageDrag::decode().
.SH "bool QImage::hasAlphaBuffer () const"
Returns TRUE if alpha buffer mode is enabled; otherwise returns FALSE.
.PP
See also setAlphaBuffer().
.SH "int QImage::height () const"
Returns the height of the image.
.PP
See also width(), size(), and rect().
.PP
Examples:
.)l canvas/canvas.cpp and opengl/texture/gltexobj.cpp.
.SH "const char * QImage::imageFormat ( const QString & fileName )\fC [static]\fR"
Returns a string that specifies the image format of the file \fIfileName\fR, or 0 if the file cannot be read or if the format is not recognized.
.PP
The QImageIO documentation lists the guaranteed supported image formats, or use QImage::inputFormats() and QImage::outputFormats() to get lists that include the installed formats.
.PP
See also load() and save().
.SH "QStringList QImage::inputFormatList ()\fC [static]\fR"
Returns a list of image formats that are supported for image input.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myImage.inputFormatList();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also outputFormatList(), inputFormats(), and QImageIO.
.PP
Example: showimg/showimg.cpp.
.SH "QStrList QImage::inputFormats ()\fC [static]\fR"
Returns a list of image formats that are supported for image input.
.PP
See also outputFormats(), inputFormatList(), and QImageIO.
.SH "void QImage::invertPixels ( bool invertAlpha = TRUE )"
Inverts all pixel values in the image.
.PP
If the depth is 32: if \fIinvertAlpha\fR is TRUE, the alpha bits are also inverted, otherwise they are left unchanged.
.PP
If the depth is not 32, the argument \fIinvertAlpha\fR has no meaning.
.PP
Note that inverting an 8-bit image means to replace all pixels using color index \fIi\fR with a pixel using color index 255 minus \fIi\fR. Similarly for a 1-bit image. The color table is not changed.
.PP
See also fill(), depth(), and hasAlphaBuffer().
.SH "bool QImage::isGrayscale () const"
For 16-bit (Qt/Embedded only) and 32-bit images, this function is equivalent to allGray().
.PP
For 8-bpp images, this function returns TRUE if color(i) is QRgb(i,i,i) for all indices of the color table; otherwise returns FALSE.
.PP
See also allGray() and depth().
.SH "bool QImage::isNull () const"
Returns TRUE if it is a null image; otherwise returns FALSE.
.PP
A null image has all parameters set to zero and no allocated data.
.PP
Example: showimg/showimg.cpp.
.SH "uchar ** QImage::jumpTable () const"
Returns a pointer to the scanline pointer table.
.PP
This is the beginning of the data block for the image.
.PP
See also bits() and scanLine().
.SH "bool QImage::load ( const QString & fileName, const char * format = 0 )"
Loads an image from the file \fIfileName\fR. Returns TRUE if the image was successfully loaded; otherwise returns FALSE.
.PP
If \fIformat\fR is specified, the loader attempts to read the image using the specified format. If \fIformat\fR is not specified (which is the default), the loader reads a few bytes from the header to guess the file format.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also loadFromData(), save(), imageFormat(), QPixmap::load(), and QImageIO.
.SH "bool QImage::loadFromData ( const uchar * buf, uint len, const char * format = 0 )"
Loads an image from the first \fIlen\fR bytes of binary data in \fIbuf\fR. Returns TRUE if the image was successfully loaded; otherwise returns FALSE.
.PP
If \fIformat\fR is specified, the loader attempts to read the image using the specified format. If \fIformat\fR is not specified (which is the default), the loader reads a few bytes from the header to guess the file format.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also load(), save(), imageFormat(), QPixmap::loadFromData(), and QImageIO.
.SH "bool QImage::loadFromData ( QByteArray buf, const char * format = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Loads an image from the QByteArray \fIbuf\fR.
.SH "QImage QImage::mirror () const"
Returns a QImage which is a vertically mirrored copy of this image. The original QImage is not changed.
.SH "QImage QImage::mirror ( bool horizontal, bool vertical ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a mirror of the image, mirrored in the horizontal and/or the vertical direction depending on whether \fIhorizontal\fR and \fIvertical\fR are set to TRUE or FALSE. The original image is not changed.
.PP
See also smoothScale().
.SH "int QImage::numBytes () const"
Returns the number of bytes occupied by the image data.
.PP
See also bytesPerLine() and bits().
.SH "int QImage::numColors () const"
Returns the size of the color table for the image.
.PP
Notice that numColors() returns 0 for 16-bpp (Qt/Embedded only) and 32-bpp images because these images do not use color tables, but instead encode pixel values as RGB triplets.
.PP
See also setNumColors() and colorTable().
.PP
Example: themes/wood.cpp.
.SH "QPoint QImage::offset () const"
Returns the number of pixels by which the image is intended to be offset by when positioning relative to other images.
.SH "bool QImage::operator!= ( const QImage & i ) const"
Returns TRUE if this image and image \fIi\fR have different contents; otherwise returns FALSE. The comparison can be slow, unless there is some obvious difference, such as different widths, in which case the function will return quickly.
.PP
See also operator=().
.SH "QImage & QImage::operator= ( const QImage & image )"
Assigns a shallow copy of \fIimage\fR to this image and returns a reference to this image.
.PP
See also copy().
.SH "QImage & QImage::operator= ( const QPixmap & pixmap )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the image bits to the \fIpixmap\fR contents and returns a reference to the image.
.PP
If the image shares data with other images, it will first dereference the shared data.
.PP
Makes a call to QPixmap::convertToImage().
.SH "bool QImage::operator== ( const QImage & i ) const"
Returns TRUE if this image and image \fIi\fR have the same contents; otherwise returns FALSE. The comparison can be slow, unless there is some obvious difference, such as different widths, in which case the function will return quickly.
.PP
See also operator=().
.SH "QStringList QImage::outputFormatList ()\fC [static]\fR"
Returns a list of image formats that are supported for image output.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myImage.outputFormatList();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also inputFormatList(), outputFormats(), and QImageIO.
.SH "QStrList QImage::outputFormats ()\fC [static]\fR"
Returns a list of image formats that are supported for image output.
.PP
See also inputFormats(), outputFormatList(), and QImageIO.
.PP
Example: showimg/showimg.cpp.
.SH "QRgb QImage::pixel ( int x, int y ) const"
Returns the color of the pixel at the coordinates (\fIx\fR, \fIy\fR).
.PP
If (\fIx\fR, \fIy\fR) is not on the image, the results are undefined.
.PP
See also setPixel(), qRed(), qGreen(), qBlue(), and valid().
.PP
Examples:
.)l canvas/canvas.cpp and qmag/qmag.cpp.
.SH "int QImage::pixelIndex ( int x, int y ) const"
Returns the pixel index at the given coordinates.
.PP
If (\fIx\fR, \fIy\fR) is not valid, or if the image is not a paletted image (depth() > 8), the results are undefined.
.PP
See also valid() and depth().
.SH "QRect QImage::rect () const"
Returns the enclosing rectangle (0, 0, width(), height()) of the image.
.PP
See also width(), height(), and size().
.SH "void QImage::reset ()"
Resets all image parameters and deallocates the image data.
.SH "bool QImage::save ( const QString & fileName, const char * format, int quality = -1 ) const"
Saves the image to the file \fIfileName\fR, using the image file format \fIformat\fR and a quality factor of \fIquality\fR. \fIquality\fR must be in the range 0..100 or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 (the default) to use the default settings.
.PP
Returns TRUE if the image was successfully saved; otherwise returns FALSE.
.PP
See also load(), loadFromData(), imageFormat(), QPixmap::save(), and QImageIO.
.SH "bool QImage::save ( QIODevice * device, const char * format, int quality = -1 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function writes a QImage to the QIODevice, \fIdevice\fR. This can be used, for example, to save an image directly into a QByteArray:
.PP
.nf
.br
    QImage image;
.br
    QByteArray ba;
.br
    QBuffer buffer( ba );
.br
    buffer.open( IO_WriteOnly );
.br
    image.save( &buffer, "PNG" ); // writes image into ba in PNG format
.br
.fi
.SH "QImage QImage::scale ( int w, int h, ScaleMode mode = ScaleFree ) const"
Returns a copy of the image scaled to a rectangle of width \fIw\fR and height \fIh\fR according to the ScaleMode \fImode\fR.
.TP
If \fImode\fR is ScaleFree, the image is scaled to (\fIw\fR, \fIh\fR).
.TP
If \fImode\fR is ScaleMin, the image is scaled to a rectangle as large as possible inside (\fIw\fR, \fIh\fR), preserving the aspect ratio.
.TP
If \fImode\fR is ScaleMax, the image is scaled to a rectangle as small as possible outside (\fIw\fR, \fIh\fR), preserving the aspect ratio.
.PP
If either the width \fIw\fR or the height \fIh\fR is 0 or negative, this function returns a null image.
.PP
This function uses a simple, fast algorithm. If you need better quality, use smoothScale() instead.
.PP
See also scaleWidth(), scaleHeight(), smoothScale(), and xForm().
.SH "QImage QImage::scale ( const QSize & s, ScaleMode mode = ScaleFree ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
The requested size of the image is \fIs\fR.
.SH "QImage QImage::scaleHeight ( int h ) const"
Returns a scaled copy of the image. The returned image has a height of \fIh\fR pixels. This function automatically calculates the width of the image so that the ratio of the image is preserved.
.PP
If \fIh\fR is 0 or negative a null image is returned.
.PP
See also scale(), scaleWidth(), smoothScale(), and xForm().
.PP
Example: table/small-table-demo/main.cpp.
.SH "QImage QImage::scaleWidth ( int w ) const"
Returns a scaled copy of the image. The returned image has a width of \fIw\fR pixels. This function automatically calculates the height of the image so that the ratio of the image is preserved.
.PP
If \fIw\fR is 0 or negative a null image is returned.
.PP
See also scale(), scaleHeight(), smoothScale(), and xForm().
.SH "uchar * QImage::scanLine ( int i ) const"
Returns a pointer to the pixel data at the scanline with index \fIi\fR. The first scanline is at index 0.
.PP
The scanline data is aligned on a 32-bit boundary.
.PP
\fBWarning:\fR If you are accessing 32-bpp image data, cast the returned pointer to \fCQRgb*\fR (QRgb has a 32-bit size) and use it to read/write the pixel value. You cannot use the \fCuchar*\fR pointer directly, because the pixel format depends on the byte order on the underlying platform. Hint: use qRed(), qGreen() and qBlue(), etc. (qcolor.h) to access the pixels.
.PP
\fBWarning:\fR If you are accessing 16-bpp image data, you must handle endianness yourself. (Qt/Embedded only)
.PP
See also bytesPerLine(), bits(), and jumpTable().
.PP
Example: desktop/desktop.cpp.
.SH "void QImage::setAlphaBuffer ( bool enable )"
Enables alpha buffer mode if \fIenable\fR is TRUE, otherwise disables it. The default setting is disabled.
.PP
An 8-bpp image has 8-bit pixels. A pixel is an index into the color table, which contains 32-bit color values. In a 32-bpp image, the 32-bit pixels are the color values.
.PP
This 32-bit value is encoded as follows: The lower 24 bits are used for the red, green, and blue components. The upper 8 bits contain the alpha component.
.PP
The alpha component specifies the transparency of a pixel. 0 means completely transparent and 255 means opaque. The alpha component is ignored if you do not enable alpha buffer mode.
.PP
The alpha buffer is used to set a mask when a QImage is translated to a QPixmap.
.PP
See also hasAlphaBuffer() and createAlphaMask().
.SH "void QImage::setColor ( int i, QRgb c )"
Sets a color in the color table at index \fIi\fR to \fIc\fR.
.PP
A color value is an RGB triplet. Use the qRgb() function (defined in qcolor.h) to make RGB triplets.
.PP
See also color(), setNumColors(), and numColors().
.PP
Examples:
.)l desktop/desktop.cpp and themes/wood.cpp.
.SH "void QImage::setDotsPerMeterX ( int x )"
Sets the value returned by dotsPerMeterX() to \fIx\fR.
.SH "void QImage::setDotsPerMeterY ( int y )"
Sets the value returned by dotsPerMeterY() to \fIy\fR.
.SH "void QImage::setNumColors ( int numColors )"
Resizes the color table to \fInumColors\fR colors.
.PP
If the color table is expanded all the extra colors will be set to black (RGB 0,0,0).
.PP
See also numColors(), color(), setColor(), and colorTable().
.SH "void QImage::setOffset ( const QPoint & p )"
Sets the value returned by offset() to \fIp\fR.
.SH "void QImage::setPixel ( int x, int y, uint index_or_rgb )"
Sets the pixel index or color at the coordinates (\fIx\fR, \fIy\fR) to \fIindex_or_rgb\fR.
.PP
If (\fIx\fR, \fIy\fR) is not valid, the result is undefined.
.PP
If the image is a paletted image (depth() <= 8) and \fIindex_or_rgb\fR >= numColors(), the result is undefined.
.PP
See also pixelIndex(), pixel(), qRgb(), qRgba(), and valid().
.SH "void QImage::setText ( const char * key, const char * lang, const QString & s )"
Records string \fIs\fR for the keyword \fIkey\fR. The \fIkey\fR should be a portable keyword recognizable by other software - some suggested values can be found in the PNG specification. \fIs\fR can be any text. \fIlang\fR should specify the language code (see RFC 1766) or 0.
.SH "QSize QImage::size () const"
Returns the size of the image, i.e. its width and height.
.PP
See also width(), height(), and rect().
.SH "QImage QImage::smoothScale ( int w, int h, ScaleMode mode = ScaleFree ) const"
Returns a smoothly scaled copy of the image. The returned image has a size of width \fIw\fR by height \fIh\fR pixels if \fImode\fR is ScaleFree. The modes ScaleMin and ScaleMax may be used to preserve the ratio of the image: if \fImode\fR is ScaleMin, the returned image is guaranteed to fit into the rectangle specified by \fIw\fR and \fIh\fR (it is as large as possible within the constraints); if \fImode\fR is ScaleMax, the returned image fits at least into the specified rectangle (it is a small as possible within the constraints).
.PP
For 32-bpp images and 1-bpp/8-bpp color images the result will be 32-bpp, whereas all-gray images (including black-and-white 1-bpp) will produce 8-bit grayscale images with the palette spanning 256 grays from black to white.
.PP
This function uses code based on pnmscale.c by Jef Poskanzer.
.PP
pnmscale.c - read a portable anymap and scale it
.PP
Copyright (C) 1989, 1991 by Jef Poskanzer.
.PP
Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. This software is provided "as is" without express or implied warranty.
.PP
See also scale() and mirror().
.SH "QImage QImage::smoothScale ( const QSize & s, ScaleMode mode = ScaleFree ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
The requested size of the image is \fIs\fR.
.SH "QImage QImage::swapRGB () const"
Returns a QImage in which the values of the red and blue components of all pixels have been swapped, effectively converting an RGB image to a BGR image. The original QImage is not changed.
.SH "Endian QImage::systemBitOrder ()\fC [static]\fR"
Determines the bit order of the display hardware. Returns QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
.PP
See also systemByteOrder().
.SH "Endian QImage::systemByteOrder ()\fC [static]\fR"
Determines the host computer byte order. Returns QImage::LittleEndian (LSB first) or QImage::BigEndian (MSB first).
.PP
See also systemBitOrder().
.SH "QString QImage::text ( const char * key, const char * lang = 0 ) const"
Returns the string recorded for the keyword \fIkey\fR in language \fIlang\fR, or in a default language if \fIlang\fR is 0.
.SH "QString QImage::text ( const QImageTextKeyLang & kl ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the string recorded for the keyword and language \fIkl\fR.
.SH "QStringList QImage::textKeys () const"
Returns the keywords for which some texts are recorded.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myImage.textKeys();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also textList(), text(), setText(), and textLanguages().
.SH "QStringList QImage::textLanguages () const"
Returns the language identifiers for which some texts are recorded.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = myImage.textLanguages();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See also textList(), text(), setText(), and textKeys().
.SH "QValueList<QImageTextKeyLang> QImage::textList () const"
Returns a list of QImageTextKeyLang objects that enumerate all the texts key/language pairs set by setText() for this image.
.PP
Note that if you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QValueList<QImageTextKeyLang> list = myImage.textList();
.br
    QValueList<QImageTextKeyLang>::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.SH "bool QImage::valid ( int x, int y ) const"
Returns TRUE if ( \fIx\fR, \fIy\fR ) is a valid coordinate in the image; otherwise returns FALSE.
.PP
See also width(), height(), and pixelIndex().
.PP
Examples:
.)l canvas/canvas.cpp and qmag/qmag.cpp.
.SH "int QImage::width () const"
Returns the width of the image.
.PP
See also height(), size(), and rect().
.PP
Examples:
.)l canvas/canvas.cpp and opengl/texture/gltexobj.cpp.
.SH "QImage QImage::xForm ( const QWMatrix & matrix ) const"
Returns a copy of the image that is transformed using the transformation matrix, \fImatrix\fR.
.PP
The transformation \fImatrix\fR is internally adjusted to compensate for unwanted translation, i.e. xForm() returns the smallest image that contains all the transformed points of the original image.
.PP
See also scale(), QPixmap::xForm(), QPixmap::trueMatrix(), and QWMatrix.
.SH RELATED FUNCTION DOCUMENTATION
.SH "void bitBlt ( QImage * dst, int dx, int dy, const QImage * src, int sx, int sy, int sw, int sh, int conversion_flags )"
Copies a block of pixels from \fIsrc\fR to \fIdst\fR. The pixels copied from source (src) are converted according to \fIconversion_flags\fR if it is incompatible with the destination (\fIdst\fR).
.PP
\fIsx\fR, \fIsy\fR is the top-left pixel in \fIsrc\fR, \fIdx\fR, \fIdy\fR is the top-left position in \fIdst\fR and \fIsw\fR, \\sh is the size of the copied block.
.PP
The copying is clipped if areas outside \fIsrc\fR or \fIdst\fR are specified.
.PP
If \fIsw\fR is -1, it is adjusted to src->width(). Similarly, if \fIsh\fR is -1, it is adjusted to src->height().
.PP
Currently inefficient for non 32-bit images.
.SH "QDataStream & operator<< ( QDataStream & s, const QImage & image )"
Writes the image \fIimage\fR to the stream \fIs\fR as a PNG image, or as a BMP image if the stream's version is 1.
.PP
Note that writing the stream to a file will not produce a valid image file.
.PP
See also QImage::save() and Format of the QDataStream operators.
.SH "QDataStream & operator>> ( QDataStream & s, QImage & image )"
Reads an image from the stream \fIs\fR and stores it in \fIimage\fR.
.PP
See also QImage::load() and Format of the QDataStream operators.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qimage.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qimage.3qt) and the Qt
version (3.3.8).
