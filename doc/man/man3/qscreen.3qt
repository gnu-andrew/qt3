'\" t
.TH QScreen 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QScreen \- And its descendants manage the framebuffer and palette
.SH SYNOPSIS
\fC#include <qgfx_qws.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQScreen\fR ( int display_id )"
.br
.ti -1c
.BI "virtual \fB~QScreen\fR ()"
.br
.ti -1c
.BI "virtual bool \fBinitDevice\fR () = 0"
.br
.ti -1c
.BI "virtual bool \fBconnect\fR ( const QString & displaySpec ) = 0"
.br
.ti -1c
.BI "virtual void \fBdisconnect\fR () = 0"
.br
.ti -1c
.BI "virtual int \fBinitCursor\fR ( void * end_of_location, bool init = FALSE )"
.br
.ti -1c
.BI "virtual void \fBshutdownDevice\fR ()"
.br
.ti -1c
.BI "virtual void \fBsetMode\fR ( int, int, int ) = 0"
.br
.ti -1c
.BI "virtual bool \fBsupportsDepth\fR ( int d ) const"
.br
.ti -1c
.BI "virtual QGfx * \fBcreateGfx\fR ( unsigned char * bytes, int w, int h, int d, int linestep )"
.br
.ti -1c
.BI "virtual QGfx * \fBscreenGfx\fR ()"
.br
.ti -1c
.BI "virtual void \fBsave\fR ()"
.br
.ti -1c
.BI "virtual void \fBrestore\fR ()"
.br
.ti -1c
.BI "virtual void \fBblank\fR ( bool on )"
.br
.ti -1c
.BI "virtual int \fBpixmapOffsetAlignment\fR ()"
.br
.ti -1c
.BI "virtual int \fBpixmapLinestepAlignment\fR ()"
.br
.ti -1c
.BI "virtual bool \fBonCard\fR ( unsigned char * p ) const"
.br
.ti -1c
.BI "virtual bool \fBonCard\fR ( unsigned char * p, ulong & offset ) const"
.br
.ti -1c
.BI "virtual void \fBset\fR ( unsigned " "int" ", unsigned " "int" ", unsigned " "int" ", unsigned int )"
.br
.ti -1c
.BI "virtual int \fBalloc\fR ( unsigned int r, unsigned int g, unsigned int b )"
.br
.ti -1c
.BI "int \fBwidth\fR () const"
.br
.ti -1c
.BI "int \fBheight\fR () const"
.br
.ti -1c
.BI "int \fBdepth\fR () const"
.br
.ti -1c
.BI "virtual int \fBpixmapDepth\fR () const"
.br
.ti -1c
.BI "int \fBpixelType\fR () const"
.br
.ti -1c
.BI "int \fBlinestep\fR () const"
.br
.ti -1c
.BI "int \fBdeviceWidth\fR () const"
.br
.ti -1c
.BI "int \fBdeviceHeight\fR () const"
.br
.ti -1c
.BI "uchar * \fBbase\fR () const"
.br
.ti -1c
.BI "virtual uchar * \fBcache\fR ( int, int )"
.br
.ti -1c
.BI "virtual void \fBuncache\fR ( uchar * )"
.br
.ti -1c
.BI "int \fBscreenSize\fR () const"
.br
.ti -1c
.BI "int \fBtotalSize\fR () const"
.br
.ti -1c
.BI "QRgb * \fBclut\fR ()"
.br
.ti -1c
.BI "int \fBnumCols\fR ()"
.br
.ti -1c
.BI "virtual QSize \fBmapToDevice\fR ( const QSize & s ) const"
.br
.ti -1c
.BI "virtual QSize \fBmapFromDevice\fR ( const QSize & s ) const"
.br
.ti -1c
.BI "virtual QPoint \fBmapToDevice\fR ( const QPoint &, const QSize & ) const"
.br
.ti -1c
.BI "virtual QPoint \fBmapFromDevice\fR ( const QPoint &, const QSize & ) const"
.br
.ti -1c
.BI "virtual QRect \fBmapToDevice\fR ( const QRect & r, const QSize & ) const"
.br
.ti -1c
.BI "virtual QRect \fBmapFromDevice\fR ( const QRect & r, const QSize & ) const"
.br
.ti -1c
.BI "virtual QImage \fBmapToDevice\fR ( const QImage & i ) const"
.br
.ti -1c
.BI "virtual QImage \fBmapFromDevice\fR ( const QImage & i ) const"
.br
.ti -1c
.BI "virtual QRegion \fBmapToDevice\fR ( const QRegion & r, const QSize & ) const"
.br
.ti -1c
.BI "virtual QRegion \fBmapFromDevice\fR ( const QRegion & r, const QSize & ) const"
.br
.ti -1c
.BI "virtual int \fBtransformOrientation\fR () const"
.br
.ti -1c
.BI "virtual bool \fBisTransformed\fR () const"
.br
.ti -1c
.BI "virtual bool \fBisInterlaced\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetDirty\fR ( const QRect & )"
.br
.ti -1c
.BI "int * \fBopType\fR ()"
.br
.ti -1c
.BI "int * \fBlastOp\fR ()"
.br
.in -1c
.SH DESCRIPTION
The QScreen class and its descendants manage the framebuffer and palette.
.PP
QScreens act as factories for the screen cursor and QGfx's. QLinuxFbScreen manages a Linux framebuffer; accelerated drivers subclass QLinuxFbScreen. There can only be one screen in a Qt/Embedded application.
.PP
See also Qt/Embedded.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QScreen::QScreen ( int display_id )"
Create a screen; the \fIdisplay_id\fR is the number of the Qt/Embedded server to connect to.
.SH "QScreen::~QScreen ()\fC [virtual]\fR"
Destroys a QScreen
.SH "int QScreen::alloc ( unsigned int r, unsigned int g, unsigned int b )\fC [virtual]\fR"
Given an RGB value \fIr\fR \fIg\fR \fIb\fR, return an index which is the closest match to it in the screen's palette. Used in paletted modes only.
.SH "uchar * QScreen::base () const"
Returns a pointer to the start of the framebuffer.
.SH "void QScreen::blank ( bool on )\fC [virtual]\fR"
If \fIon\fR is true, blank the screen. Otherwise unblank it.
.SH "uchar * QScreen::cache ( int, int )\fC [virtual]\fR"
This function is used to store pixmaps in graphics memory for the use of the accelerated drivers. See QLinuxFbScreen (where the cacheing is implemented) for more information.
.SH "QRgb * QScreen::clut ()"
Returns the screen's color lookup table (color palette). This is only valid in paletted modes (8bpp and lower).
.SH "bool QScreen::connect ( const QString & displaySpec )\fC [pure virtual]\fR"
This function is called by every Qt/Embedded application on startup. It maps in the framebuffer and in the accelerated drivers the graphics card control registers. \fIdisplaySpec\fR has the following syntax:
.PP
\fC[gfx driver][:driver specific options][:display number]\fR
.PP
for example if you want to use the mach64 driver on fb1 as display 2:
.PP
\fCMach64:/dev/fb1:2\fR
.PP
\fIdisplaySpec\fR is passed in via the QWS_DISPLAY environment variable or the -display command line parameter.
.SH "QGfx * QScreen::createGfx ( unsigned char * bytes, int w, int h, int d, int linestep )\fC [virtual]\fR"
Creates a gfx on an arbitrary buffer \fIbytes\fR, width \fIw\fR and height \fIh\fR in pixels, depth \fId\fR and \fIlinestep\fR (length in bytes of each line in the buffer). Accelerated drivers can check to see if \fIbytes\fR points into graphics memory and create an accelerated Gfx.
.SH "int QScreen::depth () const"
Gives the depth in bits per pixel of the framebuffer. This is the number of bits each pixel takes up rather than the number of significant bits, so 24bpp and 32bpp express the same range of colors (8 bits of red, green and blue)
.SH "int QScreen::deviceHeight () const"
Gives the full height of the framebuffer device, as opposed to the height which Qt/Embedded will actually use. These can differ if the display is centered within the framebuffer.
.SH "int QScreen::deviceWidth () const"
Gives the full width of the framebuffer device, as opposed to the width which Qt/Embedded will actually use. These can differ if the display is centered within the framebuffer.
.SH "void QScreen::disconnect ()\fC [pure virtual]\fR"
This function is called by every Qt/Embedded application just before exitting; it's normally used to unmap the framebuffer.
.SH "int QScreen::height () const"
Gives the height in pixels of the framebuffer.
.SH "int QScreen::initCursor ( void * end_of_location, bool init = FALSE )\fC [virtual]\fR"
This is used to initialize the software cursor - \fIend_of_location\fR points to the address after the area where the cursor image can be stored. \fIinit\fR is true for the first application this method is called from (the Qt/Embedded server), false otherwise.
.SH "bool QScreen::initDevice ()\fC [pure virtual]\fR"
This function is called by the Qt/Embedded server when initializing the framebuffer. Accelerated drivers use it to set up the graphics card.
.SH "bool QScreen::isInterlaced () const\fC [virtual]\fR"
Returns TRUE if the display is interlaced (for instance a television screen); otherwise returns FALSE. If TRUE, drawing is altered to look better on such displays.
.SH "bool QScreen::isTransformed () const\fC [virtual]\fR"
Returns TRUE if the screen is transformed (for instance, rotated 90 degrees); otherwise returns FALSE. QScreen's version always returns FALSE.
.SH "int * QScreen::lastOp ()"
Returns the screens last operation.
.SH "int QScreen::linestep () const"
Returns the length in bytes of each scanline of the framebuffer.
.SH "QSize QScreen::mapFromDevice ( const QSize & s ) const\fC [virtual]\fR"
Map a framebuffer coordinate to the coordinate space used by the application. Used by the rotated driver; the QScreen implementation simply returns \fIs\fR.
.SH "QPoint QScreen::mapFromDevice ( const QPoint &, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Map a framebuffer coordinate to the coordinate space used by the application. Used by the rotated driver; the QScreen implementation simply returns the point.
.SH "QRect QScreen::mapFromDevice ( const QRect & r, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Map a framebuffer coordinate to the coordinate space used by the application. Used by the rotated driver; the QScreen implementation simply returns \fIr\fR.
.SH "QImage QScreen::mapFromDevice ( const QImage & i ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Transforms an image so that it matches the application coordinate space (e.g. rotating it 90 degrees counter-clockwise). The QScreen implementation simply returns \fIi\fR.
.SH "QRegion QScreen::mapFromDevice ( const QRegion & r, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Transforms a region so that it matches the application coordinate space (e.g. rotating it 90 degrees counter-clockwise). The QScreen implementation simply returns \fIr\fR.
.SH "QSize QScreen::mapToDevice ( const QSize & s ) const\fC [virtual]\fR"
Map a user coordinate to the one to actually draw. Used by the rotated driver; the QScreen implementation simply returns \fIs\fR.
.SH "QPoint QScreen::mapToDevice ( const QPoint &, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Map a user coordinate to the one to actually draw. Used by the rotated driver; the QScreen implementation simply returns the point passed in.
.SH "QRect QScreen::mapToDevice ( const QRect & r, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Map a user coordinate to the one to actually draw. Used by the rotated driver; the QScreen implementation simply returns \fIr\fR.
.SH "QImage QScreen::mapToDevice ( const QImage & i ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Transforms an image so that it fits the device coordinate space (e.g. rotating it 90 degrees clockwise). The QScreen implementation simply returns \fIi\fR.
.SH "QRegion QScreen::mapToDevice ( const QRegion & r, const QSize & ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Transforms a region so that it fits the device coordinate space (e.g. rotating it 90 degrees clockwise). The QScreen implementation simply returns \fIr\fR.
.SH "int QScreen::numCols ()"
Returns the number of entries in the color table returned by clut().
.SH "bool QScreen::onCard ( unsigned char * p ) const\fC [virtual]\fR"
Returns true if the buffer pointed to by \fIp\fR is within graphics card memory, false if it's in main RAM.
.SH "bool QScreen::onCard ( unsigned char * p, ulong & offset ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This checks whether the buffer specified by \fIp\fR is on the card (as per the other version of onCard) and returns an offset in bytes from the start of graphics card memory in \fIoffset\fR if it is.
.SH "int * QScreen::opType ()"
Returns the screen's operation type.
.SH "int QScreen::pixelType () const"
Returns an integer (taking the same values as QGfx::PixelType) that specifies the pixel storage format of the screen.
.SH "int QScreen::pixmapDepth () const\fC [virtual]\fR"
Gives the preferred depth for pixmaps. By default this is the same as the screen depth, but for the VGA16 driver it's 8bpp.
.SH "int QScreen::pixmapLinestepAlignment ()\fC [virtual]\fR"
Returns the value in bits to which individual scanlines of pixmaps held in graphics card memory should be aligned. This is only useful for accelerated drivers. By default the value returned is 64 but it can be overridden by individual accelerated drivers.
.SH "int QScreen::pixmapOffsetAlignment ()\fC [virtual]\fR"
Returns the value in bits to which the start address of pixmaps held in graphics card memory should be aligned. This is only useful for accelerated drivers. By default the value returned is 64 but it can be overridden by individual accelerated drivers.
.SH "void QScreen::restore ()\fC [virtual]\fR"
Restores the state of the graphics card from a previous save()
.SH "void QScreen::save ()\fC [virtual]\fR"
Saves the state of the graphics card - used so that, for instance, the palette can be restored when switching between linux virtual consoles. Hardware QScreen descendants should save register state here if necessary if switching between virtual consoles (for example to/from X) is to be permitted.
.SH "QGfx * QScreen::screenGfx ()\fC [virtual]\fR"
Returns a QGfx (normally a QGfxRaster) initialized to point to the screen, with an origin at 0,0 and a clip region covering the whole screen.
.SH "int QScreen::screenSize () const"
Returns the size in bytes of the screen. This is always located at the beginning of framebuffer memory (i.e. at base()).
.SH "void QScreen::set ( unsigned int, unsigned int, unsigned int, unsigned int )\fC [virtual]\fR"
Sets an entry in the color palette.
.SH "void QScreen::setDirty ( const QRect & )\fC [virtual]\fR"
Indicates which section of the screen has been altered. Used by the VNC and VFB displays; the QScreen version does nothing.
.SH "void QScreen::setMode ( int, int, int )\fC [pure virtual]\fR"
This function can be used to set the framebuffer width, height and depth. It's currently unused.
.SH "void QScreen::shutdownDevice ()\fC [virtual]\fR"
Called by the Qt/Embedded server on shutdown; never called by a Qt/Embedded client. This is intended to support graphics card specific shutdown; the unaccelerated implementation simply hides the mouse cursor.
.SH "bool QScreen::supportsDepth ( int d ) const\fC [virtual]\fR"
Returns true if the screen supports a particular color depth \fId\fR. Possible values are 1,4,8,16 and 32.
.SH "int QScreen::totalSize () const"
Returns the size in bytes of available graphics card memory, including the screen. Offscreen memory is only used by the accelerated drivers.
.SH "int QScreen::transformOrientation () const\fC [virtual]\fR"
Used by the rotated server. The QScreeen implementation returns 0.
.SH "void QScreen::uncache ( uchar * )\fC [virtual]\fR"
This function is called on pixmap destruction to remove them from graphics card memory.
.SH "int QScreen::width () const"
Gives the width in pixels of the framebuffer.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qscreen.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qscreen.3qt) and the Qt
version (3.3.8).
