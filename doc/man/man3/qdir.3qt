'\" t
.TH QDir 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QDir \- Access to directory structures and their contents in a platform-independent way
.SH SYNOPSIS
All the functions in this class are reentrant when Qt is built with thread support.</p>
.PP
\fC#include <qdir.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBFilterSpec\fR { Dirs = 0x001, Files = 0x002, Drives = 0x004, NoSymLinks = 0x008, All = 0x007, TypeMask = 0x00F, Readable = 0x010, Writable = 0x020, Executable = 0x040, RWEMask = 0x070, Modified = 0x080, Hidden = 0x100, System = 0x200, AccessMask = 0x3F0, DefaultFilter = -1 }"
.br
.ti -1c
.BI "enum \fBSortSpec\fR { Name = 0x00, Time = 0x01, Size = 0x02, Unsorted = 0x03, SortByMask = 0x03, DirsFirst = 0x04, Reversed = 0x08, IgnoreCase = 0x10, LocaleAware = 0x20, DefaultSort = -1 }"
.br
.ti -1c
.BI "\fBQDir\fR ()"
.br
.ti -1c
.BI "\fBQDir\fR ( const QString & path, const QString & nameFilter = QString::null, int sortSpec = Name | IgnoreCase, int filterSpec = All )"
.br
.ti -1c
.BI "\fBQDir\fR ( const QDir & d )"
.br
.ti -1c
.BI "virtual \fB~QDir\fR ()"
.br
.ti -1c
.BI "QDir & \fBoperator=\fR ( const QDir & d )"
.br
.ti -1c
.BI "QDir & \fBoperator=\fR ( const QString & path )"
.br
.ti -1c
.BI "virtual void \fBsetPath\fR ( const QString & path )"
.br
.ti -1c
.BI "virtual QString \fBpath\fR () const"
.br
.ti -1c
.BI "virtual QString \fBabsPath\fR () const"
.br
.ti -1c
.BI "virtual QString \fBcanonicalPath\fR () const"
.br
.ti -1c
.BI "virtual QString \fBdirName\fR () const"
.br
.ti -1c
.BI "virtual QString \fBfilePath\fR ( const QString & fileName, bool acceptAbsPath = TRUE ) const"
.br
.ti -1c
.BI "virtual QString \fBabsFilePath\fR ( const QString & fileName, bool acceptAbsPath = TRUE ) const"
.br
.ti -1c
.BI "virtual bool \fBcd\fR ( const QString & dirName, bool acceptAbsPath = TRUE )"
.br
.ti -1c
.BI "virtual bool \fBcdUp\fR ()"
.br
.ti -1c
.BI "QString \fBnameFilter\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetNameFilter\fR ( const QString & nameFilter )"
.br
.ti -1c
.BI "FilterSpec \fBfilter\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFilter\fR ( int filterSpec )"
.br
.ti -1c
.BI "SortSpec \fBsorting\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetSorting\fR ( int sortSpec )"
.br
.ti -1c
.BI "bool \fBmatchAllDirs\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMatchAllDirs\fR ( bool enable )"
.br
.ti -1c
.BI "uint \fBcount\fR () const"
.br
.ti -1c
.BI "QString \fBoperator[]\fR ( int index ) const"
.br
.ti -1c
.BI "virtual QStrList encodedEntryList ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual QStrList encodedEntryList ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual QStringList \fBentryList\fR ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const"
.br
.ti -1c
.BI "virtual QStringList \fBentryList\fR ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const"
.br
.ti -1c
.BI "virtual const QFileInfoList * \fBentryInfoList\fR ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const"
.br
.ti -1c
.BI "virtual const QFileInfoList * \fBentryInfoList\fR ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const"
.br
.ti -1c
.BI "virtual bool \fBmkdir\fR ( const QString & dirName, bool acceptAbsPath = TRUE ) const"
.br
.ti -1c
.BI "virtual bool \fBrmdir\fR ( const QString & dirName, bool acceptAbsPath = TRUE ) const"
.br
.ti -1c
.BI "virtual bool \fBisReadable\fR () const"
.br
.ti -1c
.BI "virtual bool \fBexists\fR () const"
.br
.ti -1c
.BI "virtual bool \fBisRoot\fR () const"
.br
.ti -1c
.BI "virtual bool \fBisRelative\fR () const"
.br
.ti -1c
.BI "virtual void \fBconvertToAbs\fR ()"
.br
.ti -1c
.BI "virtual bool \fBoperator==\fR ( const QDir & d ) const"
.br
.ti -1c
.BI "virtual bool \fBoperator!=\fR ( const QDir & d ) const"
.br
.ti -1c
.BI "virtual bool \fBremove\fR ( const QString & fileName, bool acceptAbsPath = TRUE )"
.br
.ti -1c
.BI "virtual bool \fBrename\fR ( const QString & oldName, const QString & newName, bool acceptAbsPaths = TRUE )"
.br
.ti -1c
.BI "virtual bool \fBexists\fR ( const QString & name, bool acceptAbsPath = TRUE )"
.br
.ti -1c
.BI "void \fBrefresh\fR () const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QString \fBconvertSeparators\fR ( const QString & pathName )"
.br
.ti -1c
.BI "const QFileInfoList * \fBdrives\fR ()"
.br
.ti -1c
.BI "char \fBseparator\fR ()"
.br
.ti -1c
.BI "bool \fBsetCurrent\fR ( const QString & path )"
.br
.ti -1c
.BI "QDir \fBcurrent\fR ()"
.br
.ti -1c
.BI "QDir \fBhome\fR ()"
.br
.ti -1c
.BI "QDir \fBroot\fR ()"
.br
.ti -1c
.BI "QString \fBcurrentDirPath\fR ()"
.br
.ti -1c
.BI "QString \fBhomeDirPath\fR ()"
.br
.ti -1c
.BI "QString \fBrootDirPath\fR ()"
.br
.ti -1c
.BI "bool \fBmatch\fR ( const QStringList & filters, const QString & fileName )"
.br
.ti -1c
.BI "bool \fBmatch\fR ( const QString & filter, const QString & fileName )"
.br
.ti -1c
.BI "QString \fBcleanDirPath\fR ( const QString & filePath )"
.br
.ti -1c
.BI "bool \fBisRelativePath\fR ( const QString & path )"
.br
.in -1c
.SH DESCRIPTION
The QDir class provides access to directory structures and their contents in a platform-independent way.
.PP
A QDir is used to manipulate path names, access information regarding paths and files, and manipulate the underlying file system.
.PP
A QDir can point to a file using either a relative or an absolute path. Absolute paths begin with the directory separator "/" (optionally preceded by a drive specification under Windows). If you always use "/" as a directory separator, Qt will translate your paths to conform to the underlying operating system. Relative file names begin with a directory name or a file name and specify a path relative to the current directory.
.PP
The "current" path refers to the application's working directory. A QDir's own path is set and retrieved with setPath() and path().
.PP
An example of an absolute path is the string "/tmp/quartz", a relative path might look like "src/fatlib". You can use the function isRelative() to check if a QDir is using a relative or an absolute file path. Call convertToAbs() to convert a relative QDir to an absolute one. For a simplified path use cleanDirPath(). To obtain a path which has no symbolic links or redundant ".." elements use canonicalPath(). The path can be set with setPath(), and changed with cd() and cdUp().
.PP
QDir provides several static functions, for example, setCurrent() to set the application's working directory and currentDirPath() to retrieve the application's working directory. Access to some common paths is provided with the static functions, current(), home() and root() which return QDir objects or currentDirPath(), homeDirPath() and rootDirPath() which return the path as a string. If you want to know about your application's path use QApplication::applicationDirPath().
.PP
The number of entries in a directory is returned by count(). Obtain a string list of the names of all the files and directories in a directory with entryList(). If you prefer a list of QFileInfo pointers use entryInfoList(). Both these functions can apply a name filter, an attributes filter (e.g. read-only, files not directories, etc.), and a sort order. The filters and sort may be set with calls to setNameFilter(), setFilter() and setSorting(). They may also be specified in the entryList() and entryInfoList()'s arguments.
.PP
Create a new directory with mkdir(), rename a directory with rename() and remove an existing directory with rmdir(). Remove a file with remove(). You can interrogate a directory with exists(), isReadable() and isRoot().
.PP
To get a path with a filename use filePath(), and to get a directory name use dirName(); neither of these functions checks for the existence of the file or directory.
.PP
The list of root directories is provided by drives(); on Unix systems this returns a list containing one root directory, "/"; on Windows the list will usually contain "C:/", and possibly "D:/", etc.
.PP
It is easiest to work with "/" separators in Qt code. If you need to present a path to the user or need a path in a form suitable for a function in the underlying operating system use convertSeparators().
.PP
Examples:
.)l
.PP
See if a directory exists.
.PP
.nf
.br
    QDir d( "example" );                        // "./example"
.br
    if ( !d.exists() )
.br
        qWarning( "Cannot find the example directory" );
.br
.fi
.PP
Traversing directories and reading a file.
.PP
.nf
.br
    QDir d = QDir::root();                      // "/"
.br
    if ( !d.cd("tmp") ) {                       // "/tmp"
.br
        qWarning( "Cannot find the \\"/tmp\\" directory" );
.br
    } else {
.br
        QFile f( d.filePath("ex1.txt") );       // "/tmp/ex1.txt"
.br
        if ( !f.open(IO_ReadWrite) )
.br
            qWarning( "Cannot create the file %s", f.name() );
.br
    }
.br
.fi
.PP
A program that lists all the files in the current directory (excluding symbolic links), sorted by size, smallest first:
.PP
.nf
.br
    #include <stdio.h>
.br
    #include <qdir.h>
.br
.br
    int main( int argc, char **argv )
.br
    {
.br
        QDir d;
.br
        d.setFilter( QDir::Files | QDir::Hidden | QDir::NoSymLinks );
.br
        d.setSorting( QDir::Size | QDir::Reversed );
.br
.br
        const QFileInfoList *list = d.entryInfoList();
.br
        QFileInfoListIterator it( *list );
.br
        QFileInfo *fi;
.br
.br
        printf( "     Bytes Filename\\n" );
.br
        while ( (fi = it.current()) != 0 ) {
.br
            printf( "%10li %s\\n", fi->size(), fi->fileName().latin1() );
.br
            ++it;
.br
        }
.br
        return 0;
.br
    }
.br
.fi
.PP
See also QApplication::applicationDirPath() and Input/Output and Networking.
.SS "Member Type Documentation"
.SH "QDir::FilterSpec"
This enum describes the filtering options available to QDir, e.g. for entryList() and entryInfoList(). The filter value is specified by OR-ing together values from the following list:
.TP
\fCQDir::Dirs\fR - List directories only.
.TP
\fCQDir::Files\fR - List files only.
.TP
\fCQDir::Drives\fR - List disk drives (ignored under Unix).
.TP
\fCQDir::NoSymLinks\fR - Do not list symbolic links (ignored by operating systems that don't support symbolic links).
.TP
\fCQDir::All\fR - List directories, files, drives and symlinks (this does not list broken symlinks unless you specify System).
.TP
\fCQDir::TypeMask\fR - A mask for the the Dirs, Files, Drives and NoSymLinks flags.
.TP
\fCQDir::Readable\fR - List files for which the application has read access.
.TP
\fCQDir::Writable\fR - List files for which the application has write access.
.TP
\fCQDir::Executable\fR - List files for which the application has execute access. Executables needs to be combined with Dirs or Files.
.TP
\fCQDir::RWEMask\fR - A mask for the Readable, Writable and Executable flags.
.TP
\fCQDir::Modified\fR - Only list files that have been modified (ignored under Unix).
.TP
\fCQDir::Hidden\fR - List hidden files (on Unix, files starting with a .).
.TP
\fCQDir::System\fR - List system files (on Unix, FIFOs, sockets and device files)
.TP
\fCQDir::AccessMask\fR - A mask for the Readable, Writable, Executable Modified, Hidden and System flags
.TP
\fCQDir::DefaultFilter\fR - Internal flag.
.PP
If you do not set any of Readable, Writable or Executable, QDir will set all three of them. This makes the default easy to write and at the same time useful.
.PP
Examples:
.)l \fCReadable|Writable\fR means list all files for which the
application has read access, write access or both. \fCDirs|Drives\fR means list drives, directories, all files that the application can read, write or execute, and also symlinks to such files/directories.
.SH "QDir::SortSpec"
This enum describes the sort options available to QDir, e.g. for entryList() and entryInfoList(). The sort value is specified by OR-ing together values from the following list:
.TP
\fCQDir::Name\fR - Sort by name.
.TP
\fCQDir::Time\fR - Sort by time (modification time).
.TP
\fCQDir::Size\fR - Sort by file size.
.TP
\fCQDir::Unsorted\fR - Do not sort.
.TP
\fCQDir::SortByMask\fR - A mask for Name, Time and Size.
.TP
\fCQDir::DirsFirst\fR - Put the directories first, then the files.
.TP
\fCQDir::Reversed\fR - Reverse the sort order.
.TP
\fCQDir::IgnoreCase\fR - Sort case-insensitively.
.TP
\fCQDir::LocaleAware\fR - Sort names using locale aware compares
.TP
\fCQDir::DefaultSort\fR - Internal flag.
.PP
You can only specify one of the first four.
.PP
If you specify both DirsFirst and Reversed, directories are still put first, but in reverse order; the files will be listed after the directories, again in reverse order.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QDir::QDir ()"
Constructs a QDir pointing to the current directory (".").
.PP
See also currentDirPath().
.SH "QDir::QDir ( const QString & path, const QString & nameFilter = QString::null, int sortSpec = Name | IgnoreCase, int filterSpec = All )"
Constructs a QDir with path \fIpath\fR, that filters its entries by name using \fInameFilter\fR and by attributes using \fIfilterSpec\fR. It also sorts the names using \fIsortSpec\fR.
.PP
The default \fInameFilter\fR is an empty string, which excludes nothing; the default \fIfilterSpec\fR is All, which also means exclude nothing. The default \fIsortSpec\fR is \fCName|IgnoreCase\fR, i.e. sort by name case-insensitively.
.PP
Example that lists all the files in "/tmp":
.PP
.nf
.br
    QDir d( "/tmp" );
.br
    for ( int i = 0; i < d.count(); i++ )
.br
        printf( "%s\\n", d[i] );
.br
.fi
.PP
If \fIpath\fR is "" or QString::null, QDir uses "." (the current directory). If \fInameFilter\fR is "" or QString::null, QDir uses the name filter "*" (all files).
.PP
Note that \fIpath\fR need not exist.
.PP
See also exists(), setPath(), setNameFilter(), setFilter(), and setSorting().
.SH "QDir::QDir ( const QDir & d )"
Constructs a QDir that is a copy of the directory \fId\fR.
.PP
See also operator=().
.SH "QDir::~QDir ()\fC [virtual]\fR"
Destroys the QDir frees up its resources.
.SH "QString QDir::absFilePath ( const QString & fileName, bool acceptAbsPath = TRUE ) const\fC [virtual]\fR"
Returns the absolute path name of a file in the directory. Does \fInot\fR check if the file actually exists in the directory. Redundant multiple separators or "." and ".." directories in \fIfileName\fR will not be removed (see cleanDirPath()).
.PP
If \fIacceptAbsPath\fR is TRUE a \fIfileName\fR starting with a separator "/" will be returned without change. If \fIacceptAbsPath\fR is FALSE an absolute path will be prepended to the fileName and the resultant string returned.
.PP
See also filePath().
.SH "QString QDir::absPath () const\fC [virtual]\fR"
Returns the absolute path (a path that starts with "/" or with a drive specification), which may contain symbolic links, but never contains redundant ".", ".." or multiple separators.
.PP
See also setPath(), canonicalPath(), exists(), cleanDirPath(), dirName(), and absFilePath().
.PP
Example: fileiconview/qfileiconview.cpp.
.SH "QString QDir::canonicalPath () const\fC [virtual]\fR"
Returns the canonical path, i.e. a path without symbolic links or redundant "." or ".." elements.
.PP
On systems that do not have symbolic links this function will always return the same string that absPath() returns. If the canonical path does not exist (normally due to dangling symbolic links) canonicalPath() returns QString::null.
.PP
See also path(), absPath(), exists(), cleanDirPath(), dirName(), absFilePath(), and QString::isNull().
.SH "bool QDir::cd ( const QString & dirName, bool acceptAbsPath = TRUE )\fC [virtual]\fR"
Changes the QDir's directory to \fIdirName\fR.
.PP
If \fIacceptAbsPath\fR is TRUE a path starting with separator "/" will cause the function to change to the absolute directory. If \fIacceptAbsPath\fR is FALSE any number of separators at the beginning of \fIdirName\fR will be removed and the function will descend into \fIdirName\fR.
.PP
Returns TRUE if the new directory exists and is readable; otherwise returns FALSE. Note that the logical cd() operation is not performed if the new directory does not exist.
.PP
Calling cd( ".." ) is equivalent to calling cdUp().
.PP
See also cdUp(), isReadable(), exists(), and path().
.PP
Example: fileiconview/mainwindow.cpp.
.SH "bool QDir::cdUp ()\fC [virtual]\fR"
Changes directory by moving one directory up from the QDir's current directory.
.PP
Returns TRUE if the new directory exists and is readable; otherwise returns FALSE. Note that the logical cdUp() operation is not performed if the new directory does not exist.
.PP
See also cd(), isReadable(), exists(), and path().
.SH "QString QDir::cleanDirPath ( const QString & filePath )\fC [static]\fR"
Removes all multiple directory separators "/" and resolves any"
."s or ".."s found in the path, \fIfilePath\fR.
.PP
Symbolic links are kept. This function does not return the canonical path, but rather the simplest version of the input. For example, "./local" becomes "local", "local/../bin" becomes" bin" and "/local/usr/../bin" becomes "/local/bin".
.PP
See also absPath() and canonicalPath().
.SH "QString QDir::convertSeparators ( const QString & pathName )\fC [static]\fR"
Returns \fIpathName\fR with the '/' separators converted to separators that are appropriate for the underlying operating system.
.PP
On Windows, convertSeparators("c:/winnt/system32") returns" c:\\winnt\\system32".
.PP
The returned string may be the same as the argument on some operating systems, for example on Unix.
.PP
Examples:
.)l dirview/dirview.cpp and fileiconview/qfileiconview.cpp.
.SH "void QDir::convertToAbs ()\fC [virtual]\fR"
Converts the directory path to an absolute path. If it is already absolute nothing is done.
.PP
See also isRelative().
.SH "uint QDir::count () const"
Returns the total number of directories and files that were found.
.PP
Equivalent to entryList().count().
.PP
See also operator[]() and entryList().
.SH "QDir QDir::current ()\fC [static]\fR"
Returns the application's current directory.
.PP
Use path() to access a QDir object's path.
.PP
See also currentDirPath() and QDir::QDir().
.SH "QString QDir::currentDirPath ()\fC [static]\fR"
Returns the absolute path of the application's current directory.
.PP
See also current().
.PP
Examples:
.)l dirview/dirview.cpp, helpviewer/helpwindow.cpp, and qdir/qdir.cpp.
.SH "QString QDir::dirName () const\fC [virtual]\fR"
Returns the name of the directory; this is \fInot\fR the same as the path, e.g. a directory with the name "mail", might have the path" /var/spool/mail". If the directory has no name (e.g. it is the root directory) QString::null is returned.
.PP
No check is made to ensure that a directory with this name actually exists.
.PP
See also path(), absPath(), absFilePath(), exists(), and QString::isNull().
.SH "const QFileInfoList * QDir::drives ()\fC [static]\fR"
Returns a list of the root directories on this system. On Windows this returns a number of QFileInfo objects containing "C:/", "D:/" etc. On other operating systems, it returns a list containing just one root directory (e.g. "/").
.PP
The returned pointer is owned by Qt. Callers should \fInot\fR delete or modify it.
.PP
Example: dirview/main.cpp.
.SH "QStrList QDir::encodedEntryList ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This function is included to easy porting from Qt 1.x to Qt 2.0, it is the same as entryList(), but encodes the filenames as 8-bit strings using QFile::encodedName().
.PP
It is more efficient to use entryList().
.SH "QStrList QDir::encodedEntryList ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function is included to easy porting from Qt 1.x to Qt 2.0, it is the same as entryList(), but encodes the filenames as 8-bit strings using QFile::encodedName().
.PP
It is more efficient to use entryList().
.SH "const QFileInfoList * QDir::entryInfoList ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
Returns a list of QFileInfo objects for all the files and directories in the directory, ordered in accordance with setSorting() and filtered in accordance with setFilter() and setNameFilter().
.PP
The filter and sorting specifications can be overridden using the \fInameFilter\fR, \fIfilterSpec\fR and \fIsortSpec\fR arguments.
.PP
Returns 0 if the directory is unreadable or does not exist.
.PP
The returned pointer is a const pointer to a QFileInfoList. The list is owned by the QDir object and will be reused on the next call to entryInfoList() for the same QDir instance. If you want to keep the entries of the list after a subsequent call to this function you must copy them.
.PP
Note: QFileInfoList is really a QPtrList<QFileInfo>.
.PP
See also entryList(), setNameFilter(), setSorting(), and setFilter().
.PP
Examples:
.)l dirview/dirview.cpp and fileiconview/qfileiconview.cpp.
.SH "const QFileInfoList * QDir::entryInfoList ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a list of QFileInfo objects for all the files and directories in the directory, ordered in accordance with setSorting() and filtered in accordance with setFilter() and setNameFilter().
.PP
The filter and sorting specifications can be overridden using the \fIfilterSpec\fR and \fIsortSpec\fR arguments.
.PP
Returns 0 if the directory is unreadable or does not exist.
.PP
The returned pointer is a const pointer to a QFileInfoList. The list is owned by the QDir object and will be reused on the next call to entryInfoList() for the same QDir instance. If you want to keep the entries of the list after a subsequent call to this function you must copy them.
.PP
Note: QFileInfoList is really a QPtrList<QFileInfo>.
.PP
See also entryList(), setNameFilter(), setSorting(), and setFilter().
.SH "QStringList QDir::entryList ( const QString & nameFilter, int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
Returns a list of the names of all the files and directories in the directory, ordered in accordance with setSorting() and filtered in accordance with setFilter() and setNameFilter().
.PP
The filter and sorting specifications can be overridden using the \fInameFilter\fR, \fIfilterSpec\fR and \fIsortSpec\fR arguments.
.PP
Returns an empty list if the directory is unreadable or does not exist.
.PP
See also entryInfoList(), setNameFilter(), setSorting(), and setFilter().
.PP
Example: table/statistics/statistics.cpp.
.SH "QStringList QDir::entryList ( int filterSpec = DefaultFilter, int sortSpec = DefaultSort ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a list of the names of all the files and directories in the directory, ordered in accordance with setSorting() and filtered in accordance with setFilter() and setNameFilter().
.PP
The filter and sorting specifications can be overridden using the \fIfilterSpec\fR and \fIsortSpec\fR arguments.
.PP
Returns an empty list if the directory is unreadable or does not exist.
.PP
See also entryInfoList(), setNameFilter(), setSorting(), and setFilter().
.SH "bool QDir::exists ( const QString & name, bool acceptAbsPath = TRUE )\fC [virtual]\fR"
Checks for the existence of the file \fIname\fR.
.PP
If \fIacceptAbsPath\fR is TRUE a path starting with separator "/" will check the file with the absolute path. If \fIacceptAbsPath\fR is FALSE any number of separators at the beginning of \fIname\fR will be removed and the resultant file name will be checked.
.PP
Returns TRUE if the file exists; otherwise returns FALSE.
.PP
See also QFileInfo::exists() and QFile::exists().
.SH "bool QDir::exists () const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if the \fIdirectory\fR exists; otherwise returns FALSE. (If a file with the same name is found this function will return FALSE).
.PP
See also QFileInfo::exists() and QFile::exists().
.SH "QString QDir::filePath ( const QString & fileName, bool acceptAbsPath = TRUE ) const\fC [virtual]\fR"
Returns the path name of a file in the directory. Does \fInot\fR check if the file actually exists in the directory. If the QDir is relative the returned path name will also be relative. Redundant multiple separators or "." and ".." directories in \fIfileName\fR will not be removed (see cleanDirPath()).
.PP
If \fIacceptAbsPath\fR is TRUE a \fIfileName\fR starting with a separator "/" will be returned without change. If \fIacceptAbsPath\fR is FALSE an absolute path will be prepended to the fileName and the resultant string returned.
.PP
See also absFilePath(), isRelative(), and canonicalPath().
.SH "FilterSpec QDir::filter () const"
Returns the value set by setFilter()
.SH "QDir QDir::home ()\fC [static]\fR"
Returns the home directory.
.PP
Under Windows the \fCHOME\fR environment variable is used. If this does not exist the \fCUSERPROFILE\fR environment variable is used. If that does not exist the path is formed by concatenating the \fCHOMEDRIVE\fR and \fCHOMEPATH\fR environment variables. If they don't exist the rootDirPath() is used (this uses the \fCSystemDrive\fR environment variable). If none of these exist "C:&#92;" is used.
.PP
Under non-Windows operating systems the \fCHOME\fR environment variable is used if it exists, otherwise rootDirPath() is used.
.PP
See also homeDirPath().
.SH "QString QDir::homeDirPath ()\fC [static]\fR"
Returns the absolute path of the user's home directory.
.PP
See also home().
.SH "bool QDir::isReadable () const\fC [virtual]\fR"
Returns TRUE if the directory is readable \fIand\fR we can open files by name; otherwise returns FALSE.
.PP
\fBWarning:\fR A FALSE value from this function is not a guarantee that files in the directory are not accessible.
.PP
See also QFileInfo::isReadable().
.PP
Examples:
.)l dirview/dirview.cpp and fileiconview/qfileiconview.cpp.
.SH "bool QDir::isRelative () const\fC [virtual]\fR"
Returns TRUE if the directory path is relative to the current directory and returns FALSE if the path is absolute (e.g. under UNIX a path is relative if it does not start with a "/").
.PP
See also convertToAbs().
.SH "bool QDir::isRelativePath ( const QString & path )\fC [static]\fR"
Returns TRUE if \fIpath\fR is relative; returns FALSE if it is absolute.
.PP
See also isRelative().
.SH "bool QDir::isRoot () const\fC [virtual]\fR"
Returns TRUE if the directory is the root directory; otherwise returns FALSE.
.PP
Note: If the directory is a symbolic link to the root directory this function returns FALSE. If you want to test for this use canonicalPath(), e.g.
.PP
.nf
.br
    QDir d( "/tmp/root_link" );
.br
    d = d.canonicalPath();
.br
    if ( d.isRoot() )
.br
        qWarning( "It is a root link" );
.br
.fi
.PP
See also root() and rootDirPath().
.SH "bool QDir::match ( const QString & filter, const QString & fileName )\fC [static]\fR"
Returns TRUE if the \fIfileName\fR matches the wildcard (glob) pattern \fIfilter\fR; otherwise returns FALSE. The \fIfilter\fR may contain multiple patterns separated by spaces or semicolons.
.PP
(See QRegExp wildcard matching.)
.PP
See also QRegExp::match().
.SH "bool QDir::match ( const QStringList & filters, const QString & fileName )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if the \fIfileName\fR matches any of the wildcard (glob) patterns in the list of \fIfilters\fR; otherwise returns FALSE.
.PP
(See QRegExp wildcard matching.)
.PP
See also QRegExp::match().
.SH "bool QDir::matchAllDirs () const"
Returns the value set by setMatchAllDirs()
.PP
See also setMatchAllDirs().
.SH "bool QDir::mkdir ( const QString & dirName, bool acceptAbsPath = TRUE ) const\fC [virtual]\fR"
Creates a directory.
.PP
If \fIacceptAbsPath\fR is TRUE a path starting with a separator ('/') will create the absolute directory; if \fIacceptAbsPath\fR is FALSE any number of separators at the beginning of \fIdirName\fR will be removed.
.PP
Returns TRUE if successful; otherwise returns FALSE.
.PP
See also rmdir().
.SH "QString QDir::nameFilter () const"
Returns the string set by setNameFilter()
.SH "bool QDir::operator!= ( const QDir & d ) const\fC [virtual]\fR"
Returns TRUE if directory \fId\fR and this directory have different paths or different sort or filter settings; otherwise returns FALSE.
.PP
Example:
.PP
.nf
.br
    // The current directory is "/usr/local"
.br
    QDir d1( "/usr/local/bin" );
.br
    QDir d2( "bin" );
.br
    if ( d1 != d2 )
.br
        qDebug( "They differ" );
.br
.fi
.SH "QDir & QDir::operator= ( const QDir & d )"
Makes a copy of QDir \fId\fR and assigns it to this QDir.
.SH "QDir & QDir::operator= ( const QString & path )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the directory path to be the given \fIpath\fR.
.SH "bool QDir::operator== ( const QDir & d ) const\fC [virtual]\fR"
Returns TRUE if directory \fId\fR and this directory have the same path and their sort and filter settings are the same; otherwise returns FALSE.
.PP
Example:
.PP
.nf
.br
    // The current directory is "/usr/local"
.br
    QDir d1( "/usr/local/bin" );
.br
    QDir d2( "bin" );
.br
    d2.convertToAbs();
.br
    if ( d1 == d2 )
.br
        qDebug( "They're the same" );
.br
.fi
.SH "QString QDir::operator[] ( int index ) const"
Returns the file name at position \fIindex\fR in the list of file names. Equivalent to entryList().at(index).
.PP
Returns a QString::null if the \fIindex\fR is out of range or if the entryList() function failed.
.PP
See also count() and entryList().
.SH "QString QDir::path () const\fC [virtual]\fR"
Returns the path, this may contain symbolic links, but never contains redundant ".", ".." or multiple separators.
.PP
The returned path can be either absolute or relative (see setPath()).
.PP
See also setPath(), absPath(), exists(), cleanDirPath(), dirName(), absFilePath(), and convertSeparators().
.SH "void QDir::refresh () const"
Refreshes the directory information.
.SH "bool QDir::remove ( const QString & fileName, bool acceptAbsPath = TRUE )\fC [virtual]\fR"
Removes the file, \fIfileName\fR.
.PP
If \fIacceptAbsPath\fR is TRUE a path starting with separator "/" will remove the file with the absolute path. If \fIacceptAbsPath\fR is FALSE any number of separators at the beginning of \fIfileName\fR will be removed and the resultant file name will be removed.
.PP
Returns TRUE if the file is removed successfully; otherwise returns FALSE.
.SH "bool QDir::rename ( const QString & oldName, const QString & newName, bool acceptAbsPaths = TRUE )\fC [virtual]\fR"
Renames a file or directory.
.PP
If \fIacceptAbsPaths\fR is TRUE a path starting with a separator ('/') will rename the file with the absolute path; if \fIacceptAbsPaths\fR is FALSE any number of separators at the beginning of the names will be removed.
.PP
Returns TRUE if successful; otherwise returns FALSE.
.PP
On most file systems, rename() fails only if \fIoldName\fR does not exist or if \fInewName\fR and \fIoldName\fR are not on the same partition. On Windows, rename() will fail if \fInewName\fR already exists. However, there are also other reasons why rename() can fail. For example, on at least one file system rename() fails if \fInewName\fR points to an open file.
.PP
Example: fileiconview/qfileiconview.cpp.
.SH "bool QDir::rmdir ( const QString & dirName, bool acceptAbsPath = TRUE ) const\fC [virtual]\fR"
Removes a directory.
.PP
If \fIacceptAbsPath\fR is TRUE a path starting with a separator ('/') will remove the absolute directory; if \fIacceptAbsPath\fR is FALSE any number of separators at the beginning of \fIdirName\fR will be removed.
.PP
The directory must be empty for rmdir() to succeed.
.PP
Returns TRUE if successful; otherwise returns FALSE.
.PP
See also mkdir().
.SH "QDir QDir::root ()\fC [static]\fR"
Returns the root directory.
.PP
See also rootDirPath() and drives().
.SH "QString QDir::rootDirPath ()\fC [static]\fR"
Returns the absolute path for the root directory.
.PP
For UNIX operating systems this returns "/". For Windows file systems this normally returns "c:/".
.PP
See also root() and drives().
.SH "char QDir::separator ()\fC [static]\fR"
Returns the native directory separator; "/" under UNIX (including Mac OS X) and "&#92;" under Windows.
.PP
You do not need to use this function to build file paths. If you always use "/", Qt will translate your paths to conform to the underlying operating system.
.SH "bool QDir::setCurrent ( const QString & path )\fC [static]\fR"
Sets the application's current working directory to \fIpath\fR. Returns TRUE if the directory was successfully changed; otherwise returns FALSE.
.SH "void QDir::setFilter ( int filterSpec )\fC [virtual]\fR"
Sets the filter used by entryList() and entryInfoList() to \fIfilterSpec\fR. The filter is used to specify the kind of files that should be returned by entryList() and entryInfoList(). See QDir::FilterSpec.
.PP
See also filter() and setNameFilter().
.SH "void QDir::setMatchAllDirs ( bool enable )\fC [virtual]\fR"
If \fIenable\fR is TRUE then all directories are included (e.g. in entryList()), and the nameFilter() is only applied to the files. If \fIenable\fR is FALSE then the nameFilter() is applied to both directories and files.
.PP
See also matchAllDirs().
.SH "void QDir::setNameFilter ( const QString & nameFilter )\fC [virtual]\fR"
Sets the name filter used by entryList() and entryInfoList() to \fInameFilter\fR.
.PP
The \fInameFilter\fR is a wildcard (globbing) filter that understands" *" and "?" wildcards. (See QRegExp wildcard matching.) You may specify several filter entries all separated by a single space " " or by a semi-colon" ;".
.PP
For example, if you want entryList() and entryInfoList() to list all files ending with either ".cpp" or ".h", you would use either dir.setNameFilter("*.cpp *.h") or dir.setNameFilter("*.cpp;*.h").
.PP
See also nameFilter() and setFilter().
.SH "void QDir::setPath ( const QString & path )\fC [virtual]\fR"
Sets the path of the directory to \fIpath\fR. The path is cleaned of redundant ".", ".." and of multiple separators. No check is made to ensure that a directory with this path exists.
.PP
The path can be either absolute or relative. Absolute paths begin with the directory separator "/" (optionally preceded by a drive specification under Windows). Relative file names begin with a directory name or a file name and specify a path relative to the current directory. An example of an absolute path is the string" /tmp/quartz", a relative path might look like "src/fatlib".
.PP
See also path(), absPath(), exists(), cleanDirPath(), dirName(), absFilePath(), isRelative(), and convertToAbs().
.SH "void QDir::setSorting ( int sortSpec )\fC [virtual]\fR"
Sets the sort order used by entryList() and entryInfoList().
.PP
The \fIsortSpec\fR is specified by OR-ing values from the enum QDir::SortSpec.
.PP
See also sorting() and SortSpec.
.SH "SortSpec QDir::sorting () const"
Returns the value set by setSorting()
.PP
See also setSorting() and SortSpec.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qdir.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qdir.3qt) and the Qt
version (3.3.8).
