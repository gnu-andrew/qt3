'\" t
.TH QString 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QString \- Abstraction of Unicode text and the classic C '&#92;0'-terminated char array
.SH SYNOPSIS
All the functions in this class are reentrant when Qt is built with thread support.</p>
.PP
\fC#include <qstring.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQString\fR ()"
.br
.ti -1c
.BI "\fBQString\fR ( QChar ch )"
.br
.ti -1c
.BI "\fBQString\fR ( const QString & s )"
.br
.ti -1c
.BI "\fBQString\fR ( const QByteArray & ba )"
.br
.ti -1c
.BI "\fBQString\fR ( const QChar * unicode, uint length )"
.br
.ti -1c
.BI "\fBQString\fR ( const char * str )"
.br
.ti -1c
.BI "\fBQString\fR ( const std::string & str )"
.br
.ti -1c
.BI "\fB~QString\fR ()"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( const QString & s )"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( const char * str )"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( const std::string & s )"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( const QCString & cstr )"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( QChar c )"
.br
.ti -1c
.BI "QString & \fBoperator=\fR ( char c )"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "uint \fBlength\fR () const"
.br
.ti -1c
.BI "void \fBtruncate\fR ( uint newLen )"
.br
.ti -1c
.BI "QString & \fBfill\fR ( QChar c, int len = -1 )"
.br
.ti -1c
.BI "QString copy () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QString \fBarg\fR ( long a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( ulong a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( Q_LLONG a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( Q_ULLONG a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( int a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( uint a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( short a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( ushort a, int fieldWidth = 0, int base = 10 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( double a, int fieldWidth = 0, char fmt = 'g', int prec = -1 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( char a, int fieldWidth = 0 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( QChar a, int fieldWidth = 0 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( const QString & a, int fieldWidth = 0 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( const QString & a1, const QString & a2 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( const QString & a1, const QString & a2, const QString & a3 ) const"
.br
.ti -1c
.BI "QString \fBarg\fR ( const QString & a1, const QString & a2, const QString & a3, const QString & a4 ) const"
.br
.ti -1c
.BI "QString & \fBsprintf\fR ( const char * cformat, ... )"
.br
.ti -1c
.BI "int \fBfind\fR ( QChar c, int index = 0, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( char c, int index = 0, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( const QString & str, int index = 0, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( const QRegExp & rx, int index = 0 ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( const char * str, int index = 0 ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( QChar c, int index = -1, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( char c, int index = -1, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( const QString & str, int index = -1, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( const QRegExp & rx, int index = -1 ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( const char * str, int index = -1 ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( QChar c, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( char c, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( const char * str, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( const QString & str, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( const QRegExp & rx ) const"
.br
.ti -1c
.BI "enum \fBSectionFlags\fR { SectionDefault = 0x00, SectionSkipEmpty = 0x01, SectionIncludeLeadingSep = 0x02, SectionIncludeTrailingSep = 0x04, SectionCaseInsensitiveSeps = 0x08 }"
.br
.ti -1c
.BI "QString \fBsection\fR ( QChar sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
.br
.ti -1c
.BI "QString \fBsection\fR ( char sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
.br
.ti -1c
.BI "QString \fBsection\fR ( const char * sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
.br
.ti -1c
.BI "QString \fBsection\fR ( const QString & sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
.br
.ti -1c
.BI "QString \fBsection\fR ( const QRegExp & reg, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
.br
.ti -1c
.BI "QString \fBleft\fR ( uint len ) const"
.br
.ti -1c
.BI "QString \fBright\fR ( uint len ) const"
.br
.ti -1c
.BI "QString \fBmid\fR ( uint index, uint len = 0xffffffff ) const"
.br
.ti -1c
.BI "QString \fBleftJustify\fR ( uint width, QChar fill = ' ', bool truncate = FALSE ) const"
.br
.ti -1c
.BI "QString \fBrightJustify\fR ( uint width, QChar fill = ' ', bool truncate = FALSE ) const"
.br
.ti -1c
.BI "QString \fBlower\fR () const"
.br
.ti -1c
.BI "QString \fBupper\fR () const"
.br
.ti -1c
.BI "QString \fBstripWhiteSpace\fR () const"
.br
.ti -1c
.BI "QString \fBsimplifyWhiteSpace\fR () const"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, const QString & s )"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, const QByteArray & s )"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, const char * s )"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, const QChar * s, uint len )"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, QChar c )"
.br
.ti -1c
.BI "QString & \fBinsert\fR ( uint index, char c )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( char ch )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( QChar ch )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( const QString & str )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( const QByteArray & str )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( const char * str )"
.br
.ti -1c
.BI "QString & \fBappend\fR ( const std::string & str )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( char ch )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( QChar ch )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( const QString & s )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( const QByteArray & s )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( const char * s )"
.br
.ti -1c
.BI "QString & \fBprepend\fR ( const std::string & s )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( uint index, uint len )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( const QString & str, bool cs = TRUE )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( QChar c )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( char c )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( const char * str )"
.br
.ti -1c
.BI "QString & \fBremove\fR ( const QRegExp & rx )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( uint index, uint len, const QString & s )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( uint index, uint len, const QChar * s, uint slen )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( uint index, uint len, QChar c )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( uint index, uint len, char c )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( QChar c, const QString & after, bool cs = TRUE )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( char c, const QString & after, bool cs = TRUE )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( const QString & before, const QString & after, bool cs = TRUE )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( const QRegExp & rx, const QString & after )"
.br
.ti -1c
.BI "QString & \fBreplace\fR ( QChar c1, QChar c2 )"
.br
.ti -1c
.BI "short \fBtoShort\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "ushort \fBtoUShort\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "int \fBtoInt\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "uint \fBtoUInt\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "long \fBtoLong\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "ulong \fBtoULong\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "Q_LLONG \fBtoLongLong\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "Q_ULLONG \fBtoULongLong\fR ( bool * ok = 0, int base = 10 ) const"
.br
.ti -1c
.BI "float \fBtoFloat\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "double \fBtoDouble\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( short n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( ushort n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( int n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( uint n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( long n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( ulong n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( Q_LLONG n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( Q_ULLONG n, int base = 10 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( float n, char f = 'g', int prec = 6 )"
.br
.ti -1c
.BI "QString & \fBsetNum\fR ( double n, char f = 'g', int prec = 6 )"
.br
.ti -1c
.BI "void setExpand ( uint index, QChar c )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( const QString & str )"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( const QByteArray & str )"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( const char * str )"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( const std::string & str )"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( QChar c )"
.br
.ti -1c
.BI "QString & \fBoperator+=\fR ( char c )"
.br
.ti -1c
.BI "QChar \fBat\fR ( uint i ) const"
.br
.ti -1c
.BI "QChar \fBoperator[]\fR ( int i ) const"
.br
.ti -1c
.BI "QCharRef \fBat\fR ( uint i )"
.br
.ti -1c
.BI "QCharRef \fBoperator[]\fR ( int i )"
.br
.ti -1c
.BI "QChar \fBconstref\fR ( uint i ) const"
.br
.ti -1c
.BI "QChar & \fBref\fR ( uint i )"
.br
.ti -1c
.BI "const QChar * \fBunicode\fR () const"
.br
.ti -1c
.BI "const char * \fBascii\fR () const"
.br
.ti -1c
.BI "const char * \fBlatin1\fR () const"
.br
.ti -1c
.BI "QCString \fButf8\fR () const"
.br
.ti -1c
.BI "QCString \fBlocal8Bit\fR () const"
.br
.ti -1c
.BI "bool \fBoperator!\fR () const"
.br
.ti -1c
.BI "\fBoperator const char *\fR () const"
.br
.ti -1c
.BI "\fBoperator std::string\fR () const"
.br
.ti -1c
.BI "const unsigned short * \fBucs2\fR () const"
.br
.ti -1c
.BI "QString & \fBsetUnicode\fR ( const QChar * unicode, uint len )"
.br
.ti -1c
.BI "QString & \fBsetUnicodeCodes\fR ( const ushort * unicode_as_ushorts, uint len )"
.br
.ti -1c
.BI "QString & \fBsetAscii\fR ( const char * str, int len = -1 )"
.br
.ti -1c
.BI "QString & \fBsetLatin1\fR ( const char * str, int len = -1 )"
.br
.ti -1c
.BI "int \fBcompare\fR ( const QString & s ) const"
.br
.ti -1c
.BI "int \fBlocaleAwareCompare\fR ( const QString & s ) const"
.br
.ti -1c
.BI "void \fBcompose\fR ()"
.br
.ti -1c
.BI "const char * data () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "bool \fBstartsWith\fR ( const QString & s, bool cs = TRUE ) const"
.br
.ti -1c
.BI "bool \fBendsWith\fR ( const QString & s, bool cs = TRUE ) const"
.br
.ti -1c
.BI "void \fBsetLength\fR ( uint newLen )"
.br
.ti -1c
.BI "uint \fBcapacity\fR () const"
.br
.ti -1c
.BI "void \fBreserve\fR ( uint minCapacity )"
.br
.ti -1c
.BI "void \fBsqueeze\fR ()"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QString \fBnumber\fR ( long n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( ulong n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( Q_LLONG n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( Q_ULLONG n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( int n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( uint n, int base = 10 )"
.br
.ti -1c
.BI "QString \fBnumber\fR ( double n, char f = 'g', int prec = 6 )"
.br
.ti -1c
.BI "QString \fBfromAscii\fR ( const char * ascii, int len = -1 )"
.br
.ti -1c
.BI "QString \fBfromLatin1\fR ( const char * chars, int len = -1 )"
.br
.ti -1c
.BI "QString \fBfromUtf8\fR ( const char * utf8, int len = -1 )"
.br
.ti -1c
.BI "QString \fBfromLocal8Bit\fR ( const char * local8Bit, int len = -1 )"
.br
.ti -1c
.BI "QString \fBfromUcs2\fR ( const unsigned short * str )"
.br
.ti -1c
.BI "int \fBcompare\fR ( const QString & s1, const QString & s2 )"
.br
.ti -1c
.BI "int \fBlocaleAwareCompare\fR ( const QString & s1, const QString & s2 )"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "bool \fBoperator==\fR ( const QString & s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QString & s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator<\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator<\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator<=\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator<=\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator>\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator>\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator>=\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator>=\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "const QString \fBoperator+\fR ( const QString & s1, const QString & s2 )"
.br
.ti -1c
.BI "const QString \fBoperator+\fR ( const QString & s1, const char * s2 )"
.br
.ti -1c
.BI "const QString \fBoperator+\fR ( const char * s1, const QString & s2 )"
.br
.ti -1c
.BI "const QString \fBoperator+\fR ( const QString & s, char c )"
.br
.ti -1c
.BI "const QString \fBoperator+\fR ( char c, const QString & s )"
.br
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QString & str )"
.br
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QString & str )"
.br
.in -1c
.SH DESCRIPTION
The QString class provides an abstraction of Unicode text and the classic C '&#92;0'-terminated char array.
.PP
QString uses implicit sharing, which makes it very efficient and easy to use.
.PP
In all of the QString methods that take \fCconst char *\fR parameters, the \fCconst char *\fR is interpreted as a classic C-style '&#92;0'-terminated ASCII string. It is legal for the \fCconst char *\fR parameter to be 0. If the \fCconst char *\fR is not '&#92;0'-terminated, the results are undefined. Functions that copy classic C strings into a QString will not copy the terminating '&#92;0' character. The QChar array of the QString (as returned by unicode()) is generally not terminated by a '&#92;0'. If you need to pass a QString to a function that requires a C '&#92;0'-terminated string use latin1().
.PP
A QString that has not been assigned to anything is \fInull\fR, i.e. both the length and data pointer is 0. A QString that references the empty string ("", a single '&#92;0' char) is \fIempty\fR. Both null and empty QStrings are legal parameters to the methods. Assigning \fC(const char *) 0\fR to QString gives a null QString. For convenience, QString::null is a null QString. When sorting, empty strings come first, followed by non-empty strings, followed by null strings. We recommend using \fCif ( !str.isNull() )\fR to check for a non-null string rather than \fCif ( !str )\fR; see operator!() for an explanation.
.PP
Note that if you find that you are mixing usage of QCString, QString, and QByteArray, this causes lots of unnecessary copying and might indicate that the true nature of the data you are dealing with is uncertain. If the data is '&#92;0'-terminated 8-bit data, use QCString; if it is unterminated (i.e. contains '&#92;0's) 8-bit data, use QByteArray; if it is text, use QString.
.PP
Lists of strings are handled by the QStringList class. You can split a string into a list of strings using QStringList::split(), and join a list of strings into a single string with an optional separator using QStringList::join(). You can obtain a list of strings from a string list that contain a particular substring or that match a particular regex using QStringList::grep().
.PP
\fBNote for C programmers\fR
.PP
Due to C++'s type system and the fact that QString is implicitly shared, QStrings can be treated like ints or other simple base types. For example:
.PP
.nf
.br
    QString boolToString( bool b )
.br
    {
.br
        QString result;
.br
        if ( b )
.br
            result = "True";
.br
        else
.br
            result = "False";
.br
        return result;
.br
    }
.br
.fi
.PP
The variable, result, is an auto variable allocated on the stack. When return is called, because we're returning by value, The copy constructor is called and a copy of the string is returned. (No actual copying takes place thanks to the implicit sharing, see below.)
.PP
Throughout Qt's source code you will encounter QString usages like this:
.PP
.nf
.br
    QString func( const QString& input )
.br
    {
.br
        QString output = input;
.br
        // process output
.br
        return output;
.br
    }
.br
.fi
.PP
The 'copying' of input to output is almost as fast as copying a pointer because behind the scenes copying is achieved by incrementing a reference count. QString (like all Qt's implicitly shared classes) operates on a copy-on-write basis, only copying if an instance is actually changed.
.PP
If you wish to create a deep copy of a QString without losing any Unicode information then you should use QDeepCopy.
.PP
See also QChar, QCString, QByteArray, QConstString, Implicitly and Explicitly Shared Classes, Text Related Classes, and Non-GUI Classes.
.SS "Member Type Documentation"
.SH "QString::SectionFlags"
.TP
\fCQString::SectionDefault\fR - Empty fields are counted, leading and trailing separators are not included, and the separator is compared case sensitively.
.TP
\fCQString::SectionSkipEmpty\fR - Treat empty fields as if they don't exist, i.e. they are not considered as far as \fIstart\fR and \fIend\fR are concerned.
.TP
\fCQString::SectionIncludeLeadingSep\fR - Include the leading separator (if any) in the result string.
.TP
\fCQString::SectionIncludeTrailingSep\fR - Include the trailing separator (if any) in the result string.
.TP
\fCQString::SectionCaseInsensitiveSeps\fR - Compare the separator case-insensitively.
.PP
Any of the last four values can be OR-ed together to form a flag.
.PP
See also section().
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QString::QString ()"
Constructs a null string, i.e. both the length and data pointer are 0.
.PP
See also isNull().
.SH "QString::QString ( QChar ch )"
Constructs a string of length one, containing the character \fIch\fR.
.SH "QString::QString ( const QString & s )"
Constructs an implicitly shared copy of \fIs\fR. This is very fast since it only involves incrementing a reference count.
.SH "QString::QString ( const QByteArray & ba )"
Constructs a string that is a deep copy of \fIba\fR interpreted as a classic C string.
.SH "QString::QString ( const QChar * unicode, uint length )"
Constructs a string that is a deep copy of the first \fIlength\fR characters in the QChar array.
.PP
If \fIunicode\fR and \fIlength\fR are 0, then a null string is created.
.PP
If only \fIunicode\fR is 0, the string is empty but has \fIlength\fR characters of space preallocated: QString expands automatically anyway, but this may speed up some cases a little. We recommend using the plain constructor and setLength() for this purpose since it will result in more readable code.
.PP
See also isNull() and setLength().
.SH "QString::QString ( const char * str )"
Constructs a string that is a deep copy of \fIstr\fR, interpreted as a classic C string. The encoding is assumed to be Latin-1, unless you change it using QTextCodec::setCodecForCStrings().
.PP
If \fIstr\fR is 0, then a null string is created.
.PP
This is a cast constructor, but it is perfectly safe: converting a Latin-1 \fCconst char *\fR to QString preserves all the information. You can disable this constructor by defining \fCQT_NO_CAST_ASCII\fR when you compile your applications. You can also make QString objects by using setLatin1(), fromLatin1(), fromLocal8Bit(), and fromUtf8(). Or whatever encoding is appropriate for the 8-bit data you have.
.PP
See also isNull() and fromAscii().
.SH "QString::QString ( const std::string & str )"
Constructs a string that is a deep copy of \fIstr\fR.
.PP
This is the same as fromAscii(\fIstr\fR).
.SH "QString::~QString ()"
Destroys the string and frees the string's data if this is the last reference to the string.
.SH "QString & QString::append ( const QString & str )"
Appends \fIstr\fR to the string and returns a reference to the result.
.PP
.nf
.br
        string = "Test";
.br
        string.append( "ing" );        // string == "Testing"
.br
.fi
.PP
Equivalent to operator+=().
.PP
Example: dirview/dirview.cpp.
.SH "QString & QString::append ( char ch )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends character \fIch\fR to the string and returns a reference to the result.
.PP
Equivalent to operator+=().
.SH "QString & QString::append ( QChar ch )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends character \fIch\fR to the string and returns a reference to the result.
.PP
Equivalent to operator+=().
.SH "QString & QString::append ( const QByteArray & str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the result.
.PP
Equivalent to operator+=().
.SH "QString & QString::append ( const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the result.
.PP
Equivalent to operator+=().
.SH "QString & QString::append ( const std::string & str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the result.
.PP
Equivalent to operator+=().
.SH "QString QString::arg ( const QString & a, int fieldWidth = 0 ) const"
This function will return a string that replaces the lowest numbered occurrence of \fC%1\fR, \fC%2\fR, ..., \fC%9\fR with \fIa\fR.
.PP
The \fIfieldWidth\fR value specifies the minimum amount of space that \fIa\fR is padded to. A positive value will produce right-aligned text, whereas a negative value will produce left-aligned text.
.PP
The following example shows how we could create a 'status' string when processing a list of files:
.PP
.nf
.br
    QString status = QString( "Processing file %1 of %2: %3" )
.br
                        .arg( i )         // current file's number
.br
                        .arg( total )     // number of files to process
.br
                        .arg( fileName ); // current file's name
.br
.fi
.PP
It is generally fine to use filenames and numbers as we have done in the example above. But note that using arg() to construct natural language sentences does not usually translate well into other languages because sentence structure and word order often differ between languages.
.PP
If there is no place marker (\fC%1\fR, \fC%2\fR, etc.), a warning message (qWarning()) is output and the result is undefined.
.PP
\fBWarning:\fR If any placeholder occurs more than once, the result is undefined.
.SH "QString QString::arg ( long a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
The \fIfieldWidth\fR value specifies the minimum amount of space that \fIa\fR is padded to. A positive value will produce a right-aligned number, whereas a negative value will produce a left-aligned number.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36.
.PP
The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of \fIa\fR. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using QLocale::setDefault(). The 'L' flag is ignored if \fIbase\fR is not 10.
.PP
.nf
.br
        QString str;
.br
        str = QString( "Decimal 63 is %1 in hexadecimal" )
.br
                .arg( 63, 0, 16 );
.br
        // str == "Decimal 63 is 3f in hexadecimal"
.br
.br
        QLocale::setDefault(QLocale::English, QLocale::UnitedStates);
.br
        str = QString( "%1 %L2 %L3" )
.br
                .arg( 12345 )
.br
                .arg( 12345 )
.br
                .arg( 12345, 0, 16 );
.br
        // str == "12345 12,345 3039"
.br
.fi
.SH "QString QString::arg ( ulong a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( Q_LLONG a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( Q_ULLONG a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( int a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( uint a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( short a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( ushort a, int fieldWidth = 0, int base = 10 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is expressed in base \fIbase\fR, which is 10 by default and must be between 2 and 36. If \fIbase\fR is 10, the '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( double a, int fieldWidth = 0, char fmt = 'g', int prec = -1 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Argument \fIa\fR is formatted according to the \fIfmt\fR format specified, which is 'g' by default and can be any of the following:
.PP
<center>.nf
.TS
l - l. Format Meaning format as [-]9.9e[+|-]999 format as [-]9.9E[+|-]999 format as [-]9.9 use use
.TE
.fi
</center>
.PP
With 'e', 'E', and 'f', \fIprec\fR is the number of digits after the decimal point. With 'g' and 'G', \fIprec\fR is the maximum number of significant digits (trailing zeroes are omitted).
.PP
.nf
.br
        double d = 12.34;
.br
        QString ds = QString( "'E' format, precision 3, gives %1" )
.br
                        .arg( d, 0, 'E', 3 );
.br
        // ds == "'E' format, precision 3, gives 1.234E+01"
.br
.fi
.PP
The '%L' syntax can be used to produce localized strings.
.SH "QString QString::arg ( char a, int fieldWidth = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR is assumed to be in the Latin-1 character set.
.SH "QString QString::arg ( QChar a, int fieldWidth = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QString QString::arg ( const QString & a1, const QString & a2 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This is the same as str.arg(\fIa1\fR).arg(\fIa2\fR), except that the strings are replaced in one pass. This can make a difference if \fIa1\fR contains e.g. \fC%1\fR:
.PP
.nf
.br
    QString str( "%1 %2" );
.br
    str.arg( "Hello", "world" );        // returns "Hello world"
.br
    str.arg( "Hello" ).arg( "world" );  // returns "Hello world"
.br
.br
    str.arg( "(%1)", "Hello" );           // returns "(%1) Hello"
.br
    str.arg( "(%1)" ).arg( "Hello" );     // returns "(Hello) %2"
.br
.fi
.SH "QString QString::arg ( const QString & a1, const QString & a2, const QString & a3 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This is the same as calling str.arg(\fIa1\fR).arg(\fIa2\fR).arg(\fIa3\fR), except that the strings are replaced in one pass.
.SH "QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This is the same as calling str.arg(\fIa1\fR).arg(\fIa2\fR).arg(\fIa3\fR).arg(\fIa4\fR), except that the strings are replaced in one pass.
.SH "const char * QString::ascii () const"
Returns an 8-bit ASCII representation of the string.
.PP
If a codec has been set using QTextCodec::codecForCStrings(), it is used to convert Unicode to 8-bit char. Otherwise, this function does the same as latin1().
.PP
See also fromAscii(), latin1(), utf8(), and local8Bit().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QChar QString::at ( uint i ) const"
Returns the character at index \fIi\fR, or 0 if \fIi\fR is beyond the length of the string.
.PP
.nf
.br
        const QString string( "abcdefgh" );
.br
        QChar ch = string.at( 4 );
.br
        // ch == 'e'
.br
.fi
.PP
If the QString is not const (i.e. const QString) or const& (i.e. const QString &), then the non-const overload of at() will be used instead.
.SH "QCharRef QString::at ( uint i )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
The function returns a reference to the character at index \fIi\fR. The resulting reference can then be assigned to, or used immediately, but it will become invalid once further modifications are made to the original string.
.PP
If \fIi\fR is beyond the length of the string then the string is expanded with QChar::null.
.SH "uint QString::capacity () const"
Returns the number of characters this string can hold in the allocated memory.
.PP
See also reserve() and squeeze().
.SH "int QString::compare ( const QString & s1, const QString & s2 )\fC [static]\fR"
Lexically compares \fIs1\fR with \fIs2\fR and returns an integer less than, equal to, or greater than zero if \fIs1\fR is less than, equal to, or greater than \fIs2\fR.
.PP
The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with QString::localeAwareCompare().
.PP
.nf
.br
        int a = QString::compare( "def", "abc" );   // a > 0
.br
        int b = QString::compare( "abc", "def" );   // b < 0
.br
        int c = QString::compare( "abc", "abc" );   // c == 0
.br
.fi
.SH "int QString::compare ( const QString & s ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Lexically compares this string with \fIs\fR and returns an integer less than, equal to, or greater than zero if it is less than, equal to, or greater than \fIs\fR.
.SH "void QString::compose ()"
\fBWarning:\fR This function is not supported in Qt 3.x. It is provided for experimental and illustrative purposes only. It is mainly of interest to those experimenting with Arabic and other composition-rich texts.
.PP
Applies possible ligatures to a QString. Useful when composition-rich text requires rendering with glyph-poor fonts, but it also makes compositions such as QChar(0x0041) ('A') and QChar(0x0308) (Unicode accent diaresis), giving QChar(0x00c4) (German A Umlaut).
.SH "QChar QString::constref ( uint i ) const"
Returns the QChar at index \fIi\fR by value.
.PP
Equivalent to at(\fIi\fR).
.PP
See also ref().
.SH "int QString::contains ( QChar c, bool cs = TRUE ) const"
Returns the number of times the character \fIc\fR occurs in the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
.nf
.br
    QString string( "Trolltech and Qt" );
.br
    int n = string.contains( 't', FALSE );
.br
    // n == 3
.br
.fi
.PP
Examples:
.)l fileiconview/qfileiconview.cpp and mdi/application.cpp.
.SH "int QString::contains ( char c, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "int QString::contains ( const char * str, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the number of times the string \fIstr\fR occurs in the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.SH "int QString::contains ( const QString & str, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the number of times \fIstr\fR occurs in the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
This function counts overlapping strings, so in the example below, there are two instances of "ana" in "bananas".
.PP
.nf
.br
    QString str( "bananas" );
.br
    int i = str.contains( "ana" );  // i == 2
.br
.fi
.PP
See also findRev().
.SH "int QString::contains ( const QRegExp & rx ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the number of times the regexp, \fIrx\fR, matches in the string.
.PP
This function counts overlapping matches, so in the example below, there are four instances of "ana" or "ama".
.PP
.nf
.br
        QString str = "banana and panama";
.br
        QRegExp rxp = QRegExp( "a[nm]a", TRUE, FALSE );
.br
        int i = str.contains( rxp );    // i == 4
.br
.fi
.PP
See also find() and findRev().
.SH "QString QString::copy () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
In Qt 2.0 and later, all calls to this function are needless. Just remove them.
.SH "const char * QString::data () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns a pointer to a '&#92;0'-terminated classic C string.
.PP
In Qt 1.x, this returned a char* allowing direct manipulation of the string as a sequence of bytes. In Qt 2.x where QString is a Unicode string, char* conversion constructs a temporary string, and hence direct character operations are meaningless.
.SH "bool QString::endsWith ( const QString & s, bool cs = TRUE ) const"
Returns TRUE if the string ends with \fIs\fR; otherwise returns FALSE.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
.nf
.br
        QString str( "Bananas" );
.br
        str.endsWith( "anas" );         // returns TRUE
.br
        str.endsWith( "pple" );         // returns FALSE
.br
.fi
.PP
See also startsWith().
.PP
Example: chart/main.cpp.
.SH "QString & QString::fill ( QChar c, int len = -1 )"
Fills the string with \fIlen\fR characters of value \fIc\fR, and returns a reference to the string.
.PP
If \fIlen\fR is negative (the default), the current string length is used.
.PP
.nf
.br
        QString str;
.br
        str.fill( 'g', 5 );      // string == "ggggg"
.br
.fi
.SH "int QString::find ( const QRegExp & rx, int index = 0 ) const"
Finds the first match of the regular expression \fIrx\fR, starting from position \fIindex\fR. If \fIindex\fR is -1, the search starts at the last character; if -2, at the next to last character and so on. (See findRev() for searching backwards.)
.PP
Returns the position of the first match of \fIrx\fR or -1 if no match was found.
.PP
.nf
.br
        QString string( "bananas" );
.br
        int i = string.find( QRegExp("an"), 0 );    // i == 1
.br
.fi
.PP
See also findRev(), replace(), and contains().
.PP
Example: network/mail/smtp.cpp.
.SH "int QString::find ( QChar c, int index = 0, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the character \fIc\fR, starting at position \fIindex\fR. If \fIindex\fR is -1, the search starts at the last character; if -2, at the next to last character and so on. (See findRev() for searching backwards.)
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
Returns the position of \fIc\fR or -1 if \fIc\fR could not be found.
.SH "int QString::find ( char c, int index = 0, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Find character \fIc\fR starting from position \fIindex\fR.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.SH "int QString::find ( const QString & str, int index = 0, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the string \fIstr\fR, starting at position \fIindex\fR. If \fIindex\fR is -1, the search starts at the last character, if it is -2, at the next to last character and so on. (See findRev() for searching backwards.)
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
Returns the position of \fIstr\fR or -1 if \fIstr\fR could not be found.
.SH "int QString::find ( const char * str, int index = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Equivalent to find(QString(\fIstr\fR), \fIindex\fR).
.SH "int QString::findRev ( const char * str, int index = -1 ) const"
Equivalent to findRev(QString(\fIstr\fR), \fIindex\fR).
.SH "int QString::findRev ( QChar c, int index = -1, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the character \fIc\fR, starting at position \fIindex\fR and searching backwards. If the index is -1, the search starts at the last character, if it is -2, at the next to last character and so on.
.PP
Returns the position of \fIc\fR or -1 if \fIc\fR could not be found.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
.nf
.br
        QString string( "bananas" );
.br
        int i = string.findRev( 'a' );      // i == 5
.br
.fi
.SH "int QString::findRev ( char c, int index = -1, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Find character \fIc\fR starting from position \fIindex\fR and working backwards.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.SH "int QString::findRev ( const QString & str, int index = -1, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the string \fIstr\fR, starting at position \fIindex\fR and searching backwards. If the index is -1, the search starts at the last character, if it is -2, at the next to last character and so on.
.PP
Returns the position of \fIstr\fR or -1 if \fIstr\fR could not be found.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
.nf
.br
    QString string("bananas");
.br
    int i = string.findRev( "ana" );      // i == 3
.br
.fi
.SH "int QString::findRev ( const QRegExp & rx, int index = -1 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first match of the regexp \fIrx\fR, starting at position \fIindex\fR and searching backwards. If the index is -1, the search starts at the last character, if it is -2, at the next to last character and so on. (See findRev() for searching backwards.)
.PP
Returns the position of the match or -1 if no match was found.
.PP
.nf
.br
        QString string( "bananas" );
.br
        int i = string.findRev( QRegExp("an") );      // i == 3
.br
.fi
.PP
See also find().
.SH "QString QString::fromAscii ( const char * ascii, int len = -1 )\fC [static]\fR"
Returns the Unicode string decoded from the first \fIlen\fR bytes of \fIascii\fR, ignoring the rest of \fIascii\fR. If \fIlen\fR is -1 then the length of \fIascii\fR is used. If \fIlen\fR is bigger than the length of \fIascii\fR then it will use the length of \fIascii\fR.
.PP
If a codec has been set using QTextCodec::codecForCStrings(), it is used to convert the string from 8-bit characters to Unicode. Otherwise, this function does the same as fromLatin1().
.PP
This is the same as the QString(const char*) constructor, but you can make that constructor invisible if you compile with the define \fCQT_NO_CAST_ASCII\fR, in which case you can explicitly create a QString from 8-bit ASCII text using this function.
.PP
.nf
.br
        QString str = QString::fromAscii( "123456789", 5 );
.br
        // str == "12345"
.br
.fi
.SH "QString QString::fromLatin1 ( const char * chars, int len = -1 )\fC [static]\fR"
Returns the Unicode string decoded from the first \fIlen\fR bytes of \fIchars\fR, ignoring the rest of \fIchars\fR. If \fIlen\fR is -1 then the length of \fIchars\fR is used. If \fIlen\fR is bigger than the length of \fIchars\fR then it will use the length of \fIchars\fR.
.PP
See also fromAscii().
.PP
Examples:
.)l listbox/listbox.cpp and network/mail/smtp.cpp.
.SH "QString QString::fromLocal8Bit ( const char * local8Bit, int len = -1 )\fC [static]\fR"
Returns the Unicode string decoded from the first \fIlen\fR bytes of \fIlocal8Bit\fR, ignoring the rest of \fIlocal8Bit\fR. If \fIlen\fR is -1 then the length of \fIlocal8Bit\fR is used. If \fIlen\fR is bigger than the length of \fIlocal8Bit\fR then it will use the length of \fIlocal8Bit\fR.
.PP
.nf
.br
        QString str = QString::fromLocal8Bit( "123456789", 5 );
.br
        // str == "12345"
.br
.fi
.PP
\fIlocal8Bit\fR is assumed to be encoded in a locale-specific format.
.PP
See QTextCodec for more diverse coding/decoding of Unicode strings.
.SH "QString QString::fromUcs2 ( const unsigned short * str )\fC [static]\fR"
Constructs a string that is a deep copy of \fIstr\fR, interpreted as a UCS2 encoded, zero terminated, Unicode string.
.PP
If \fIstr\fR is 0, then a null string is created.
.PP
See also isNull().
.SH "QString QString::fromUtf8 ( const char * utf8, int len = -1 )\fC [static]\fR"
Returns the Unicode string decoded from the first \fIlen\fR bytes of \fIutf8\fR, ignoring the rest of \fIutf8\fR. If \fIlen\fR is -1 then the length of \fIutf8\fR is used. If \fIlen\fR is bigger than the length of \fIutf8\fR then it will use the length of \fIutf8\fR.
.PP
.nf
.br
        QString str = QString::fromUtf8( "123456789", 5 );
.br
        // str == "12345"
.br
.fi
.PP
See QTextCodec for more diverse coding/decoding of Unicode strings.
.PP
Example: fonts/simple-qfont-demo/viewer.cpp.
.SH "QString & QString::insert ( uint index, const QString & s )"
Inserts \fIs\fR into the string at position \fIindex\fR.
.PP
If \fIindex\fR is beyond the end of the string, the string is extended with spaces to length \fIindex\fR and \fIs\fR is then appended and returns a reference to the string.
.PP
.nf
.br
        QString string( "I like fish" );
.br
        str = string.insert( 2, "don't " );
.br
        // str == "I don't like fish"
.br
.fi
.PP
See also remove() and replace().
.PP
Examples:
.)l themes/themes.cpp and xform/xform.cpp.
.SH "QString & QString::insert ( uint index, const QByteArray & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIs\fR into the string at position \fIindex\fR and returns a reference to the string.
.SH "QString & QString::insert ( uint index, const char * s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIs\fR into the string at position \fIindex\fR and returns a reference to the string.
.SH "QString & QString::insert ( uint index, const QChar * s, uint len )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts the first \fIlen\fR characters in \fIs\fR into the string at position \fIindex\fR and returns a reference to the string.
.SH "QString & QString::insert ( uint index, QChar c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Insert \fIc\fR into the string at position \fIindex\fR and returns a reference to the string.
.PP
If \fIindex\fR is beyond the end of the string, the string is extended with spaces (ASCII 32) to length \fIindex\fR and \fIc\fR is then appended.
.SH "QString & QString::insert ( uint index, char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Insert character \fIc\fR at position \fIindex\fR.
.SH "bool QString::isEmpty () const"
Returns TRUE if the string is empty, i.e. if length() == 0; otherwise returns FALSE. Null strings are also empty.
.PP
.nf
.br
        QString a( "" );
.br
        a.isEmpty();        // TRUE
.br
        a.isNull();         // FALSE
.br
.br
        QString b;
.br
        b.isEmpty();        // TRUE
.br
        b.isNull();         // TRUE
.br
.fi
.PP
See also isNull() and length().
.PP
Examples:
.)l addressbook/mainwindow.cpp, chart/chartform.cpp, chart/chartform_canvas.cpp, network/networkprotocol/nntp.cpp, qmag/qmag.cpp, and qwerty/qwerty.cpp.
.SH "bool QString::isNull () const"
Returns TRUE if the string is null; otherwise returns FALSE. A null string is always empty.
.PP
.nf
.br
        QString a;          // a.unicode() == 0, a.length() == 0
.br
        a.isNull();         // TRUE, because a.unicode() == 0
.br
        a.isEmpty();        // TRUE, because a.length() == 0
.br
.fi
.PP
See also isEmpty() and length().
.PP
Examples:
.)l i18n/main.cpp, network/ftpclient/ftpmainwindow.ui.h, and qdir/qdir.cpp.
.SH "const char * QString::latin1 () const"
Returns a Latin-1 representation of the string. The returned value is undefined if the string contains non-Latin-1 characters. If you want to convert strings into formats other than Unicode, see the QTextCodec classes.
.PP
This function is mainly useful for boot-strapping legacy code to use Unicode.
.PP
The result remains valid so long as one unmodified copy of the source string exists.
.PP
See also fromLatin1(), ascii(), utf8(), and local8Bit().
.PP
Examples:
.)l fileiconview/qfileiconview.cpp and network/networkprotocol/nntp.cpp.
.SH "QString QString::left ( uint len ) const"
Returns a substring that contains the \fIlen\fR leftmost characters of the string.
.PP
The whole string is returned if \fIlen\fR exceeds the length of the string.
.PP
.nf
.br
        QString s = "Pineapple";
.br
        QString t = s.left( 4 );    // t == "Pine"
.br
.fi
.PP
See also right(), mid(), and isEmpty().
.PP
Example: themes/themes.cpp.
.SH "QString QString::leftJustify ( uint width, QChar fill = ' ', bool truncate = FALSE ) const"
Returns a string of length \fIwidth\fR that contains this string padded by the \fIfill\fR character.
.PP
If \fItruncate\fR is FALSE and the length of the string is more than \fIwidth\fR, then the returned string is a copy of the string.
.PP
If \fItruncate\fR is TRUE and the length of the string is more than \fIwidth\fR, then any characters in a copy of the string after length \fIwidth\fR are removed, and the copy is returned.
.PP
.nf
.br
        QString s( "apple" );
.br
        QString t = s.leftJustify( 8, '.' );        // t == "apple..."
.br
.fi
.PP
See also rightJustify().
.SH "uint QString::length () const"
Returns the length of the string.
.PP
Null strings and empty strings have zero length.
.PP
See also isNull() and isEmpty().
.PP
Examples:
.)l dirview/dirview.cpp, fileiconview/qfileiconview.cpp, network/networkprotocol/nntp.cpp, rot13/rot13.cpp, and themes/themes.cpp.
.SH "QCString QString::local8Bit () const"
Returns the string encoded in a locale-specific format. On X11, this is the QTextCodec::codecForLocale(). On Windows, it is a system-defined encoding. On Mac OS X, this always uses UTF-8 as the encoding.
.PP
See QTextCodec for more diverse coding/decoding of Unicode strings.
.PP
See also fromLocal8Bit(), ascii(), latin1(), and utf8().
.SH "int QString::localeAwareCompare ( const QString & s1, const QString & s2 )\fC [static]\fR"
Compares \fIs1\fR with \fIs2\fR and returns an integer less than, equal to, or greater than zero if \fIs1\fR is less than, equal to, or greater than \fIs2\fR.
.PP
The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.
.PP
See also QString::compare() and QTextCodec::locale().
.SH "int QString::localeAwareCompare ( const QString & s ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Compares this string with \fIs\fR.
.SH "QString QString::lower () const"
Returns a lowercase copy of the string.
.PP
.nf
.br
        QString string( "TROlltECH" );
.br
        str = string.lower();   // str == "trolltech"
.br
.fi
.PP
See also upper().
.PP
Example: scribble/scribble.cpp.
.SH "QString QString::mid ( uint index, uint len = 0xffffffff ) const"
Returns a string that contains the \fIlen\fR characters of this string, starting at position \fIindex\fR.
.PP
Returns a null string if the string is empty or \fIindex\fR is out of range. Returns the whole string from \fIindex\fR if \fIindex\fR + \fIlen\fR exceeds the length of the string.
.PP
.nf
.br
        QString s( "Five pineapples" );
.br
        QString t = s.mid( 5, 4 );                  // t == "pine"
.br
.fi
.PP
See also left() and right().
.PP
Examples:
.)l network/mail/smtp.cpp, qmag/qmag.cpp, and themes/themes.cpp.
.SH "QString QString::number ( long n, int base = 10 )\fC [static]\fR"
A convenience function that returns a string equivalent of the number \fIn\fR to base \fIbase\fR, which is 10 by default and must be between 2 and 36. The returned string is in "C" locale.
.PP
.nf
.br
        long a = 63;
.br
        QString str = QString::number( a, 16 );             // str == "3f"
.br
        QString str = QString::number( a, 16 ).upper();     // str == "3F"
.br
.fi
.PP
See also setNum().
.PP
Examples:
.)l application/application.cpp, chart/chartform.cpp, fonts/simple-qfont-demo/viewer.cpp, helpviewer/helpwindow.cpp, mdi/application.cpp, regexptester/regexptester.cpp, and sql/overview/extract/main.cpp.
.SH "QString QString::number ( ulong n, int base = 10 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
See also setNum().
.SH "QString QString::number ( Q_LLONG n, int base = 10 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
See also setNum().
.SH "QString QString::number ( Q_ULLONG n, int base = 10 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
See also setNum().
.SH "QString QString::number ( int n, int base = 10 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
See also setNum().
.SH "QString QString::number ( uint n, int base = 10 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
A convenience factory function that returns a string representation of the number \fIn\fR to the base \fIbase\fR, which is 10 by default and must be between 2 and 36.
.PP
See also setNum().
.SH "QString QString::number ( double n, char f = 'g', int prec = 6 )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Argument \fIn\fR is formatted according to the \fIf\fR format specified, which is \fCg\fR by default, and can be any of the following:
.PP
<center>.nf
.TS
l - l. Format Meaning format as [-]9.9e[+|-]999 format as [-]9.9E[+|-]999 format as [-]9.9 use use
.TE
.fi
</center>
.PP
With 'e', 'E', and 'f', \fIprec\fR is the number of digits after the decimal point. With 'g' and 'G', \fIprec\fR is the maximum number of significant digits (trailing zeroes are omitted).
.PP
.nf
.br
    double d = 12.34;
.br
    QString ds = QString( "'E' format, precision 3, gives %1" )
.br
                    .arg( d, 0, 'E', 3 );
.br
    // ds == "1.234E+001"
.br
.fi
.PP
See also setNum().
.SH "QString::operator const char * () const"
Returns ascii(). Be sure to see the warnings documented in the ascii() function. Note that for new code which you wish to be strictly Unicode-clean, you can define the macro \fCQT_NO_ASCII_CAST\fR when compiling your code to hide this function so that automatic casts are not done. This has the added advantage that you catch the programming error described in operator!().
.SH "QString::operator std::string () const"
Returns ascii() as a std::string.
.PP
\fBWarning:\fR The function may cause an application to crash if a static C run-time is in use. This can happen in Microsoft Visual C++ if Qt is configured as single-threaded. A safe alternative is to call ascii() directly and construct a std::string manually.
.SH "bool QString::operator! () const"
Returns TRUE if this is a null string; otherwise returns FALSE.
.PP
.nf
.br
        QString name = getName();
.br
        if ( !name )
.br
            name = "Rodney";
.br
.fi
.PP
Note that if you say
.PP
.nf
.br
        QString name = getName();
.br
        if ( name )
.br
            doSomethingWith(name);
.br
.fi
.PP
It will call "operator const char*()", which is inefficent; you may wish to define the macro \fCQT_NO_ASCII_CAST\fR when writing code which you wish to remain Unicode-clean.
.PP
When you want the above semantics, use:
.PP
.nf
.br
        QString name = getName();
.br
        if ( !name.isNull() )
.br
            doSomethingWith(name);
.br
.fi
.PP
See also isEmpty().
.SH "QString & QString::operator+= ( const QString & str )"
Appends \fIstr\fR to the string and returns a reference to the string.
.SH "QString & QString::operator+= ( const QByteArray & str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the string.
.SH "QString & QString::operator+= ( const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the string.
.SH "QString & QString::operator+= ( const std::string & str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIstr\fR to the string and returns a reference to the string.
.SH "QString & QString::operator+= ( QChar c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIc\fR to the string and returns a reference to the string.
.SH "QString & QString::operator+= ( char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends \fIc\fR to the string and returns a reference to the string.
.SH "QString & QString::operator= ( QChar c )"
Sets the string to contain just the single character \fIc\fR.
.SH "QString & QString::operator= ( const QString & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns a shallow copy of \fIs\fR to this string and returns a reference to this string. This is very fast because the string isn't actually copied.
.SH "QString & QString::operator= ( const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns a deep copy of \fIstr\fR, interpreted as a classic C string to this string and returns a reference to this string.
.PP
If \fIstr\fR is 0, then a null string is created.
.PP
See also isNull().
.SH "QString & QString::operator= ( const std::string & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Makes a deep copy of \fIs\fR and returns a reference to the deep copy.
.SH "QString & QString::operator= ( const QCString & cstr )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns a deep copy of \fIcstr\fR, interpreted as a classic C string, to this string. Returns a reference to this string.
.SH "QString & QString::operator= ( char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to contain just the single character \fIc\fR.
.SH "QChar QString::operator[] ( int i ) const"
Returns the character at index \fIi\fR, or QChar::null if \fIi\fR is beyond the length of the string.
.PP
If the QString is not const (i.e., const QString) or const& (i.e., const QString&), then the non-const overload of operator[] will be used instead.
.SH "QCharRef QString::operator[] ( int i )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
The function returns a reference to the character at index \fIi\fR. The resulting reference can then be assigned to, or used immediately, but it will become invalid once further modifications are made to the original string.
.PP
If \fIi\fR is beyond the length of the string then the string is expanded with QChar::nulls, so that the QCharRef references a valid (null) character in the string.
.PP
The QCharRef internal class can be used much like a constant QChar, but if you assign to it, you change the original string (which will detach itself because of QString's copy-on-write semantics). You will get compilation errors if you try to use the result as anything but a QChar.
.SH "QString & QString::prepend ( const QString & s )"
Inserts \fIs\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIs\fR).
.PP
.nf
.br
        QString string = "42";
.br
        string.prepend( "The answer is " );
.br
        // string == "The answer is 42"
.br
.fi
.PP
See also insert().
.SH "QString & QString::prepend ( char ch )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIch\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIch\fR).
.PP
See also insert().
.SH "QString & QString::prepend ( QChar ch )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIch\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIch\fR).
.PP
See also insert().
.SH "QString & QString::prepend ( const QByteArray & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIs\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIs\fR).
.PP
See also insert().
.SH "QString & QString::prepend ( const char * s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIs\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIs\fR).
.PP
See also insert().
.SH "QString & QString::prepend ( const std::string & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIs\fR at the beginning of the string and returns a reference to the string.
.PP
Equivalent to insert(0, \fIs\fR).
.PP
See also insert().
.SH "QChar & QString::ref ( uint i )"
Returns the QChar at index \fIi\fR by reference, expanding the string with QChar::null if necessary. The resulting reference can be assigned to, or otherwise used immediately, but becomes invalid once furher modifications are made to the string.
.PP
.nf
.br
        QString string("ABCDEF");
.br
        QChar ch = string.ref( 3 );         // ch == 'D'
.br
.fi
.PP
See also constref().
.SH "QString & QString::remove ( uint index, uint len )"
Removes \fIlen\fR characters from the string starting at position \fIindex\fR, and returns a reference to the string.
.PP
If \fIindex\fR is beyond the length of the string, nothing happens. If \fIindex\fR is within the string, but \fIindex\fR + \fIlen\fR is beyond the end of the string, the string is truncated at position \fIindex\fR.
.PP
.nf
.br
        QString string( "Montreal" );
.br
        string.remove( 1, 4 );      // string == "Meal"
.br
.fi
.PP
See also insert() and replace().
.SH "QString & QString::remove ( const QString & str, bool cs = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes every occurrence of \fIstr\fR in the string. Returns a reference to the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
This is the same as replace(\fIstr\fR, "", \fIcs\fR).
.SH "QString & QString::remove ( QChar c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes every occurrence of the character \fIc\fR in the string. Returns a reference to the string.
.PP
This is the same as replace(\fIc\fR, "").
.SH "QString & QString::remove ( char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes every occurrence of the character \fIc\fR in the string. Returns a reference to the string.
.PP
This is the same as replace(\fIc\fR, "").
.SH "QString & QString::remove ( const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes every occurrence of \fIstr\fR in the string. Returns a reference to the string.
.SH "QString & QString::remove ( const QRegExp & rx )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes every occurrence of the regular expression \fIrx\fR in the string. Returns a reference to the string.
.PP
This is the same as replace(\fIrx\fR, "").
.SH "QString & QString::replace ( uint index, uint len, const QString & s )"
Replaces \fIlen\fR characters from the string with \fIs\fR, starting at position \fIindex\fR, and returns a reference to the string.
.PP
If \fIindex\fR is beyond the length of the string, nothing is deleted and \fIs\fR is appended at the end of the string. If \fIindex\fR is valid, but \fIindex\fR + \fIlen\fR is beyond the end of the string, the string is truncated at position \fIindex\fR, then \fIs\fR is appended at the end.
.PP
.nf
.br
        QString string( "Say yes!" );
.br
        string = string.replace( 4, 3, "NO" );
.br
        // string == "Say NO!"
.br
.fi
.PP
\fBWarning:\fR Qt 3.3.3 and earlier had different semantics for the case \fIindex\fR >= length(), which contradicted the documentation. To avoid portability problems between Qt 3 versions and with Qt 4, we recommend that you never call the function with \fIindex\fR >= length().
.PP
See also insert() and remove().
.PP
Examples:
.)l listviews/listviews.cpp, network/networkprotocol/nntp.cpp, qmag/qmag.cpp, and regexptester/regexptester.cpp.
.SH "QString & QString::replace ( uint index, uint len, const QChar * s, uint slen )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces \fIlen\fR characters with \fIslen\fR characters of QChar data from \fIs\fR, starting at position \fIindex\fR, and returns a reference to the string.
.PP
See also insert() and remove().
.SH "QString & QString::replace ( uint index, uint len, QChar c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This is the same as replace(\fIindex\fR, \fIlen\fR, QString(\fIc\fR)).
.SH "QString & QString::replace ( uint index, uint len, char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This is the same as replace(\fIindex\fR, \fIlen\fR, QChar(\fIc\fR)).
.SH "QString & QString::replace ( QChar c, const QString & after, bool cs = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the character \fIc\fR in the string with \fIafter\fR. Returns a reference to the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
Example:
.PP
.nf
.br
    QString s = "a,b,c";
.br
    s.replace( QChar(','), " or " );
.br
    // s == "a or b or c"
.br
.fi
.SH "QString & QString::replace ( char c, const QString & after, bool cs = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the character \fIc\fR in the string with \fIafter\fR. Returns a reference to the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.SH "QString & QString::replace ( const QString & before, const QString & after, bool cs = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the string \fIbefore\fR in the string with the string \fIafter\fR. Returns a reference to the string.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
Example:
.PP
.nf
.br
    QString s = "Greek is Greek";
.br
    s.replace( "Greek", "English" );
.br
    // s == "English is English"
.br
.fi
.SH "QString & QString::replace ( const QRegExp & rx, const QString & after )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the regexp \fIrx\fR in the string with \fIafter\fR. Returns a reference to the string. For example:
.PP
.nf
.br
    QString s = "banana";
.br
    s.replace( QRegExp("an"), "" );
.br
    // s == "ba"
.br
.fi
.PP
For regexps containing capturing parentheses, occurrences of \fB&#92;1\fR, \fB&#92;2\fR, ..., in \fIafter\fR are replaced with \fIrx\fR.cap(1), cap(2), ...
.PP
.nf
.br
    QString t = "A <i>bon mot</i>.";
.br
    t.replace( QRegExp("<i>([^<]*)</i>"), "\\\\emph{\\\\1}" );
.br
    // t == "A \\\\emph{bon mot}."
.br
.fi
.PP
See also find(), findRev(), and QRegExp::cap().
.SH "QString & QString::replace ( QChar c1, QChar c2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of \fIc1\fR with the char \fIc2\fR. Returns a reference to the string.
.SH "void QString::reserve ( uint minCapacity )"
Ensures that at least \fIminCapacity\fR characters are allocated to the string.
.PP
This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is true, and we're fairly sure that size is big enough:
.PP
.nf
.br
        QString result;
.br
        int len = 0;
.br
        result.reserve(maxLen);
.br
        while (...) {
.br
            result[len++] = ...         // fill part of the space
.br
        }
.br
        result.squeeze();
.br
.fi
.PP
If \fImaxLen\fR is an underestimate, the worst that will happen is that the loop will slow down.
.PP
If it is not possible to allocate enough memory, the string remains unchanged.
.PP
See also capacity(), squeeze(), and setLength().
.SH "QString QString::right ( uint len ) const"
Returns a string that contains the \fIlen\fR rightmost characters of the string.
.PP
If \fIlen\fR is greater than the length of the string then the whole string is returned.
.PP
.nf
.br
        QString string( "Pineapple" );
.br
        QString t = string.right( 5 );   // t == "apple"
.br
.fi
.PP
See also left(), mid(), and isEmpty().
.PP
Example: fileiconview/qfileiconview.cpp.
.SH "QString QString::rightJustify ( uint width, QChar fill = ' ', bool truncate = FALSE ) const"
Returns a string of length \fIwidth\fR that contains the \fIfill\fR character followed by the string.
.PP
If \fItruncate\fR is FALSE and the length of the string is more than \fIwidth\fR, then the returned string is a copy of the string.
.PP
If \fItruncate\fR is TRUE and the length of the string is more than \fIwidth\fR, then the resulting string is truncated at position \fIwidth\fR.
.PP
.nf
.br
        QString string( "apple" );
.br
        QString t = string.rightJustify( 8, '.' );  // t == "...apple"
.br
.fi
.PP
See also leftJustify().
.SH "QString QString::section ( QChar sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
This function returns a section of the string.
.PP
This string is treated as a sequence of fields separated by the character, \fIsep\fR. The returned string consists of the fields from position \fIstart\fR to position \fIend\fR inclusive. If \fIend\fR is not specified, all fields from position \fIstart\fR to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.
.PP
The \fIflags\fR argument can be used to affect some aspects of the function's behaviour, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see SectionFlags.
.PP
.nf
.br
    QString csv( "forename,middlename,surname,phone" );
.br
    QString s = csv.section( ',', 2, 2 );   // s == "surname"
.br
.br
    QString path( "/usr/local/bin/myapp" ); // First field is empty
.br
    QString s = path.section( '/', 3, 4 );  // s == "bin/myapp"
.br
    QString s = path.section( '/', 3, 3, SectionSkipEmpty ); // s == "myapp"
.br
.fi
.PP
If \fIstart\fR or \fIend\fR is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.
.PP
.nf
.br
    QString csv( "forename,middlename,surname,phone" );
.br
    QString s = csv.section( ',', -3, -2 );  // s == "middlename,surname"
.br
.br
    QString path( "/usr/local/bin/myapp" ); // First field is empty
.br
    QString s = path.section( '/', -1 ); // s == "myapp"
.br
.fi
.PP
See also QStringList::split().
.PP
Examples:
.)l chart/element.cpp and network/ftpclient/ftpmainwindow.ui.h.
.SH "QString QString::section ( char sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QString QString::section ( const char * sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QString QString::section ( const QString & sep, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function returns a section of the string.
.PP
This string is treated as a sequence of fields separated by the string, \fIsep\fR. The returned string consists of the fields from position \fIstart\fR to position \fIend\fR inclusive. If \fIend\fR is not specified, all fields from position \fIstart\fR to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.
.PP
The \fIflags\fR argument can be used to affect some aspects of the function's behaviour, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see SectionFlags.
.PP
.nf
.br
    QString data( "forename**middlename**surname**phone" );
.br
    QString s = data.section( "**", 2, 2 ); // s == "surname"
.br
.fi
.PP
If \fIstart\fR or \fIend\fR is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.
.PP
.nf
.br
    QString data( "forename**middlename**surname**phone" );
.br
    QString s = data.section( "**", -3, -2 ); // s == "middlename**surname"
.br
.fi
.PP
See also QStringList::split().
.SH "QString QString::section ( const QRegExp & reg, int start, int end = 0xffffffff, int flags = SectionDefault ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function returns a section of the string.
.PP
This string is treated as a sequence of fields separated by the regular expression, \fIreg\fR. The returned string consists of the fields from position \fIstart\fR to position \fIend\fR inclusive. If \fIend\fR is not specified, all fields from position \fIstart\fR to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.
.PP
The \fIflags\fR argument can be used to affect some aspects of the function's behaviour, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see SectionFlags.
.PP
.nf
.br
    QString line( "forename\\tmiddlename  surname \\t \\t phone" );
.br
    QRegExp sep( "\\s+" );
.br
    QString s = line.section( sep, 2, 2 ); // s == "surname"
.br
.fi
.PP
If \fIstart\fR or \fIend\fR is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.
.PP
.nf
.br
    QString line( "forename\\tmiddlename  surname \\t \\t phone" );
.br
    QRegExp sep( "\\\\s+" );
.br
    QString s = line.section( sep, -3, -2 ); // s == "middlename  surname"
.br
.fi
.PP
\fBWarning:\fR Using this QRegExp version is much more expensive than the overloaded string and character versions.
.PP
See also QStringList::split() and simplifyWhiteSpace().
.SH "QString & QString::setAscii ( const char * str, int len = -1 )"
Sets this string to \fIstr\fR, interpreted as a classic 8-bit ASCII C string. If \fIlen\fR is -1 (the default), then it is set to strlen(str).
.PP
If \fIstr\fR is 0 a null string is created. If \fIstr\fR is "", an empty string is created.
.PP
See also isNull() and isEmpty().
.SH "void QString::setExpand ( uint index, QChar c )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Sets the character at position \fIindex\fR to \fIc\fR and expands the string if necessary, filling with spaces.
.PP
This method is redundant in Qt 3.x, because operator[] will expand the string as necessary.
.SH "QString & QString::setLatin1 ( const char * str, int len = -1 )"
Sets this string to \fIstr\fR, interpreted as a classic Latin-1 C string. If \fIlen\fR is -1 (the default), then it is set to strlen(str).
.PP
If \fIstr\fR is 0 a null string is created. If \fIstr\fR is "", an empty string is created.
.PP
See also isNull() and isEmpty().
.SH "void QString::setLength ( uint newLen )"
Ensures that at least \fInewLen\fR characters are allocated to the string, and sets the length of the string to \fInewLen\fR. Any new space allocated contains arbitrary data.
.PP
See also reserve() and truncate().
.SH "QString & QString::setNum ( Q_LLONG n, int base = 10 )"
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string. The returned string is in "C" locale.
.PP
The base is 10 by default and must be between 2 and 36.
.PP
.nf
.br
        QString string;
.br
        string = string.setNum( 1234 );     // string == "1234"
.br
.fi
.SH "QString & QString::setNum ( short n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string.
.PP
The base is 10 by default and must be between 2 and 36.
.SH "QString & QString::setNum ( ushort n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string.
.PP
The base is 10 by default and must be between 2 and 36.
.SH "QString & QString::setNum ( int n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string.
.PP
The base is 10 by default and must be between 2 and 36.
.SH "QString & QString::setNum ( uint n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string.
.PP
The base is 10 by default and must be between 2 and 36.
.SH "QString & QString::setNum ( long n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QString & QString::setNum ( ulong n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QString & QString::setNum ( Q_ULLONG n, int base = 10 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR in base \fIbase\fR and returns a reference to the string.
.PP
The base is 10 by default and must be between 2 and 36.
.SH "QString & QString::setNum ( float n, char f = 'g', int prec = 6 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR, formatted in format \fIf\fR with precision \fIprec\fR, and returns a reference to the string.
.PP
The format \fIf\fR can be 'f', 'F', 'e', 'E', 'g' or 'G'. See arg() for an explanation of the formats.
.SH "QString & QString::setNum ( double n, char f = 'g', int prec = 6 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the printed value of \fIn\fR, formatted in format \fIf\fR with precision \fIprec\fR, and returns a reference to the string.
.PP
The format \fIf\fR can be 'f', 'F', 'e', 'E', 'g' or 'G'. See arg() for an explanation of the formats.
.SH "QString & QString::setUnicode ( const QChar * unicode, uint len )"
Resizes the string to \fIlen\fR characters and copies \fIunicode\fR into the string. If \fIunicode\fR is 0, nothing is copied, but the string is still resized to \fIlen\fR. If \fIlen\fR is zero, then the string becomes a null string.
.PP
See also setLatin1() and isNull().
.SH "QString & QString::setUnicodeCodes ( const ushort * unicode_as_ushorts, uint len )"
Resizes the string to \fIlen\fR characters and copies \fIunicode_as_ushorts\fR into the string (on some X11 client platforms this will involve a byte-swapping pass).
.PP
If \fIunicode_as_ushorts\fR is 0, nothing is copied, but the string is still resized to \fIlen\fR. If \fIlen\fR is zero, the string becomes a null string.
.PP
See also setLatin1() and isNull().
.SH "QString QString::simplifyWhiteSpace () const"
Returns a string that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.
.PP
Whitespace means any character for which QChar::isSpace() returns TRUE. This includes Unicode characters with decimal values 9 (TAB), 10 (LF), 11 (VT), 12 (FF), 13 (CR), and 32 (Space).
.PP
.nf
.br
        QString string = "  lots\\t of\\nwhite    space ";
.br
        QString t = string.simplifyWhiteSpace();
.br
        // t == "lots of white space"
.br
.fi
.PP
See also stripWhiteSpace().
.SH "QString & QString::sprintf ( const char * cformat, ... )"
Safely builds a formatted string from the format string \fIcformat\fR and an arbitrary list of arguments. The format string supports all the escape sequences of printf() in the standard C library.
.PP
The %s escape sequence expects a utf8() encoded string. The format string \fIcformat\fR is expected to be in latin1. If you need a Unicode format string, use arg() instead. For typesafe string building, with full Unicode support, you can use QTextOStream like this:
.PP
.nf
.br
        QString str;
.br
        QString s = ...;
.br
        int x = ...;
.br
        QTextOStream( &str ) << s << " : " << x;
.br
.fi
.PP
For translations, especially if the strings contains more than one escape sequence, you should consider using the arg() function instead. This allows the order of the replacements to be controlled by the translator, and has Unicode support.
.PP
The %lc escape sequence expects a unicode character of type ushort (as returned by QChar::unicode()). The %ls escape sequence expects a pointer to a zero-terminated array of unicode characters of type ushort (as returned by QString::ucs2()).
.PP
See also arg().
.PP
Examples:
.)l dclock/dclock.cpp, forever/forever.cpp, layout/layout.cpp, qmag/qmag.cpp, scrollview/scrollview.cpp, tooltip/tooltip.cpp, and xform/xform.cpp.
.SH "void QString::squeeze ()"
Squeezes the string's capacity to the current content.
.PP
See also capacity() and reserve().
.SH "bool QString::startsWith ( const QString & s, bool cs = TRUE ) const"
Returns TRUE if the string starts with \fIs\fR; otherwise returns FALSE.
.PP
If \fIcs\fR is TRUE (the default), the search is case sensitive; otherwise the search is case insensitive.
.PP
.nf
.br
        QString str( "Bananas" );
.br
        str.startsWith( "Ban" );     // returns TRUE
.br
        str.startsWith( "Car" );     // returns FALSE
.br
.fi
.PP
See also endsWith().
.SH "QString QString::stripWhiteSpace () const"
Returns a string that has whitespace removed from the start and the end.
.PP
Whitespace means any character for which QChar::isSpace() returns TRUE. This includes Unicode characters with decimal values 9 (TAB), 10 (LF), 11 (VT), 12 (FF), 13 (CR) and 32 (Space), and may also include other Unicode characters.
.PP
.nf
.br
        QString string = "   white space   ";
.br
        QString s = string.stripWhiteSpace();       // s == "white space"
.br
.fi
.PP
See also simplifyWhiteSpace().
.SH "double QString::toDouble ( bool * ok = 0 ) const"
Returns the string converted to a \fCdouble\fR value.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
.nf
.br
        QString string( "1234.56" );
.br
        double a = string.toDouble();   // a == 1234.56
.br
.fi
.PP
The string-to-number functions:
.TP
toShort()
.TP
toUShort()
.TP
toInt()
.TP
toUInt()
.TP
toLong()
.TP
toULong()
.TP
toLongLong()
.TP
toULongLong()
.TP
toFloat()
.TP
toDouble() can handle numbers represented in various locales. These representations may use different characters for the decimal point, thousands group sepearator and even individual digits. QString's functions try to interpret the string according to the current locale. The current locale is determined from the system at application startup and can be changed by calling QLocale::setDefault(). If the string cannot be interpreted according to the current locale, this function falls back on the "C" locale.
.PP
.nf
.br
        bool ok;
.br
        double d;
.br
.br
        QLocale::setDefault(QLocale::C);
.br
        d = QString( "1234,56" ).toDouble(&ok); // ok == false
.br
        d = QString( "1234.56" ).toDouble(&ok); // ok == true, d == 1234.56
.br
.br
        QLocale::setDefault(QLocale::German);
.br
        d = QString( "1234,56" ).toDouble(&ok); // ok == true, d == 1234.56
.br
        d = QString( "1234.56" ).toDouble(&ok); // ok == true, d == 1234.56
.br
.fi
.PP
Due to the ambiguity between the decimal point and thousands group separator in various locales, these functions do not handle thousands group separators. If you need to convert such numbers, use the corresponding function in QLocale.
.PP
.nf
.br
        bool ok;
.br
        QLocale::setDefault(QLocale::C);
.br
        double d = QString( "1,234,567.89" ).toDouble(&ok); // ok == false
.br
.fi
.PP
\fBWarning:\fR If the string contains trailing whitespace this function will fail, and set \fI*ok\fR to false if \fIok\fR is not 0. Leading whitespace is ignored.
.PP
See also number(), QLocale::setDefault(), QLocale::toDouble(), and stripWhiteSpace().
.SH "float QString::toFloat ( bool * ok = 0 ) const"
Returns the string converted to a \fCfloat\fR value.
.PP
Returns 0.0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
\fBWarning:\fR If the string contains trailing whitespace this function will fail, settings \fI*ok\fR to false if \fIok\fR is not 0. Leading whitespace is ignored.
.PP
See also number().
.SH "int QString::toInt ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to an \fCint\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
.nf
.br
        QString str( "FF" );
.br
        bool ok;
.br
        int hex = str.toInt( &ok, 16 );     // hex == 255, ok == TRUE
.br
        int dec = str.toInt( &ok, 10 );     // dec == 0, ok == FALSE
.br
.fi
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "long QString::toLong ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to a \fClong\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "Q_LLONG QString::toLongLong ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to a \fClong long\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "short QString::toShort ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to a \fCshort\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "uint QString::toUInt ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to an \fCunsigned int\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "ulong QString::toULong ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to an \fCunsigned long\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "Q_ULLONG QString::toULongLong ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to an \fCunsigned long long\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "ushort QString::toUShort ( bool * ok = 0, int base = 10 ) const"
Returns the string converted to an \fCunsigned short\fR using base \fIbase\fR, which is 10 by default and must be between 2 and 36 or 0. If \fIbase\fR is 0, the base is determined automatically using the following rules:
.TP
If the string begins with "0x", it is assumed to be hexadecimal;
.TP
If it begins with "0", it is assumed to be octal;
.TP
Otherwise it is assumed to be decimal.
.PP
Returns 0 if the conversion fails.
.PP
If \fIok\fR is not 0: if a conversion error occurs, \fI*ok\fR is set to FALSE; otherwise \fI*ok\fR is set to TRUE.
.PP
Leading and trailing whitespace is ignored by this function.
.PP
For information on how string-to-number functions in QString handle localized input, see toDouble().
.PP
See also number().
.SH "void QString::truncate ( uint newLen )"
If \fInewLen\fR is less than the length of the string, then the string is truncated at position \fInewLen\fR. Otherwise nothing happens.
.PP
.nf
.br
        QString s = "truncate me";
.br
        s.truncate( 5 );            // s == "trunc"
.br
.fi
.PP
See also setLength().
.PP
Example: network/mail/smtp.cpp.
.SH "const unsigned short * QString::ucs2 () const"
Returns the QString as a zero terminated array of unsigned shorts if the string is not null; otherwise returns zero.
.PP
The result remains valid so long as one unmodified copy of the source string exists.
.PP
Example: dotnet/wrapper/lib/tools.cpp.
.SH "const QChar * QString::unicode () const"
Returns the Unicode representation of the string. The result remains valid until the string is modified.
.SH "QString QString::upper () const"
Returns an uppercase copy of the string.
.PP
.nf
.br
        QString string( "TeXt" );
.br
        str = string.upper();     // t == "TEXT"
.br
.fi
.PP
See also lower().
.PP
Examples:
.)l scribble/scribble.cpp and sql/overview/custom1/main.cpp.
.SH "QCString QString::utf8 () const"
Returns the string encoded in UTF-8 format.
.PP
See QTextCodec for more diverse coding/decoding of Unicode strings.
.PP
See also fromUtf8(), ascii(), latin1(), and local8Bit().
.PP
Example: network/archivesearch/archivedialog.ui.h.
.SH RELATED FUNCTION DOCUMENTATION
.SH "bool operator!= ( const QString & s1, const QString & s2 )"
Returns TRUE if \fIs1\fR is not equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) != 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator!= ( const QString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is not equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) != 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator!= ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is not equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) != 0.
.PP
See also isNull() and isEmpty().
.SH "const QString operator+ ( const QString & s1, const QString & s2 )"
Returns a string which is the result of concatenating the string \fIs1\fR and the string \fIs2\fR.
.PP
Equivalent to \fIs1\fR.append(\fIs2\fR).
.SH "const QString operator+ ( const QString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which is the result of concatenating the string \fIs1\fR and character \fIs2\fR.
.PP
Equivalent to \fIs1\fR.append(\fIs2\fR).
.SH "const QString operator+ ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which is the result of concatenating the character \fIs1\fR and string \fIs2\fR.
.SH "const QString operator+ ( const QString & s, char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which is the result of concatenating the string \fIs\fR and character \fIc\fR.
.PP
Equivalent to \fIs\fR.append(\fIc\fR).
.SH "const QString operator+ ( char c, const QString & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which is the result of concatenating the character \fIc\fR and string \fIs\fR.
.PP
Equivalent to \fIs\fR.prepend(\fIc\fR).
.SH "bool operator< ( const QString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is lexically less than \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) < 0.
.SH "bool operator< ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is lexically less than \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) < 0.
.SH "QDataStream & operator<< ( QDataStream & s, const QString & str )"
Writes the string \fIstr\fR to the stream \fIs\fR.
.PP
See also Format of the QDataStream operators
.SH "bool operator<= ( const QString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is lexically less than or equal to \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR,\fIs2\fR) <= 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator<= ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is lexically less than or equal to \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) <= 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator== ( const QString & s1, const QString & s2 )"
Returns TRUE if \fIs1\fR is equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) == 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator== ( const QString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) == 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator== ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is equal to \fIs2\fR; otherwise returns FALSE. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) == 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator> ( const QString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is lexically greater than \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) > 0.
.SH "bool operator> ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is lexically greater than \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) > 0.
.SH "bool operator>= ( const QString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is lexically greater than or equal to \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) >= 0.
.PP
See also isNull() and isEmpty().
.SH "bool operator>= ( const char * s1, const QString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is lexically greater than or equal to \fIs2\fR; otherwise returns FALSE. The comparison is case sensitive. Note that a null string is not equal to a not-null empty string.
.PP
Equivalent to compare(\fIs1\fR, \fIs2\fR) >= 0.
.PP
See also isNull() and isEmpty().
.SH "QDataStream & operator>> ( QDataStream & s, QString & str )"
Reads a string from the stream \fIs\fR into string \fIstr\fR.
.PP
See also Format of the QDataStream operators

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qstring.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qstring.3qt) and the Qt
version (3.3.8).
