'\" t
.TH QSqlCursor 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QSqlCursor \- Browsing and editing of SQL tables and views
.SH SYNOPSIS
\fC#include <qsqlcursor.h>\fR
.PP
Inherits QSqlRecord and QSqlQuery.
.PP
Inherited by QSqlSelectCursor.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQSqlCursor\fR ( const QString & name = QString::null, bool autopopulate = TRUE, QSqlDatabase * db = 0 )"
.br
.ti -1c
.BI "\fBQSqlCursor\fR ( const QSqlCursor & other )"
.br
.ti -1c
.BI "QSqlCursor & \fBoperator=\fR ( const QSqlCursor & other )"
.br
.ti -1c
.BI "\fB~QSqlCursor\fR ()"
.br
.ti -1c
.BI "enum \fBMode\fR { ReadOnly = 0, Insert = 1, Update = 2, Delete = 4, Writable = 7 }"
.br
.ti -1c
.BI "virtual QSqlIndex \fBprimaryIndex\fR ( bool setFromCursor = TRUE ) const"
.br
.ti -1c
.BI "virtual QSqlIndex \fBindex\fR ( const QStringList & fieldNames ) const"
.br
.ti -1c
.BI "QSqlIndex \fBindex\fR ( const QString & fieldName ) const"
.br
.ti -1c
.BI "QSqlIndex \fBindex\fR ( const char * fieldName ) const"
.br
.ti -1c
.BI "virtual void \fBsetPrimaryIndex\fR ( const QSqlIndex & idx )"
.br
.ti -1c
.BI "virtual void \fBappend\fR ( const QSqlFieldInfo & fieldInfo )"
.br
.ti -1c
.BI "virtual void \fBinsert\fR ( int pos, const QSqlFieldInfo & fieldInfo )"
.br
.ti -1c
.BI "virtual void \fBremove\fR ( int pos )"
.br
.ti -1c
.BI "virtual void \fBclear\fR ()"
.br
.ti -1c
.BI "virtual void \fBsetGenerated\fR ( const QString & name, bool generated )"
.br
.ti -1c
.BI "virtual void \fBsetGenerated\fR ( int i, bool generated )"
.br
.ti -1c
.BI "virtual QSqlRecord * \fBeditBuffer\fR ( bool copy = FALSE )"
.br
.ti -1c
.BI "virtual QSqlRecord * \fBprimeInsert\fR ()"
.br
.ti -1c
.BI "virtual QSqlRecord * \fBprimeUpdate\fR ()"
.br
.ti -1c
.BI "virtual QSqlRecord * \fBprimeDelete\fR ()"
.br
.ti -1c
.BI "virtual int \fBinsert\fR ( bool invalidate = TRUE )"
.br
.ti -1c
.BI "virtual int \fBupdate\fR ( bool invalidate = TRUE )"
.br
.ti -1c
.BI "virtual int \fBdel\fR ( bool invalidate = TRUE )"
.br
.ti -1c
.BI "virtual void \fBsetMode\fR ( int mode )"
.br
.ti -1c
.BI "int \fBmode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCalculated\fR ( const QString & name, bool calculated )"
.br
.ti -1c
.BI "bool \fBisCalculated\fR ( const QString & name ) const"
.br
.ti -1c
.BI "virtual void \fBsetTrimmed\fR ( const QString & name, bool trim )"
.br
.ti -1c
.BI "bool \fBisTrimmed\fR ( const QString & name ) const"
.br
.ti -1c
.BI "bool \fBisReadOnly\fR () const"
.br
.ti -1c
.BI "bool \fBcanInsert\fR () const"
.br
.ti -1c
.BI "bool \fBcanUpdate\fR () const"
.br
.ti -1c
.BI "bool \fBcanDelete\fR () const"
.br
.ti -1c
.BI "bool \fBselect\fR ()"
.br
.ti -1c
.BI "bool \fBselect\fR ( const QSqlIndex & sort )"
.br
.ti -1c
.BI "bool \fBselect\fR ( const QSqlIndex & filter, const QSqlIndex & sort )"
.br
.ti -1c
.BI "virtual bool \fBselect\fR ( const QString & filter, const QSqlIndex & sort = QSqlIndex ( ) )"
.br
.ti -1c
.BI "virtual void \fBsetSort\fR ( const QSqlIndex & sort )"
.br
.ti -1c
.BI "QSqlIndex \fBsort\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFilter\fR ( const QString & filter )"
.br
.ti -1c
.BI "QString \fBfilter\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetName\fR ( const QString & name, bool autopopulate = TRUE )"
.br
.ti -1c
.BI "QString \fBname\fR () const"
.br
.ti -1c
.BI "bool \fBisNull\fR ( int i ) const"
.br
.ti -1c
.BI "bool \fBisNull\fR ( const QString & name ) const"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual QVariant \fBcalculateField\fR ( const QString & name )"
.br
.ti -1c
.BI "virtual int \fBupdate\fR ( const QString & filter, bool invalidate = TRUE )"
.br
.ti -1c
.BI "virtual int \fBdel\fR ( const QString & filter, bool invalidate = TRUE )"
.br
.ti -1c
.BI "virtual QString \fBtoString\fR ( const QString & prefix, QSqlField * field, const QString & fieldSep ) const"
.br
.ti -1c
.BI "virtual QString \fBtoString\fR ( QSqlRecord * rec, const QString & prefix, const QString & fieldSep, const QString & sep ) const"
.br
.ti -1c
.BI "virtual QString \fBtoString\fR ( const QSqlIndex & i, QSqlRecord * rec, const QString & prefix, const QString & fieldSep, const QString & sep ) const"
.br
.in -1c
.SH DESCRIPTION
The QSqlCursor class provides browsing and editing of SQL tables and views.
.PP
A QSqlCursor is a database record (see QSqlRecord) that corresponds to a table or view within an SQL database (see QSqlDatabase). There are two buffers in a cursor, one used for browsing and one used for editing records. Each buffer contains a list of fields which correspond to the fields in the table or view.
.PP
When positioned on a valid record, the browse buffer contains the values of the current record's fields from the database. The edit buffer is separate, and is used for editing existing records and inserting new records.
.PP
For browsing data, a cursor must first select() data from the database. After a successful select() the cursor is active (isActive() returns TRUE), but is initially not positioned on a valid record (isValid() returns FALSE). To position the cursor on a valid record, use one of the navigation functions, next(), prev(), first(), last(), or seek(). Once positioned on a valid record, data can be retrieved from the browse buffer using value(). If a navigation function is not successful, it returns FALSE, the cursor will no longer be positioned on a valid record and the values returned by value() are undefined.
.PP
For example:
.PP
.nf
.br
            QSqlCursor cur( "staff" ); // Specify the table/view name
.br
            cur.select(); // We'll retrieve every record
.br
            while ( cur.next() ) {
.br
                qDebug( cur.value( "id" ).toString() + ": " +
.br
                        cur.value( "surname" ).toString() + " " +
.br
                        cur.value( "salary" ).toString() );
.br
            }
.fi
.PP
In the above example, a cursor is created specifying a table or view name in the database. Then, select() is called, which can be optionally parameterised to filter and order the records retrieved. Each record in the cursor is retrieved using next(). When next() returns FALSE, there are no more records to process, and the loop terminates.
.PP
For editing records (rows of data), a cursor contains a separate edit buffer which is independent of the fields used when browsing. The functions insert(), update() and del() operate on the edit buffer. This allows the cursor to be repositioned to other records while simultaneously maintaining a separate buffer for edits. You can get a pointer to the edit buffer using editBuffer(). The primeInsert(), primeUpdate() and primeDelete() functions also return a pointer to the edit buffer and prepare it for insert, update and delete respectively. Edit operations only affect a single row at a time. Note that update() and del() require that the table or view contain a primaryIndex() to ensure that edit operations affect a unique record within the database.
.PP
For example:
.PP
.nf
.br
            QSqlCursor cur( "prices" );
.br
            cur.select( "id=202" );
.br
            if ( cur.next() ) {
.br
                QSqlRecord *buffer = cur.primeUpdate();
.br
                double price = buffer->value( "price" ).toDouble();
.br
                double newprice = price * 1.05;
.br
                buffer->setValue( "price", newprice );
.br
                cur.update();
.br
            }
.fi
.PP
To edit an existing database record, first move to the record you wish to update. Call primeUpdate() to get the pointer to the cursor's edit buffer. Then use this pointer to modify the values in the edit buffer. Finally, call update() to save the changes to the database. The values in the edit buffer will be used to locate the appropriate record when updating the database (see primaryIndex()).
.PP
Similarly, when deleting an existing database record, first move to the record you wish to delete. Then, call primeDelete() to get the pointer to the edit buffer. Finally, call del() to delete the record from the database. Again, the values in the edit buffer will be used to locate and delete the appropriate record.
.PP
To insert a new record, call primeInsert() to get the pointer to the edit buffer. Use this pointer to populate the edit buffer with new values and then insert() the record into the database.
.PP
After calling insert(), update() or del(), the cursor is no longer positioned on a valid record and can no longer be navigated (isValid() return FALSE). The reason for this is that any changes made to the database will not be visible until select() is called to refresh the cursor. You can change this behavior by passing FALSE to insert(), update() or del() which will prevent the cursor from becoming invalid. The edits will still not be visible when navigating the cursor until select() is called.
.PP
QSqlCursor contains virtual methods which allow editing behavior to be customized by subclasses. This allows custom cursors to be created that encapsulate the editing behavior of a database table for an entire application. For example, a cursor can be customized to always auto-number primary index fields, or provide fields with suitable default values, when inserting new records. QSqlCursor generates SQL statements which are sent to the database engine; you can control which fields are included in these statements using setGenerated().
.PP
Note that QSqlCursor does not inherit from QObject. This means that you are responsible for destroying instances of this class yourself. However if you create a QSqlCursor and use it in a QDataTable, QDataBrowser or a QDataView these classes will usually take ownership of the cursor and destroy it when they don't need it anymore. The documentation for QDataTable, QDataBrowser and QDataView explicitly states which calls take ownership of the cursor.
.PP
See also Database Classes.
.SS "Member Type Documentation"
.SH "QSqlCursor::Mode"
This enum type describes how QSqlCursor operates on records in the database.
.TP
\fCQSqlCursor::ReadOnly\fR - the cursor can only SELECT records from the database.
.TP
\fCQSqlCursor::Insert\fR - the cursor can INSERT records into the database.
.TP
\fCQSqlCursor::Update\fR - the cursor can UPDATE records in the database.
.TP
\fCQSqlCursor::Delete\fR - the cursor can DELETE records from the database.
.TP
\fCQSqlCursor::Writable\fR - the cursor can INSERT, UPDATE and DELETE records in the database.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QSqlCursor::QSqlCursor ( const QString & name = QString::null, bool autopopulate = TRUE, QSqlDatabase * db = 0 )"
Constructs a cursor on database \fIdb\fR using table or view \fIname\fR.
.PP
If \fIautopopulate\fR is TRUE (the default), the \fIname\fR of the cursor must correspond to an existing table or view name in the database so that field information can be automatically created. If the table or view does not exist, the cursor will not be functional.
.PP
The cursor is created with an initial mode of QSqlCursor::Writable (meaning that records can be inserted, updated or deleted using the cursor). If the cursor does not have a unique primary index, update and deletes cannot be performed.
.PP
Note that \fIautopopulate\fR refers to populating the cursor with meta-data, e.g. the names of the table's fields, not with retrieving data. The select() function is used to populate the cursor with data.
.PP
See also setName() and setMode().
.SH "QSqlCursor::QSqlCursor ( const QSqlCursor & other )"
Constructs a copy of \fIother\fR.
.SH "QSqlCursor::~QSqlCursor ()"
Destroys the object and frees any allocated resources.
.SH "void QSqlCursor::append ( const QSqlFieldInfo & fieldInfo )\fC [virtual]\fR"
Append a copy of field \fIfieldInfo\fR to the end of the cursor. Note that all references to the cursor edit buffer become invalidated.
.SH "QVariant QSqlCursor::calculateField ( const QString & name )\fC [virtual protected]\fR"
Protected virtual function which is called whenever a field needs to be calculated. If calculated fields are being used, derived classes must reimplement this function and return the appropriate value for field \fIname\fR. The default implementation returns an invalid QVariant.
.PP
See also setCalculated().
.PP
Examples:
.)l sql/overview/subclass3/main.cpp and sql/overview/subclass4/main.cpp.
.SH "bool QSqlCursor::canDelete () const"
Returns TRUE if the cursor will perform deletes; otherwise returns FALSE.
.PP
See also setMode().
.SH "bool QSqlCursor::canInsert () const"
Returns TRUE if the cursor will perform inserts; otherwise returns FALSE.
.PP
See also setMode().
.SH "bool QSqlCursor::canUpdate () const"
Returns TRUE if the cursor will perform updates; otherwise returns FALSE.
.PP
See also setMode().
.SH "void QSqlCursor::clear ()\fC [virtual]\fR"
Removes all fields from the cursor. Note that all references to the cursor edit buffer become invalidated.
.PP
Reimplemented from QSqlRecord.
.SH "int QSqlCursor::del ( bool invalidate = TRUE )\fC [virtual]\fR"
Deletes a record from the database using the cursor's primary index and the contents of the cursor edit buffer. Returns the number of records which were deleted. For error information, use lastError().
.PP
Only records which meet the filter criteria specified by the cursor's primary index are deleted. If the cursor does not contain a primary index, no delete is performed and 0 is returned. If \fIinvalidate\fR is TRUE (the default), the current cursor can no longer be navigated. A new select() call must be made before you can move to a valid record. For example:
.PP
.nf
.br
            QSqlCursor cur( "prices" );
.br
            cur.select( "id=999" );
.br
            if ( cur.next() ) {
.br
                cur.primeDelete();
.br
                cur.del();
.br
            }
.fi
.PP
In the above example, a cursor is created on the 'prices' table and positioned to the record to be deleted. First primeDelete() is called to populate the edit buffer with the current cursor values, e.g. with an id of 999, and then del() is called to actually delete the record from the database. Remember: all edit operations (insert(), update() and delete()) operate on the contents of the cursor edit buffer and not on the contents of the cursor itself.
.PP
See also primeDelete(), setMode(), and lastError().
.PP
Example: sql/overview/delete/main.cpp.
.SH "int QSqlCursor::del ( const QString & filter, bool invalidate = TRUE )\fC [virtual protected]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Deletes the current cursor record from the database using the filter \fIfilter\fR. Only records which meet the filter criteria are deleted. Returns the number of records which were deleted. If \fIinvalidate\fR is TRUE (the default), the current cursor can no longer be navigated. A new select() call must be made before you can move to a valid record. For error information, use lastError().
.PP
The \fIfilter\fR is an SQL \fCWHERE\fR clause, e.g. \fCid=500\fR.
.PP
See also setMode() and lastError().
.SH "QSqlRecord * QSqlCursor::editBuffer ( bool copy = FALSE )\fC [virtual]\fR"
Returns the current internal edit buffer. If \fIcopy\fR is TRUE (the default is FALSE), the current cursor field values are first copied into the edit buffer. The edit buffer is valid as long as the cursor remains valid. The cursor retains ownership of the returned pointer, so it must not be deleted or modified.
.PP
See also primeInsert(), primeUpdate(), and primeDelete().
.SH "QString QSqlCursor::filter () const"
Returns the current filter, or an empty string if there is no current filter.
.SH "QSqlIndex QSqlCursor::index ( const QStringList & fieldNames ) const\fC [virtual]\fR"
Returns an index composed of \fIfieldNames\fR, all in ASCending order. Note that all field names must exist in the cursor, otherwise an empty index is returned.
.PP
See also QSqlIndex.
.PP
Examples:
.)l sql/overview/extract/main.cpp, sql/overview/order1/main.cpp, sql/overview/order2/main.cpp, and sql/overview/table3/main.cpp.
.SH "QSqlIndex QSqlCursor::index ( const QString & fieldName ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an index based on \fIfieldName\fR.
.SH "QSqlIndex QSqlCursor::index ( const char * fieldName ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an index based on \fIfieldName\fR.
.SH "void QSqlCursor::insert ( int pos, const QSqlFieldInfo & fieldInfo )\fC [virtual]\fR"
Insert a copy of \fIfieldInfo\fR at position \fIpos\fR. If a field already exists at \fIpos\fR, it is removed. Note that all references to the cursor edit buffer become invalidated.
.PP
Examples:
.)l sql/overview/insert/main.cpp and sql/overview/insert2/main.cpp.
.SH "int QSqlCursor::insert ( bool invalidate = TRUE )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts the current contents of the cursor's edit record buffer into the database, if the cursor allows inserts. Returns the number of rows affected by the insert. For error information, use lastError().
.PP
If \fIinvalidate\fR is TRUE (the default), the cursor will no longer be positioned on a valid record and can no longer be navigated. A new select() call must be made before navigating to a valid record.
.PP
.nf
.br
            QSqlCursor cur( "prices" );
.br
            QSqlRecord *buffer = cur.primeInsert();
.br
            buffer->setValue( "id",    53981 );
.br
            buffer->setValue( "name",  "Thingy" );
.br
            buffer->setValue( "price", 105.75 );
.br
            cur.insert();
.fi
.PP
In the above example, a cursor is created on the 'prices' table and a pointer to the insert buffer is aquired using primeInsert(). Each field's value is set to the desired value and then insert() is called to insert the data into the database. Remember: all edit operations (insert(), update() and delete()) operate on the contents of the cursor edit buffer and not on the contents of the cursor itself.
.PP
See also setMode() and lastError().
.SH "bool QSqlCursor::isCalculated ( const QString & name ) const"
Returns TRUE if the field \fIname\fR exists and is calculated; otherwise returns FALSE.
.PP
See also setCalculated().
.SH "bool QSqlCursor::isNull ( int i ) const"
Returns TRUE if the field \fIi\fR is NULL or if there is no field at position \fIi\fR; otherwise returns FALSE.
.PP
This is the same as calling QSqlRecord::isNull( \fIi\fR )
.SH "bool QSqlCursor::isNull ( const QString & name ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if the field called \fIname\fR is NULL or if there is no field called \fIname\fR; otherwise returns FALSE.
.PP
This is the same as calling QSqlRecord::isNull( \fIname\fR )
.SH "bool QSqlCursor::isReadOnly () const"
Returns TRUE if the cursor is read-only; otherwise returns FALSE. The default is FALSE. Read-only cursors cannot be edited using insert(), update() or del().
.PP
See also setMode().
.SH "bool QSqlCursor::isTrimmed ( const QString & name ) const"
Returns TRUE if the field \fIname\fR exists and is trimmed; otherwise returns FALSE.
.PP
When a trimmed field of type string or cstring is read from the database any trailing (right-most) spaces are removed.
.PP
See also setTrimmed().
.SH "int QSqlCursor::mode () const"
Returns the current cursor mode.
.PP
See also setMode().
.SH "QString QSqlCursor::name () const"
Returns the name of the cursor.
.SH "QSqlCursor & QSqlCursor::operator= ( const QSqlCursor & other )"
Sets the cursor equal to \fIother\fR.
.SH "QSqlIndex QSqlCursor::primaryIndex ( bool setFromCursor = TRUE ) const\fC [virtual]\fR"
Returns the primary index associated with the cursor as defined in the database, or an empty index if there is no primary index. If \fIsetFromCursor\fR is TRUE (the default), the index fields are populated with the corresponding values in the cursor's current record.
.SH "QSqlRecord * QSqlCursor::primeDelete ()\fC [virtual]\fR"
This function primes the edit buffer's field values for delete and returns the edit buffer. The default implementation copies the field values from the current cursor record into the edit buffer (therefore, this function is equivalent to calling editBuffer( TRUE ) ). The cursor retains ownership of the returned pointer, so it must not be deleted or modified.
.PP
See also editBuffer() and del().
.PP
Example: sql/overview/delete/main.cpp.
.SH "QSqlRecord * QSqlCursor::primeInsert ()\fC [virtual]\fR"
This function primes the edit buffer's field values for insert and returns the edit buffer. The default implementation clears all field values in the edit buffer. The cursor retains ownership of the returned pointer, so it must not be deleted or modified.
.PP
See also editBuffer() and insert().
.PP
Examples:
.)l sql/overview/insert/main.cpp, sql/overview/insert2/main.cpp, sql/overview/subclass5/main.cpp, and sql/sqltable/main.cpp.
.SH "QSqlRecord * QSqlCursor::primeUpdate ()\fC [virtual]\fR"
This function primes the edit buffer's field values for update and returns the edit buffer. The default implementation copies the field values from the current cursor record into the edit buffer (therefore, this function is equivalent to calling editBuffer( TRUE ) ). The cursor retains ownership of the returned pointer, so it must not be deleted or modified.
.PP
See also editBuffer() and update().
.PP
Examples:
.)l sql/overview/custom1/main.cpp, sql/overview/form1/main.cpp, and sql/overview/update/main.cpp.
.SH "void QSqlCursor::remove ( int pos )\fC [virtual]\fR"
Removes the field at \fIpos\fR. If \fIpos\fR does not exist, nothing happens. Note that all references to the cursor edit buffer become invalidated.
.PP
Reimplemented from QSqlRecord.
.SH "bool QSqlCursor::select ( const QString & filter, const QSqlIndex & sort = QSqlIndex ( ) )\fC [virtual]\fR"
Selects all fields in the cursor from the database matching the filter criteria \fIfilter\fR. The data is returned in the order specified by the index \fIsort\fR. Returns TRUE if the data was successfully selected; otherwise returns FALSE.
.PP
The \fIfilter\fR is a string containing a SQL \fCWHERE\fR clause but without the 'WHERE' keyword. The cursor is initially positioned at an invalid row after this function is called. To move to a valid row, use seek(), first(), last(), prev() or next().
.PP
Example:
.PP
.nf
.br
    QSqlCursor cur( "Employee" ); // Use the Employee table or view
.br
    cur.select( "deptno=10" ); // select all records in department 10
.br
    while( cur.next() ) {
.br
        ... // process data
.br
    }
.br
    ...
.br
    // select records in other departments, ordered by department number
.br
    cur.select( "deptno>10", cur.index( "deptno" ) );
.br
    ...
.br
.fi
.PP
The filter will apply to any subsequent select() calls that do not explicitly specify another filter. Similarly the sort will apply to any subsequent select() calls that do not explicitly specify another sort.
.PP
.nf
.br
    QSqlCursor cur( "Employee" );
.br
    cur.select( "deptno=10" ); // select all records in department 10
.br
    while( cur.next() ) {
.br
        ... // process data
.br
    }
.br
    ...
.br
    cur.select(); // re-selects all records in department 10
.br
    ...
.br
.fi
.PP
Examples:
.)l sql/overview/delete/main.cpp, sql/overview/extract/main.cpp, sql/overview/order1/main.cpp, sql/overview/order2/main.cpp, sql/overview/retrieve2/main.cpp, sql/overview/table3/main.cpp, and sql/overview/update/main.cpp.
.SH "bool QSqlCursor::select ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Selects all fields in the cursor from the database. The rows are returned in the order specified by the last call to setSort() or the last call to select() that specified a sort, whichever is the most recent. If there is no current sort, the order in which the rows are returned is undefined. The records are filtered according to the filter specified by the last call to setFilter() or the last call to select() that specified a filter, whichever is the most recent. If there is no current filter, all records are returned. The cursor is initially positioned at an invalid row. To move to a valid row, use seek(), first(), last(), prev() or next().
.PP
See also setSort() and setFilter().
.SH "bool QSqlCursor::select ( const QSqlIndex & sort )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Selects all fields in the cursor from the database. The data is returned in the order specified by the index \fIsort\fR. The records are filtered according to the filter specified by the last call to setFilter() or the last call to select() that specified a filter, whichever is the most recent. The cursor is initially positioned at an invalid row. To move to a valid row, use seek(), first(), last(), prev() or next().
.SH "bool QSqlCursor::select ( const QSqlIndex & filter, const QSqlIndex & sort )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Selects all fields in the cursor matching the filter index \fIfilter\fR. The data is returned in the order specified by the index \fIsort\fR. The \fIfilter\fR index works by constructing a WHERE clause using the names of the fields from the \fIfilter\fR and their values from the current cursor record. The cursor is initially positioned at an invalid row. To move to a valid row, use seek(), first(), last(), prev() or next(). This function is useful, for example, for retrieving data based upon a table's primary index:
.PP
.nf
.br
    QSqlCursor cur( "Employee" );
.br
    QSqlIndex pk = cur.primaryIndex();
.br
    cur.setValue( "id", 10 );
.br
    cur.select( pk, pk ); // generates "SELECT ... FROM Employee WHERE id=10 ORDER BY id"
.br
    ...
.br
.fi
.PP
In this example the QSqlIndex, pk, is used for two different purposes. When used as the filter (first) argument, the field names it contains are used to construct the WHERE clause, each set to the current cursor value, \fCWHERE id=10\fR, in this case. When used as the sort (second) argument the field names it contains are used for the ORDER BY clause, \fCORDER BY id\fR in this example.
.SH "void QSqlCursor::setCalculated ( const QString & name, bool calculated )\fC [virtual]\fR"
Sets field \fIname\fR to \fIcalculated\fR. If the field \fIname\fR does not exist, nothing happens. The value of a calculated field is set by the calculateField() virtual function which you must reimplement (or the field value will be an invalid QVariant). Calculated fields do not appear in generated SQL statements sent to the database.
.PP
See also calculateField() and QSqlRecord::setGenerated().
.SH "void QSqlCursor::setFilter ( const QString & filter )\fC [virtual]\fR"
Sets the current filter to \fIfilter\fR. Note that no new records are selected. To select new records, use select(). The \fIfilter\fR will apply to any subsequent select() calls that do not explicitly specify a filter.
.PP
The filter is a SQL \fCWHERE\fR clause without the keyword 'WHERE', e.g. \fCname='Dave'\fR which will be processed by the DBMS.
.SH "void QSqlCursor::setGenerated ( const QString & name, bool generated )\fC [virtual]\fR"
Sets the generated flag for the field \fIname\fR to \fIgenerated\fR. If the field does not exist, nothing happens. Only fields that have \fIgenerated\fR set to TRUE are included in the SQL that is generated by insert(), update() or del().
.PP
See also isGenerated().
.PP
Reimplemented from QSqlRecord.
.SH "void QSqlCursor::setGenerated ( int i, bool generated )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the generated flag for the field \fIi\fR to \fIgenerated\fR.
.PP
See also isGenerated().
.PP
Reimplemented from QSqlRecord.
.SH "void QSqlCursor::setMode ( int mode )\fC [virtual]\fR"
Sets the cursor mode to \fImode\fR. This value can be an OR'ed combination of QSqlCursor::Mode values. The default mode for a cursor is QSqlCursor::Writable.
.PP
.nf
.br
    QSqlCursor cur( "Employee" );
.br
    cur.setMode( QSqlCursor::Writable ); // allow insert/update/delete
.br
    ...
.br
    cur.setMode( QSqlCursor::Insert | QSqlCursor::Update ); // allow inserts and updates only
.br
    ...
.br
    cur.setMode( QSqlCursor::ReadOnly ); // no inserts/updates/deletes allowed
.br
.br
.fi
.SH "void QSqlCursor::setName ( const QString & name, bool autopopulate = TRUE )\fC [virtual]\fR"
Sets the name of the cursor to \fIname\fR. If \fIautopopulate\fR is TRUE (the default), the \fIname\fR must correspond to a valid table or view name in the database. Also, note that all references to the cursor edit buffer become invalidated when fields are auto-populated. See the QSqlCursor constructor documentation for more information.
.SH "void QSqlCursor::setPrimaryIndex ( const QSqlIndex & idx )\fC [virtual]\fR"
Sets the primary index associated with the cursor to the index \fIidx\fR. Note that this index must contain a field or set of fields which identify a unique record within the underlying database table or view so that update() and del() will execute as expected.
.PP
See also update() and del().
.SH "void QSqlCursor::setSort ( const QSqlIndex & sort )\fC [virtual]\fR"
Sets the current sort to \fIsort\fR. Note that no new records are selected. To select new records, use select(). The \fIsort\fR will apply to any subsequent select() calls that do not explicitly specify a sort.
.SH "void QSqlCursor::setTrimmed ( const QString & name, bool trim )\fC [virtual]\fR"
Sets field \fIname\fR's trimmed status to \fItrim\fR. If the field \fIname\fR does not exist, nothing happens.
.PP
When a trimmed field of type string or cstring is read from the database any trailing (right-most) spaces are removed.
.PP
See also isTrimmed() and QVariant.
.SH "QSqlIndex QSqlCursor::sort () const"
Returns the current sort, or an empty index if there is no current sort.
.SH "QString QSqlCursor::toString ( QSqlRecord * rec, const QString & prefix, const QString & fieldSep, const QString & sep ) const\fC [virtual protected]\fR"
Returns a formatted string composed of all the fields in \fIrec\fR. Each field is composed of the \fIprefix\fR (e.g. table or view name),"
.", the field name, the \fIfieldSep\fR and the field value. If the
\fIprefix\fR is empty then each field will begin with the field name. The fields are then joined together separated by \fIsep\fR. Fields where isGenerated() returns FALSE are not included. This function is useful for generating SQL statements.
.SH "QString QSqlCursor::toString ( const QString & prefix, QSqlField * field, const QString & fieldSep ) const\fC [virtual protected]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a formatted string composed of the \fIprefix\fR (e.g. table or view name), ".", the \fIfield\fR name, the \fIfieldSep\fR and the field value. If the \fIprefix\fR is empty then the string will begin with the \fIfield\fR name. This function is useful for generating SQL statements.
.SH "QString QSqlCursor::toString ( const QSqlIndex & i, QSqlRecord * rec, const QString & prefix, const QString & fieldSep, const QString & sep ) const\fC [virtual protected]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a formatted string composed of all the fields in the index \fIi\fR. Each field is composed of the \fIprefix\fR (e.g. table or view name), ".", the field name, the \fIfieldSep\fR and the field value. If the \fIprefix\fR is empty then each field will begin with the field name. The field values are taken from \fIrec\fR. The fields are then joined together separated by \fIsep\fR. Fields where isGenerated() returns FALSE are ignored. This function is useful for generating SQL statements.
.SH "int QSqlCursor::update ( bool invalidate = TRUE )\fC [virtual]\fR"
Updates the database with the current contents of the edit buffer. Returns the number of records which were updated. For error information, use lastError().
.PP
Only records which meet the filter criteria specified by the cursor's primary index are updated. If the cursor does not contain a primary index, no update is performed and 0 is returned.
.PP
If \fIinvalidate\fR is TRUE (the default), the current cursor can no longer be navigated. A new select() call must be made before you can move to a valid record. For example:
.PP
.nf
.br
            QSqlCursor cur( "prices" );
.br
            cur.select( "id=202" );
.br
            if ( cur.next() ) {
.br
                QSqlRecord *buffer = cur.primeUpdate();
.br
                double price = buffer->value( "price" ).toDouble();
.br
                double newprice = price * 1.05;
.br
                buffer->setValue( "price", newprice );
.br
                cur.update();
.br
            }
.fi
.PP
In the above example, a cursor is created on the 'prices' table and is positioned on the record to be updated. Then a pointer to the cursor's edit buffer is acquired using primeUpdate(). A new value is calculated and placed into the edit buffer with the setValue() call. Finally, an update() call is made on the cursor which uses the tables's primary index to update the record in the database with the contents of the cursor's edit buffer. Remember: all edit operations (insert(), update() and delete()) operate on the contents of the cursor edit buffer and not on the contents of the cursor itself.
.PP
Note that if the primary index does not uniquely distinguish records the database may be changed into an inconsistent state.
.PP
See also setMode() and lastError().
.PP
Example: sql/overview/update/main.cpp.
.SH "int QSqlCursor::update ( const QString & filter, bool invalidate = TRUE )\fC [virtual protected]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Updates the database with the current contents of the cursor edit buffer using the specified \fIfilter\fR. Returns the number of records which were updated. For error information, use lastError().
.PP
Only records which meet the filter criteria are updated, otherwise all records in the table are updated.
.PP
If \fIinvalidate\fR is TRUE (the default), the cursor can no longer be navigated. A new select() call must be made before you can move to a valid record.
.PP
See also primeUpdate(), setMode(), and lastError().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qsqlcursor.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qsqlcursor.3qt) and the Qt
version (3.3.8).
