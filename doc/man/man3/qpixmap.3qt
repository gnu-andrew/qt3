'\" t
.TH QPixmap 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QPixmap \- Off-screen, pixel-based paint device
.SH SYNOPSIS
\fC#include <qpixmap.h>\fR
.PP
Inherits QPaintDevice and Qt.
.PP
Inherited by QBitmap and QCanvasPixmap.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBColorMode\fR { Auto, Color, Mono }"
.br
.ti -1c
.BI "enum \fBOptimization\fR { DefaultOptim, NoOptim, MemoryOptim = NoOptim, NormalOptim, BestOptim }"
.br
.ti -1c
.BI "\fBQPixmap\fR ()"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QImage & image )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( int w, int h, int depth = -1, Optimization optimization = DefaultOptim )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QSize & size, int depth = -1, Optimization optimization = DefaultOptim )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QString & fileName, const char * format = 0, ColorMode mode = Auto )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QString & fileName, const char * format, int conversion_flags )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const char * xpm[] )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QByteArray & img_data )"
.br
.ti -1c
.BI "\fBQPixmap\fR ( const QPixmap & pixmap )"
.br
.ti -1c
.BI "\fB~QPixmap\fR ()"
.br
.ti -1c
.BI "QPixmap & \fBoperator=\fR ( const QPixmap & pixmap )"
.br
.ti -1c
.BI "QPixmap & \fBoperator=\fR ( const QImage & image )"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "int \fBwidth\fR () const"
.br
.ti -1c
.BI "int \fBheight\fR () const"
.br
.ti -1c
.BI "QSize \fBsize\fR () const"
.br
.ti -1c
.BI "QRect \fBrect\fR () const"
.br
.ti -1c
.BI "int \fBdepth\fR () const"
.br
.ti -1c
.BI "void \fBfill\fR ( const QColor & fillColor = Qt::white )"
.br
.ti -1c
.BI "void \fBfill\fR ( const QWidget * widget, int xofs, int yofs )"
.br
.ti -1c
.BI "void \fBfill\fR ( const QWidget * widget, const QPoint & ofs )"
.br
.ti -1c
.BI "void \fBresize\fR ( int w, int h )"
.br
.ti -1c
.BI "void \fBresize\fR ( const QSize & size )"
.br
.ti -1c
.BI "const QBitmap * \fBmask\fR () const"
.br
.ti -1c
.BI "void \fBsetMask\fR ( const QBitmap & newmask )"
.br
.ti -1c
.BI "bool \fBselfMask\fR () const"
.br
.ti -1c
.BI "bool \fBhasAlpha\fR () const"
.br
.ti -1c
.BI "bool \fBhasAlphaChannel\fR () const"
.br
.ti -1c
.BI "QBitmap \fBcreateHeuristicMask\fR ( bool clipTight = TRUE ) const"
.br
.ti -1c
.BI "QPixmap \fBxForm\fR ( const QWMatrix & matrix ) const"
.br
.ti -1c
.BI "QImage \fBconvertToImage\fR () const"
.br
.ti -1c
.BI "bool \fBconvertFromImage\fR ( const QImage & image, ColorMode mode = Auto )"
.br
.ti -1c
.BI "bool \fBconvertFromImage\fR ( const QImage & img, int conversion_flags )"
.br
.ti -1c
.BI "bool \fBload\fR ( const QString & fileName, const char * format = 0, ColorMode mode = Auto )"
.br
.ti -1c
.BI "bool \fBload\fR ( const QString & fileName, const char * format, int conversion_flags )"
.br
.ti -1c
.BI "bool \fBloadFromData\fR ( const uchar * buf, uint len, const char * format = 0, ColorMode mode = Auto )"
.br
.ti -1c
.BI "bool \fBloadFromData\fR ( const uchar * buf, uint len, const char * format, int conversion_flags )"
.br
.ti -1c
.BI "bool \fBloadFromData\fR ( const QByteArray & buf, const char * format = 0, int conversion_flags = 0 )"
.br
.ti -1c
.BI "bool \fBsave\fR ( const QString & fileName, const char * format, int quality = -1 ) const"
.br
.ti -1c
.BI "bool \fBsave\fR ( QIODevice * device, const char * format, int quality = -1 ) const"
.br
.ti -1c
.BI "int \fBserialNumber\fR () const"
.br
.ti -1c
.BI "Optimization \fBoptimization\fR () const"
.br
.ti -1c
.BI "void \fBsetOptimization\fR ( Optimization optimization )"
.br
.ti -1c
.BI "virtual void \fBdetach\fR ()"
.br
.ti -1c
.BI "bool \fBisQBitmap\fR () const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "int \fBdefaultDepth\fR ()"
.br
.ti -1c
.BI "QPixmap \fBfromMimeSource\fR ( const QString & abs_name )"
.br
.ti -1c
.BI "QPixmap \fBgrabWindow\fR ( WId window, int x = 0, int y = 0, int w = -1, int h = -1 )"
.br
.ti -1c
.BI "QPixmap \fBgrabWidget\fR ( QWidget * widget, int x = 0, int y = 0, int w = -1, int h = -1 )"
.br
.ti -1c
.BI "QWMatrix \fBtrueMatrix\fR ( const QWMatrix & matrix, int w, int h )"
.br
.ti -1c
.BI "const char * \fBimageFormat\fR ( const QString & fileName )"
.br
.ti -1c
.BI "Optimization \fBdefaultOptimization\fR ()"
.br
.ti -1c
.BI "void \fBsetDefaultOptimization\fR ( Optimization optimization )"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "\fBQPixmap\fR ( int w, int h, const uchar * bits, bool isXbitmap )"
.br
.ti -1c
.BI "virtual int \fBmetric\fR ( int m ) const"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QPixmap & pixmap )"
.br
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QPixmap & pixmap )"
.br
.ti -1c
.BI "void \fBcopyBlt\fR ( QPixmap * dst, int dx, int dy, const QPixmap * src, int sx, int sy, int sw, int sh )"
.br
.in -1c
.SH DESCRIPTION
The QPixmap class is an off-screen, pixel-based paint device.
.PP
QPixmap is one of the two classes Qt provides for dealing with images; the other is QImage. QPixmap is designed and optimized for drawing; QImage is designed and optimized for I/O and for direct pixel access/manipulation. There are (slow) functions to convert between QImage and QPixmap: convertToImage() and convertFromImage().
.PP
One common use of the QPixmap class is to enable smooth updating of widgets. Whenever something complex needs to be drawn, you can use a pixmap to obtain flicker-free drawing, like this:
.PP
<ol type=1>
.IP 1
Create a pixmap with the same size as the widget.
.IP 2
Fill the pixmap with the widget background color.
.IP 3
Paint the pixmap.
.IP 4
bitBlt() the pixmap contents onto the widget.
.PP
Pixel data in a pixmap is internal and is managed by the underlying window system. Pixels can be accessed only through QPainter functions, through bitBlt(), and by converting the QPixmap to a QImage.
.PP
You can easily display a QPixmap on the screen using QLabel::setPixmap(). For example, all the QButton subclasses support pixmap use.
.PP
The QPixmap class uses copy-on-write, so it is practical to pass QPixmap objects by value.
.PP
You can retrieve the width(), height(), depth() and size() of a pixmap. The enclosing rectangle is given by rect(). Pixmaps can be filled with fill() and resized with resize(). You can create and set a mask with createHeuristicMask() and setMask(). Use selfMask() to see if the pixmap is identical to its mask.
.PP
In addition to loading a pixmap from file using load() you can also loadFromData(). You can control optimization with setOptimization() and obtain a transformed version of the pixmap using xForm()
.PP
Note regarding Windows 95 and 98: on Windows 9x the system crashes if you create more than about 1000 pixmaps, independent of the size of the pixmaps or installed RAM. Windows NT-systems (including 2000, XP and following versions) do not have the same limitation, but depending on the graphics equipment the system will fail to allocate pixmap objects at some point (due to system running out of GDI resources).
.PP
Qt tries to work around the resource limitation. If you set the pixmap optimization to QPixmap::MemoryOptim and the width of your pixmap is less than or equal to 128 pixels, Qt stores the pixmap in a way that is very memory-efficient when there are many pixmaps.
.PP
If your application uses dozens or hundreds of pixmaps (for example on tool bar buttons and in popup menus), and you plan to run it on Windows 95 or Windows 98, we recommend using code like this:
.PP
.nf
.br
        QPixmap::setDefaultOptimization( QPixmap::MemoryOptim );
.br
        while ( ... ) {
.br
            // load tool bar pixmaps etc.
.br
            QPixmap *pixmap = new QPixmap(fileName);
.br
        }
.br
        QPixmap::setDefaultOptimization( QPixmap::NormalOptim );
.br
.fi
.PP
In general it is recommended to make as much use of QPixmap's implicit sharing and the QPixmapCache as possible.
.PP
See also QBitmap, QImage, QImageIO, Shared Classes, Graphics Classes, Image Processing Classes, and Implicitly and Explicitly Shared Classes.
.SS "Member Type Documentation"
.SH "QPixmap::ColorMode"
This enum type defines the color modes that exist for converting QImage objects to QPixmap.
.TP
\fCQPixmap::Auto\fR - Select Color or Mono on a case-by-case basis.
.TP
\fCQPixmap::Color\fR - Always create colored pixmaps.
.TP
\fCQPixmap::Mono\fR - Always create bitmaps.
.SH "QPixmap::Optimization"
QPixmap has the choice of optimizing for speed or memory in a few places; the best choice varies from pixmap to pixmap but can generally be derived heuristically. This enum type defines a number of optimization modes that you can set for any pixmap to tweak the speed/memory tradeoffs:
.TP
\fCQPixmap::DefaultOptim\fR - Whatever QPixmap::defaultOptimization() returns. A pixmap with this optimization will have whatever the current default optimization is. If the default optimization is changed using setDefaultOptimization(), then this will not effect any pixmaps that have already been created.
.TP
\fCQPixmap::NoOptim\fR - No optimization (currently the same as MemoryOptim).
.TP
\fCQPixmap::MemoryOptim\fR - Optimize for minimal memory use on Windows 9x and X11 systems.
.TP
\fCQPixmap::NormalOptim\fR - Optimize for typical usage. Often uses more memory than MemoryOptim, and is often faster.
.TP
\fCQPixmap::BestOptim\fR - Optimize for pixmaps that are drawn very often and where performance is critical. Generally uses more memory than NormalOptim and may provide a little more speed.
.PP
We recommend using DefaultOptim.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QPixmap::QPixmap ()"
Constructs a null pixmap.
.PP
See also isNull().
.SH "QPixmap::QPixmap ( const QImage & image )"
Constructs a pixmap from the QImage \fIimage\fR.
.PP
See also convertFromImage().
.SH "QPixmap::QPixmap ( int w, int h, int depth = -1, Optimization optimization = DefaultOptim )"
Constructs a pixmap with \fIw\fR width, \fIh\fR height and \fIdepth\fR bits per pixel. The pixmap is optimized in accordance with the \fIoptimization\fR value.
.PP
The contents of the pixmap is uninitialized.
.PP
The \fIdepth\fR can be either 1 (monochrome) or the depth of the current video mode. If \fIdepth\fR is negative, then the hardware depth of the current video mode will be used.
.PP
If either \fIw\fR or \fIh\fR is zero, a null pixmap is constructed.
.PP
See also isNull() and QPixmap::Optimization.
.SH "QPixmap::QPixmap ( const QSize & size, int depth = -1, Optimization optimization = DefaultOptim )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Constructs a pixmap of size \fIsize\fR, \fIdepth\fR bits per pixel, optimized in accordance with the \fIoptimization\fR value.
.SH "QPixmap::QPixmap ( const QString & fileName, const char * format = 0, ColorMode mode = Auto )"
Constructs a pixmap from the file \fIfileName\fR. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap.
.PP
The \fIfileName\fR, \fIformat\fR and \fImode\fR parameters are passed on to load(). This means that the data in \fIfileName\fR is not compiled into the binary. If \fIfileName\fR contains a relative path (e.g. the filename only) the relevant file must be found relative to the runtime working directory.
.PP
See also QPixmap::ColorMode, isNull(), load(), loadFromData(), save(), and imageFormat().
.SH "QPixmap::QPixmap ( const QString & fileName, const char * format, int conversion_flags )"
Constructs a pixmap from the file \fIfileName\fR. If the file does not exist or is of an unknown format, the pixmap becomes a null pixmap.
.PP
The \fIfileName\fR, \fIformat\fR and \fIconversion_flags\fR parameters are passed on to load(). This means that the data in \fIfileName\fR is not compiled into the binary. If \fIfileName\fR contains a relative path (e.g. the filename only) the relevant file must be found relative to the runtime working directory.
.PP
If the image needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \fIconversion_flags\fR to specify how you'd prefer this to happen.
.PP
See also Qt::ImageConversionFlags, isNull(), load(), loadFromData(), save(), and imageFormat().
.SH "QPixmap::QPixmap ( const char * xpm[] )"
Constructs a pixmap from \fIxpm\fR, which must be a valid XPM image.
.PP
Errors are silently ignored.
.PP
Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:
.PP
.nf
.br
        static const char * const start_xpm[]={
.br
            "16 15 8 1",
.br
            "a c #cec6bd",
.br
        ....
.br
.fi
.PP
The extra \fCconst\fR makes the entire definition read-only, which is slightly more efficient (for example, when the code is in a shared library) and ROMable when the application is to be stored in ROM.
.PP
In order to use that sort of declaration you must cast the variable back to \fCconst char **\fR when you create the QPixmap.
.SH "QPixmap::QPixmap ( const QByteArray & img_data )"
Constructs a pixmaps by loading from \fIimg_data\fR. The data can be in any image format supported by Qt.
.PP
See also loadFromData().
.SH "QPixmap::QPixmap ( const QPixmap & pixmap )"
Constructs a pixmap that is a copy of \fIpixmap\fR.
.SH "QPixmap::QPixmap ( int w, int h, const uchar * bits, bool isXbitmap )\fC [protected]\fR"
Constructs a monochrome pixmap, with width \fIw\fR and height \fIh\fR, that is initialized with the data in \fIbits\fR. The \fIisXbitmap\fR indicates whether the data is an X bitmap and defaults to FALSE. This constructor is protected and used by the QBitmap class.
.SH "QPixmap::~QPixmap ()"
Destroys the pixmap.
.SH "bool QPixmap::convertFromImage ( const QImage & img, int conversion_flags )"
Converts image \fIimg\fR and sets this pixmap. Returns TRUE if successful; otherwise returns FALSE.
.PP
The \fIconversion_flags\fR argument is a bitwise-OR of the Qt::ImageConversionFlags. Passing 0 for \fIconversion_flags\fR sets all the default options.
.PP
Note that even though a QPixmap with depth 1 behaves much like a QBitmap, isQBitmap() returns FALSE.
.PP
If a pixmap with depth 1 is painted with color0 and color1 and converted to an image, the pixels painted with color0 will produce pixel index 0 in the image and those painted with color1 will produce pixel index 1.
.PP
See also convertToImage(), isQBitmap(), QImage::convertDepth(), defaultDepth(), and QImage::hasAlphaBuffer().
.PP
Examples:
.)l canvas/canvas.cpp and themes/wood.cpp.
.SH "bool QPixmap::convertFromImage ( const QImage & image, ColorMode mode = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Converts \fIimage\fR and sets this pixmap using color mode \fImode\fR. Returns TRUE if successful; otherwise returns FALSE.
.PP
See also QPixmap::ColorMode.
.SH "QImage QPixmap::convertToImage () const"
Converts the pixmap to a QImage. Returns a null image if it fails.
.PP
If the pixmap has 1-bit depth, the returned image will also be 1 bit deep. If the pixmap has 2- to 8-bit depth, the returned image has 8-bit depth. If the pixmap has greater than 8-bit depth, the returned image has 32-bit depth.
.PP
Note that for the moment, alpha masks on monochrome images are ignored.
.PP
See also convertFromImage().
.PP
Example: qmag/qmag.cpp.
.SH "QBitmap QPixmap::createHeuristicMask ( bool clipTight = TRUE ) const"
Creates and returns a heuristic mask for this pixmap. It works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges.
.PP
The mask may not be perfect but it should be reasonable, so you can do things such as the following:
.PP
.nf
.br
    pm->setMask( pm->createHeuristicMask() );
.br
.fi
.PP
This function is slow because it involves transformation to a QImage, non-trivial computations and a transformation back to a QBitmap.
.PP
If \fIclipTight\fR is TRUE the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.
.PP
See also QImage::createHeuristicMask().
.SH "int QPixmap::defaultDepth ()\fC [static]\fR"
Returns the default pixmap depth, i.e. the depth a pixmap gets if -1 is specified.
.PP
See also depth().
.SH "Optimization QPixmap::defaultOptimization ()\fC [static]\fR"
Returns the default pixmap optimization setting.
.PP
See also setDefaultOptimization(), setOptimization(), and optimization().
.SH "int QPixmap::depth () const"
Returns the depth of the pixmap.
.PP
The pixmap depth is also called bits per pixel (bpp) or bit planes of a pixmap. A null pixmap has depth 0.
.PP
See also defaultDepth(), isNull(), and QImage::convertDepth().
.SH "void QPixmap::detach ()\fC [virtual]\fR"
This is a special-purpose function that detaches the pixmap from shared pixmap data.
.PP
A pixmap is automatically detached by Qt whenever its contents is about to change. This is done in all QPixmap member functions that modify the pixmap (fill(), resize(), convertFromImage(), load(), etc.), in bitBlt() for the destination pixmap and in QPainter::begin() on a pixmap.
.PP
It is possible to modify a pixmap without letting Qt know. You can first obtain the system-dependent handle() and then call system-specific functions (for instance, BitBlt under Windows) that modify the pixmap contents. In such cases, you can call detach() to cut the pixmap loose from other pixmaps that share data with this one.
.PP
detach() returns immediately if there is just a single reference or if the pixmap has not been initialized yet.
.SH "void QPixmap::fill ( const QColor & fillColor = Qt::white )"
Fills the pixmap with the color \fIfillColor\fR.
.PP
Examples:
.)l chart/setdataform.cpp, desktop/desktop.cpp, grapher/grapher.cpp, hello/hello.cpp, t10/cannon.cpp, themes/metal.cpp, and xform/xform.cpp.
.SH "void QPixmap::fill ( const QWidget * widget, int xofs, int yofs )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Fills the pixmap with the \fIwidget\fR's background color or pixmap. If the background is empty, nothing is done. \fIxofs\fR, \fIyofs\fR is an offset in the widget.
.SH "void QPixmap::fill ( const QWidget * widget, const QPoint & ofs )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Fills the pixmap with the \fIwidget\fR's background color or pixmap. If the background is empty, nothing is done.
.PP
The \fIofs\fR point is an offset in the widget.
.PP
The point \fIofs\fR is a point in the widget's coordinate system. The pixmap's top-left pixel will be mapped to the point \fIofs\fR in the widget. This is significant if the widget has a background pixmap; otherwise the pixmap will simply be filled with the background color of the widget.
.PP
Example:
.PP
.nf
.br
    void CuteWidget::paintEvent( QPaintEvent *e )
.br
    {
.br
        QRect ur = e->rect();            // rectangle to update
.br
        QPixmap pix( ur.size() );        // Pixmap for double-buffering
.br
        pix.fill( this, ur.topLeft() );  // fill with widget background
.br
.br
        QPainter p( &pix );
.br
        p.translate( -ur.x(), -ur.y() ); // use widget coordinate system
.br
                                         // when drawing on pixmap
.br
        //    ... draw on pixmap ...
.br
.br
        p.end();
.br
.br
        bitBlt( this, ur.topLeft(), &pix );
.br
    }
.br
.fi
.SH "QPixmap QPixmap::fromMimeSource ( const QString & abs_name )\fC [static]\fR"
Convenience function. Gets the data associated with the absolute name \fIabs_name\fR from the default mime source factory and decodes it to a pixmap.
.PP
See also QMimeSourceFactory, QImage::fromMimeSource(), and QImageDrag::decode().
.PP
Example: textedit/textedit.cpp.
.SH "QPixmap QPixmap::grabWidget ( QWidget * widget, int x = 0, int y = 0, int w = -1, int h = -1 )\fC [static]\fR"
Creates a pixmap and paints \fIwidget\fR in it.
.PP
If the \fIwidget\fR has any children, then they are also painted in the appropriate positions.
.PP
If you specify \fIx\fR, \fIy\fR, \fIw\fR or \fIh\fR, only the rectangle you specify is painted. The defaults are 0, 0 (top-left corner) and -1,-1 (which means the entire widget).
.PP
(If \fIw\fR is negative, the function copies everything to the right border of the window. If \fIh\fR is negative, the function copies everything to the bottom of the window.)
.PP
If \fIwidget\fR is 0, or if the rectangle defined by \fIx\fR, \fIy\fR, the modified \fIw\fR and the modified \fIh\fR does not overlap the \fIwidget\fR->rect(), this function will return a null QPixmap.
.PP
This function actually asks \fIwidget\fR to paint itself (and its children to paint themselves). QPixmap::grabWindow() grabs pixels off the screen, which is a bit faster and picks up \fIexactly\fR what's on-screen. This function works by calling paintEvent() with painter redirection turned on. If there are overlaying windows, grabWindow() will see them, but not this function.
.PP
If there is overlap, it returns a pixmap of the size you want, containing a rendering of \fIwidget\fR. If the rectangle you ask for is a superset of \fIwidget\fR, the areas outside \fIwidget\fR are covered with the widget's background.
.PP
If an error occurs when trying to grab the widget, such as the size of the widget being too large to fit in memory, an isNull() pixmap is returned.
.PP
See also grabWindow(), QPainter::redirect(), and QWidget::paintEvent().
.SH "QPixmap QPixmap::grabWindow ( WId window, int x = 0, int y = 0, int w = -1, int h = -1 )\fC [static]\fR"
Grabs the contents of the window \fIwindow\fR and makes a pixmap out of it. Returns the pixmap.
.PP
The arguments \fI(x, y)\fR specify the offset in the window, whereas \fI(w, h)\fR specify the width and height of the area to be copied.
.PP
If \fIw\fR is negative, the function copies everything to the right border of the window. If \fIh\fR is negative, the function copies everything to the bottom of the window.
.PP
Note that grabWindow() grabs pixels from the screen, not from the window. If there is another window partially or entirely over the one you grab, you get pixels from the overlying window, too.
.PP
Note also that the mouse cursor is generally not grabbed.
.PP
The reason we use a window identifier and not a QWidget is to enable grabbing of windows that are not part of the application, window system frames, and so on.
.PP
\fBWarning:\fR Grabbing an area outside the screen is not safe in general. This depends on the underlying window system.
.PP
\fBWarning:\fR X11 only: If \fIwindow\fR is not the same depth as the root window and another window partially or entirely obscures the one you grab, you will \fInot\fR get pixels from the overlying window. The contests of the obscured areas in the pixmap are undefined and uninitialized.
.PP
See also grabWidget().
.PP
Example: qmag/qmag.cpp.
.SH "bool QPixmap::hasAlpha () const"
Returns TRUE this pixmap has an alpha channel or a mask.
.PP
See also hasAlphaChannel() and mask().
.SH "bool QPixmap::hasAlphaChannel () const"
Returns TRUE if the pixmap has an alpha channel; otherwise it returns FALSE.
.PP
NOTE: If the pixmap has a mask but not alpha channel, this function returns FALSE.
.PP
See also hasAlpha() and mask().
.SH "int QPixmap::height () const"
Returns the height of the pixmap.
.PP
See also width(), size(), and rect().
.PP
Examples:
.)l desktop/desktop.cpp, movies/main.cpp, scribble/scribble.cpp, scrollview/scrollview.cpp, t10/cannon.cpp, and xform/xform.cpp.
.SH "const char * QPixmap::imageFormat ( const QString & fileName )\fC [static]\fR"
Returns a string that specifies the image format of the file \fIfileName\fR, or 0 if the file cannot be read or if the format cannot be recognized.
.PP
The QImageIO documentation lists the supported image formats.
.PP
See also load() and save().
.SH "bool QPixmap::isNull () const"
Returns TRUE if this is a null pixmap; otherwise returns FALSE.
.PP
A null pixmap has zero width, zero height and no contents. You cannot draw in a null pixmap or bitBlt() anything to it.
.PP
Resizing an existing pixmap to (0, 0) makes a pixmap into a null pixmap.
.PP
See also resize().
.PP
Examples:
.)l movies/main.cpp, qdir/qdir.cpp, qmag/qmag.cpp, and scrollview/scrollview.cpp.
.SH "bool QPixmap::isQBitmap () const"
Returns TRUE if this is a QBitmap; otherwise returns FALSE.
.SH "bool QPixmap::load ( const QString & fileName, const char * format, int conversion_flags )"
Loads a pixmap from the file \fIfileName\fR at runtime. Returns TRUE if successful; otherwise returns FALSE.
.PP
If \fIformat\fR is specified, the loader attempts to read the pixmap using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file's format.
.PP
See the convertFromImage() documentation for a description of the \fIconversion_flags\fR argument.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also loadFromData(), save(), imageFormat(), QImage::load(), and QImageIO.
.PP
Examples:
.)l picture/picture.cpp, scrollview/scrollview.cpp, and xform/xform.cpp.
.SH "bool QPixmap::load ( const QString & fileName, const char * format = 0, ColorMode mode = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Loads a pixmap from the file \fIfileName\fR at runtime.
.PP
If \fIformat\fR is specified, the loader attempts to read the pixmap using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file's format.
.PP
The \fImode\fR is used to specify the color mode of the pixmap.
.PP
See also QPixmap::ColorMode.
.SH "bool QPixmap::loadFromData ( const uchar * buf, uint len, const char * format, int conversion_flags )"
Loads a pixmap from the binary data in \fIbuf\fR (\fIlen\fR bytes). Returns TRUE if successful; otherwise returns FALSE.
.PP
If \fIformat\fR is specified, the loader attempts to read the pixmap using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file's format.
.PP
See the convertFromImage() documentation for a description of the \fIconversion_flags\fR argument.
.PP
The QImageIO documentation lists the supported image formats and explains how to add extra formats.
.PP
See also load(), save(), imageFormat(), QImage::loadFromData(), and QImageIO.
.SH "bool QPixmap::loadFromData ( const uchar * buf, uint len, const char * format = 0, ColorMode mode = Auto )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Loads a pixmap from the binary data in \fIbuf\fR (\fIlen\fR bytes) using color mode \fImode\fR. Returns TRUE if successful; otherwise returns FALSE.
.PP
If \fIformat\fR is specified, the loader attempts to read the pixmap using the specified format. If \fIformat\fR is not specified (default), the loader reads a few bytes from the header to guess the file's format.
.PP
See also QPixmap::ColorMode.
.SH "bool QPixmap::loadFromData ( const QByteArray & buf, const char * format = 0, int conversion_flags = 0 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "const QBitmap * QPixmap::mask () const"
Returns the mask bitmap, or 0 if no mask has been set.
.PP
See also setMask(), QBitmap, and hasAlpha().
.SH "int QPixmap::metric ( int m ) const\fC [virtual protected]\fR"
Internal implementation of the virtual QPaintDevice::metric() function.
.PP
Use the QPaintDeviceMetrics class instead.
.PP
\fIm\fR is the metric to get.
.SH "QPixmap & QPixmap::operator= ( const QPixmap & pixmap )"
Assigns the pixmap \fIpixmap\fR to this pixmap and returns a reference to this pixmap.
.SH "QPixmap & QPixmap::operator= ( const QImage & image )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Converts the image \fIimage\fR to a pixmap that is assigned to this pixmap. Returns a reference to the pixmap.
.PP
See also convertFromImage().
.SH "Optimization QPixmap::optimization () const"
Returns the optimization setting for this pixmap.
.PP
The default optimization setting is QPixmap::NormalOptim. You can change this setting in two ways:
.TP
Call setDefaultOptimization() to set the default optimization for all new pixmaps.
.TP
Call setOptimization() to set the optimization for individual pixmaps.
.PP
See also setOptimization(), setDefaultOptimization(), and defaultOptimization().
.SH "QRect QPixmap::rect () const"
Returns the enclosing rectangle (0,0,width(),height()) of the pixmap.
.PP
See also width(), height(), and size().
.SH "void QPixmap::resize ( int w, int h )"
Resizes the pixmap to \fIw\fR width and \fIh\fR height. If either \fIw\fR or \fIh\fR is 0, the pixmap becomes a null pixmap.
.PP
If both \fIw\fR and \fIh\fR are greater than 0, a valid pixmap is created. New pixels will be uninitialized (random) if the pixmap is expanded.
.PP
Examples:
.)l desktop/desktop.cpp and grapher/grapher.cpp.
.SH "void QPixmap::resize ( const QSize & size )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Resizes the pixmap to size \fIsize\fR.
.SH "bool QPixmap::save ( const QString & fileName, const char * format, int quality = -1 ) const"
Saves the pixmap to the file \fIfileName\fR using the image file format \fIformat\fR and a quality factor \fIquality\fR. \fIquality\fR must be in the range [0,100] or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 to use the default settings. Returns TRUE if successful; otherwise returns FALSE.
.PP
See also load(), loadFromData(), imageFormat(), QImage::save(), and QImageIO.
.PP
Example: qmag/qmag.cpp.
.SH "bool QPixmap::save ( QIODevice * device, const char * format, int quality = -1 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function writes a QPixmap to the QIODevice, \fIdevice\fR. This can be used, for example, to save a pixmap directly into a QByteArray:
.PP
.nf
.br
    QPixmap pixmap;
.br
    QByteArray ba;
.br
    QBuffer buffer( ba );
.br
    buffer.open( IO_WriteOnly );
.br
    pixmap.save( &buffer, "PNG" ); // writes pixmap into ba in PNG format
.br
.fi
.SH "bool QPixmap::selfMask () const"
Returns TRUE if the pixmap's mask is identical to the pixmap itself; otherwise returns FALSE.
.PP
See also mask().
.SH "int QPixmap::serialNumber () const"
Returns a number that uniquely identifies the contents of this QPixmap object. This means that multiple QPixmap objects can have the same serial number as long as they refer to the same contents.
.PP
An example of where this is useful is for caching QPixmaps.
.PP
See also QPixmapCache.
.SH "void QPixmap::setDefaultOptimization ( Optimization optimization )\fC [static]\fR"
Sets the default pixmap optimization.
.PP
All \fInew\fR pixmaps that are created will use this default optimization. You may also set optimization for individual pixmaps using the setOptimization() function.
.PP
The initial default \fIoptimization\fR setting is \fCQPixmap::Normal\fR.
.PP
See also defaultOptimization(), setOptimization(), and optimization().
.SH "void QPixmap::setMask ( const QBitmap & newmask )"
Sets a mask bitmap.
.PP
The \fInewmask\fR bitmap defines the clip mask for this pixmap. Every pixel in \fInewmask\fR corresponds to a pixel in this pixmap. Pixel value 1 means opaque and pixel value 0 means transparent. The mask must have the same size as this pixmap.
.PP
\fBWarning:\fR Setting the mask on a pixmap will cause any alpha channel data to be cleared. For example:
.PP
.nf
.br
        QPixmap alpha( "image-with-alpha.png" );
.br
        QPixmap alphacopy = alpha;
.br
        alphacopy.setMask( *alphacopy.mask() );
.br
.fi
Now, alpha and alphacopy are visually different.
.PP
Setting a null mask resets the mask.
.PP
See also mask(), createHeuristicMask(), and QBitmap.
.SH "void QPixmap::setOptimization ( Optimization optimization )"
Sets pixmap drawing optimization for this pixmap.
.PP
The \fIoptimization\fR setting affects pixmap operations, in particular drawing of transparent pixmaps (bitBlt() a pixmap with a mask set) and pixmap transformations (the xForm() function).
.PP
Pixmap optimization involves keeping intermediate results in a cache buffer and using the cache to speed up bitBlt() and xForm(). The cost is more memory consumption, up to twice as much as an unoptimized pixmap.
.PP
Use the setDefaultOptimization() to change the default optimization for all new pixmaps.
.PP
See also optimization(), setDefaultOptimization(), and defaultOptimization().
.PP
Example: desktop/desktop.cpp.
.SH "QSize QPixmap::size () const"
Returns the size of the pixmap.
.PP
See also width(), height(), and rect().
.PP
Example: movies/main.cpp.
.SH "QWMatrix QPixmap::trueMatrix ( const QWMatrix & matrix, int w, int h )\fC [static]\fR"
Returns the actual matrix used for transforming a pixmap with \fIw\fR width and \fIh\fR height and matrix \fImatrix\fR.
.PP
When transforming a pixmap with xForm(), the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. xForm() returns the smallest pixmap containing all transformed points of the original pixmap.
.PP
This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.
.PP
See also xForm() and QWMatrix.
.SH "int QPixmap::width () const"
Returns the width of the pixmap.
.PP
See also height(), size(), and rect().
.PP
Examples:
.)l desktop/desktop.cpp, movies/main.cpp, scribble/scribble.cpp, scrollview/scrollview.cpp, and xform/xform.cpp.
.SH "QPixmap QPixmap::xForm ( const QWMatrix & matrix ) const"
Returns a copy of the pixmap that is transformed using \fImatrix\fR. The original pixmap is not changed.
.PP
The transformation \fImatrix\fR is internally adjusted to compensate for unwanted translation, i.e. xForm() returns the smallest image that contains all the transformed points of the original image.
.PP
This function is slow because it involves transformation to a QImage, non-trivial computations and a transformation back to a QPixmap.
.PP
See also trueMatrix(), QWMatrix, QPainter::setWorldMatrix(), and QImage::xForm().
.PP
Examples:
.)l desktop/desktop.cpp, fileiconview/qfileiconview.cpp, movies/main.cpp, and qmag/qmag.cpp.
.SH RELATED FUNCTION DOCUMENTATION
.SH "void copyBlt ( QPixmap * dst, int dx, int dy, const QPixmap * src, int sx, int sy, int sw, int sh )"
Copies a block of pixels from \fIsrc\fR to \fIdst\fR. The alpha channel and mask data (if any) is also copied from \fIsrc\fR. NOTE: \fIsrc\fR is \fInot\fR alpha blended or masked when copied to \fIdst\fR. Use bitBlt() or QPainter::drawPixmap() to perform alpha blending or masked drawing.
.PP
\fIsx\fR, \fIsy\fR is the top-left pixel in \fIsrc\fR (0, 0 by default), \fIdx\fR, \fIdy\fR is the top-left position in \fIdst\fR and \fIsw\fR, \\sh is the size of the copied block (all of \fIsrc\fR by default).
.PP
If \fIsrc\fR, \fIdst\fR, \fIsw\fR or \fIsh\fR is 0 (zero), copyBlt() does nothing. If \fIsw\fR or \fIsh\fR is negative, copyBlt() copies starting at \fIsx\fR (and respectively, \fIsy\fR) and ending at the right edge (and respectively, the bottom edge) of \fIsrc\fR.
.PP
copyBlt() does nothing if \fIsrc\fR and \fIdst\fR have different depths.
.SH "QDataStream & operator<< ( QDataStream & s, const QPixmap & pixmap )"
Writes the pixmap \fIpixmap\fR to the stream \fIs\fR as a PNG image.
.PP
Note that writing the stream to a file will not produce a valid image file.
.PP
See also QPixmap::save() and Format of the QDataStream operators.
.SH "QDataStream & operator>> ( QDataStream & s, QPixmap & pixmap )"
Reads a pixmap from the stream \fIs\fR into the pixmap \fIpixmap\fR.
.PP
See also QPixmap::load() and Format of the QDataStream operators.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qpixmap.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qpixmap.3qt) and the Qt
version (3.3.8).
