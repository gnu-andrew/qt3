'\" t
.TH QMap 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QMap \- Value-based template class that provides a dictionary
.SH SYNOPSIS
\fC#include <qmap.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "typedef Key \fBkey_type\fR"
.br
.ti -1c
.BI "typedef T \fBmapped_type\fR"
.br
.ti -1c
.BI "typedef QPair<const key_type, mapped_type> \fBvalue_type\fR"
.br
.ti -1c
.BI "typedef value_type * \fBpointer\fR"
.br
.ti -1c
.BI "typedef const value_type * \fBconst_pointer\fR"
.br
.ti -1c
.BI "typedef value_type & \fBreference\fR"
.br
.ti -1c
.BI "typedef const value_type & \fBconst_reference\fR"
.br
.ti -1c
.BI "typedef size_t \fBsize_type\fR"
.br
.ti -1c
.BI "typedef QMapIterator<Key, T> \fBiterator\fR"
.br
.ti -1c
.BI "typedef QMapConstIterator<Key, T> \fBconst_iterator\fR"
.br
.ti -1c
.BI "typedef QPair<iterator, bool> \fBinsert_pair\fR"
.br
.ti -1c
.BI "typedef QMapIterator<Key, T> \fBIterator\fR"
.br
.ti -1c
.BI "typedef QMapConstIterator<Key, T> \fBConstIterator\fR"
.br
.ti -1c
.BI "typedef T \fBValueType\fR"
.br
.ti -1c
.BI "\fBQMap\fR ()"
.br
.ti -1c
.BI "\fBQMap\fR ( const QMap<Key, T> & m )"
.br
.ti -1c
.BI "\fBQMap\fR ( const std::map<Key, T> & m )"
.br
.ti -1c
.BI "\fB~QMap\fR ()"
.br
.ti -1c
.BI "QMap<Key, T> & \fBoperator=\fR ( const QMap<Key, T> & m )"
.br
.ti -1c
.BI "QMap<Key, T> & \fBoperator=\fR ( const std::map<Key, T> & m )"
.br
.ti -1c
.BI "iterator \fBbegin\fR ()"
.br
.ti -1c
.BI "iterator \fBend\fR ()"
.br
.ti -1c
.BI "const_iterator \fBbegin\fR () const"
.br
.ti -1c
.BI "const_iterator \fBend\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstBegin\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstEnd\fR () const"
.br
.ti -1c
.BI "iterator \fBreplace\fR ( const Key & k, const T & v )"
.br
.ti -1c
.BI "size_type \fBsize\fR () const"
.br
.ti -1c
.BI "bool \fBempty\fR () const"
.br
.ti -1c
.BI "QPair<iterator, bool> \fBinsert\fR ( const value_type & x )"
.br
.ti -1c
.BI "void \fBerase\fR ( iterator it )"
.br
.ti -1c
.BI "void \fBerase\fR ( const key_type & k )"
.br
.ti -1c
.BI "size_type \fBcount\fR ( const key_type & k ) const"
.br
.ti -1c
.BI "T & \fBoperator[]\fR ( const Key & k )"
.br
.ti -1c
.BI "void \fBclear\fR ()"
.br
.ti -1c
.BI "iterator \fBfind\fR ( const Key & k )"
.br
.ti -1c
.BI "const_iterator \fBfind\fR ( const Key & k ) const"
.br
.ti -1c
.BI "const T & \fBoperator[]\fR ( const Key & k ) const"
.br
.ti -1c
.BI "bool \fBcontains\fR ( const Key & k ) const"
.br
.ti -1c
.BI "size_type \fBcount\fR () const"
.br
.ti -1c
.BI "QValueList<Key> \fBkeys\fR () const"
.br
.ti -1c
.BI "QValueList<T> \fBvalues\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "iterator \fBinsert\fR ( const Key & key, const T & value, bool overwrite = TRUE )"
.br
.ti -1c
.BI "void \fBremove\fR ( iterator it )"
.br
.ti -1c
.BI "void \fBremove\fR ( const Key & k )"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "void \fBdetach\fR ()"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QMap<Key, T> & m )"
.br
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QMap<Key, T> & m )"
.br
.in -1c
.SH DESCRIPTION
The QMap class is a value-based template class that provides a dictionary.
.PP
QMap is a Qt implementation of an STL-like map container. It can be used in your application if the standard \fCmap\fR is not available on all your target platforms. QMap is part of the Qt Template Library.
.PP
QMap<Key, Data> defines a template instance to create a dictionary with keys of type Key and values of type Data. QMap does not store pointers to the members of the map; instead, it holds a copy of every member. For this reason, QMap is value-based, whereas QPtrList and QDict are pointer-based.
.PP
QMap contains and manages a collection of objects of type Data with associated key values of type Key and provides iterators that allow the contained objects to be addressed. QMap owns the contained items.
.PP
Some classes cannot be used within a QMap. For example everything derived from QObject and thus all classes that implement widgets. Only values can be used in a QMap. To qualify as a value, the class must provide
.TP
A copy constructor
.TP
An assignment operator
.TP
A default constructor, i.e. a constructor that does not take any arguments.
.PP
Note that C++ defaults to field-by-field assignment operators and copy constructors if no explicit version is supplied. In many cases, this is sufficient.
.PP
The class used for the key requires that the \fCoperator<\fR is implemented to define ordering of the keys.
.PP
QMap's function naming is consistent with the other Qt classes (e.g., count(), isEmpty()). QMap also provides extra functions for compatibility with STL algorithms, such as size() and empty(). Programmers already familiar with the STL \fCmap\fR can use these the STL-like functions if preferred.
.PP
Example:
.PP
.nf
.br
    #include <qstring.h>
.br
    #include <qmap.h>
.br
    #include <qstring.h>
.br
.br
    class Employee
.br
    {
.br
    public:
.br
        Employee(): sn(0) {}
.br
        Employee( const QString& forename, const QString& surname, int salary )
.br
            : fn(forename), sn(surname), sal(salary)
.br
        { }
.br
.br
        QString forename() const { return fn; }
.br
        QString surname() const { return sn; }
.br
        int salary() const { return sal; }
.br
        void setSalary( int salary ) { sal = salary; }
.br
.br
    private:
.br
        QString fn;
.br
        QString sn;
.br
        int sal;
.br
    };
.br
.br
    int main(int argc, char **argv)
.br
    {
.br
        QApplication app( argc, argv );
.br
.br
        typedef QMap<QString, Employee> EmployeeMap;
.br
        EmployeeMap map;
.br
.br
        map["JD001"] = Employee("John", "Doe", 50000);
.br
        map["JW002"] = Employee("Jane", "Williams", 80000);
.br
        map["TJ001"] = Employee("Tom", "Jones", 60000);
.br
.br
        Employee sasha( "Sasha", "Hind", 50000 );
.br
        map["SH001"] = sasha;
.br
        sasha.setSalary( 40000 );
.br
.br
        EmployeeMap::Iterator it;
.br
        for ( it = map.begin(); it != map.end(); ++it ) {
.br
            printf( "%s: %s, %s earns %d\\n",
.br
                    it.key().latin1(),
.br
                    it.data().surname().latin1(),
.br
                    it.data().forename().latin1(),
.br
                    it.data().salary() );
.br
        }
.br
        return 0;
.br
    }
.br
.fi
.PP
Program output:
.PP
.nf
.br
    JD001: Doe, John earns 50000
.br
    JW002: Williams, Jane earns 80000
.br
    SH001: Hind, Sasha earns 50000
.br
    TJ001: Jones, Tom earns 60000
.br
.fi
.PP
The latest changes to Sasha's salary did not affect the value in the list because the map created a copy of Sasha's entry. In addition, notice that the items are sorted alphabetically (by key) when iterating over the map.
.PP
There are several ways to find items in a map. The begin() and end() functions return iterators to the beginning and end of the map. The advantage of using an iterator is that you can move forward or backward by incrementing/decrementing the iterator. The iterator returned by end() points to the element which is one past the last element in the container. The past-the-end iterator is still associated with the map it belongs to, however it is \fInot\fR dereferenceable; operator*() will not return a well-defined value. If the map is empty, the iterator returned by begin() will equal the iterator returned by end().
.PP
Another way to find an element in the map is by using the find() function. This returns an iterator pointing to the desired item or to the end() iterator if no such element exists.
.PP
Another approach uses the operator[]. But be warned: if the map does not contain an entry for the element you are looking for, operator[] inserts a default value. If you do not know that the element you are searching for is really in the list, you should not use operator[]. The following example illustrates this:
.PP
.nf
.br
        QMap<QString,QString> map;
.br
        map["Clinton"] = "Bill";
.br
        str << map["Clinton"] << map["Bush"] << endl;
.br
.fi
.PP
The code fragment will print out "Clinton", "". Since the value associated with the "Bush" key did not exist, the map inserted a default value (in this case, an empty string). If you are not sure whether a certain element is in the map, you should use find() and iterators instead.
.PP
If you just want to know whether a certain key is contained in the map, use the contains() function. In addition, count() tells you how many keys are in the map.
.PP
It is safe to have multiple iterators at the same time. If some member of the map is removed, only iterators pointing to the removed member become invalid; inserting in the map does not invalidate any iterators.
.PP
Since QMap is value-based, there is no need to be concerned about deleting items in the map. The map holds its own copies and will free them if the corresponding member or the map itself is deleted.
.PP
QMap is implicitly shared. This means you can just make copies of the map in time O(1). If multiple QMap instances share the same data and one is modifying the map's data, this modifying instance makes a copy and modifies its private copy: so it does not affect other instances. If a QMap is being used in a multi-threaded program, you must protect all access to the map. See QMutex.
.PP
There are a couple of ways of inserting new items into the map. One uses the insert() method; the other uses operator[]:
.PP
.nf
.br
    QMap<QString, QString> map;
.br
    map["Clinton"] = "Bill";
.br
    map.insert( "Bush", "George" );
.br
.fi
.PP
Items can also be removed from the map in several ways. One way is to pass an iterator to remove(). Another way is to pass a key value to remove(), which will delete the entry with the requested key. In addition you can clear the entire map using the clear() method.
.PP
See also QMapIterator, Qt Template Library Classes, Implicitly and Explicitly Shared Classes, and Non-GUI Classes.
.SS "Member Type Documentation"
.SH "QMap::ConstIterator"
The map's const iterator type, Qt style.
.SH "QMap::Iterator"
The map's iterator type, Qt style.
.SH "QMap::ValueType"
Corresponds to QPair<key_type, mapped_type>, Qt style.
.SH "QMap::const_iterator"
The map's const iterator type.
.SH "QMap::const_pointer"
Const pointer to value_type.
.SH "QMap::const_reference"
Const reference to value_type.
.SH "QMap::iterator"
The map's iterator type.
.SH "QMap::key_type"
The map's key type.
.SH "QMap::mapped_type"
The map's data type.
.SH "QMap::pointer"
Pointer to value_type.
.SH "QMap::reference"
Reference to value_type.
.SH "QMap::size_type"
An unsigned integral type, used to represent various sizes.
.SH "QMap::value_type"
Corresponds to QPair<key_type, mapped_type>.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QMap::QMap ()"
Constructs an empty map.
.SH "QMap::QMap ( const QMap<Key, T> & m )"
Constructs a copy of \fIm\fR.
.PP
This operation costs O(1) time because QMap is implicitly shared. This makes returning a QMap from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes O(n) time.
.SH "QMap::QMap ( const std::map<Key, T> & m )"
Constructs a copy of \fIm\fR.
.SH "QMap::~QMap ()"
Destroys the map. References to the values in the map and all iterators of this map become invalidated. Since QMap is highly tuned for performance you won't see warnings if you use invalid iterators, because it is not possible for an iterator to check whether it is valid or not.
.SH "iterator QMap::begin ()"
Returns an iterator pointing to the first element in the map. This iterator equals end() if the map is empty.
.PP
The items in the map are traversed in the order defined by operator<(Key, Key).
.PP
See also end() and QMapIterator.
.SH "const_iterator QMap::begin () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
See also end() and QMapConstIterator.
.SH "void QMap::clear ()"
Removes all items from the map.
.PP
See also remove().
.SH "const_iterator QMap::constBegin () const"
Returns an iterator pointing to the first element in the map. This iterator equals end() if the map is empty.
.PP
The items in the map are traversed in the order defined by operator<(Key, Key).
.PP
See also constEnd() and QMapConstIterator.
.SH "const_iterator QMap::constEnd () const"
The iterator returned by end() points to the element which is one past the last element in the container. The past-the-end iterator is still associated with the map it belongs to, but it is \fInot\fR dereferenceable; operator*() will not return a well-defined value.
.PP
This iterator equals constBegin() if the map is empty.
.PP
See also constBegin() and QMapConstIterator.
.SH "bool QMap::contains ( const Key & k ) const"
Returns TRUE if the map contains an item with key \fIk\fR; otherwise returns FALSE.
.SH "size_type QMap::count ( const key_type & k ) const"
Returns the number of items whose key is \fIk\fR. Since QMap does not allow duplicate keys, the return value is always 0 or 1.
.PP
This function is provided for STL compatibility.
.SH "size_type QMap::count () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the number of items in the map.
.PP
See also isEmpty().
.SH "void QMap::detach ()\fC [protected]\fR"
If the map does not share its data with another QMap instance, nothing happens; otherwise the function creates a new copy of this map and detaches from the shared one. This function is called whenever the map is modified. The implicit sharing mechanism is implemented this way.
.SH "bool QMap::empty () const"
Returns TRUE if the map contains no items; otherwise returns FALSE.
.PP
This function is provided for STL compatibility. It is equivalent to isEmpty().
.PP
See also size().
.SH "iterator QMap::end ()"
The iterator returned by end() points to the element which is one past the last element in the container. The past-the-end iterator is still associated with the map it belongs to, but it is \fInot\fR dereferenceable; operator*() will not return a well-defined value.
.PP
This iterator equals begin() if the map is empty.
.PP
See also begin() and QMapIterator.
.SH "const_iterator QMap::end () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "void QMap::erase ( iterator it )"
Removes the item associated with the iterator \fIit\fR from the map.
.PP
This function is provided for STL compatibility. It is equivalent to remove().
.PP
See also clear().
.SH "void QMap::erase ( const key_type & k )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes the item with the key \fIk\fR from the map.
.SH "iterator QMap::find ( const Key & k )"
Returns an iterator pointing to the element with key \fIk\fR in the map.
.PP
Returns end() if no key matched.
.PP
See also QMapIterator.
.SH "const_iterator QMap::find ( const Key & k ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator pointing to the element with key \fIk\fR in the map.
.PP
Returns end() if no key matched.
.PP
See also QMapConstIterator.
.SH "iterator QMap::insert ( const Key & key, const T & value, bool overwrite = TRUE )"
Inserts a new item with the key, \fIkey\fR, and a value of \fIvalue\fR. If there is already an item whose key is \fIkey\fR, that item's value is replaced with \fIvalue\fR, unless \fIoverwrite\fR is FALSE (it is TRUE by default). In this case an iterator to this item is returned, else an iterator to the new item is returned.
.SH "QPair<iterator, bool> QMap::insert ( const value_type & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts the (key, value) pair \fIx\fR into the map. \fIx\fR is a QPair whose \fCfirst\fR element is a key to be inserted and whose \fCsecond\fR element is the associated value to be inserted. Returns a pair whose \fCfirst\fR element is an iterator pointing to the inserted item and whose \fCsecond\fR element is a bool indicating TRUE if \fIx\fR was inserted and FALSE if it was not inserted, e.g. because it was already present.
.PP
See also replace().
.SH "bool QMap::isEmpty () const"
Returns TRUE if the map contains no items; otherwise returns FALSE.
.PP
See also count().
.SH "QValueList<Key> QMap::keys () const"
Returns a list of all the keys in the map, in order.
.SH "QMap<Key, T> & QMap::operator= ( const QMap<Key, T> & m )"
Assigns \fIm\fR to this map and returns a reference to this map.
.PP
All iterators of the current map become invalidated by this operation. The cost of such an assignment is O(1), because QMap is implicitly shared.
.SH "QMap<Key, T> & QMap::operator= ( const std::map<Key, T> & m )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns \fIm\fR to this map and returns a reference to this map.
.PP
All iterators of the current map become invalidated by this operation.
.SH "T & QMap::operator[] ( const Key & k )"
Returns the value associated with the key \fIk\fR. If no such key is present, an empty item is inserted with this key and a reference to the empty item is returned.
.PP
You can use this operator both for reading and writing:
.PP
.nf
.br
    QMap<QString, QString> map;
.br
    map["Clinton"] = "Bill";
.br
    stream << map["Clinton"];
.br
.fi
.SH "const T & QMap::operator[] ( const Key & k ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fBWarning:\fR This function differs from the non-const version of the same function. It will \fInot\fR insert an empty value if the key \fIk\fR does not exist. This may lead to logic errors in your program. You should check if the element exists before calling this function.
.PP
Returns the value associated with the key \fIk\fR. If no such key is present, a reference to an empty item is returned.
.SH "void QMap::remove ( iterator it )"
Removes the item associated with the iterator \fIit\fR from the map.
.PP
See also clear().
.SH "void QMap::remove ( const Key & k )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes the item with the key \fIk\fR from the map.
.SH "iterator QMap::replace ( const Key & k, const T & v )"
Replaces the value of the element with key \fIk\fR, with the value \fIv\fR.
.PP
See also insert() and remove().
.SH "size_type QMap::size () const"
Returns the number of items in the map.
.PP
This function is provided for STL compatibility. It is equivalent to count().
.PP
See also empty().
.SH "QValueList<T> QMap::values () const"
Returns a list of all the values in the map, in key order.
.SH RELATED FUNCTION DOCUMENTATION
.SH "QDataStream & operator<< ( QDataStream & s, const QMap<Key, T> & m )"
Writes the map \fIm\fR to the stream \fIs\fR. The types \fIKey\fR and \fIT\fR must implement the streaming operator as well.
.SH "QDataStream & operator>> ( QDataStream & s, QMap<Key, T> & m )"
Reads the map \fIm\fR from the stream \fIs\fR. The types \fIKey\fR and \fIT\fR
must implement the streaming operator as well.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qmap.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qmap.3qt) and the Qt
version (3.3.8).
