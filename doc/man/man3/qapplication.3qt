'\" t
.TH QApplication 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QApplication \- Manages the GUI application's control flow and main settings
.SH SYNOPSIS
\fC#include <qapplication.h>\fR
.PP
Inherits QObject.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQApplication\fR ( int & argc, char ** argv )"
.br
.ti -1c
.BI "\fBQApplication\fR ( int & argc, char ** argv, bool GUIenabled )"
.br
.ti -1c
.BI "enum \fBType\fR { Tty, GuiClient, GuiServer }"
.br
.ti -1c
.BI "\fBQApplication\fR ( int & argc, char ** argv, Type type )"
.br
.ti -1c
.BI "\fBQApplication\fR ( Display * dpy, HANDLE visual = 0, HANDLE colormap = 0 )"
.br
.ti -1c
.BI "\fBQApplication\fR ( Display * dpy, int argc, char ** argv, HANDLE visual = 0, HANDLE colormap = 0 )"
.br
.ti -1c
.BI "virtual \fB~QApplication\fR ()"
.br
.ti -1c
.BI "int \fBargc\fR () const"
.br
.ti -1c
.BI "char ** \fBargv\fR () const"
.br
.ti -1c
.BI "Type \fBtype\fR () const"
.br
.ti -1c
.BI "enum \fBColorSpec\fR { NormalColor = 0, CustomColor = 1, ManyColor = 2 }"
.br
.ti -1c
.BI "QWidget * \fBmainWidget\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMainWidget\fR ( QWidget * mainWidget )"
.br
.ti -1c
.BI "virtual void \fBpolish\fR ( QWidget * w )"
.br
.ti -1c
.BI "QWidget * \fBfocusWidget\fR () const"
.br
.ti -1c
.BI "QWidget * \fBactiveWindow\fR () const"
.br
.ti -1c
.BI "int \fBexec\fR ()"
.br
.ti -1c
.BI "void \fBprocessEvents\fR ()"
.br
.ti -1c
.BI "void \fBprocessEvents\fR ( int maxtime )"
.br
.ti -1c
.BI "void processOneEvent ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "bool \fBhasPendingEvents\fR ()"
.br
.ti -1c
.BI "int enter_loop ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void exit_loop ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "int loopLevel () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual bool \fBnotify\fR ( QObject * receiver, QEvent * e )"
.br
.ti -1c
.BI "void setDefaultCodec ( QTextCodec * codec )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QTextCodec * defaultCodec () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBinstallTranslator\fR ( QTranslator * mf )"
.br
.ti -1c
.BI "void \fBremoveTranslator\fR ( QTranslator * mf )"
.br
.ti -1c
.BI "enum \fBEncoding\fR { DefaultCodec, UnicodeUTF8 }"
.br
.ti -1c
.BI "QString \fBtranslate\fR ( const char * context, const char * sourceText, const char * comment = 0, Encoding encoding = DefaultCodec ) const"
.br
.ti -1c
.BI "QString \fBapplicationDirPath\fR ()"
.br
.ti -1c
.BI "QString \fBapplicationFilePath\fR ()"
.br
.ti -1c
.BI "virtual bool \fBmacEventFilter\fR ( EventHandlerCallRef, EventRef )"
.br
.ti -1c
.BI "virtual bool \fBwinEventFilter\fR ( MSG * )"
.br
.ti -1c
.BI "virtual bool \fBx11EventFilter\fR ( XEvent * )"
.br
.ti -1c
.BI "int \fBx11ProcessEvent\fR ( XEvent * event )"
.br
.ti -1c
.BI "virtual bool \fBqwsEventFilter\fR ( QWSEvent * )"
.br
.ti -1c
.BI "void \fBqwsSetCustomColors\fR ( QRgb * colorTable, int start, int numColors )"
.br
.ti -1c
.BI "void \fBwinFocus\fR ( QWidget * widget, bool gotFocus )"
.br
.ti -1c
.BI "bool \fBisSessionRestored\fR () const"
.br
.ti -1c
.BI "QString \fBsessionId\fR () const"
.br
.ti -1c
.BI "QString \fBsessionKey\fR () const"
.br
.ti -1c
.BI "virtual void \fBcommitData\fR ( QSessionManager & sm )"
.br
.ti -1c
.BI "virtual void \fBsaveState\fR ( QSessionManager & sm )"
.br
.ti -1c
.BI "void \fBwakeUpGuiThread\fR ()"
.br
.ti -1c
.BI "void \fBlock\fR ()"
.br
.ti -1c
.BI "void \fBunlock\fR ( bool wakeUpGui = TRUE )"
.br
.ti -1c
.BI "bool \fBlocked\fR ()"
.br
.ti -1c
.BI "bool \fBtryLock\fR ()"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "void \fBquit\fR ()"
.br
.ti -1c
.BI "void \fBcloseAllWindows\fR ()"
.br
.ti -1c
.BI "void \fBaboutQt\fR ()"
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBlastWindowClosed\fR ()"
.br
.ti -1c
.BI "void \fBaboutToQuit\fR ()"
.br
.ti -1c
.BI "void \fBguiThreadAwake\fR ()"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QStyle & \fBstyle\fR ()"
.br
.ti -1c
.BI "void \fBsetStyle\fR ( QStyle * style )"
.br
.ti -1c
.BI "QStyle * \fBsetStyle\fR ( const QString & style )"
.br
.ti -1c
.BI "int \fBcolorSpec\fR ()"
.br
.ti -1c
.BI "void \fBsetColorSpec\fR ( int spec )"
.br
.ti -1c
.BI "QCursor * \fBoverrideCursor\fR ()"
.br
.ti -1c
.BI "void \fBsetOverrideCursor\fR ( const QCursor & cursor, bool replace = FALSE )"
.br
.ti -1c
.BI "void \fBrestoreOverrideCursor\fR ()"
.br
.ti -1c
.BI "bool \fBhasGlobalMouseTracking\fR ()"
.br
.ti -1c
.BI "void \fBsetGlobalMouseTracking\fR ( bool enable )"
.br
.ti -1c
.BI "QPalette \fBpalette\fR ( const QWidget * w = 0 )"
.br
.ti -1c
.BI "void \fBsetPalette\fR ( const QPalette & palette, bool informWidgets = FALSE, const char * className = 0 )"
.br
.ti -1c
.BI "QFont \fBfont\fR ( const QWidget * w = 0 )"
.br
.ti -1c
.BI "void \fBsetFont\fR ( const QFont & font, bool informWidgets = FALSE, const char * className = 0 )"
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR ()"
.br
.ti -1c
.BI "QWidgetList * \fBallWidgets\fR ()"
.br
.ti -1c
.BI "QWidgetList * \fBtopLevelWidgets\fR ()"
.br
.ti -1c
.BI "QDesktopWidget * \fBdesktop\fR ()"
.br
.ti -1c
.BI "QWidget * \fBactivePopupWidget\fR ()"
.br
.ti -1c
.BI "QWidget * \fBactiveModalWidget\fR ()"
.br
.ti -1c
.BI "QClipboard * \fBclipboard\fR ()"
.br
.ti -1c
.BI "QWidget * \fBwidgetAt\fR ( int x, int y, bool child = FALSE )"
.br
.ti -1c
.BI "QWidget * \fBwidgetAt\fR ( const QPoint & pos, bool child = FALSE )"
.br
.ti -1c
.BI "QEventLoop * \fBeventLoop\fR ()"
.br
.ti -1c
.BI "void \fBexit\fR ( int retcode = 0 )"
.br
.ti -1c
.BI "bool \fBsendEvent\fR ( QObject * receiver, QEvent * event )"
.br
.ti -1c
.BI "void \fBpostEvent\fR ( QObject * receiver, QEvent * event )"
.br
.ti -1c
.BI "void \fBsendPostedEvents\fR ( QObject * receiver, int event_type )"
.br
.ti -1c
.BI "void \fBsendPostedEvents\fR ()"
.br
.ti -1c
.BI "void \fBremovePostedEvents\fR ( QObject * receiver )"
.br
.ti -1c
.BI "bool \fBstartingUp\fR ()"
.br
.ti -1c
.BI "bool \fBclosingDown\fR ()"
.br
.ti -1c
.BI "void \fBflushX\fR ()"
.br
.ti -1c
.BI "void \fBflush\fR ()"
.br
.ti -1c
.BI "void \fBsyncX\fR ()"
.br
.ti -1c
.BI "void \fBbeep\fR ()"
.br
.ti -1c
.BI "void setWinStyleHighlightColor ( const QColor & c )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "const QColor & winStyleHighlightColor ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBsetDesktopSettingsAware\fR ( bool on )"
.br
.ti -1c
.BI "bool \fBdesktopSettingsAware\fR ()"
.br
.ti -1c
.BI "void \fBsetCursorFlashTime\fR ( int msecs )"
.br
.ti -1c
.BI "int \fBcursorFlashTime\fR ()"
.br
.ti -1c
.BI "void \fBsetDoubleClickInterval\fR ( int ms )"
.br
.ti -1c
.BI "int \fBdoubleClickInterval\fR ()"
.br
.ti -1c
.BI "void \fBsetWheelScrollLines\fR ( int n )"
.br
.ti -1c
.BI "int \fBwheelScrollLines\fR ()"
.br
.ti -1c
.BI "void \fBsetGlobalStrut\fR ( const QSize & strut )"
.br
.ti -1c
.BI "QSize \fBglobalStrut\fR ()"
.br
.ti -1c
.BI "void \fBsetLibraryPaths\fR ( const QStringList & paths )"
.br
.ti -1c
.BI "QStringList \fBlibraryPaths\fR ()"
.br
.ti -1c
.BI "void \fBaddLibraryPath\fR ( const QString & path )"
.br
.ti -1c
.BI "void \fBremoveLibraryPath\fR ( const QString & path )"
.br
.ti -1c
.BI "void \fBsetStartDragTime\fR ( int ms )"
.br
.ti -1c
.BI "int \fBstartDragTime\fR ()"
.br
.ti -1c
.BI "void \fBsetStartDragDistance\fR ( int l )"
.br
.ti -1c
.BI "int \fBstartDragDistance\fR ()"
.br
.ti -1c
.BI "void \fBsetReverseLayout\fR ( bool b )"
.br
.ti -1c
.BI "bool \fBreverseLayout\fR ()"
.br
.ti -1c
.BI "int \fBhorizontalAlignment\fR ( int align )"
.br
.ti -1c
.BI "bool \fBisEffectEnabled\fR ( Qt::UIEffect effect )"
.br
.ti -1c
.BI "void \fBsetEffectEnabled\fR ( Qt::UIEffect effect, bool enable = TRUE )"
.br
.ti -1c
.BI "QWSDecoration & \fBqwsDecoration\fR ()"
.br
.ti -1c
.BI "void \fBqwsSetDecoration\fR ( QWSDecoration * d )"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "void \fBqAddPostRoutine\fR ( QtCleanUpFunction p )"
.br
.ti -1c
.BI "const char * \fBqVersion\fR ()"
.br
.ti -1c
.BI "bool \fBqSysInfo\fR ( int * wordSize, bool * bigEndian )"
.br
.ti -1c
.BI "void \fBqDebug\fR ( const char * msg, ... )"
.br
.ti -1c
.BI "void \fBqWarning\fR ( const char * msg, ... )"
.br
.ti -1c
.BI "void \fBqFatal\fR ( const char * msg, ... )"
.br
.ti -1c
.BI "void \fBqSystemWarning\fR ( const char * msg, int code )"
.br
.ti -1c
.BI "void \fBQ_ASSERT\fR ( bool test )"
.br
.ti -1c
.BI "void \fBQ_CHECK_PTR\fR ( void * p )"
.br
.ti -1c
.BI "QtMsgHandler \fBqInstallMsgHandler\fR ( QtMsgHandler h )"
.br
.in -1c
.SH DESCRIPTION
The QApplication class manages the GUI application's control flow and main settings.
.PP
It contains the main event loop, where all events from the window system and other sources are processed and dispatched. It also handles the application's initialization and finalization, and provides session management. It also handles most system-wide and application-wide settings.
.PP
For any GUI application that uses Qt, there is precisely one QApplication object, no matter whether the application has 0, 1, 2 or more windows at any time.
.PP
The QApplication object is accessible through the global pointer \fCqApp\fR. Its main areas of responsibility are:
.IP
.TP
It initializes the application with the user's desktop settings such as palette(), font() and doubleClickInterval(). It keeps track of these properties in case the user changes the desktop globally, for example through some kind of control panel.
.IP
.TP
It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. By using sendEvent() and postEvent() you can send your own events to widgets.
.IP
.TP
It parses common command line arguments and sets its internal state accordingly. See the constructor documentation below for more details about this.
.IP
.TP
It defines the application's look and feel, which is encapsulated in a QStyle object. This can be changed at runtime with setStyle().
.IP
.TP
It specifies how the application is to allocate colors. See setColorSpec() for details.
.IP
.TP
It provides localization of strings that are visible to the user via translate().
.IP
.TP
It provides some magical objects like the desktop() and the clipboard().
.IP
.TP
It knows about the application's windows. You can ask which widget is at a certain position using widgetAt(), get a list of topLevelWidgets() and closeAllWindows(), etc.
.IP
.TP
It manages the application's mouse cursor handling, see setOverrideCursor() and setGlobalMouseTracking().
.IP
.TP
On the X window system, it provides functions to flush and sync the communication stream, see flushX() and syncX().
.IP
.TP
It provides support for sophisticated session management. This makes it possible for applications to terminate gracefully when the user logs out, to cancel a shutdown process if termination isn't possible and even to preserve the entire application's state for a future session. See isSessionRestored(), sessionId() and commitData() and saveState() for details.
.IP
.PP
The Application walk-through example contains a typical complete main() that does the usual things with QApplication.
.PP
Since the QApplication object does so much initialization, it \fBmust\fR be created before any other objects related to the user interface are created.
.PP
Since it also deals with common command line arguments, it is usually a good idea to create it \fIbefore\fR any interpretation or modification of \fCargv\fR is done in the application itself. (Note also that for X11, setMainWidget() may change the main widget according to the \fC-geometry\fR option. To preserve this functionality, you must set your defaults before setMainWidget() and any overrides after.)
.PP
<center>.nf
.TS
l - l. Groups of functions System settings desktopSettingsAware(), setDesktopSettingsAware(), cursorFlashTime(), setCursorFlashTime(), doubleClickInterval(), setDoubleClickInterval(), wheelScrollLines(), setWheelScrollLines(), palette(), setPalette(), font(), setFont(), fontMetrics(). Event handling exec(), processEvents(), enter_loop(), exit_loop(), exit(), quit(). sendEvent(), postEvent(), sendPostedEvents(), removePostedEvents(), hasPendingEvents(), notify(), macEventFilter(), qwsEventFilter(), x11EventFilter(), x11ProcessEvent(), winEventFilter(). GUI Styles style(), setStyle(), polish(). Color usage colorSpec(), setColorSpec(), qwsSetCustomColors(). Text handling installTranslator(), removeTranslator() translate(). Widgets mainWidget(), setMainWidget(), allWidgets(), topLevelWidgets(), desktop(), activePopupWidget(), activeModalWidget(), clipboard(), focusWidget(), winFocus(), activeWindow(), widgetAt(). Advanced cursor handling hasGlobalMouseTracking(), setGlobalMouseTracking(), overrideCursor(), setOverrideCursor(), restoreOverrideCursor(). X Window System synchronization flushX(), syncX(). Session management isSessionRestored(), sessionId(), commitData(), saveState(). Threading lock(), unlock(), locked(), tryLock(), wakeUpGuiThread() Miscellaneous
.TE
.fi
</center>
.PP
\fINon-GUI programs:\fR While Qt is not optimized or designed for writing non-GUI programs, it's possible to use some of its classes without creating a QApplication. This can be useful if you wish to share code between a non-GUI server and a GUI client.
.PP
See also Main Window and Related Classes.
.SS "Member Type Documentation"
.SH "QApplication::ColorSpec"
.TP
\fCQApplication::NormalColor\fR - the default color allocation policy
.TP
\fCQApplication::CustomColor\fR - the same as NormalColor for X11; allocates colors to a palette on demand under Windows
.TP
\fCQApplication::ManyColor\fR - the right choice for applications that use thousands of colors
.PP
See setColorSpec() for full details.
.SH "QApplication::Encoding"
This enum type defines the 8-bit encoding of character string arguments to translate():
.TP
\fCQApplication::DefaultCodec\fR - the encoding specified by QTextCodec::codecForTr() (Latin-1 if none has been set)
.TP
\fCQApplication::UnicodeUTF8\fR - UTF-8
.PP
See also QObject::tr(), QObject::trUtf8(), and QString::fromUtf8().
.SH "QApplication::Type"
.TP
\fCQApplication::Tty\fR - a console application
.TP
\fCQApplication::GuiClient\fR - a GUI client application
.TP
\fCQApplication::GuiServer\fR - a GUI server application
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QApplication::QApplication ( int & argc, char ** argv )"
Initializes the window system and constructs an application object with \fIargc\fR command line arguments in \fIargv\fR.
.PP
The global \fCqApp\fR pointer refers to this application object. Only one application object should be created.
.PP
This application object must be constructed before any paint devices (including widgets, pixmaps, bitmaps etc.).
.PP
Note that \fIargc\fR and \fIargv\fR might be changed. Qt removes command line arguments that it recognizes. The modified \fIargc\fR and \fIargv\fR can also be accessed later with \fCqApp->argc()\fR and \fCqApp->argv()\fR. The documentation for argv() contains a detailed description of how to process command line arguments.
.PP
Qt debugging options (not available if Qt was compiled with the QT_NO_DEBUG flag defined):
.TP
-nograb, tells Qt that it must never grab the mouse or the keyboard.
.TP
-dograb (only under X11), running under a debugger can cause an implicit -nograb, use -dograb to override.
.TP
-sync (only under X11), switches to synchronous mode for debugging.
.PP
See Debugging Techniques for a more detailed explanation.
.PP
All Qt programs automatically support the following command line options:
.TP
-reverse causes text to be formatted for right-to-left languages rather than in the usual left-to-right direction.
.TP
-style= \fIstyle\fR, sets the application GUI style. Possible values are \fCmotif\fR, \fCwindows\fR, and \fCplatinum\fR. If you compiled Qt with additional styles or have additional styles as plugins these will be available to the \fC-style\fR command line option.
.TP
-style \fIstyle\fR, is the same as listed above.
.TP
-session= \fIsession\fR, restores the application from an earlier session.
.TP
-session \fIsession\fR, is the same as listed above.
.TP
-widgetcount, prints debug message at the end about number of widgets left undestroyed and maximum number of widgets existed at the same time
.PP
The X11 version of Qt also supports some traditional X11 command line options:
.TP
-display \fIdisplay\fR, sets the X display (default is $DISPLAY).
.TP
-geometry \fIgeometry\fR, sets the client geometry of the main widget.
.TP
-fn or \fC-font\fR \fIfont\fR, defines the application font. The font should be specified using an X logical font description.
.TP
-bg or \fC-background\fR \fIcolor\fR, sets the default background color and an application palette (light and dark shades are calculated).
.TP
-fg or \fC-foreground\fR \fIcolor\fR, sets the default foreground color.
.TP
-btn or \fC-button\fR \fIcolor\fR, sets the default button color.
.TP
-name \fIname\fR, sets the application name.
.TP
-title \fItitle\fR, sets the application title (caption).
.TP
-visual \fCTrueColor\fR, forces the application to use a TrueColor visual on an 8-bit display.
.TP
-ncols \fIcount\fR, limits the number of colors allocated in the color cube on an 8-bit display, if the application is using the QApplication::ManyColor color specification. If \fIcount\fR is 216 then a 6x6x6 color cube is used (i.e. 6 levels of red, 6 of green, and 6 of blue); for other values, a cube approximately proportional to a 2x3x1 cube is used.
.TP
-cmap, causes the application to install a private color map on an 8-bit display.
.PP
See also argc() and argv().
.SH "QApplication::QApplication ( int & argc, char ** argv, bool GUIenabled )"
Constructs an application object with \fIargc\fR command line arguments in \fIargv\fR. If \fIGUIenabled\fR is TRUE, a GUI application is constructed, otherwise a non-GUI (console) application is created.
.PP
Set \fIGUIenabled\fR to FALSE for programs without a graphical user interface that should be able to run without a window system.
.PP
On X11, the window system is initialized if \fIGUIenabled\fR is TRUE. If \fIGUIenabled\fR is FALSE, the application does not connect to the X-server. On Windows and Macintosh, currently the window system is always initialized, regardless of the value of GUIenabled. This may change in future versions of Qt.
.PP
The following example shows how to create an application that uses a graphical interface when available.
.PP
.nf
.br
  int main( int argc, char **argv )
.br
  {
.br
#ifdef Q_WS_X11
.br
    bool useGUI = getenv( "DISPLAY" ) != 0;
.br
#else
.br
    bool useGUI = TRUE;
.br
#endif
.br
    QApplication app(argc, argv, useGUI);
.br
.br
    if ( useGUI ) {
.br
       //start GUI version
.br
       ...
.br
    } else {
.br
       //start non-GUI version
.br
       ...
.br
    }
.br
    return app.exec();
.br
  }
.fi
.SH "QApplication::QApplication ( int & argc, char ** argv, Type type )"
Constructs an application object with \fIargc\fR command line arguments in \fIargv\fR.
.PP
For Qt/Embedded, passing QApplication::GuiServer for \fItype\fR makes this application the server (equivalent to running with the -qws option).
.SH "QApplication::QApplication ( Display * dpy, HANDLE visual = 0, HANDLE colormap = 0 )"
Create an application, given an already open display \fIdpy\fR. If \fIvisual\fR and \fIcolormap\fR are non-zero, the application will use those as the default Visual and Colormap contexts.
.PP
\fBWarning:\fR Qt only supports TrueColor visuals at depths higher than 8 bits-per-pixel.
.PP
This is available only on X11.
.SH "QApplication::QApplication ( Display * dpy, int argc, char ** argv, HANDLE visual = 0, HANDLE colormap = 0 )"
Create an application, given an already open display \fIdpy\fR and using \fIargc\fR command line arguments in \fIargv\fR. If \fIvisual\fR and \fIcolormap\fR are non-zero, the application will use those as the default Visual and Colormap contexts.
.PP
\fBWarning:\fR Qt only supports TrueColor visuals at depths higher than 8 bits-per-pixel.
.PP
This is available only on X11.
.SH "QApplication::~QApplication ()\fC [virtual]\fR"
Cleans up any window system resources that were allocated by this application. Sets the global variable \fCqApp\fR to 0.
.SH "void QApplication::aboutQt ()\fC [slot]\fR"
Displays a simple message box about Qt. The message includes the version number of Qt being used by the application.
.PP
This is useful for inclusion in the Help menu of an application. See the examples/menu/menu.cpp example.
.PP
This function is a convenience slot for QMessageBox::aboutQt().
.SH "void QApplication::aboutToQuit ()\fC [signal]\fR"
This signal is emitted when the application is about to quit the main event loop, e.g. when the event loop level drops to zero. This may happen either after a call to quit() from inside the application or when the users shuts down the entire desktop session.
.PP
The signal is particularly useful if your application has to do some last-second cleanup. Note that no user interaction is possible in this state.
.PP
See also quit().
.SH "QWidget * QApplication::activeModalWidget ()\fC [static]\fR"
Returns the active modal widget.
.PP
A modal widget is a special top level widget which is a subclass of QDialog that specifies the modal parameter of the constructor as TRUE. A modal widget must be closed before the user can continue with other parts of the program.
.PP
Modal widgets are organized in a stack. This function returns the active modal widget at the top of the stack.
.PP
See also activePopupWidget() and topLevelWidgets().
.SH "QWidget * QApplication::activePopupWidget ()\fC [static]\fR"
Returns the active popup widget.
.PP
A popup widget is a special top level widget that sets the WType_Popup widget flag, e.g. the QPopupMenu widget. When the application opens a popup widget, all events are sent to the popup. Normal widgets and modal widgets cannot be accessed before the popup widget is closed.
.PP
Only other popup widgets may be opened when a popup widget is shown. The popup widgets are organized in a stack. This function returns the active popup widget at the top of the stack.
.PP
See also activeModalWidget() and topLevelWidgets().
.SH "QWidget * QApplication::activeWindow () const"
Returns the application top-level window that has the keyboard input focus, or 0 if no application window has the focus. Note that there might be an activeWindow() even if there is no focusWidget(), for example if no widget in that window accepts key events.
.PP
See also QWidget::setFocus(), QWidget::focus, and focusWidget().
.PP
Example: network/mail/smtp.cpp.
.SH "void QApplication::addLibraryPath ( const QString & path )\fC [static]\fR"
Append \fIpath\fR to the end of the library path list. If \fIpath\fR is empty or already in the path list, the path list is not changed.
.PP
The default path list consists of a single entry, the installation directory for plugins. The default installation directory for plugins is \fCINSTALL/plugins\fR, where \fCINSTALL\fR is the directory where Qt was installed.
.PP
See also removeLibraryPath(), libraryPaths(), and setLibraryPaths().
.SH "QWidgetList * QApplication::allWidgets ()\fC [static]\fR"
Returns a list of all the widgets in the application.
.PP
The list is created using \fCnew\fR and must be deleted by the caller.
.PP
The list is empty (QPtrList::isEmpty()) if there are no widgets.
.PP
Note that some of the widgets may be hidden.
.PP
Example that updates all widgets:
.PP
.nf
.br
    QWidgetList  *list = QApplication::allWidgets();
.br
    QWidgetListIt it( *list );         // iterate over the widgets
.br
    QWidget * w;
.br
    while ( (w=it.current()) != 0 ) {  // for each widget...
.br
        ++it;
.br
        w->update();
.br
    }
.br
    delete list;                      // delete the list, not the widgets
.br
.fi
.PP
The QWidgetList class is defined in the \fCqwidgetlist.h\fR header file.
.PP
\fBWarning:\fR Delete the list as soon as you have finished using it. The widgets in the list may be deleted by someone else at any time.
.PP
See also topLevelWidgets(), QWidget::visible, and QPtrList::isEmpty().
.SH "QString QApplication::applicationDirPath ()"
Returns the directory that contains the application executable.
.PP
For example, if you have installed Qt in the \fCC:&#92;Trolltech&#92;Qt\fR directory, and you run the \fCdemo\fR example, this function will return "C:/Trolltech/Qt/examples/demo".
.PP
On Mac OS X this will point to the directory actually containing the executable, which may be inside of an application bundle (if the application is bundled).
.PP
\fBWarning:\fR On Unix, this function assumes that argv[0] contains the file name of the executable (which it normally does). It also assumes that the current directory hasn't been changed by the application.
.PP
See also applicationFilePath().
.SH "QString QApplication::applicationFilePath ()"
Returns the file path of the application executable.
.PP
For example, if you have installed Qt in the \fCC:&#92;Trolltech&#92;Qt\fR directory, and you run the \fCdemo\fR example, this function will return "C:/Trolltech/Qt/examples/demo/demo.exe".
.PP
\fBWarning:\fR On Unix, this function assumes that argv[0] contains the file name of the executable (which it normally does). It also assumes that the current directory hasn't been changed by the application.
.PP
See also applicationDirPath().
.SH "int QApplication::argc () const"
Returns the number of command line arguments.
.PP
The documentation for argv() describes how to process command line arguments.
.PP
See also argv() and QApplication::QApplication().
.PP
Examples:
.)l chart/main.cpp and scribble/scribble.cpp.
.SH "char ** QApplication::argv () const"
Returns the command line argument vector.
.PP
\fCargv()[0]\fR is the program name, \fCargv()[1]\fR is the first argument and \fCargv()[argc()-1]\fR is the last argument.
.PP
A QApplication object is constructed by passing \fIargc\fR and \fIargv\fR from the \fCmain()\fR function. Some of the arguments may be recognized as Qt options and removed from the argument vector. For example, the X11 version of Qt knows about \fC-display\fR, \fC-font\fR and a few more options.
.PP
Example:
.PP
.nf
.br
        // showargs.cpp - displays program arguments in a list box
.br
.br
        #include <qapplication.h>
.br
        #include <qlistbox.h>
.br
.br
        int main( int argc, char **argv )
.br
        {
.br
            QApplication a( argc, argv );
.br
            QListBox b;
.br
            a.setMainWidget( &b );
.br
            for ( int i = 0; i < a.argc(); i++ )  // a.argc() == argc
.br
                b.insertItem( a.argv()[i] );      // a.argv()[i] == argv[i]
.br
            b.show();
.br
            return a.exec();
.br
        }
.br
.fi
.PP
If you run \fCshowargs -display unix:0 -font 9x15bold hello world\fR under X11, the list box contains the three strings "showargs"," hello" and "world".
.PP
Qt provides a global pointer, \fCqApp\fR, that points to the QApplication object, and through which you can access argc() and argv() in functions other than main().
.PP
See also argc() and QApplication::QApplication().
.PP
Examples:
.)l chart/main.cpp and scribble/scribble.cpp.
.SH "void QApplication::beep ()\fC [static]\fR"
Sounds the bell, using the default volume and sound.
.SH "QClipboard * QApplication::clipboard ()\fC [static]\fR"
Returns a pointer to the application global clipboard.
.PP
Examples:
.)l regexptester/regexptester.cpp and showimg/showimg.cpp.
.SH "void QApplication::closeAllWindows ()\fC [slot]\fR"
Closes all top-level windows.
.PP
This function is particularly useful for applications with many top-level windows. It could, for example, be connected to a "Quit" entry in the file menu as shown in the following code example:
.PP
.nf
.br
    // the "Quit" menu entry should try to close all windows
.br
    QPopupMenu* file = new QPopupMenu( this );
.br
    file->insertItem( "&Quit", qApp, SLOT(closeAllWindows()), CTRL+Key_Q );
.br
.br
    // when the last window is closed, the application should quit
.br
    connect( qApp, SIGNAL( lastWindowClosed() ), qApp, SLOT( quit() ) );
.br
.fi
.PP
The windows are closed in random order, until one window does not accept the close event.
.PP
See also QWidget::close(), QWidget::closeEvent(), lastWindowClosed(), quit(), topLevelWidgets(), and QWidget::isTopLevel.
.PP
Examples:
.)l action/application.cpp, application/application.cpp, helpviewer/helpwindow.cpp, mdi/application.cpp, and qwerty/qwerty.cpp.
.SH "bool QApplication::closingDown ()\fC [static]\fR"
Returns TRUE if the application objects are being destroyed; otherwise returns FALSE.
.PP
See also startingUp().
.SH "int QApplication::colorSpec ()\fC [static]\fR"
Returns the color specification.
.PP
See also QApplication::setColorSpec().
.PP
Example: showimg/showimg.cpp.
.SH "void QApplication::commitData ( QSessionManager & sm )\fC [virtual]\fR"
This function deals with session management. It is invoked when the QSessionManager wants the application to commit all its data.
.PP
Usually this means saving all open files, after getting permission from the user. Furthermore you may want to provide a means by which the user can cancel the shutdown.
.PP
Note that you should not exit the application within this function. Instead, the session manager may or may not do this afterwards, depending on the context.
.PP
\fBWarning:\fR Within this function, no user interaction is possible, \fIunless\fR you ask the session manager \fIsm\fR for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details and example usage.
.PP
The default implementation requests interaction and sends a close event to all visible top level widgets. If any event was rejected, the shutdown is canceled.
.PP
See also isSessionRestored(), sessionId(), saveState(), and the Session Management overview.
.SH "int QApplication::cursorFlashTime ()\fC [static]\fR"
Returns the text cursor's flash (blink) time in milliseconds. The flash time is the time required to display, invert and restore the caret display.
.PP
The default value on X11 is 1000 milliseconds. On Windows, the control panel value is used.
.PP
Widgets should not cache this value since it may be changed at any time by the user changing the global desktop settings.
.PP
See also setCursorFlashTime().
.SH "QTextCodec * QApplication::defaultCodec () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns QTextCodec::codecForTr().
.SH "QDesktopWidget * QApplication::desktop ()\fC [static]\fR"
Returns the desktop widget (also called the root window).
.PP
The desktop widget is useful for obtaining the size of the screen. It may also be possible to draw on the desktop. We recommend against assuming that it's possible to draw on the desktop, since this does not work on all operating systems.
.PP
.nf
.br
    QDesktopWidget *d = QApplication::desktop();
.br
    int w = d->width();     // returns desktop width
.br
    int h = d->height();    // returns desktop height
.br
.fi
.PP
Examples:
.)l canvas/main.cpp, desktop/desktop.cpp, helpviewer/main.cpp, i18n/main.cpp, qmag/qmag.cpp, qwerty/main.cpp, and scribble/main.cpp.
.SH "bool QApplication::desktopSettingsAware ()\fC [static]\fR"
Returns the value set by setDesktopSettingsAware(); by default TRUE.
.PP
See also setDesktopSettingsAware().
.SH "int QApplication::doubleClickInterval ()\fC [static]\fR"
Returns the maximum duration for a double click.
.PP
The default value on X11 is 400 milliseconds. On Windows, the control panel value is used.
.PP
See also setDoubleClickInterval().
.SH "int QApplication::enter_loop ()"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This function enters the main event loop (recursively). Do not call it unless you really know what you are doing.
.PP
Use QApplication::eventLoop()->enterLoop() instead.
.SH "QEventLoop * QApplication::eventLoop ()\fC [static]\fR"
Returns the application event loop. This function will return zero if called during and after destroying QApplication.
.PP
To create your own instance of QEventLoop or QEventLoop subclass create it before you create the QApplication object.
.PP
See also QEventLoop.
.PP
Example: distributor/distributor.ui.h.
.SH "int QApplication::exec ()"
Enters the main event loop and waits until exit() is called or the main widget is destroyed, and returns the value that was set to exit() (which is 0 if exit() is called via quit()).
.PP
It is necessary to call this function to start event handling. The main event loop receives events from the window system and dispatches these to the application widgets.
.PP
Generally speaking, no user interaction can take place before calling exec(). As a special case, modal widgets like QMessageBox can be used before calling exec(), because modal widgets call exec() to start a local event loop.
.PP
To make your application perform idle processing, i.e. executing a special function whenever there are no pending events, use a QTimer with 0 timeout. More advanced idle processing schemes can be achieved using processEvents().
.PP
See also quit(), exit(), processEvents(), and setMainWidget().
.PP
Examples:
.)l helpsystem/main.cpp, life/main.cpp, network/archivesearch/main.cpp, network/ftpclient/main.cpp, opengl/main.cpp, t1/main.cpp, and t4/main.cpp.
.SH "void QApplication::exit ( int retcode = 0 )\fC [static]\fR"
Tells the application to exit with a return code.
.PP
After this function has been called, the application leaves the main event loop and returns from the call to exec(). The exec() function returns \fIretcode\fR.
.PP
By convention, a \fIretcode\fR of 0 means success, and any non-zero value indicates an error.
.PP
Note that unlike the C library function of the same name, this function \fIdoes\fR return to the caller -- it is event processing that stops.
.PP
See also quit() and exec().
.PP
Examples:
.)l chart/chartform.cpp, extension/mainform.ui.h, and picture/picture.cpp.
.SH "void QApplication::exit_loop ()"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This function exits from a recursive call to the main event loop. Do not call it unless you are an expert.
.PP
Use QApplication::eventLoop()->exitLoop() instead.
.SH "void QApplication::flush ()\fC [static]\fR"
Flushes the window system specific event queues.
.PP
If you are doing graphical changes inside a loop that does not return to the event loop on asynchronous window systems like X11 or double buffered window systems like MacOS X, and you want to visualize these changes immediately (e.g. Splash Screens), call this function.
.PP
See also flushX(), sendPostedEvents(), and QPainter::flush().
.SH "void QApplication::flushX ()\fC [static]\fR"
Flushes the X event queue in the X11 implementation. This normally returns almost immediately. Does nothing on other platforms.
.PP
See also syncX().
.PP
Example: xform/xform.cpp.
.SH "QWidget * QApplication::focusWidget () const"
Returns the application widget that has the keyboard input focus, or 0 if no widget in this application has the focus.
.PP
See also QWidget::setFocus(), QWidget::focus, and activeWindow().
.SH "QFont QApplication::font ( const QWidget * w = 0 )\fC [static]\fR"
Returns the default font for the widget \fIw\fR, or the default application font if \fIw\fR is 0.
.PP
See also setFont(), fontMetrics(), and QWidget::font.
.PP
Examples:
.)l qfd/fontdisplayer.cpp, themes/metal.cpp, and themes/themes.cpp.
.SH "QFontMetrics QApplication::fontMetrics ()\fC [static]\fR"
Returns display (screen) font metrics for the application font.
.PP
See also font(), setFont(), QWidget::fontMetrics(), and QPainter::fontMetrics().
.SH "QSize QApplication::globalStrut ()\fC [static]\fR"
Returns the application's global strut.
.PP
The strut is a size object whose dimensions are the minimum that any GUI element that the user can interact with should have. For example no button should be resized to be smaller than the global strut size.
.PP
See also setGlobalStrut().
.SH "void QApplication::guiThreadAwake ()\fC [signal]\fR"
This signal is emitted after the event loop returns from a function that could block.
.PP
See also wakeUpGuiThread().
.SH "bool QApplication::hasGlobalMouseTracking ()\fC [static]\fR"
Returns TRUE if global mouse tracking is enabled; otherwise returns FALSE.
.PP
See also setGlobalMouseTracking().
.SH "bool QApplication::hasPendingEvents ()"
This function returns TRUE if there are pending events; otherwise returns FALSE. Pending events can be either from the window system or posted events using QApplication::postEvent().
.SH "int QApplication::horizontalAlignment ( int align )\fC [static]\fR"
Strips out vertical alignment flags and transforms an alignment \fIalign\fR of AlignAuto into AlignLeft or AlignRight according to the language used. The other horizontal alignment flags are left untouched.
.SH "void QApplication::installTranslator ( QTranslator * mf )"
Adds the message file \fImf\fR to the list of message files to be used for translations.
.PP
Multiple message files can be installed. Translations are searched for in the last installed message file, then the one from last, and so on, back to the first installed message file. The search stops as soon as a matching translation is found.
.PP
See also removeTranslator(), translate(), and QTranslator::load().
.PP
Example: i18n/main.cpp.
.SH "bool QApplication::isEffectEnabled ( Qt::UIEffect effect )\fC [static]\fR"
Returns TRUE if \fIeffect\fR is enabled; otherwise returns FALSE.
.PP
By default, Qt will try to use the desktop settings. Call setDesktopSettingsAware(FALSE) to prevent this.
.PP
Note: All effects are disabled on screens running at less than 16-bit color depth.
.PP
See also setEffectEnabled() and Qt::UIEffect.
.SH "bool QApplication::isSessionRestored () const"
Returns TRUE if the application has been restored from an earlier session; otherwise returns FALSE.
.PP
See also sessionId(), commitData(), and saveState().
.SH "void QApplication::lastWindowClosed ()\fC [signal]\fR"
This signal is emitted when the user has closed the last top level window.
.PP
The signal is very useful when your application has many top level widgets but no main widget. You can then connect it to the quit() slot.
.PP
For convenience, this signal is \fInot\fR emitted for transient top level widgets such as popup menus and dialogs.
.PP
See also mainWidget(), topLevelWidgets(), QWidget::isTopLevel, and QWidget::close().
.PP
Examples:
.)l addressbook/main.cpp, extension/main.cpp, helpviewer/main.cpp, mdi/main.cpp, network/archivesearch/main.cpp, qwerty/main.cpp, and regexptester/main.cpp.
.SH "QStringList QApplication::libraryPaths ()\fC [static]\fR"
Returns a list of paths that the application will search when dynamically loading libraries. The installation directory for plugins is the only entry if no paths have been set. The default installation directory for plugins is \fCINSTALL/plugins\fR, where \fCINSTALL\fR is the directory where Qt was installed. The directory of the application executable (NOT the working directory) is also added to the plugin paths.
.PP
If you want to iterate over the list, you should iterate over a copy, e.g.
.PP
.nf
.br
    QStringList list = app.libraryPaths();
.br
    QStringList::Iterator it = list.begin();
.br
    while( it != list.end() ) {
.br
        myProcessing( *it );
.br
        ++it;
.br
    }
.br
.fi
.PP
See the plugins documentation for a description of how the library paths are used.
.PP
See also setLibraryPaths(), addLibraryPath(), removeLibraryPath(), and QLibrary.
.SH "void QApplication::lock ()"
Lock the Qt Library Mutex. If another thread has already locked the mutex, the calling thread will block until the other thread has unlocked the mutex.
.PP
See also unlock(), locked(), and Thread Support in Qt.
.SH "bool QApplication::locked ()"
Returns TRUE if the Qt Library Mutex is locked by a different thread; otherwise returns FALSE.
.PP
\fBWarning:\fR Due to different implementations of recursive mutexes on the supported platforms, calling this function from the same thread that previously locked the mutex will give undefined results.
.PP
See also lock(), unlock(), and Thread Support in Qt.
.SH "int QApplication::loopLevel () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the current loop level.
.PP
Use QApplication::eventLoop()->loopLevel() instead.
.SH "bool QApplication::macEventFilter ( EventHandlerCallRef, EventRef )\fC [virtual]\fR"
This virtual function is only implemented under Macintosh.
.PP
If you create an application that inherits QApplication and reimplement this function, you get direct access to all Carbon Events that are received from the MacOS.
.PP
Return TRUE if you want to stop the event from being processed. Return FALSE for normal event dispatching.
.SH "QWidget * QApplication::mainWidget () const"
Returns the main application widget, or 0 if there is no main widget.
.PP
See also setMainWidget().
.SH "bool QApplication::notify ( QObject * receiver, QEvent * e )\fC [virtual]\fR"
Sends event \fIe\fR to \fIreceiver\fR: \fIreceiver\fR->event(\fIe\fR). Returns the value that is returned from the receiver's event handler.
.PP
For certain types of events (e.g. mouse and key events), the event will be propagated to the receiver's parent and so on up to the top-level object if the receiver is not interested in the event (i.e., it returns FALSE).
.PP
There are five different ways that events can be processed; reimplementing this virtual function is just one of them. All five approaches are listed below: <ol type=1>
.TP
Reimplementing this function. This is very powerful, providing complete control; but only one subclass can be qApp.
.IP
.TP
Installing an event filter on qApp. Such an event filter is able to process all events for all widgets, so it's just as powerful as reimplementing notify(); furthermore, it's possible to have more than one application-global event filter. Global event filters even see mouse events for disabled widgets, and if global mouse tracking is enabled, as well as mouse move events for all widgets.
.IP
.TP
Reimplementing QObject::event() (as QWidget does). If you do this you get Tab key presses, and you get to see the events before any widget-specific event filters.
.IP
.TP
Installing an event filter on the object. Such an event filter gets all the events except Tab and Shift-Tab key presses.
.IP
.TP
Reimplementing paintEvent(), mousePressEvent() and so on. This is the commonest, easiest and least powerful way.
.PP
See also QObject::event() and installEventFilter().
.SH "QCursor * QApplication::overrideCursor ()\fC [static]\fR"
Returns the active application override cursor.
.PP
This function returns 0 if no application cursor has been defined (i.e. the internal cursor stack is empty).
.PP
See also setOverrideCursor() and restoreOverrideCursor().
.SH "QPalette QApplication::palette ( const QWidget * w = 0 )\fC [static]\fR"
Returns the application palette.
.PP
If a widget is passed in \fIw\fR, the default palette for the widget's class is returned. This may or may not be the application palette. In most cases there isn't a special palette for certain types of widgets, but one notable exception is the popup menu under Windows, if the user has defined a special background color for menus in the display settings.
.PP
See also setPalette() and QWidget::palette.
.PP
Examples:
.)l desktop/desktop.cpp, themes/metal.cpp, and themes/wood.cpp.
.SH "void QApplication::polish ( QWidget * w )\fC [virtual]\fR"
Initialization of the appearance of the widget \fIw\fR \fIbefore\fR it is first shown.
.PP
Usually widgets call this automatically when they are polished. It may be used to do some style-based central customization of widgets.
.PP
Note that you are not limited to the public functions of QWidget. Instead, based on meta information like QObject::className() you are able to customize any kind of widget.
.PP
See also QStyle::polish(), QWidget::polish(), setPalette(), and setFont().
.SH "void QApplication::postEvent ( QObject * receiver, QEvent * event )\fC [static]\fR"
\fBNote:\fR This function is thread-safe when Qt is built withthread support.</p> Adds the event \fIevent\fR with the object \fIreceiver\fR as the receiver of the event, to an event queue and returns immediately.
.PP
The event must be allocated on the heap since the post event queue will take ownership of the event and delete it once it has been posted.
.PP
When control returns to the main event loop, all events that are stored in the queue will be sent using the notify() function.
.PP
See also sendEvent() and notify().
.SH "void QApplication::processEvents ()"
Processes pending events, for 3 seconds or until there are no more events to process, whichever is shorter.
.PP
You can call this function occasionally when your program is busy performing a long operation (e.g. copying a file).
.PP
See also exec(), QTimer, and QEventLoop::processEvents().
.PP
Examples:
.)l fileiconview/qfileiconview.cpp and network/ftpclient/main.cpp.
.SH "void QApplication::processEvents ( int maxtime )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Processes pending events for \fImaxtime\fR milliseconds or until there are no more events to process, whichever is shorter.
.PP
You can call this function occasionally when you program is busy doing a long operation (e.g. copying a file).
.PP
See also exec(), QTimer, and QEventLoop::processEvents().
.SH "void QApplication::processOneEvent ()"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Waits for an event to occur, processes it, then returns.
.PP
This function is useful for adapting Qt to situations where the event processing must be grafted onto existing program loops.
.PP
Using this function in new applications may be an indication of design problems.
.PP
See also processEvents(), exec(), and QTimer.
.SH "void QApplication::quit ()\fC [slot]\fR"
Tells the application to exit with return code 0 (success). Equivalent to calling QApplication::exit( 0 ).
.PP
It's common to connect the lastWindowClosed() signal to quit(), and you also often connect e.g. QButton::clicked() or signals in QAction, QPopupMenu or QMenuBar to it.
.PP
Example:
.PP
.nf
.br
    QPushButton *quitButton = new QPushButton( "Quit" );
.br
    connect( quitButton, SIGNAL(clicked()), qApp, SLOT(quit()) );
.br
.fi
.PP
See also exit(), aboutToQuit(), lastWindowClosed(), and QAction.
.PP
Examples:
.)l addressbook/main.cpp, mdi/main.cpp, network/archivesearch/main.cpp, regexptester/main.cpp, t2/main.cpp, t4/main.cpp, and t6/main.cpp.
.SH "QWSDecoration & QApplication::qwsDecoration ()\fC [static]\fR"
Return the QWSDecoration used for decorating windows.
.PP
This method is non-portable. It is available \fIonly\fR in Qt/Embedded.
.PP
See also QWSDecoration.
.SH "bool QApplication::qwsEventFilter ( QWSEvent * )\fC [virtual]\fR"
This virtual function is only implemented under Qt/Embedded.
.PP
If you create an application that inherits QApplication and reimplement this function, you get direct access to all QWS (Q Window System) events that the are received from the QWS master process.
.PP
Return TRUE if you want to stop the event from being processed. Return FALSE for normal event dispatching.
.SH "void QApplication::qwsSetCustomColors ( QRgb * colorTable, int start, int numColors )"
Set Qt/Embedded custom color table.
.PP
Qt/Embedded on 8-bpp displays allocates a standard 216 color cube. The remaining 40 colors may be used by setting a custom color table in the QWS master process before any clients connect.
.PP
\fIcolorTable\fR is an array of up to 40 custom colors. \fIstart\fR is the starting index (0-39) and \fInumColors\fR is the number of colors to be set (1-40).
.PP
This method is non-portable. It is available \fIonly\fR in Qt/Embedded.
.SH "void QApplication::qwsSetDecoration ( QWSDecoration * d )\fC [static]\fR"
Set the QWSDecoration derived class to use for decorating the Qt/Embedded windows to \fId\fR.
.PP
This method is non-portable. It is available \fIonly\fR in Qt/Embedded.
.PP
See also QWSDecoration.
.SH "void QApplication::removeLibraryPath ( const QString & path )\fC [static]\fR"
Removes \fIpath\fR from the library path list. If \fIpath\fR is empty or not in the path list, the list is not changed.
.PP
See also addLibraryPath(), libraryPaths(), and setLibraryPaths().
.SH "void QApplication::removePostedEvents ( QObject * receiver )\fC [static]\fR"
\fBNote:\fR This function is thread-safe when Qt is built withthread support.</p> Removes all events posted using postEvent() for \fIreceiver\fR.
.PP
The events are \fInot\fR dispatched, instead they are removed from the queue. You should never need to call this function. If you do call it, be aware that killing events may cause \fIreceiver\fR to break one or more invariants.
.SH "void QApplication::removeTranslator ( QTranslator * mf )"
Removes the message file \fImf\fR from the list of message files used by this application. (It does not delete the message file from the file system.)
.PP
See also installTranslator(), translate(), and QObject::tr().
.PP
Example: i18n/main.cpp.
.SH "void QApplication::restoreOverrideCursor ()\fC [static]\fR"
Undoes the last setOverrideCursor().
.PP
If setOverrideCursor() has been called twice, calling restoreOverrideCursor() will activate the first cursor set. Calling this function a second time restores the original widgets' cursors.
.PP
See also setOverrideCursor() and overrideCursor().
.PP
Examples:
.)l distributor/distributor.ui.h, network/archivesearch/archivedialog.ui.h, network/ftpclient/ftpmainwindow.ui.h, and showimg/showimg.cpp.
.SH "bool QApplication::reverseLayout ()\fC [static]\fR"
Returns TRUE if all dialogs and widgets will be laid out in a mirrored (right to left) fashion. Returns FALSE if dialogs and widgets will be laid out left to right.
.PP
See also setReverseLayout().
.SH "void QApplication::saveState ( QSessionManager & sm )\fC [virtual]\fR"
This function deals with session management. It is invoked when the session manager wants the application to preserve its state for a future session.
.PP
For example, a text editor would create a temporary file that includes the current contents of its edit buffers, the location of the cursor and other aspects of the current editing session.
.PP
Note that you should never exit the application within this function. Instead, the session manager may or may not do this afterwards, depending on the context. Futhermore, most session managers will very likely request a saved state immediately after the application has been started. This permits the session manager to learn about the application's restart policy.
.PP
\fBWarning:\fR Within this function, no user interaction is possible, \fIunless\fR you ask the session manager \fIsm\fR for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details.
.PP
See also isSessionRestored(), sessionId(), commitData(), and the Session Management overview.
.SH "bool QApplication::sendEvent ( QObject * receiver, QEvent * event )\fC [static]\fR"
Sends event \fIevent\fR directly to receiver \fIreceiver\fR, using the notify() function. Returns the value that was returned from the event handler.
.PP
The event is \fInot\fR deleted when the event has been sent. The normal approach is to create the event on the stack, e.g.
.PP
.nf
.br
    QMouseEvent me( QEvent::MouseButtonPress, pos, 0, 0 );
.br
    QApplication::sendEvent( mainWindow, &me );
.br
.fi
If you create the event on the heap you must delete it.
.PP
See also postEvent() and notify().
.PP
Example: popup/popup.cpp.
.SH "void QApplication::sendPostedEvents ( QObject * receiver, int event_type )\fC [static]\fR"
Immediately dispatches all events which have been previously queued with QApplication::postEvent() and which are for the object \fIreceiver\fR and have the event type \fIevent_type\fR.
.PP
Note that events from the window system are \fInot\fR dispatched by this function, but by processEvents().
.PP
If \fIreceiver\fR is null, the events of \fIevent_type\fR are sent for all objects. If \fIevent_type\fR is 0, all the events are sent for \fIreceiver\fR.
.SH "void QApplication::sendPostedEvents ()\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Dispatches all posted events, i.e. empties the event queue.
.SH "QString QApplication::sessionId () const"
Returns the current session's identifier.
.PP
If the application has been restored from an earlier session, this identifier is the same as it was in that previous session.
.PP
The session identifier is guaranteed to be unique both for different applications and for different instances of the same application.
.PP
See also isSessionRestored(), sessionKey(), commitData(), and saveState().
.SH "QString QApplication::sessionKey () const"
Returns the session key in the current session.
.PP
If the application has been restored from an earlier session, this key is the same as it was when the previous session ended.
.PP
The session key changes with every call of commitData() or saveState().
.PP
See also isSessionRestored(), sessionId(), commitData(), and saveState().
.SH "void QApplication::setColorSpec ( int spec )\fC [static]\fR"
Sets the color specification for the application to \fIspec\fR.
.PP
The color specification controls how the application allocates colors when run on a display with a limited amount of colors, e.g. 8 bit / 256 color displays.
.PP
The color specification must be set before you create the QApplication object.
.PP
The options are:
.TP
QApplication::NormalColor. This is the default color allocation strategy. Use this option if your application uses buttons, menus, texts and pixmaps with few colors. With this option, the application uses system global colors. This works fine for most applications under X11, but on Windows machines it may cause dithering of non-standard colors.
.TP
QApplication::CustomColor. Use this option if your application needs a small number of custom colors. On X11, this option is the same as NormalColor. On Windows, Qt creates a Windows palette, and allocates colors to it on demand.
.TP
QApplication::ManyColor. Use this option if your application is very color hungry (e.g. it requires thousands of colors). Under X11 the effect is:
.TP
For 256-color displays which have at best a 256 color true color visual, the default visual is used, and colors are allocated from a color cube. The color cube is the 6x6x6 (216 color) "Web palette"<sup>*</sup>, but the number of colors can be changed by the \fI-ncols\fR option. The user can force the application to use the true color visual with the -visual option.
.TP
For 256-color displays which have a true color visual with more than 256 colors, use that visual. Silicon Graphics X servers have this feature, for example. They provide an 8 bit visual by default but can deliver true color when asked. On Windows, Qt creates a Windows palette, and fills it with a color cube.
.PP
Be aware that the CustomColor and ManyColor choices may lead to colormap flashing: The foreground application gets (most) of the available colors, while the background windows will look less attractive.
.PP
Example:
.PP
.nf
.br
  int main( int argc, char **argv )
.br
  {
.br
      QApplication::setColorSpec( QApplication::ManyColor );
.br
      QApplication a( argc, argv );
.br
      ...
.br
  }
.br
.fi
.PP
QColor provides more functionality for controlling color allocation and freeing up certain colors. See QColor::enterAllocContext() for more information.
.PP
To check what mode you end up with, call QColor::numBitPlanes() once the QApplication object exists. A value greater than 8 (typically 16, 24 or 32) means true color.
.PP
<sup>*</sup> The color cube used by Qt has 216 colors whose red, green, and blue components always have one of the following values: 0x00, 0x33, 0x66, 0x99, 0xCC, or 0xFF.
.PP
See also colorSpec(), QColor::numBitPlanes(), and QColor::enterAllocContext().
.PP
Examples:
.)l helpviewer/main.cpp, opengl/main.cpp, showimg/main.cpp, t9/main.cpp, tetrax/tetrax.cpp, tetrix/tetrix.cpp, and themes/main.cpp.
.SH "void QApplication::setCursorFlashTime ( int msecs )\fC [static]\fR"
Sets the text cursor's flash (blink) time to \fImsecs\fR milliseconds. The flash time is the time required to display, invert and restore the caret display. Usually the text cursor is displayed for \fImsecs/2\fR milliseconds, then hidden for \fImsecs/2\fR milliseconds, but this may vary.
.PP
Note that on Microsoft Windows, calling this function sets the cursor flash time for all windows.
.PP
See also cursorFlashTime().
.SH "void QApplication::setDefaultCodec ( QTextCodec * codec )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This is the same as QTextCodec::setCodecForTr().
.SH "void QApplication::setDesktopSettingsAware ( bool on )\fC [static]\fR"
By default, Qt will try to use the current standard colors, fonts etc., from the underlying window system's desktop settings, and use them for all relevant widgets. This behavior can be switched off by calling this function with \fIon\fR set to FALSE.
.PP
This static function must be called before creating the QApplication object, like this:
.PP
.nf
.br
  int main( int argc, char** argv ) {
.br
    QApplication::setDesktopSettingsAware( FALSE ); // I know better than the user
.br
    QApplication myApp( argc, argv ); // Use default fonts & colors
.br
    ...
.br
  }
.br
.fi
.PP
See also desktopSettingsAware().
.SH "void QApplication::setDoubleClickInterval ( int ms )\fC [static]\fR"
Sets the time limit that distinguishes a double click from two consecutive mouse clicks to \fIms\fR milliseconds.
.PP
Note that on Microsoft Windows, calling this function sets the double click interval for all windows.
.PP
See also doubleClickInterval().
.SH "void QApplication::setEffectEnabled ( Qt::UIEffect effect, bool enable = TRUE )\fC [static]\fR"
Enables the UI effect \fIeffect\fR if \fIenable\fR is TRUE, otherwise the effect will not be used.
.PP
Note: All effects are disabled on screens running at less than 16-bit color depth.
.PP
See also isEffectEnabled(), Qt::UIEffect, and setDesktopSettingsAware().
.SH "void QApplication::setFont ( const QFont & font, bool informWidgets = FALSE, const char * className = 0 )\fC [static]\fR"
Changes the default application font to \fIfont\fR. If \fIinformWidgets\fR is TRUE, then existing widgets are informed about the change and may adjust themselves to the new application setting. If \fIinformWidgets\fR is FALSE, the change only affects newly created widgets. If \fIclassName\fR is passed, the change applies only to classes that inherit \fIclassName\fR (as reported by QObject::inherits()).
.PP
On application start-up, the default font depends on the window system. It can vary depending on both the window system version and the locale. This function lets you override the default font; but overriding may be a bad idea because, for example, some locales need extra-large fonts to support their special characters.
.PP
See also font(), fontMetrics(), and QWidget::font.
.PP
Examples:
.)l desktop/desktop.cpp, themes/metal.cpp, and themes/themes.cpp.
.SH "void QApplication::setGlobalMouseTracking ( bool enable )\fC [static]\fR"
Enables global mouse tracking if \fIenable\fR is TRUE, or disables it if \fIenable\fR is FALSE.
.PP
Enabling global mouse tracking makes it possible for widget event filters or application event filters to get all mouse move events, even when no button is depressed. This is useful for special GUI elements, e.g. tooltips.
.PP
Global mouse tracking does not affect widgets and their mouseMoveEvent(). For a widget to get mouse move events when no button is depressed, it must do QWidget::setMouseTracking(TRUE).
.PP
This function uses an internal counter. Each setGlobalMouseTracking(TRUE) must have a corresponding setGlobalMouseTracking(FALSE):
.PP
.nf
.br
        // at this point global mouse tracking is off
.br
        QApplication::setGlobalMouseTracking( TRUE );
.br
        QApplication::setGlobalMouseTracking( TRUE );
.br
        QApplication::setGlobalMouseTracking( FALSE );
.br
        // at this point it's still on
.br
        QApplication::setGlobalMouseTracking( FALSE );
.br
        // but now it's off
.br
.fi
.PP
See also hasGlobalMouseTracking() and QWidget::mouseTracking.
.SH "void QApplication::setGlobalStrut ( const QSize & strut )\fC [static]\fR"
Sets the application's global strut to \fIstrut\fR.
.PP
The strut is a size object whose dimensions are the minimum that any GUI element that the user can interact with should have. For example no button should be resized to be smaller than the global strut size.
.PP
The strut size should be considered when reimplementing GUI controls that may be used on touch-screens or similar IO-devices.
.PP
Example:
.PP
.nf
.br
  QSize& WidgetClass::sizeHint() const
.br
  {
.br
      return QSize( 80, 25 ).expandedTo( QApplication::globalStrut() );
.br
  }
.br
.fi
.PP
See also globalStrut().
.SH "void QApplication::setLibraryPaths ( const QStringList & paths )\fC [static]\fR"
Sets the list of directories to search when loading libraries to \fIpaths\fR. All existing paths will be deleted and the path list will consist of the paths given in \fIpaths\fR.
.PP
See also libraryPaths(), addLibraryPath(), removeLibraryPath(), and QLibrary.
.SH "void QApplication::setMainWidget ( QWidget * mainWidget )\fC [virtual]\fR"
Sets the application's main widget to \fImainWidget\fR.
.PP
In most respects the main widget is like any other widget, except that if it is closed, the application exits. Note that QApplication does \fInot\fR take ownership of the \fImainWidget\fR, so if you create your main widget on the heap you must delete it yourself.
.PP
You need not have a main widget; connecting lastWindowClosed() to quit() is an alternative.
.PP
For X11, this function also resizes and moves the main widget according to the \fI-geometry\fR command-line option, so you should set the default geometry (using QWidget::setGeometry()) before calling setMainWidget().
.PP
See also mainWidget(), exec(), and quit().
.PP
Examples:
.)l chart/main.cpp, helpsystem/main.cpp, life/main.cpp, network/ftpclient/main.cpp, opengl/main.cpp, t1/main.cpp, and t4/main.cpp.
.SH "void QApplication::setOverrideCursor ( const QCursor & cursor, bool replace = FALSE )\fC [static]\fR"
Sets the application override cursor to \fIcursor\fR.
.PP
Application override cursors are intended for showing the user that the application is in a special state, for example during an operation that might take some time.
.PP
This cursor will be displayed in all the application's widgets until restoreOverrideCursor() or another setOverrideCursor() is called.
.PP
Application cursors are stored on an internal stack. setOverrideCursor() pushes the cursor onto the stack, and restoreOverrideCursor() pops the active cursor off the stack. Every setOverrideCursor() must eventually be followed by a corresponding restoreOverrideCursor(), otherwise the stack will never be emptied.
.PP
If \fIreplace\fR is TRUE, the new cursor will replace the last override cursor (the stack keeps its depth). If \fIreplace\fR is FALSE, the new stack is pushed onto the top of the stack.
.PP
Example:
.PP
.nf
.br
        QApplication::setOverrideCursor( QCursor(Qt::WaitCursor) );
.br
        calculateHugeMandelbrot();              // lunch time...
.br
        QApplication::restoreOverrideCursor();
.br
.fi
.PP
See also overrideCursor(), restoreOverrideCursor(), and QWidget::cursor.
.PP
Examples:
.)l distributor/distributor.ui.h, network/archivesearch/archivedialog.ui.h, network/ftpclient/ftpmainwindow.ui.h, and showimg/showimg.cpp.
.SH "void QApplication::setPalette ( const QPalette & palette, bool informWidgets = FALSE, const char * className = 0 )\fC [static]\fR"
Changes the default application palette to \fIpalette\fR. If \fIinformWidgets\fR is TRUE, then existing widgets are informed about the change and may adjust themselves to the new application setting. If \fIinformWidgets\fR is FALSE, the change only affects newly created widgets.
.PP
If \fIclassName\fR is passed, the change applies only to widgets that inherit \fIclassName\fR (as reported by QObject::inherits()). If \fIclassName\fR is left 0, the change affects all widgets, thus overriding any previously set class specific palettes.
.PP
The palette may be changed according to the current GUI style in QStyle::polish().
.PP
See also QWidget::palette, palette(), and QStyle::polish().
.PP
Examples:
.)l i18n/main.cpp, themes/metal.cpp, themes/themes.cpp, and themes/wood.cpp.
.SH "void QApplication::setReverseLayout ( bool b )\fC [static]\fR"
If \fIb\fR is TRUE, all dialogs and widgets will be laid out in a mirrored fashion, as required by right to left languages such as Arabic and Hebrew. If \fIb\fR is FALSE, dialogs and widgets are laid out left to right.
.PP
Changing this flag in runtime does not cause a relayout of already instantiated widgets.
.PP
See also reverseLayout().
.SH "void QApplication::setStartDragDistance ( int l )\fC [static]\fR"
Sets the distance after which a drag should start to \fIl\fR pixels.
.PP
See also startDragDistance().
.SH "void QApplication::setStartDragTime ( int ms )\fC [static]\fR"
Sets the time after which a drag should start to \fIms\fR ms.
.PP
See also startDragTime().
.SH "void QApplication::setStyle ( QStyle * style )\fC [static]\fR"
Sets the application's GUI style to \fIstyle\fR. Ownership of the style object is transferred to QApplication, so QApplication will delete the style object on application exit or when a new style is set.
.PP
Example usage:
.PP
.nf
.br
    QApplication::setStyle( new QWindowsStyle );
.br
.fi
.PP
When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.
.PP
See also style(), QStyle, setPalette(), and desktopSettingsAware().
.PP
Example: themes/themes.cpp.
.SH "QStyle * QApplication::setStyle ( const QString & style )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Requests a QStyle object for \fIstyle\fR from the QStyleFactory.
.PP
The string must be one of the QStyleFactory::keys(), typically one of "windows", "motif", "cde", "motifplus", "platinum", "sgi" and" compact". Depending on the platform, "windowsxp", "aqua" or" macintosh" may be available.
.PP
A later call to the QApplication constructor will override the requested style when a "-style" option is passed in as a commandline parameter.
.PP
Returns 0 if an unknown \fIstyle\fR is passed, otherwise the QStyle object returned is set as the application's GUI style.
.SH "void QApplication::setWheelScrollLines ( int n )\fC [static]\fR"
Sets the number of lines to scroll when the mouse wheel is rotated to \fIn\fR.
.PP
If this number exceeds the number of visible lines in a certain widget, the widget should interpret the scroll operation as a single page up / page down operation instead.
.PP
See also wheelScrollLines().
.SH "void QApplication::setWinStyleHighlightColor ( const QColor & c )\fC [static]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Sets the color used to mark selections in windows style for all widgets in the application. Will repaint all widgets if the color is changed.
.PP
The default color is \fCdarkBlue\fR.
.PP
See also winStyleHighlightColor().
.SH "int QApplication::startDragDistance ()\fC [static]\fR"
If you support drag and drop in you application and a drag should start after a mouse click and after moving the mouse a certain distance, you should use the value which this method returns as the distance.
.PP
For example, if the mouse position of the click is stored in \fCstartPos\fR and the current position (e.g. in the mouse move event) is \fCcurrPos\fR, you can find out if a drag should be started with code like this:
.PP
.nf
.br
  if ( ( startPos - currPos ).manhattanLength() >
.br
       QApplication::startDragDistance() )
.br
    startTheDrag();
.br
.fi
.PP
Qt uses this value internally, e.g. in QFileDialog.
.PP
The default value is 4 pixels.
.PP
See also setStartDragDistance(), startDragTime(), and QPoint::manhattanLength().
.SH "int QApplication::startDragTime ()\fC [static]\fR"
If you support drag and drop in you application and a drag should start after a mouse click and after a certain time elapsed, you should use the value which this method returns as the delay (in ms).
.PP
Qt also uses this delay internally, e.g. in QTextEdit and QLineEdit, for starting a drag.
.PP
The default value is 500 ms.
.PP
See also setStartDragTime() and startDragDistance().
.SH "bool QApplication::startingUp ()\fC [static]\fR"
Returns TRUE if an application object has not been created yet; otherwise returns FALSE.
.PP
See also closingDown().
.SH "QStyle & QApplication::style ()\fC [static]\fR"
Returns the application's style object.
.PP
See also setStyle() and QStyle.
.SH "void QApplication::syncX ()\fC [static]\fR"
Synchronizes with the X server in the X11 implementation. This normally takes some time. Does nothing on other platforms.
.PP
See also flushX().
.SH "QWidgetList * QApplication::topLevelWidgets ()\fC [static]\fR"
Returns a list of the top level widgets in the application.
.PP
The list is created using \fCnew\fR and must be deleted by the caller.
.PP
The list is empty (QPtrList::isEmpty()) if there are no top level widgets.
.PP
Note that some of the top level widgets may be hidden, for example the tooltip if no tooltip is currently shown.
.PP
Example:
.PP
.nf
.br
    // Show all hidden top level widgets.
.br
    QWidgetList  *list = QApplication::topLevelWidgets();
.br
    QWidgetListIt it( *list );  // iterate over the widgets
.br
    QWidget * w;
.br
    while ( (w=it.current()) != 0 ) {   // for each top level widget...
.br
        ++it;
.br
        if ( !w->isVisible() )
.br
            w->show();
.br
    }
.br
    delete list;                // delete the list, not the widgets
.br
.fi
.PP
\fBWarning:\fR Delete the list as soon you have finished using it. The widgets in the list may be deleted by someone else at any time.
.PP
See also allWidgets(), QWidget::isTopLevel, QWidget::visible, and QPtrList::isEmpty().
.SH "QString QApplication::translate ( const char * context, const char * sourceText, const char * comment = 0, Encoding encoding = DefaultCodec ) const"
\fBNote:\fR This function is reentrant when Qt is built with thread support.</p> Returns the translation text for \fIsourceText\fR, by querying the installed messages files. The message files are searched from the most recently installed message file back to the first installed message file.
.PP
QObject::tr() and QObject::trUtf8() provide this functionality more conveniently.
.PP
\fIcontext\fR is typically a class name (e.g., "MyDialog") and \fIsourceText\fR is either English text or a short identifying text, if the output text will be very long (as for help texts).
.PP
\fIcomment\fR is a disambiguating comment, for when the same \fIsourceText\fR is used in different roles within the same context. By default, it is null. \fIencoding\fR indicates the 8-bit encoding of character stings
.PP
See the QTranslator documentation for more information about contexts and comments.
.PP
If none of the message files contain a translation for \fIsourceText\fR in \fIcontext\fR, this function returns a QString equivalent of \fIsourceText\fR. The encoding of \fIsourceText\fR is specified by \fIencoding\fR; it defaults to DefaultCodec.
.PP
This function is not virtual. You can use alternative translation techniques by subclassing QTranslator.
.PP
\fBWarning:\fR This method is reentrant only if all translators are installed \fIbefore\fR calling this method. Installing or removing translators while performing translations is not supported. Doing so will most likely result in crashes or other undesirable behavior.
.PP
See also QObject::tr(), installTranslator(), and defaultCodec().
.SH "bool QApplication::tryLock ()"
Attempts to lock the Qt Library Mutex, and returns immediately. If the lock was obtained, this function returns TRUE. If another thread has locked the mutex, this function returns FALSE, instead of waiting for the lock to become available.
.PP
The mutex must be unlocked with unlock() before another thread can successfully lock it.
.PP
See also lock(), unlock(), and Thread Support in Qt.
.SH "Type QApplication::type () const"
Returns the type of application, Tty, GuiClient or GuiServer.
.SH "void QApplication::unlock ( bool wakeUpGui = TRUE )"
Unlock the Qt Library Mutex. If \fIwakeUpGui\fR is TRUE (the default), then the GUI thread will be woken with QApplication::wakeUpGuiThread().
.PP
See also lock(), locked(), and Thread Support in Qt.
.SH "void QApplication::wakeUpGuiThread ()"
Wakes up the GUI thread.
.PP
See also guiThreadAwake() and Thread Support in Qt.
.SH "int QApplication::wheelScrollLines ()\fC [static]\fR"
Returns the number of lines to scroll when the mouse wheel is rotated.
.PP
See also setWheelScrollLines().
.SH "QWidget * QApplication::widgetAt ( int x, int y, bool child = FALSE )\fC [static]\fR"
Returns a pointer to the widget at global screen position \fI(x, y)\fR, or 0 if there is no Qt widget there.
.PP
If \fIchild\fR is FALSE and there is a child widget at position \fI(x, y)\fR, the top-level widget containing it is returned. If \fIchild\fR is TRUE the child widget at position \fI(x, y)\fR is returned.
.PP
This function is normally rather slow.
.PP
See also QCursor::pos(), QWidget::grabMouse(), and QWidget::grabKeyboard().
.SH "QWidget * QApplication::widgetAt ( const QPoint & pos, bool child = FALSE )\fC [static]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a pointer to the widget at global screen position \fIpos\fR, or 0 if there is no Qt widget there.
.PP
If \fIchild\fR is FALSE and there is a child widget at position \fIpos\fR, the top-level widget containing it is returned. If \fIchild\fR is TRUE the child widget at position \fIpos\fR is returned.
.SH "bool QApplication::winEventFilter ( MSG * )\fC [virtual]\fR"
This virtual function is only implemented under Windows.
.PP
The message procedure calls this function for every message received. Reimplement this function if you want to process window messages that are not processed by Qt. If you don't want the event to be processed by Qt, then return TRUE; otherwise return FALSE.
.SH "void QApplication::winFocus ( QWidget * widget, bool gotFocus )"
This function is available only on Windows.
.PP
If \fIgotFocus\fR is TRUE, \fIwidget\fR will become the active window. Otherwise the active window is reset to NULL.
.SH "const QColor & QApplication::winStyleHighlightColor ()\fC [static]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns the color used to mark selections in windows style.
.PP
See also setWinStyleHighlightColor().
.SH "bool QApplication::x11EventFilter ( XEvent * )\fC [virtual]\fR"
This virtual function is only implemented under X11.
.PP
If you create an application that inherits QApplication and reimplement this function, you get direct access to all X events that the are received from the X server.
.PP
Return TRUE if you want to stop the event from being processed. Return FALSE for normal event dispatching.
.PP
See also x11ProcessEvent().
.SH "int QApplication::x11ProcessEvent ( XEvent * event )"
This function does the core processing of individual X \fIevent\fRs, normally by dispatching Qt events to the right destination.
.PP
It returns 1 if the event was consumed by special handling, 0 if the \fIevent\fR was consumed by normal handling, and -1 if the \fIevent\fR was for an unrecognized widget.
.PP
See also x11EventFilter().
.SH RELATED FUNCTION DOCUMENTATION
.SH "void Q_ASSERT ( bool test )"
Prints a warning message containing the source code file name and line number if \fItest\fR is FALSE.
.PP
This is really a macro defined in qglobal.h.
.PP
Q_ASSERT is useful for testing pre- and post-conditions.
.PP
Example:
.PP
.nf
.br
        //
.br
        // File: div.cpp
.br
        //
.br
.br
        #include <qglobal.h>
.br
.br
        int divide( int a, int b )
.br
        {
.br
            Q_ASSERT( b != 0 );                 // this is line 9
.br
            return a/b;
.br
        }
.br
.fi
.PP
If \fCb\fR is zero, the Q_ASSERT statement will output the following message using the qWarning() function:
.PP
.nf
.br
        ASSERT: "b != 0" in div.cpp (9)
.br
.fi
.PP
See also qWarning() and Debugging.
.SH "void Q_CHECK_PTR ( void * p )"
If \fIp\fR is 0, prints a warning message containing the source code file name and line number, saying that the program ran out of memory.
.PP
This is really a macro defined in qglobal.h.
.PP
Example:
.PP
.nf
.br
        int *a;
.br
.br
        Q_CHECK_PTR( a = new int[80] );  // WRONG!
.br
.br
        a = new (nothrow) int[80];       // Right
.br
        Q_CHECK_PTR( a );
.br
.fi
.PP
See also qWarning() and Debugging.
.SH "void qAddPostRoutine ( QtCleanUpFunction p )"
Adds a global routine that will be called from the QApplication destructor. This function is normally used to add cleanup routines for program-wide functionality.
.PP
The function given by \fIp\fR should take no arguments and return nothing, like this:
.PP
.nf
.br
    static int *global_ptr = 0;
.br
.br
    static void cleanup_ptr()
.br
    {
.br
        delete [] global_ptr;
.br
        global_ptr = 0;
.br
    }
.br
.br
    void init_ptr()
.br
    {
.br
        global_ptr = new int[100];      // allocate data
.br
        qAddPostRoutine( cleanup_ptr ); // delete later
.br
    }
.br
.fi
.PP
Note that for an application- or module-wide cleanup, qAddPostRoutine() is often not suitable. People have a tendency to make such modules dynamically loaded, and then unload those modules long before the QApplication destructor is called, for example.
.PP
For modules and libraries, using a reference-counted initialization manager or Qt' parent-child delete mechanism may be better. Here is an example of a private class which uses the parent-child mechanism to call a cleanup function at the right time:
.PP
.nf
.br
    class MyPrivateInitStuff: public QObject {
.br
    private:
.br
        MyPrivateInitStuff( QObject * parent ): QObject( parent) {
.br
            // initialization goes here
.br
        }
.br
        MyPrivateInitStuff * p;
.br
.br
    public:
.br
        static MyPrivateInitStuff * initStuff( QObject * parent ) {
.br
            if ( !p )
.br
                p = new MyPrivateInitStuff( parent );
.br
            return p;
.br
        }
.br
.br
        ~MyPrivateInitStuff() {
.br
            // cleanup (the "post routine") goes here
.br
        }
.br
    }
.br
.fi
.PP
By selecting the right parent widget/object, this can often be made to clean up the module's data at the exact right moment.
.SH "void qDebug ( const char * msg, ... )"
Prints a debug message \fImsg\fR, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
        qDebug( "my window handle = %x", myWidget->id() );
.br
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the '&#92;0'-terminator).
.PP
\fBWarning:\fR Passing (const char *)0 as argument to qDebug might lead to crashes on certain platforms due to the platforms printf implementation.
.PP
See also qWarning(), qFatal(), qInstallMsgHandler(), and Debugging.
.SH "void qFatal ( const char * msg, ... )"
Prints a fatal error message \fImsg\fR and exits, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
        int divide( int a, int b )
.br
        {
.br
            if ( b == 0 )                               // program error
.br
                qFatal( "divide: cannot divide by zero" );
.br
            return a/b;
.br
        }
.br
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the '&#92;0'-terminator).
.PP
\fBWarning:\fR Passing (const char *)0 as argument to qFatal might lead to crashes on certain platforms due to the platforms printf implementation.
.PP
See also qDebug(), qWarning(), qInstallMsgHandler(), and Debugging.
.SH "QtMsgHandler qInstallMsgHandler ( QtMsgHandler h )"
Installs a Qt message handler \fIh\fR. Returns a pointer to the message handler previously defined.
.PP
The message handler is a function that prints out debug messages, warnings and fatal error messages. The Qt library (debug version) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. If you implement your own message handler, you get total control of these messages.
.PP
The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.
.PP
Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.
.PP
To restore the message handler, call \fCqInstallMsgHandler(0)\fR.
.PP
Example:
.PP
.nf
.br
        #include <qapplication.h>
.br
        #include <stdio.h>
.br
        #include <stdlib.h>
.br
.br
        void myMessageOutput( QtMsgType type, const char *msg )
.br
        {
.br
            switch ( type ) {
.br
                case QtDebugMsg:
.br
                    fprintf( stderr, "Debug: %s\\n", msg );
.br
                    break;
.br
                case QtWarningMsg:
.br
                    fprintf( stderr, "Warning: %s\\n", msg );
.br
                    break;
.br
                case QtFatalMsg:
.br
                    fprintf( stderr, "Fatal: %s\\n", msg );
.br
                    abort();                    // deliberately core dump
.br
            }
.br
        }
.br
.br
        int main( int argc, char **argv )
.br
        {
.br
            qInstallMsgHandler( myMessageOutput );
.br
            QApplication a( argc, argv );
.br
            ...
.br
            return a.exec();
.br
        }
.br
.fi
.PP
See also qDebug(), qWarning(), qFatal(), and Debugging.
.SH "bool qSysInfo ( int * wordSize, bool * bigEndian )"
Obtains information about the system.
.PP
The system's word size in bits (typically 32) is returned in \fI*wordSize\fR. The \fI*bigEndian\fR is set to TRUE if this is a big-endian machine, or to FALSE if this is a little-endian machine.
.PP
In debug mode, this function calls qFatal() with a message if the computer is truly weird (i.e. different endianness for 16 bit and 32 bit integers); in release mode it returns FALSE.
.SH "void qSystemWarning ( const char * msg, int code )"
Prints the message \fImsg\fR and uses \fIcode\fR to get a system specific error message. When \fIcode\fR is -1 (the default), the system's last error code will be used if possible. Use this method to handle failures in platform specific API calls.
.PP
This function does nothing when Qt is built with \fCQT_NO_DEBUG\fR defined.
.SH "const char * qVersion ()"
Returns the Qt version number as a string, for example, "2.3.0" or" 3.0.5".
.PP
The \fCQT_VERSION\fR define has the numeric value in the form: 0xmmiibb (m = major, i = minor, b = bugfix). For example, Qt 3.0.5's \fCQT_VERSION\fR is 0x030005.
.SH "void qWarning ( const char * msg, ... )"
Prints a warning message \fImsg\fR, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
        void f( int c )
.br
        {
.br
            if ( c > 200 )
.br
                qWarning( "f: bad argument, c == %d", c );
.br
        }
.br
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the '&#92;0'-terminator).
.PP
\fBWarning:\fR Passing (const char *)0 as argument to qWarning might lead to crashes on certain platforms due to the platforms printf implementation.
.PP
See also qDebug(), qFatal(), qInstallMsgHandler(), and Debugging.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qapplication.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qapplication.3qt) and the Qt
version (3.3.8).
