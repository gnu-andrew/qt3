'\" t
.TH QTable 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QTable \- Flexible editable table widget
.SH SYNOPSIS
\fC#include <qtable.h>\fR
.PP
Inherits QScrollView.
.PP
Inherited by QDataTable.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQTable\fR ( QWidget * parent = 0, const char * name = 0 )"
.br
.ti -1c
.BI "\fBQTable\fR ( int numRows, int numCols, QWidget * parent = 0, const char * name = 0 )"
.br
.ti -1c
.BI "\fB~QTable\fR ()"
.br
.ti -1c
.BI "QHeader * \fBhorizontalHeader\fR () const"
.br
.ti -1c
.BI "QHeader * \fBverticalHeader\fR () const"
.br
.ti -1c
.BI "enum \fBSelectionMode\fR { Single, Multi, SingleRow, MultiRow, NoSelection }"
.br
.ti -1c
.BI "virtual void \fBsetSelectionMode\fR ( SelectionMode mode )"
.br
.ti -1c
.BI "SelectionMode \fBselectionMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetItem\fR ( int row, int col, QTableItem * item )"
.br
.ti -1c
.BI "virtual void \fBsetText\fR ( int row, int col, const QString & text )"
.br
.ti -1c
.BI "virtual void \fBsetPixmap\fR ( int row, int col, const QPixmap & pix )"
.br
.ti -1c
.BI "virtual QTableItem * \fBitem\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual QString \fBtext\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual QPixmap \fBpixmap\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual void \fBclearCell\fR ( int row, int col )"
.br
.ti -1c
.BI "virtual QRect \fBcellGeometry\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual int \fBcolumnWidth\fR ( int col ) const"
.br
.ti -1c
.BI "virtual int \fBrowHeight\fR ( int row ) const"
.br
.ti -1c
.BI "virtual int \fBcolumnPos\fR ( int col ) const"
.br
.ti -1c
.BI "virtual int \fBrowPos\fR ( int row ) const"
.br
.ti -1c
.BI "virtual int \fBcolumnAt\fR ( int x ) const"
.br
.ti -1c
.BI "virtual int \fBrowAt\fR ( int y ) const"
.br
.ti -1c
.BI "virtual int \fBnumRows\fR () const"
.br
.ti -1c
.BI "virtual int \fBnumCols\fR () const"
.br
.ti -1c
.BI "void \fBupdateCell\fR ( int row, int col )"
.br
.ti -1c
.BI "int \fBcurrentRow\fR () const"
.br
.ti -1c
.BI "int \fBcurrentColumn\fR () const"
.br
.ti -1c
.BI "void \fBensureCellVisible\fR ( int row, int col )"
.br
.ti -1c
.BI "bool \fBisSelected\fR ( int row, int col ) const"
.br
.ti -1c
.BI "bool \fBisRowSelected\fR ( int row, bool full = FALSE ) const"
.br
.ti -1c
.BI "bool \fBisColumnSelected\fR ( int col, bool full = FALSE ) const"
.br
.ti -1c
.BI "int \fBnumSelections\fR () const"
.br
.ti -1c
.BI "QTableSelection \fBselection\fR ( int num ) const"
.br
.ti -1c
.BI "virtual int \fBaddSelection\fR ( const QTableSelection & s )"
.br
.ti -1c
.BI "virtual void \fBremoveSelection\fR ( const QTableSelection & s )"
.br
.ti -1c
.BI "virtual void \fBremoveSelection\fR ( int num )"
.br
.ti -1c
.BI "virtual int \fBcurrentSelection\fR () const"
.br
.ti -1c
.BI "void \fBselectCells\fR ( int start_row, int start_col, int end_row, int end_col )"
.br
.ti -1c
.BI "void \fBselectRow\fR ( int row )"
.br
.ti -1c
.BI "void \fBselectColumn\fR ( int col )"
.br
.ti -1c
.BI "bool \fBshowGrid\fR () const"
.br
.ti -1c
.BI "bool \fBcolumnMovingEnabled\fR () const"
.br
.ti -1c
.BI "bool \fBrowMovingEnabled\fR () const"
.br
.ti -1c
.BI "virtual void \fBsortColumn\fR ( int col, bool ascending = TRUE, bool wholeRows = FALSE )"
.br
.ti -1c
.BI "bool \fBsorting\fR () const"
.br
.ti -1c
.BI "virtual void \fBtakeItem\fR ( QTableItem * i )"
.br
.ti -1c
.BI "virtual void \fBsetCellWidget\fR ( int row, int col, QWidget * e )"
.br
.ti -1c
.BI "virtual QWidget * \fBcellWidget\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual void \fBclearCellWidget\fR ( int row, int col )"
.br
.ti -1c
.BI "virtual QRect \fBcellRect\fR ( int row, int col ) const"
.br
.ti -1c
.BI "virtual void \fBpaintCell\fR ( QPainter * p, int row, int col, const QRect & cr, bool selected )"
.br
.ti -1c
.BI "virtual void \fBpaintCell\fR ( QPainter * p, int row, int col, const QRect & cr, bool selected, const QColorGroup & cg )"
.br
.ti -1c
.BI "virtual void \fBpaintFocus\fR ( QPainter * p, const QRect & cr )"
.br
.ti -1c
.BI "bool \fBisReadOnly\fR () const"
.br
.ti -1c
.BI "bool \fBisRowReadOnly\fR ( int row ) const"
.br
.ti -1c
.BI "bool \fBisColumnReadOnly\fR ( int col ) const"
.br
.ti -1c
.BI "void \fBrepaintSelections\fR ()"
.br
.ti -1c
.BI "enum \fBFocusStyle\fR { FollowStyle, SpreadSheet }"
.br
.ti -1c
.BI "virtual void \fBsetFocusStyle\fR ( FocusStyle fs )"
.br
.ti -1c
.BI "FocusStyle \fBfocusStyle\fR () const"
.br
.ti -1c
.BI "void \fBupdateHeaderStates\fR ()"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBsetNumRows\fR ( int r )"
.br
.ti -1c
.BI "virtual void \fBsetNumCols\fR ( int r )"
.br
.ti -1c
.BI "virtual void \fBsetShowGrid\fR ( bool b )"
.br
.ti -1c
.BI "virtual void \fBhideRow\fR ( int row )"
.br
.ti -1c
.BI "virtual void \fBhideColumn\fR ( int col )"
.br
.ti -1c
.BI "virtual void \fBshowRow\fR ( int row )"
.br
.ti -1c
.BI "virtual void \fBshowColumn\fR ( int col )"
.br
.ti -1c
.BI "bool \fBisRowHidden\fR ( int row ) const"
.br
.ti -1c
.BI "bool \fBisColumnHidden\fR ( int col ) const"
.br
.ti -1c
.BI "virtual void \fBsetColumnWidth\fR ( int col, int w )"
.br
.ti -1c
.BI "virtual void \fBsetRowHeight\fR ( int row, int h )"
.br
.ti -1c
.BI "virtual void \fBadjustColumn\fR ( int col )"
.br
.ti -1c
.BI "virtual void \fBadjustRow\fR ( int row )"
.br
.ti -1c
.BI "virtual void \fBsetColumnStretchable\fR ( int col, bool stretch )"
.br
.ti -1c
.BI "virtual void \fBsetRowStretchable\fR ( int row, bool stretch )"
.br
.ti -1c
.BI "bool \fBisColumnStretchable\fR ( int col ) const"
.br
.ti -1c
.BI "bool \fBisRowStretchable\fR ( int row ) const"
.br
.ti -1c
.BI "virtual void \fBsetSorting\fR ( bool b )"
.br
.ti -1c
.BI "virtual void \fBswapRows\fR ( int row1, int row2, bool swapHeader = FALSE )"
.br
.ti -1c
.BI "virtual void \fBswapColumns\fR ( int col1, int col2, bool swapHeader = FALSE )"
.br
.ti -1c
.BI "virtual void \fBswapCells\fR ( int row1, int col1, int row2, int col2 )"
.br
.ti -1c
.BI "virtual void \fBsetLeftMargin\fR ( int m )"
.br
.ti -1c
.BI "virtual void \fBsetTopMargin\fR ( int m )"
.br
.ti -1c
.BI "virtual void \fBsetCurrentCell\fR ( int row, int col )"
.br
.ti -1c
.BI "void \fBclearSelection\fR ( bool repaint = TRUE )"
.br
.ti -1c
.BI "virtual void \fBsetColumnMovingEnabled\fR ( bool b )"
.br
.ti -1c
.BI "virtual void \fBsetRowMovingEnabled\fR ( bool b )"
.br
.ti -1c
.BI "virtual void \fBsetReadOnly\fR ( bool b )"
.br
.ti -1c
.BI "virtual void \fBsetRowReadOnly\fR ( int row, bool ro )"
.br
.ti -1c
.BI "virtual void \fBsetColumnReadOnly\fR ( int col, bool ro )"
.br
.ti -1c
.BI "virtual void \fBsetDragEnabled\fR ( bool b )"
.br
.ti -1c
.BI "bool \fBdragEnabled\fR () const"
.br
.ti -1c
.BI "virtual void \fBinsertRows\fR ( int row, int count = 1 )"
.br
.ti -1c
.BI "virtual void \fBinsertColumns\fR ( int col, int count = 1 )"
.br
.ti -1c
.BI "virtual void \fBremoveRow\fR ( int row )"
.br
.ti -1c
.BI "virtual void \fBremoveRows\fR ( const QMemArray<int> & rows )"
.br
.ti -1c
.BI "virtual void \fBremoveColumn\fR ( int col )"
.br
.ti -1c
.BI "virtual void \fBremoveColumns\fR ( const QMemArray<int> & cols )"
.br
.ti -1c
.BI "virtual void \fBeditCell\fR ( int row, int col, bool replace = FALSE )"
.br
.ti -1c
.BI "void \fBsetRowLabels\fR ( const QStringList & labels )"
.br
.ti -1c
.BI "void \fBsetColumnLabels\fR ( const QStringList & labels )"
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBcurrentChanged\fR ( int row, int col )"
.br
.ti -1c
.BI "void \fBclicked\fR ( int row, int col, int button, const QPoint & mousePos )"
.br
.ti -1c
.BI "void \fBdoubleClicked\fR ( int row, int col, int button, const QPoint & mousePos )"
.br
.ti -1c
.BI "void \fBpressed\fR ( int row, int col, int button, const QPoint & mousePos )"
.br
.ti -1c
.BI "void \fBselectionChanged\fR ()"
.br
.ti -1c
.BI "void \fBvalueChanged\fR ( int row, int col )"
.br
.ti -1c
.BI "void \fBcontextMenuRequested\fR ( int row, int col, const QPoint & pos )"
.br
.ti -1c
.BI "void \fBdropped\fR ( QDropEvent * e )"
.br
.in -1c
.SS "Properties"
.in +1c
.ti -1c
.BI "bool \fBcolumnMovingEnabled\fR - whether columns can be moved by the user"
.br
.ti -1c
.BI "FocusStyle \fBfocusStyle\fR - how the current (focus) cell is drawn"
.br
.ti -1c
.BI "int \fBnumCols\fR - the number of columns in the table"
.br
.ti -1c
.BI "int \fBnumRows\fR - the number of rows in the table"
.br
.ti -1c
.BI "int \fBnumSelections\fR - the number of selections  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBreadOnly\fR - whether the table is read-only"
.br
.ti -1c
.BI "bool \fBrowMovingEnabled\fR - whether rows can be moved by the user"
.br
.ti -1c
.BI "SelectionMode \fBselectionMode\fR - the current selection mode"
.br
.ti -1c
.BI "bool \fBshowGrid\fR - whether the table's grid is displayed"
.br
.ti -1c
.BI "bool \fBsorting\fR - whether a click on the header of a column sorts that column"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "enum \fBEditMode\fR { NotEditing, Editing, Replacing }"
.br
.ti -1c
.BI "virtual void \fBdrawContents\fR ( QPainter * p, int cx, int cy, int cw, int ch )"
.br
.ti -1c
.BI "void \fBsetEditMode\fR ( EditMode mode, int row, int col )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragEnterEvent\fR ( QDragEnterEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragMoveEvent\fR ( QDragMoveEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragLeaveEvent\fR ( QDragLeaveEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsDropEvent\fR ( QDropEvent * e )"
.br
.ti -1c
.BI "virtual QDragObject * \fBdragObject\fR ()"
.br
.ti -1c
.BI "virtual void \fBstartDrag\fR ()"
.br
.ti -1c
.BI "virtual void \fBpaintEmptyArea\fR ( QPainter * p, int cx, int cy, int cw, int ch )"
.br
.ti -1c
.BI "virtual void \fBactivateNextCell\fR ()"
.br
.ti -1c
.BI "virtual QWidget * \fBcreateEditor\fR ( int row, int col, bool initFromCell ) const"
.br
.ti -1c
.BI "virtual void \fBsetCellContentFromEditor\fR ( int row, int col )"
.br
.ti -1c
.BI "virtual QWidget * \fBbeginEdit\fR ( int row, int col, bool replace )"
.br
.ti -1c
.BI "virtual void \fBendEdit\fR ( int row, int col, bool accept, bool replace )"
.br
.ti -1c
.BI "virtual void \fBresizeData\fR ( int len )"
.br
.ti -1c
.BI "virtual void \fBinsertWidget\fR ( int row, int col, QWidget * w )"
.br
.ti -1c
.BI "int \fBindexOf\fR ( int row, int col ) const"
.br
.ti -1c
.BI "bool \fBisEditing\fR () const"
.br
.ti -1c
.BI "EditMode \fBeditMode\fR () const"
.br
.ti -1c
.BI "int \fBcurrEditRow\fR () const"
.br
.ti -1c
.BI "int \fBcurrEditCol\fR () const"
.br
.in -1c
.SS "Protected Slots"
.in +1c
.ti -1c
.BI "virtual void \fBcolumnWidthChanged\fR ( int col )"
.br
.ti -1c
.BI "virtual void \fBrowHeightChanged\fR ( int row )"
.br
.ti -1c
.BI "virtual void \fBcolumnIndexChanged\fR ( int section, int fromIndex, int toIndex )"
.br
.ti -1c
.BI "virtual void \fBrowIndexChanged\fR ( int section, int fromIndex, int toIndex )"
.br
.ti -1c
.BI "virtual void \fBcolumnClicked\fR ( int col )"
.br
.in -1c
.SH DESCRIPTION
The QTable class provides a flexible editable table widget.
.PP
QTable is easy to use, although it does have a large API because of the comprehensive functionality that it provides. QTable includes functions for manipulating headers, rows and columns, cells and selections. QTable also provides in-place editing and drag and drop, as well as a useful set of signals. QTable efficiently supports very large tables, for example, tables one million by one million cells are perfectly possible. QTable is economical with memory, using none for unused cells.
.PP
.nf
.br
    QTable *table = new QTable( 100, 250, this );
.br
    table->setPixmap( 3, 2, pix );
.br
    table->setText( 3, 2, "A pixmap" );
.br
.fi
.PP
The first line constructs the table specifying its size in rows and columns. We then insert a pixmap and some text into the \fIsame\fR cell, with the pixmap appearing to the left of the text. QTable cells can be populated with QTableItems, QComboTableItems or by QCheckTableItems. By default a vertical header appears at the left of the table showing row numbers and a horizontal header appears at the top of the table showing column numbers. (The numbers displayed start at 1, although row and column numbers within QTable begin at 0.)
.PP
If you want to use mouse tracking call setMouseTracking( TRUE ) on the \fIviewport\fR; (see QScrollView).
.PP
<center>
.ce 1
.B "[Image Omitted]"
.PP
</center>
.SH "Headers"
QTable supports a header column, e.g. to display row numbers, and a header row, e.g to display column titles. To set row or column labels use QHeader::setLabel() on the pointers returned by verticalHeader() and horizontalHeader() respectively. The vertical header is displayed within the table's left margin whose width is set with setLeftMargin(). The horizontal header is displayed within the table's top margin whose height is set with setTopMargin(). The table's grid can be switched off with setShowGrid(). If you want to hide a horizontal header call hide(), and call setTopMargin( 0 ) so that the area the header would have occupied is reduced to zero size.
.PP
Header labels are indexed via their section numbers. Note that the default behavior of QHeader regarding section numbers is overriden for QTable. See the explanation below in the Rows and Columns section in the discussion of moving columns and rows.
.SH "Rows and Columns"
Row and column sizes are set with setRowHeight() and setColumnWidth(). If you want a row high enough to show the tallest item in its entirety, use adjustRow(). Similarly, to make a column wide enough to show the widest item use adjustColumn(). If you want the row height and column width to adjust automatically as the height and width of the table changes use setRowStretchable() and setColumnStretchable().
.PP
Rows and columns can be hidden and shown with hideRow(), hideColumn(), showRow() and showColumn(). New rows and columns are inserted using insertRows() and insertColumns(). Additional rows and columns are added at the bottom (rows) or right (columns) if you set setNumRows() or setNumCols() to be larger than numRows() or numCols(). Existing rows and columns are removed with removeRow() and removeColumn(). Multiple rows and columns can be removed with removeRows() and removeColumns().
.PP
Rows and columns can be set to be moveable using rowMovingEnabled() and columnMovingEnabled(). The user can drag them to reorder them holding down the Ctrl key and dragging the mouse. For performance reasons, the default behavior of QHeader section numbers is overridden by QTable. Currently in QTable, when a row or column is dragged and reordered, the section number is also changed to its new position. Therefore, there is no difference between the section and the index fields in QHeader. The QTable QHeader classes do not provide a mechanism for indexing independently of the user interface ordering.
.PP
The table can be sorted using sortColumn(). Users can sort a column by clicking its header if setSorting() is set to TRUE. Rows can be swapped with swapRows(), columns with swapColumns() and cells with swapCells().
.PP
For editable tables (see setReadOnly()) you can set the read-only property of individual rows and columns with setRowReadOnly() and setColumnReadOnly(). (Whether a cell is editable or read-only depends on these settings and the cell's QTableItem::EditType.)
.PP
The row and column which have the focus are returned by currentRow() and currentColumn() respectively.
.PP
Although many QTable functions operate in terms of rows and columns the indexOf() function returns a single integer identifying a particular cell.
.SH "Cells"
All of a QTable's cells are empty when the table is constructed.
.PP
There are two approaches to populating the table's cells. The first and simplest approach is to use QTableItems or QTableItem subclasses. The second approach doesn't use QTableItems at all which is useful for very large sparse tables but requires you to reimplement a number of functions. We'll look at each approach in turn.
.PP
To put a string in a cell use setText(). This function will create a new QTableItem for the cell if one doesn't already exist, and displays the text in it. By default the table item's widget will be a QLineEdit. A pixmap may be put in a cell with setPixmap(), which also creates a table item if required. A cell may contain \fIboth\fR a pixmap and text; the pixmap is displayed to the left of the text. Another approach is to construct a QTableItem or QTableItem subclass, set its properties, then insert it into a cell with setItem().
.PP
If you want cells which contain comboboxes use the QComboTableItem class. Similarly if you require cells containing checkboxes use the QCheckTableItem class. These table items look and behave just like the combobox or checkbox widgets but consume far less memory.
.PP
.nf
.br
        for ( int j = 0; j < numRows; ++j )
.br
            table.setItem( j, 1, new QCheckTableItem( &table, "Check me" ) );
.fi
In the example above we create a column of QCheckTableItems and insert them into the table using setItem().
.PP
QTable takes ownership of its QTableItems and will delete them when the table itself is destroyed. You can take ownership of a table item using takeItem() which you use to move a cell's contents from one cell to another, either within the same table, or from one table to another. (See also, swapCells()).
.PP
In-place editing of the text in QTableItems, and the values in QComboTableItems and QCheckTableItems works automatically. Cells may be editable or read-only, see QTableItem::EditType. If you want fine control over editing see beginEdit() and endEdit().
.PP
The contents of a cell can be retrieved as a QTableItem using item(), or as a string with text() or as a pixmap (if there is one) with pixmap(). A cell's bounding rectangle is given by cellGeometry(). Use updateCell() to repaint a cell, for example to clear away a cell's visual representation after it has been deleted with clearCell(). The table can be forced to scroll to show a particular cell with ensureCellVisible(). The isSelected() function indicates if a cell is selected.
.PP
It is possible to use your own widget as a cell's widget using setCellWidget(), but subclassing QTableItem might be a simpler approach. The cell's widget (if there is one) can be removed with clearCellWidget().
.PP

<h4> Large tables </h4>
.PP
For large, sparse, tables using QTableItems or other widgets is inefficient. The solution is to \fIdraw\fR the cell as it should appear and to create and destroy cell editors on demand.
.PP
This approach requires that you reimplement various functions. Reimplement paintCell() to display your data, and createEditor() and setCellContentFromEditor() to support in-place editing. It is very important to reimplement resizeData() to have no functionality, to prevent QTable from attempting to create a huge array. You will also need to reimplement item(), setItem(), takeItem(), clearCell(), and insertWidget(), cellWidget() and clearCellWidget(). In almost every circumstance (for sorting, removing and inserting columns and rows, etc.), you also need to reimplement swapRows(), swapCells() and swapColumns(), including header handling.
.PP
If you represent active cells with a dictionary of QTableItems and QWidgets, i.e. only store references to cells that are actually used, many of the functions can be implemented with a single line of code. (See the table/bigtable/main.cpp example.)
.PP
For more information on cells see the QTableItem documenation.
.SH "Selections"
QTable's support single selection, multi-selection (multiple cells) or no selection. The selection mode is set with setSelectionMode(). Use isSelected() to determine if a particular cell is selected, and isRowSelected() and isColumnSelected() to see if a row or column is selected.
.PP
QTable's support many simultaneous selections. You can programmatically select cells with addSelection(). The number of selections is given by numSelections(). The current selection is returned by currentSelection(). You can remove a selection with removeSelection() and remove all selections with clearSelection(). Selections are QTableSelection objects.
.PP
To easily add a new selection use selectCells(), selectRow() or selectColumn().
.PP
Alternatively, use addSelection() to add new selections using QTableSelection objects. The advantage of using QTableSelection objects is that you can call QTableSelection::expandTo() to resize the selection and can query and compare them.
.PP
The number of selections is given by numSelections(). The current selection is returned by currentSelection(). You can remove a selection with removeSelection() and remove all selections with clearSelection().
.SH "Signals"
When the user clicks a cell the currentChanged() signal is emitted. You can also connect to the lower level clicked(), doubleClicked() and pressed() signals. If the user changes the selection the selectionChanged() signal is emitted; similarly if the user changes a cell's value the valueChanged() signal is emitted. If the user right-clicks (or presses the appropriate platform-specific key sequence) the contextMenuRequested() signal is emitted. If the user drops a drag and drop object the dropped() signal is emitted with the drop event.
.PP
See also Advanced Widgets.
.SS "Member Type Documentation"
.SH "QTable::EditMode"
.TP
\fCQTable::NotEditing\fR - No cell is currently being edited.
.TP
\fCQTable::Editing\fR - A cell is currently being edited. The editor was initialised with the cell's contents.
.TP
\fCQTable::Replacing\fR - A cell is currently being edited. The editor was not initialised with the cell's contents.
.SH "QTable::FocusStyle"
Specifies how the current cell (focus cell) is drawn.
.TP
\fCQTable::FollowStyle\fR - The current cell is drawn according to the current style and the cell's background is also drawn selected, if the current cell is within a selection
.TP
\fCQTable::SpreadSheet\fR - The current cell is drawn as in a spreadsheet. This means, it is signified by a black rectangle around the cell, and the background of the current cell is always drawn with the widget's base color - even when selected.
.SH "QTable::SelectionMode"
.TP
\fCQTable::NoSelection\fR - No cell can be selected by the user.
.TP
\fCQTable::Single\fR - The user may only select a single range of cells.
.TP
\fCQTable::Multi\fR - The user may select multiple ranges of cells.
.TP
\fCQTable::SingleRow\fR - The user may select one row at once.
.TP
\fCQTable::MultiRow\fR - The user may select multiple rows.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QTable::QTable ( QWidget * parent = 0, const char * name = 0 )"
Creates an empty table object called \fIname\fR as a child of \fIparent\fR.
.PP
Call setNumRows() and setNumCols() to set the table size before populating the table if you're using QTableItems.
.PP
See also QWidget::clearWFlags() and Qt::WidgetFlags.
.SH "QTable::QTable ( int numRows, int numCols, QWidget * parent = 0, const char * name = 0 )"
Constructs an empty table called \fIname\fR with \fInumRows\fR rows and \fInumCols\fR columns. The table is a child of \fIparent\fR.
.PP
If you're using QTableItems to populate the table's cells, you can create QTableItem, QComboTableItem and QCheckTableItem items and insert them into the table using setItem(). (See the notes on large tables for an alternative to using QTableItems.)
.PP
See also QWidget::clearWFlags() and Qt::WidgetFlags.
.SH "QTable::~QTable ()"
Releases all the resources used by the QTable object, including all QTableItems and their widgets.
.SH "void QTable::activateNextCell ()\fC [virtual protected]\fR"
This function is called to activate the next cell if in-place editing was finished by pressing the Enter key.
.PP
The default behaviour is to move from top to bottom, i.e. move to the cell beneath the cell being edited. Reimplement this function if you want different behaviour, e.g. moving from left to right.
.SH "int QTable::addSelection ( const QTableSelection & s )\fC [virtual]\fR"
Adds a selection described by \fIs\fR to the table and returns its number or -1 if the selection is invalid.
.PP
Remember to call QTableSelection::init() and QTableSelection::expandTo() to make the selection valid (see also QTableSelection::isActive(), or use the QTableSelection(int,int,int,int) constructor).
.PP
See also numSelections, removeSelection(), and clearSelection().
.SH "void QTable::adjustColumn ( int col )\fC [virtual slot]\fR"
Resizes column \fIcol\fR so that the column width is wide enough to display the widest item the column contains.
.PP
See also adjustRow().
.PP
Example: regexptester/regexptester.cpp.
.PP
Reimplemented in QDataTable.
.SH "void QTable::adjustRow ( int row )\fC [virtual slot]\fR"
Resizes row \fIrow\fR so that the row height is tall enough to display the tallest item the row contains.
.PP
See also adjustColumn().
.SH "QWidget * QTable::beginEdit ( int row, int col, bool replace )\fC [virtual protected]\fR"
This function is called to start in-place editing of the cell at \fIrow\fR, \fIcol\fR. Editing is achieved by creating an editor (createEditor() is called) and setting the cell's editor with setCellWidget() to the newly created editor. (After editing is complete endEdit() will be called to replace the cell's content with the editor's content.) If \fIreplace\fR is TRUE the editor will start empty; otherwise it will be initialized with the cell's content (if any), i.e. the user will be modifying the original cell content.
.PP
See also endEdit().
.SH "QRect QTable::cellGeometry ( int row, int col ) const\fC [virtual]\fR"
Returns the bounding rectangle of the cell at \fIrow\fR, \fIcol\fR in content coordinates.
.SH "QRect QTable::cellRect ( int row, int col ) const\fC [virtual]\fR"
Returns the geometry of cell \fIrow\fR, \fIcol\fR in the cell's coordinate system. This is a convenience function useful in paintCell(). It is equivalent to QRect( QPoint(0,0), cellGeometry( row, col).size() );
.PP
See also cellGeometry().
.PP
Example: chart/setdataform.cpp.
.SH "QWidget * QTable::cellWidget ( int row, int col ) const\fC [virtual]\fR"
Returns the widget that has been set for the cell at \fIrow\fR, \fIcol\fR, or 0 if no widget has been set.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.PP
See also clearCellWidget() and setCellWidget().
.PP
Example: chart/setdataform.cpp.
.SH "void QTable::clearCell ( int row, int col )\fC [virtual]\fR"
Removes the QTableItem at \fIrow\fR, \fIcol\fR.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.SH "void QTable::clearCellWidget ( int row, int col )\fC [virtual]\fR"
Removes the widget (if there is one) set for the cell at \fIrow\fR, \fIcol\fR.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.PP
This function deletes the widget at \fIrow\fR, \fIcol\fR. Note that the widget is not deleted immediately; instead QObject::deleteLater() is called on the widget to avoid problems with timing issues.
.PP
See also cellWidget() and setCellWidget().
.SH "void QTable::clearSelection ( bool repaint = TRUE )\fC [slot]\fR"
Clears all selections and repaints the appropriate regions if \fIrepaint\fR is TRUE.
.PP
See also removeSelection().
.SH "void QTable::clicked ( int row, int col, int button, const QPoint & mousePos )\fC [signal]\fR"
This signal is emitted when mouse button \fIbutton\fR is clicked. The cell where the event took place is at \fIrow\fR, \fIcol\fR, and the mouse's position is in \fImousePos\fR.
.PP
See also Qt::ButtonState.
.PP
Example: chart/setdataform.cpp.
.SH "int QTable::columnAt ( int x ) const\fC [virtual]\fR"
Returns the number of the column at position \fIx\fR. \fIx\fR must be given in content coordinates.
.PP
See also columnPos() and rowAt().
.SH "void QTable::columnClicked ( int col )\fC [virtual protected slot]\fR"
This function is called when the column \fIcol\fR has been clicked. The default implementation sorts this column if sorting() is TRUE.
.SH "void QTable::columnIndexChanged ( int section, int fromIndex, int toIndex )\fC [virtual protected slot]\fR"
This function is called when column order is to be changed, i.e. when the user moved the column header \fIsection\fR from \fIfromIndex\fR to \fItoIndex\fR.
.PP
If you want to change the column order programmatically, call swapRows() or swapColumns();
.PP
See also QHeader::indexChange() and rowIndexChanged().
.SH "bool QTable::columnMovingEnabled () const"
Returns TRUE if columns can be moved by the user; otherwise returns FALSE. See the "columnMovingEnabled" property for details.
.SH "int QTable::columnPos ( int col ) const\fC [virtual]\fR"
Returns the x-coordinate of the column \fIcol\fR in content coordinates.
.PP
See also columnAt() and rowPos().
.SH "int QTable::columnWidth ( int col ) const\fC [virtual]\fR"
Returns the width of column \fIcol\fR.
.PP
See also setColumnWidth() and rowHeight().
.SH "void QTable::columnWidthChanged ( int col )\fC [virtual protected slot]\fR"
This function should be called whenever the column width of \fIcol\fR has been changed. It updates the geometry of any affected columns and repaints the table to reflect the changes it has made.
.SH "void QTable::contentsDragEnterEvent ( QDragEnterEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever a QTable object receives a QDragEnterEvent \fIe\fR, i.e. when the user pressed the mouse button to drag something.
.PP
The focus is moved to the cell where the QDragEnterEvent occurred.
.PP
Reimplemented from QScrollView.
.SH "void QTable::contentsDragLeaveEvent ( QDragLeaveEvent * e )\fC [virtual protected]\fR"
This event handler is called when a drag activity leaves \fIthis\fR QTable object with event \fIe\fR.
.PP
Reimplemented from QScrollView.
.SH "void QTable::contentsDragMoveEvent ( QDragMoveEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever a QTable object receives a QDragMoveEvent \fIe\fR, i.e. when the user actually drags the mouse.
.PP
The focus is moved to the cell where the QDragMoveEvent occurred.
.PP
Reimplemented from QScrollView.
.SH "void QTable::contentsDropEvent ( QDropEvent * e )\fC [virtual protected]\fR"
This event handler is called when the user ends a drag and drop by dropping something onto \fIthis\fR QTable and thus triggers the drop event, \fIe\fR.
.PP
Reimplemented from QScrollView.
.SH "void QTable::contextMenuRequested ( int row, int col, const QPoint & pos )\fC [signal]\fR"
This signal is emitted when the user invokes a context menu with the right mouse button (or with a system-specific keypress). The cell where the event took place is at \fIrow\fR, \fIcol\fR. \fIpos\fR is the position where the context menu will appear in the global coordinate system. This signal is always emitted, even if the contents of the cell are disabled.
.SH "QWidget * QTable::createEditor ( int row, int col, bool initFromCell ) const\fC [virtual protected]\fR"
This function returns the widget which should be used as an editor for the contents of the cell at \fIrow\fR, \fIcol\fR.
.PP
If \fIinitFromCell\fR is TRUE, the editor is used to edit the current contents of the cell (so the editor widget should be initialized with this content). If \fIinitFromCell\fR is FALSE, the content of the cell is replaced with the new content which the user entered into the widget created by this function.
.PP
The default functionality is as follows: if \fIinitFromCell\fR is TRUE or the cell has a QTableItem and the table item's QTableItem::isReplaceable() is FALSE then the cell is asked to create an appropriate editor (using QTableItem::createEditor()). Otherwise a QLineEdit is used as the editor.
.PP
If you want to create your own editor for certain cells, implement a custom QTableItem subclass and reimplement QTableItem::createEditor().
.PP
If you are not using QTableItems and you don't want to use a QLineEdit as the default editor, subclass QTable and reimplement this function with code like this:
.PP
.nf
.br
    QTableItem *i = item( row, col );
.br
    if ( initFromCell || ( i && !i->isReplaceable() ) )
.br
        // If we had a QTableItem ask the base class to create the editor
.br
        return QTable::createEditor( row, col, initFromCell );
.br
    else
.br
        return ...(create your own editor)
.br
.fi
Ownership of the editor widget is transferred to the caller.
.PP
If you reimplement this function return 0 for read-only cells. You will need to reimplement setCellContentFromEditor() to retrieve the data the user entered.
.PP
See also QTableItem::createEditor().
.SH "int QTable::currEditCol () const\fC [protected]\fR"
Returns the current edited column
.SH "int QTable::currEditRow () const\fC [protected]\fR"
Returns the current edited row
.SH "void QTable::currentChanged ( int row, int col )\fC [signal]\fR"
This signal is emitted when the current cell has changed to \fIrow\fR, \fIcol\fR.
.PP
Example: chart/setdataform.cpp.
.SH "int QTable::currentColumn () const"
Returns the current column.
.PP
See also currentRow().
.PP
Example: chart/setdataform.cpp.
.SH "int QTable::currentRow () const"
Returns the current row.
.PP
See also currentColumn().
.PP
Example: chart/setdataform.cpp.
.SH "int QTable::currentSelection () const\fC [virtual]\fR"
Returns the number of the current selection or -1 if there is no current selection.
.PP
See also numSelections.
.SH "void QTable::doubleClicked ( int row, int col, int button, const QPoint & mousePos )\fC [signal]\fR"
This signal is emitted when mouse button \fIbutton\fR is double-clicked. The cell where the event took place is at \fIrow\fR, \fIcol\fR, and the mouse's position is in \fImousePos\fR.
.PP
See also Qt::ButtonState.
.SH "bool QTable::dragEnabled () const\fC [slot]\fR"
If this function returns TRUE, the table supports dragging.
.PP
See also setDragEnabled().
.SH "QDragObject * QTable::dragObject ()\fC [virtual protected]\fR"
If the user presses the mouse on a selected cell, starts moving (i.e. dragging), and dragEnabled() is TRUE, this function is called to obtain a drag object. A drag using this object begins immediately unless dragObject() returns 0.
.PP
By default this function returns 0. You might reimplement it and create a QDragObject depending on the selected items.
.PP
See also dropped().
.SH "void QTable::drawContents ( QPainter * p, int cx, int cy, int cw, int ch )\fC [virtual protected]\fR"
Draws the table contents on the painter \fIp\fR. This function is optimized so that it only draws the cells inside the \fIcw\fR pixels wide and \fIch\fR pixels high clipping rectangle at position \fIcx\fR, \fIcy\fR.
.PP
Additionally, drawContents() highlights the current cell.
.PP
Reimplemented from QScrollView.
.SH "void QTable::dropped ( QDropEvent * e )\fC [signal]\fR"
This signal is emitted when a drop event occurred on the table.
.PP
\fIe\fR contains information about the drop.
.SH "void QTable::editCell ( int row, int col, bool replace = FALSE )\fC [virtual slot]\fR"
Starts editing the cell at \fIrow\fR, \fIcol\fR.
.PP
If \fIreplace\fR is TRUE the content of this cell will be replaced by the content of the editor when editing is finished, i.e. the user will be entering new data; otherwise the current content of the cell (if any) will be modified in the editor.
.PP
See also beginEdit().
.SH "EditMode QTable::editMode () const\fC [protected]\fR"
Returns the current edit mode
.PP
See also QTable::EditMode.
.SH "void QTable::endEdit ( int row, int col, bool accept, bool replace )\fC [virtual protected]\fR"
This function is called when in-place editing of the cell at \fIrow\fR, \fIcol\fR is requested to stop.
.PP
If the cell is not being edited or \fIaccept\fR is FALSE the function returns and the cell's contents are left unchanged.
.PP
If \fIaccept\fR is TRUE the content of the editor must be transferred to the relevant cell. If \fIreplace\fR is TRUE the current content of this cell should be replaced by the content of the editor (this means removing the current QTableItem of the cell and creating a new one for the cell). Otherwise (if possible) the content of the editor should just be set to the existing QTableItem of this cell.
.PP
setCellContentFromEditor() is called to replace the contents of the cell with the contents of the cell's editor.
.PP
Finally clearCellWidget() is called to remove the editor widget.
.PP
See also setCellContentFromEditor() and beginEdit().
.SH "void QTable::ensureCellVisible ( int row, int col )"
Scrolls the table until the cell at \fIrow\fR, \fIcol\fR becomes visible.
.SH "FocusStyle QTable::focusStyle () const"
Returns how the current (focus) cell is drawn. See the "focusStyle" property for details.
.SH "void QTable::hideColumn ( int col )\fC [virtual slot]\fR"
Hides column \fIcol\fR.
.PP
See also showColumn() and hideRow().
.SH "void QTable::hideRow ( int row )\fC [virtual slot]\fR"
Hides row \fIrow\fR.
.PP
See also showRow() and hideColumn().
.SH "QHeader * QTable::horizontalHeader () const"
Returns the table's top QHeader.
.PP
This header contains the column labels.
.PP
To modify a column label use QHeader::setLabel(), e.g.
.PP
.nf
.br
        horizontalHeader()->setLabel( 0, tr( "File" ) );
.fi
.PP
See also verticalHeader(), setTopMargin(), and QHeader.
.PP
Examples:
.)l chart/setdataform.cpp, helpsystem/mainwindow.cpp, regexptester/regexptester.cpp, and table/small-table-demo/main.cpp.
.SH "int QTable::indexOf ( int row, int col ) const\fC [protected]\fR"
Returns a single integer which identifies a particular \fIrow\fR and \fIcol\fR by mapping the 2D table to a 1D array.
.PP
This is useful, for example, if you have a sparse table and want to use a QIntDict to map integers to the cells that are used.
.SH "void QTable::insertColumns ( int col, int count = 1 )\fC [virtual slot]\fR"
Inserts \fIcount\fR empty columns at column \fIcol\fR. Also clears the selection(s).
.PP
See also insertRows() and removeColumn().
.SH "void QTable::insertRows ( int row, int count = 1 )\fC [virtual slot]\fR"
Inserts \fIcount\fR empty rows at row \fIrow\fR. Also clears the selection(s).
.PP
See also insertColumns() and removeRow().
.SH "void QTable::insertWidget ( int row, int col, QWidget * w )\fC [virtual protected]\fR"
Inserts widget \fIw\fR at \fIrow\fR, \fIcol\fR into the internal data structure. See the documentation of setCellWidget() for further details.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.SH "bool QTable::isColumnHidden ( int col ) const\fC [slot]\fR"
Returns TRUE if column \fIcol\fR is hidden; otherwise returns FALSE.
.PP
See also hideColumn() and isRowHidden().
.SH "bool QTable::isColumnReadOnly ( int col ) const"
Returns TRUE if column \fIcol\fR is read-only; otherwise returns FALSE.
.PP
Whether a cell in this column is editable or read-only depends on the cell's EditType, and this setting: see QTableItem::EditType.
.PP
See also setColumnReadOnly() and isRowReadOnly().
.SH "bool QTable::isColumnSelected ( int col, bool full = FALSE ) const"
Returns TRUE if column \fIcol\fR is selected; otherwise returns FALSE.
.PP
If \fIfull\fR is FALSE (the default), 'column is selected' means that at least one cell in the column is selected. If \fIfull\fR is TRUE, then 'column is selected' means every cell in the column is selected.
.PP
See also isRowSelected() and isSelected().
.SH "bool QTable::isColumnStretchable ( int col ) const\fC [slot]\fR"
Returns TRUE if column \fIcol\fR is stretchable; otherwise returns FALSE.
.PP
See also setColumnStretchable() and isRowStretchable().
.SH "bool QTable::isEditing () const\fC [protected]\fR"
Returns TRUE if the EditMode is Editing or Replacing; otherwise (i.e. the EditMode is NotEditing) returns FALSE.
.PP
See also QTable::EditMode.
.SH "bool QTable::isReadOnly () const"
Returns TRUE if the table is read-only; otherwise returns FALSE. See the "readOnly" property for details.
.SH "bool QTable::isRowHidden ( int row ) const\fC [slot]\fR"
Returns TRUE if row \fIrow\fR is hidden; otherwise returns FALSE.
.PP
See also hideRow() and isColumnHidden().
.SH "bool QTable::isRowReadOnly ( int row ) const"
Returns TRUE if row \fIrow\fR is read-only; otherwise returns FALSE.
.PP
Whether a cell in this row is editable or read-only depends on the cell's EditType, and this setting: see QTableItem::EditType.
.PP
See also setRowReadOnly() and isColumnReadOnly().
.SH "bool QTable::isRowSelected ( int row, bool full = FALSE ) const"
Returns TRUE if row \fIrow\fR is selected; otherwise returns FALSE.
.PP
If \fIfull\fR is FALSE (the default), 'row is selected' means that at least one cell in the row is selected. If \fIfull\fR is TRUE, then 'row is selected' means every cell in the row is selected.
.PP
See also isColumnSelected() and isSelected().
.SH "bool QTable::isRowStretchable ( int row ) const\fC [slot]\fR"
Returns TRUE if row \fIrow\fR is stretchable; otherwise returns FALSE.
.PP
See also setRowStretchable() and isColumnStretchable().
.SH "bool QTable::isSelected ( int row, int col ) const"
Returns TRUE if the cell at \fIrow\fR, \fIcol\fR is selected; otherwise returns FALSE.
.PP
See also isRowSelected() and isColumnSelected().
.SH "QTableItem * QTable::item ( int row, int col ) const\fC [virtual]\fR"
Returns the QTableItem representing the contents of the cell at \fIrow\fR, \fIcol\fR.
.PP
If \fIrow\fR or \fIcol\fR are out of range or no content has been set for this cell, item() returns 0.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.PP
See also setItem().
.PP
Example: regexptester/regexptester.cpp.
.SH "int QTable::numCols () const\fC [virtual]\fR"
Returns the number of columns in the table. See the "numCols" property for details.
.PP
Reimplemented in QDataTable.
.SH "int QTable::numRows () const\fC [virtual]\fR"
Returns the number of rows in the table. See the "numRows" property for details.
.PP
Reimplemented in QDataTable.
.SH "int QTable::numSelections () const"
Returns the number of selections. See the "numSelections" property for details.
.SH "void QTable::paintCell ( QPainter * p, int row, int col, const QRect & cr, bool selected, const QColorGroup & cg )\fC [virtual]\fR"
Paints the cell at \fIrow\fR, \fIcol\fR on the painter \fIp\fR. The painter has already been translated to the cell's origin. \fIcr\fR describes the cell coordinates in the content coordinate system.
.PP
If \fIselected\fR is TRUE the cell is highlighted.
.PP
\fIcg\fR is the colorgroup which should be used to draw the cell content.
.PP
If you want to draw custom cell content, for example right-aligned text, you must either reimplement paintCell(), or subclass QTableItem and reimplement QTableItem::paint() to do the custom drawing.
.PP
If you're using a QTableItem subclass, for example, to store a data structure, then reimplementing QTableItem::paint() may be the best approach. For data you want to draw immediately, e.g. data retrieved from a database, it is probably best to reimplement paintCell(). Note that if you reimplement paintCell(), i.e. don't use QTableItems, you must reimplement other functions: see the notes on large tables.
.PP
Note that the painter is not clipped by default in order to get maximum efficiency. If you want clipping, use code like this:
.PP
.nf
.br
    p->setClipRect( cellRect(row, col), QPainter::CoordPainter );
.br
    //... your drawing code
.br
    p->setClipping( FALSE );
.br
.fi
.SH "void QTable::paintCell ( QPainter * p, int row, int col, const QRect & cr, bool selected )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Use the other paintCell() function. This function is only included for backwards compatibilty.
.SH "void QTable::paintEmptyArea ( QPainter * p, int cx, int cy, int cw, int ch )\fC [virtual protected]\fR"
This function fills the \fIcw\fR pixels wide and \fIch\fR pixels high rectangle starting at position \fIcx\fR, \fIcy\fR with the background color using the painter \fIp\fR.
.PP
paintEmptyArea() is invoked by drawContents() to erase or fill unused areas.
.SH "void QTable::paintFocus ( QPainter * p, const QRect & cr )\fC [virtual]\fR"
Draws the focus rectangle of the current cell (see currentRow(), currentColumn()).
.PP
The painter \fIp\fR is already translated to the cell's origin, while \fIcr\fR specifies the cell's geometry in content coordinates.
.SH "QPixmap QTable::pixmap ( int row, int col ) const\fC [virtual]\fR"
Returns the pixmap set for the cell at \fIrow\fR, \fIcol\fR, or a null-pixmap if the cell contains no pixmap.
.PP
See also setPixmap().
.PP
Example: chart/setdataform.cpp.
.SH "void QTable::pressed ( int row, int col, int button, const QPoint & mousePos )\fC [signal]\fR"
This signal is emitted when mouse button \fIbutton\fR is pressed. The cell where the event took place is at \fIrow\fR, \fIcol\fR, and the mouse's position is in \fImousePos\fR.
.PP
See also Qt::ButtonState.
.SH "void QTable::removeColumn ( int col )\fC [virtual slot]\fR"
Removes column \fIcol\fR, and deletes all its cells including any table items and widgets the cells may contain. Also clears the selection(s).
.PP
See also removeColumns(), hideColumn(), insertColumns(), and removeRow().
.SH "void QTable::removeColumns ( const QMemArray<int> & cols )\fC [virtual slot]\fR"
Removes the columns listed in the array \fIcols\fR, and deletes all their cells including any table items and widgets the cells may contain.
.PP
The array passed in must only contain valid columns (in the range from 0 to numCols() - 1) with no duplicates, and must be sorted in ascending order. Also clears the selection(s).
.PP
See also removeColumn(), insertColumns(), and removeRows().
.SH "void QTable::removeRow ( int row )\fC [virtual slot]\fR"
Removes row \fIrow\fR, and deletes all its cells including any table items and widgets the cells may contain. Also clears the selection(s).
.PP
See also hideRow(), insertRows(), removeColumn(), and removeRows().
.SH "void QTable::removeRows ( const QMemArray<int> & rows )\fC [virtual slot]\fR"
Removes the rows listed in the array \fIrows\fR, and deletes all their cells including any table items and widgets the cells may contain.
.PP
The array passed in must only contain valid rows (in the range from 0 to numRows() - 1) with no duplicates, and must be sorted in ascending order. Also clears the selection(s).
.PP
See also removeRow(), insertRows(), and removeColumns().
.SH "void QTable::removeSelection ( const QTableSelection & s )\fC [virtual]\fR"
If the table has a selection, \fIs\fR, this selection is removed from the table.
.PP
See also addSelection() and numSelections.
.SH "void QTable::removeSelection ( int num )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes selection number \fInum\fR from the table.
.PP
See also numSelections, addSelection(), and clearSelection().
.SH "void QTable::repaintSelections ()"
Repaints all selections
.SH "void QTable::resizeData ( int len )\fC [virtual protected]\fR"
This is called when QTable's internal array needs to be resized to \fIlen\fR elements.
.PP
If you don't use QTableItems you should reimplement this as an empty method to avoid wasting memory. See the notes on large tables for further details.
.SH "int QTable::rowAt ( int y ) const\fC [virtual]\fR"
Returns the number of the row at position \fIy\fR. \fIy\fR must be given in content coordinates.
.PP
See also rowPos() and columnAt().
.SH "int QTable::rowHeight ( int row ) const\fC [virtual]\fR"
Returns the height of row \fIrow\fR.
.PP
See also setRowHeight() and columnWidth().
.PP
Example: table/small-table-demo/main.cpp.
.SH "void QTable::rowHeightChanged ( int row )\fC [virtual protected slot]\fR"
This function should be called whenever the row height of \fIrow\fR has been changed. It updates the geometry of any affected rows and repaints the table to reflect the changes it has made.
.SH "void QTable::rowIndexChanged ( int section, int fromIndex, int toIndex )\fC [virtual protected slot]\fR"
This function is called when the order of the rows is to be changed, i.e. the user moved the row header section \fIsection\fR from \fIfromIndex\fR to \fItoIndex\fR.
.PP
If you want to change the order programmatically, call swapRows() or swapColumns();
.PP
See also QHeader::indexChange() and columnIndexChanged().
.SH "bool QTable::rowMovingEnabled () const"
Returns TRUE if rows can be moved by the user; otherwise returns FALSE. See the "rowMovingEnabled" property for details.
.SH "int QTable::rowPos ( int row ) const\fC [virtual]\fR"
Returns the y-coordinate of the row \fIrow\fR in content coordinates.
.PP
See also rowAt() and columnPos().
.SH "void QTable::selectCells ( int start_row, int start_col, int end_row, int end_col )"
Selects the range starting at \fIstart_row\fR and \fIstart_col\fR and ending at \fIend_row\fR and \fIend_col\fR.
.PP
See also QTableSelection.
.SH "void QTable::selectColumn ( int col )"
Selects the column \fIcol\fR.
.PP
See also QTableSelection.
.SH "void QTable::selectRow ( int row )"
Selects the row \fIrow\fR.
.PP
See also QTableSelection.
.SH "QTableSelection QTable::selection ( int num ) const"
Returns selection number \fInum\fR, or an inactive QTableSelection if \fInum\fR is out of range (see QTableSelection::isActive()).
.SH "void QTable::selectionChanged ()\fC [signal]\fR"
This signal is emitted whenever a selection changes.
.PP
See also QTableSelection.
.SH "SelectionMode QTable::selectionMode () const"
Returns the current selection mode. See the "selectionMode" property for details.
.SH "void QTable::setCellContentFromEditor ( int row, int col )\fC [virtual protected]\fR"
This function is called to replace the contents of the cell at \fIrow\fR, \fIcol\fR with the contents of the cell's editor.
.PP
If there already exists a QTableItem for the cell, it calls QTableItem::setContentFromEditor() on this QTableItem.
.PP
If, for example, you want to create different QTableItems depending on the contents of the editor, you might reimplement this function.
.PP
If you want to work without QTableItems, you will need to reimplement this function to save the data the user entered into your data structure. (See the notes on large tables.)
.PP
See also QTableItem::setContentFromEditor() and createEditor().
.SH "void QTable::setCellWidget ( int row, int col, QWidget * e )\fC [virtual]\fR"
Sets the widget \fIe\fR to the cell at \fIrow\fR, \fIcol\fR and takes care of placing and resizing the widget when the cell geometry changes.
.PP
By default widgets are inserted into a vector with numRows() * numCols() elements. In very large tables you will probably want to store the widgets in a data structure that consumes less memory (see the notes on large tables). To support the use of your own data structure this function calls insertWidget() to add the widget to the internal data structure. To use your own data structure reimplement insertWidget(), cellWidget() and clearCellWidget().
.PP
Cell widgets are created dynamically with the \fCnew\fR operator. The cell widgets are destroyed automatically once the table is destroyed; the table takes ownership of the widget when using setCellWidget.
.PP
Example: chart/setdataform.cpp.
.SH "void QTable::setColumnLabels ( const QStringList & labels )\fC [slot]\fR"
Sets the section labels of the horizontalHeader() to \fIlabels\fR
.SH "void QTable::setColumnMovingEnabled ( bool b )\fC [virtual slot]\fR"
Sets whether columns can be moved by the user to \fIb\fR. See the "columnMovingEnabled" property for details.
.SH "void QTable::setColumnReadOnly ( int col, bool ro )\fC [virtual slot]\fR"
If \fIro\fR is TRUE, column \fIcol\fR is set to be read-only; otherwise the column is set to be editable.
.PP
Whether a cell in this column is editable or read-only depends on the cell's EditType, and this setting: see QTableItem::EditType.
.PP
See also isColumnReadOnly(), setRowReadOnly(), and readOnly.
.PP
Example: chart/setdataform.cpp.
.SH "void QTable::setColumnStretchable ( int col, bool stretch )\fC [virtual slot]\fR"
If \fIstretch\fR is TRUE, column \fIcol\fR is set to be stretchable; otherwise column \fIcol\fR is set to be unstretchable.
.PP
If the table widget's width decreases or increases stretchable columns will grow narrower or wider to fit the space available as completely as possible. The user cannot manually resize stretchable columns.
.PP
See also isColumnStretchable(), setRowStretchable(), and adjustColumn().
.SH "void QTable::setColumnWidth ( int col, int w )\fC [virtual slot]\fR"
Resizes column \fIcol\fR to be \fIw\fR pixels wide.
.PP
See also columnWidth() and setRowHeight().
.PP
Example: chart/setdataform.cpp.
.PP
Reimplemented in QDataTable.
.SH "void QTable::setCurrentCell ( int row, int col )\fC [virtual slot]\fR"
Moves the focus to the cell at \fIrow\fR, \fIcol\fR.
.PP
See also currentRow() and currentColumn().
.SH "void QTable::setDragEnabled ( bool b )\fC [virtual slot]\fR"
If \fIb\fR is TRUE, the table starts a drag (see dragObject()) when the user presses and moves the mouse on a selected cell.
.SH "void QTable::setEditMode ( EditMode mode, int row, int col )\fC [protected]\fR"
Sets the current edit mode to \fImode\fR, the current edit row to \fIrow\fR and the current edit column to \fIcol\fR.
.PP
See also EditMode.
.SH "void QTable::setFocusStyle ( FocusStyle fs )\fC [virtual]\fR"
Sets how the current (focus) cell is drawn to \fIfs\fR. See the "focusStyle" property for details.
.SH "void QTable::setItem ( int row, int col, QTableItem * item )\fC [virtual]\fR"
Inserts the table item \fIitem\fR into the table at row \fIrow\fR, column \fIcol\fR, and repaints the cell. If a table item already exists in this cell it is deleted and replaced with \fIitem\fR. The table takes ownership of the table item.
.PP
If you don't use QTableItems you may need to reimplement this function: see the notes on large tables.
.PP
See also item() and takeItem().
.PP
Examples:
.)l helpsystem/mainwindow.cpp and table/small-table-demo/main.cpp.
.SH "void QTable::setLeftMargin ( int m )\fC [virtual slot]\fR"
Sets the left margin to be \fIm\fR pixels wide.
.PP
The verticalHeader(), which displays row labels, occupies this margin.
.PP
In an Arabic or Hebrew localization, the verticalHeader() will appear on the right side of the table, and this call will set the right margin.
.PP
See also leftMargin(), setTopMargin(), and verticalHeader().
.PP
Example: regexptester/regexptester.cpp.
.SH "void QTable::setNumCols ( int r )\fC [virtual slot]\fR"
Sets the number of columns in the table to \fIr\fR. See the "numCols" property for details.
.SH "void QTable::setNumRows ( int r )\fC [virtual slot]\fR"
Sets the number of rows in the table to \fIr\fR. See the "numRows" property for details.
.SH "void QTable::setPixmap ( int row, int col, const QPixmap & pix )\fC [virtual]\fR"
Sets the pixmap in the cell at \fIrow\fR, \fIcol\fR to \fIpix\fR.
.PP
If the cell does not contain a table item a QTableItem is created with an EditType of \fCOnTyping\fR, otherwise the existing table item's pixmap (if any) is replaced with \fIpix\fR.
.PP
Note that QComboTableItems and QCheckTableItems don't show pixmaps.
.PP
See also pixmap(), setText(), setItem(), and QTableItem::setPixmap().
.PP
Examples:
.)l chart/setdataform.cpp and table/small-table-demo/main.cpp.
.SH "void QTable::setReadOnly ( bool b )\fC [virtual slot]\fR"
Sets whether the table is read-only to \fIb\fR. See the "readOnly" property for details.
.SH "void QTable::setRowHeight ( int row, int h )\fC [virtual slot]\fR"
Resizes row \fIrow\fR to be \fIh\fR pixels high.
.PP
See also rowHeight() and setColumnWidth().
.SH "void QTable::setRowLabels ( const QStringList & labels )\fC [slot]\fR"
Sets the section labels of the verticalHeader() to \fIlabels\fR
.SH "void QTable::setRowMovingEnabled ( bool b )\fC [virtual slot]\fR"
Sets whether rows can be moved by the user to \fIb\fR. See the "rowMovingEnabled" property for details.
.SH "void QTable::setRowReadOnly ( int row, bool ro )\fC [virtual slot]\fR"
If \fIro\fR is TRUE, row \fIrow\fR is set to be read-only; otherwise the row is set to be editable.
.PP
Whether a cell in this row is editable or read-only depends on the cell's EditType, and this setting: see QTableItem::EditType.
.PP
See also isRowReadOnly(), setColumnReadOnly(), and readOnly.
.SH "void QTable::setRowStretchable ( int row, bool stretch )\fC [virtual slot]\fR"
If \fIstretch\fR is TRUE, row \fIrow\fR is set to be stretchable; otherwise row \fIrow\fR is set to be unstretchable.
.PP
If the table widget's height decreases or increases stretchable rows will grow shorter or taller to fit the space available as completely as possible. The user cannot manually resize stretchable rows.
.PP
See also isRowStretchable() and setColumnStretchable().
.SH "void QTable::setSelectionMode ( SelectionMode mode )\fC [virtual]\fR"
Sets the current selection mode to \fImode\fR. See the "selectionMode" property for details.
.SH "void QTable::setShowGrid ( bool b )\fC [virtual slot]\fR"
Sets whether the table's grid is displayed to \fIb\fR. See the "showGrid" property for details.
.SH "void QTable::setSorting ( bool b )\fC [virtual slot]\fR"
Sets whether a click on the header of a column sorts that column to \fIb\fR. See the "sorting" property for details.
.SH "void QTable::setText ( int row, int col, const QString & text )\fC [virtual]\fR"
Sets the text in the cell at \fIrow\fR, \fIcol\fR to \fItext\fR.
.PP
If the cell does not contain a table item a QTableItem is created with an EditType of \fCOnTyping\fR, otherwise the existing table item's text (if any) is replaced with \fItext\fR.
.PP
See also text(), setPixmap(), setItem(), and QTableItem::setText().
.PP
Examples:
.)l chart/setdataform.cpp, helpsystem/mainwindow.cpp, regexptester/regexptester.cpp, and table/small-table-demo/main.cpp.
.SH "void QTable::setTopMargin ( int m )\fC [virtual slot]\fR"
Sets the top margin to be \fIm\fR pixels high.
.PP
The horizontalHeader(), which displays column labels, occupies this margin.
.PP
See also topMargin() and setLeftMargin().
.PP
Example: regexptester/regexptester.cpp.
.SH "void QTable::showColumn ( int col )\fC [virtual slot]\fR"
Shows column \fIcol\fR.
.PP
See also hideColumn() and showRow().
.SH "bool QTable::showGrid () const"
Returns TRUE if the table's grid is displayed; otherwise returns FALSE. See the "showGrid" property for details.
.SH "void QTable::showRow ( int row )\fC [virtual slot]\fR"
Shows row \fIrow\fR.
.PP
See also hideRow() and showColumn().
.SH "void QTable::sortColumn ( int col, bool ascending = TRUE, bool wholeRows = FALSE )\fC [virtual]\fR"
Sorts column \fIcol\fR. If \fIascending\fR is TRUE the sort is in ascending order, otherwise the sort is in descending order.
.PP
If \fIwholeRows\fR is TRUE, entire rows are sorted using swapRows(); otherwise only cells in the column are sorted using swapCells().
.PP
Note that if you are not using QTableItems you will need to reimplement swapRows() and swapCells(). (See the notes on large tables.)
.PP
See also swapRows().
.PP
Example: table/statistics/statistics.cpp.
.PP
Reimplemented in QDataTable.
.SH "bool QTable::sorting () const"
Returns TRUE if a click on the header of a column sorts that column; otherwise returns FALSE. See the "sorting" property for details.
.SH "void QTable::startDrag ()\fC [virtual protected]\fR"
Starts a drag.
.PP
Usually you don't need to call or reimplement this function yourself.
.PP
See also dragObject().
.SH "void QTable::swapCells ( int row1, int col1, int row2, int col2 )\fC [virtual slot]\fR"
Swaps the contents of the cell at \fIrow1\fR, \fIcol1\fR with the contents of the cell at \fIrow2\fR, \fIcol2\fR.
.PP
This function is also called when the table is sorted.
.PP
If you don't use QTableItems and want your users to be able to swap cells, you will need to reimplement this function. (See the notes on large tables.)
.PP
See also swapColumns() and swapRows().
.SH "void QTable::swapColumns ( int col1, int col2, bool swapHeader = FALSE )\fC [virtual slot]\fR"
Swaps the data in \fIcol1\fR with \fIcol2\fR.
.PP
This function is used to swap the positions of two columns. It is called when the user changes the order of columns (see setColumnMovingEnabled(), and when columns are sorted.
.PP
If you don't use QTableItems and want your users to be able to swap columns you will need to reimplement this function. (See the notes on large tables.)
.PP
If \fIswapHeader\fR is TRUE, the columns' header contents is also swapped.
.PP
See also swapCells().
.SH "void QTable::swapRows ( int row1, int row2, bool swapHeader = FALSE )\fC [virtual slot]\fR"
Swaps the data in \fIrow1\fR and \fIrow2\fR.
.PP
This function is used to swap the positions of two rows. It is called when the user changes the order of rows (see setRowMovingEnabled()), and when rows are sorted.
.PP
If you don't use QTableItems and want your users to be able to swap rows, e.g. for sorting, you will need to reimplement this function. (See the notes on large tables.)
.PP
If \fIswapHeader\fR is TRUE, the rows' header contents is also swapped.
.PP
This function will not update the QTable, you will have to do this manually, e.g. by calling updateContents().
.PP
See also swapColumns() and swapCells().
.SH "void QTable::takeItem ( QTableItem * i )\fC [virtual]\fR"
Takes the table item \fIi\fR out of the table. This function does \fInot\fR delete the table item. You must either delete the table item yourself or put it into a table (using setItem()) which will then take ownership of it.
.PP
Use this function if you want to move an item from one cell in a table to another, or to move an item from one table to another, reinserting the item with setItem().
.PP
If you want to exchange two cells use swapCells().
.SH "QString QTable::text ( int row, int col ) const\fC [virtual]\fR"
Returns the text in the cell at \fIrow\fR, \fIcol\fR, or QString::null if the relevant item does not exist or has no text.
.PP
See also setText() and setPixmap().
.PP
Example: chart/setdataform.cpp.
.PP
Reimplemented in QDataTable.
.SH "void QTable::updateCell ( int row, int col )"
Repaints the cell at \fIrow\fR, \fIcol\fR.
.SH "void QTable::updateHeaderStates ()"
This functions updates all the header states to be in sync with the current selections. This should be called after programatically changing, adding or removing selections, so that the headers are updated.
.SH "void QTable::valueChanged ( int row, int col )\fC [signal]\fR"
This signal is emitted when the user changed the value in the cell at \fIrow\fR, \fIcol\fR.
.PP
Example: chart/setdataform.cpp.
.SH "QHeader * QTable::verticalHeader () const"
Returns the table's vertical QHeader.
.PP
This header contains the row labels.
.PP
See also horizontalHeader(), setLeftMargin(), and QHeader.
.PP
Examples:
.)l helpsystem/mainwindow.cpp and regexptester/regexptester.cpp.
.SS "Property Documentation"
.SH "bool columnMovingEnabled"
This property holds whether columns can be moved by the user.
.PP
The default is FALSE. Columns are moved by dragging whilst holding down the Ctrl key.
.PP
\fBWarning:\fR If QTable is used to move header sections as a result of user interaction, the mapping between header indexes and section exposed by QHeader will not reflect the order of the headers in the table; i.e., QTable does not call QHeader::moveSection() to move sections but handles move operations internally.
.PP
See also rowMovingEnabled.
.PP
Set this property's value with setColumnMovingEnabled() and get this property's value with columnMovingEnabled().
.SH "FocusStyle focusStyle"
This property holds how the current (focus) cell is drawn.
.PP
The default style is SpreadSheet.
.PP
See also QTable::FocusStyle.
.PP
Set this property's value with setFocusStyle() and get this property's value with focusStyle().
.SH "int numCols"
This property holds the number of columns in the table.
.PP
Set this property's value with setNumCols() and get this property's value with numCols().
.PP
See also numRows.
.SH "int numRows"
This property holds the number of rows in the table.
.PP
Set this property's value with setNumRows() and get this property's value with numRows().
.PP
See also numCols.
.SH "int numSelections"
This property holds the number of selections.
.PP
Get this property's value with numSelections().
.PP
See also currentSelection().
.SH "bool readOnly"
This property holds whether the table is read-only.
.PP
Whether a cell in the table is editable or read-only depends on the cell's EditType, and this setting: see QTableItem::EditType.
.PP
See also QWidget::enabled, setColumnReadOnly(), and setRowReadOnly().
.PP
Set this property's value with setReadOnly() and get this property's value with isReadOnly().
.SH "bool rowMovingEnabled"
This property holds whether rows can be moved by the user.
.PP
The default is FALSE. Rows are moved by dragging whilst holding down the Ctrl key.
.PP
\fBWarning:\fR If QTable is used to move header sections as a result of user interaction, the mapping between header indexes and section exposed by QHeader will not reflect the order of the headers in the table; i.e., QTable does not call QHeader::moveSection() to move sections but handles move operations internally.
.PP
See also columnMovingEnabled.
.PP
Set this property's value with setRowMovingEnabled() and get this property's value with rowMovingEnabled().
.SH "SelectionMode selectionMode"
This property holds the current selection mode.
.PP
The default mode is Multi which allows the user to select multiple ranges of cells.
.PP
See also SelectionMode and selectionMode.
.PP
Set this property's value with setSelectionMode() and get this property's value with selectionMode().
.SH "bool showGrid"
This property holds whether the table's grid is displayed.
.PP
The grid is shown by default.
.PP
Set this property's value with setShowGrid() and get this property's value with showGrid().
.SH "bool sorting"
This property holds whether a click on the header of a column sorts that column.
.PP
Set this property's value with setSorting() and get this property's value with sorting().
.PP
See also sortColumn().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qtable.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qtable.3qt) and the Qt
version (3.3.8).
