'\" t
.TH QTextCodec 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QTextCodec \- Conversion between text encodings
.SH SYNOPSIS
Almost all the functions in this class are reentrant when Qt is built with thread support. The exceptions are \fB~QTextCodec\fR(), \fBsetCodecForTr\fR(), \fBsetCodecForCStrings\fR(), and \fBQTextCodec\fR(). </p>
.PP
\fC#include <qtextcodec.h>\fR
.PP
Inherited by QBig5Codec, QBig5hkscsCodec, QEucJpCodec, QEucKrCodec, QGb18030Codec, QJisCodec, QHebrewCodec, QSjisCodec, and QTsciiCodec.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "virtual \fB~QTextCodec\fR ()"
.br
.ti -1c
.BI "virtual const char * \fBname\fR () const = 0"
.br
.ti -1c
.BI "virtual const char * \fBmimeName\fR () const"
.br
.ti -1c
.BI "virtual int \fBmibEnum\fR () const = 0"
.br
.ti -1c
.BI "virtual QTextDecoder * \fBmakeDecoder\fR () const"
.br
.ti -1c
.BI "virtual QTextEncoder * \fBmakeEncoder\fR () const"
.br
.ti -1c
.BI "virtual QString \fBtoUnicode\fR ( const char * chars, int len ) const"
.br
.ti -1c
.BI "virtual QCString \fBfromUnicode\fR ( const QString & uc, int & lenInOut ) const"
.br
.ti -1c
.BI "QCString \fBfromUnicode\fR ( const QString & uc ) const"
.br
.ti -1c
.BI "QString \fBtoUnicode\fR ( const QByteArray & a, int len ) const"
.br
.ti -1c
.BI "QString \fBtoUnicode\fR ( const QByteArray & a ) const"
.br
.ti -1c
.BI "QString \fBtoUnicode\fR ( const QCString & a, int len ) const"
.br
.ti -1c
.BI "QString \fBtoUnicode\fR ( const QCString & a ) const"
.br
.ti -1c
.BI "QString \fBtoUnicode\fR ( const char * chars ) const"
.br
.ti -1c
.BI "virtual bool \fBcanEncode\fR ( QChar ch ) const"
.br
.ti -1c
.BI "virtual bool \fBcanEncode\fR ( const QString & s ) const"
.br
.ti -1c
.BI "virtual int \fBheuristicContentMatch\fR ( const char * chars, int len ) const = 0"
.br
.ti -1c
.BI "virtual int \fBheuristicNameMatch\fR ( const char * hint ) const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QTextCodec * \fBloadCharmap\fR ( QIODevice * iod )"
.br
.ti -1c
.BI "QTextCodec * \fBloadCharmapFile\fR ( QString filename )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForMib\fR ( int mib )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForName\fR ( const char * name, int accuracy = 0 )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForContent\fR ( const char * chars, int len )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForIndex\fR ( int i )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForLocale\fR ()"
.br
.ti -1c
.BI "void \fBsetCodecForLocale\fR ( QTextCodec * c )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForTr\fR ()"
.br
.ti -1c
.BI "void \fBsetCodecForTr\fR ( QTextCodec * c )"
.br
.ti -1c
.BI "QTextCodec * \fBcodecForCStrings\fR ()"
.br
.ti -1c
.BI "void \fBsetCodecForCStrings\fR ( QTextCodec * c )"
.br
.ti -1c
.BI "void \fBdeleteAllCodecs\fR ()"
.br
.ti -1c
.BI "const char * \fBlocale\fR ()"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "\fBQTextCodec\fR ()"
.br
.in -1c
.SS "Static Protected Members"
.in +1c
.ti -1c
.BI "int \fBsimpleHeuristicNameMatch\fR ( const char * name, const char * hint )"
.br
.in -1c
.SH DESCRIPTION
The QTextCodec class provides conversion between text encodings.
.PP
Qt uses Unicode to store, draw and manipulate strings. In many situations you may wish to deal with data that uses a different encoding. For example, most Japanese documents are still stored in Shift-JIS or ISO2022, while Russian users often have their documents in KOI8-R or CP1251.
.PP
Qt provides a set of QTextCodec classes to help with converting non-Unicode formats to and from Unicode. You can also create your own codec classes (see later).
.PP
The supported encodings are:
.TP
Latin1
.TP
Big5 -- Chinese
.TP
Big5-HKSCS -- Chinese
.TP
eucJP -- Japanese
.TP
eucKR -- Korean
.TP
GB2312 -- Chinese
.TP
GBK -- Chinese
.TP
GB18030 -- Chinese
.TP
JIS7 -- Japanese
.TP
Shift-JIS -- Japanese
.TP
TSCII -- Tamil
.TP
utf8 -- Unicode, 8-bit
.TP
utf16 -- Unicode
.TP
KOI8-R -- Russian
.TP
KOI8-U -- Ukrainian
.TP
ISO8859-1 -- Western
.TP
ISO8859-2 -- Central European
.TP
ISO8859-3 -- Central European
.TP
ISO8859-4 -- Baltic
.TP
ISO8859-5 -- Cyrillic
.TP
ISO8859-6 -- Arabic
.TP
ISO8859-7 -- Greek
.TP
ISO8859-8 -- Hebrew, visually ordered
.TP
ISO8859-8-i -- Hebrew, logically ordered
.TP
ISO8859-9 -- Turkish
.TP
ISO8859-10
.TP
ISO8859-13
.TP
ISO8859-14
.TP
ISO8859-15 -- Western
.TP
IBM 850
.TP
IBM 866
.TP
CP874
.TP
CP1250 -- Central European
.TP
CP1251 -- Cyrillic
.TP
CP1252 -- Western
.TP
CP1253 -- Greek
.TP
CP1254 -- Turkish
.TP
CP1255 -- Hebrew
.TP
CP1256 -- Arabic
.TP
CP1257 -- Baltic
.TP
CP1258
.TP
Apple Roman
.TP
TIS-620 -- Thai
.PP
QTextCodecs can be used as follows to convert some locally encoded string to Unicode. Suppose you have some string encoded in Russian KOI8-R encoding, and want to convert it to Unicode. The simple way to do this is:
.PP
.nf
.br
    QCString locallyEncoded = "..."; // text to convert
.br
    QTextCodec *codec = QTextCodec::codecForName("KOI8-R"); // get the codec for KOI8-R
.br
    QString unicodeString = codec->toUnicode( locallyEncoded );
.br
.fi
.PP
After this, \fCunicodeString\fR holds the text converted to Unicode. Converting a string from Unicode to the local encoding is just as easy:
.PP
.nf
.br
    QString unicodeString = "..."; // any Unicode text
.br
    QTextCodec *codec = QTextCodec::codecForName("KOI8-R"); // get the codec for KOI8-R
.br
    QCString locallyEncoded = codec->fromUnicode( unicodeString );
.br
.fi
.PP
Some care must be taken when trying to convert the data in chunks, for example, when receiving it over a network. In such cases it is possible that a multi-byte character will be split over two chunks. At best this might result in the loss of a character and at worst cause the entire conversion to fail.
.PP
The approach to use in these situations is to create a QTextDecoder object for the codec and use this QTextDecoder for the whole decoding process, as shown below:
.PP
.nf
.br
    QTextCodec *codec = QTextCodec::codecForName( "Shift-JIS" );
.br
    QTextDecoder *decoder = codec->makeDecoder();
.br
.br
    QString unicodeString;
.br
    while( receiving_data ) {
.br
        QByteArray chunk = new_data;
.br
        unicodeString += decoder->toUnicode( chunk.data(), chunk.length() );
.br
    }
.br
.fi
.PP
The QTextDecoder object maintains state between chunks and therefore works correctly even if a multi-byte character is split between chunks.
.SH "Creating your own Codec class"
Support for new text encodings can be added to Qt by creating QTextCodec subclasses.
.PP
Built-in codecs can be overridden by custom codecs since more recently created QTextCodec objects take precedence over earlier ones.
.PP
You may find it more convenient to make your codec class available as a plugin; see the plugin documentation for more details.
.PP
The abstract virtual functions describe the encoder to the system and the coder is used as required in the different text file formats supported by QTextStream, and under X11, for the locale-specific character input and output.
.PP
To add support for another 8-bit encoding to Qt, make a subclass of QTextCodec and implement at least the following methods:
.PP
.nf
.br
    const char* name() const
.br
.fi
Return the official name for the encoding.
.PP
.nf
.br
    int mibEnum() const
.br
.fi
Return the MIB enum for the encoding if it is listed in the IANA character-sets encoding file.
.PP
If the encoding is multi-byte then it will have "state"; that is, the interpretation of some bytes will be dependent on some preceding bytes. For such encodings, you must implement:
.PP
.nf
.br
    QTextDecoder* makeDecoder() const
.br
.fi
Return a QTextDecoder that remembers incomplete multi-byte sequence prefixes or other required state.
.PP
If the encoding does \fInot\fR require state, you should implement:
.PP
.nf
.br
    QString toUnicode(const char* chars, int len) const
.br
.fi
Converts \fIlen\fR characters from \fIchars\fR to Unicode.
.PP
The base QTextCodec class has default implementations of the above two functions, \fIbut they are mutually recursive\fR, so you must re-implement at least one of them, or both for improved efficiency.
.PP
For conversion from Unicode to 8-bit encodings, it is rarely necessary to maintain state. However, two functions similar to the two above are used for encoding:
.PP
.nf
.br
    QTextEncoder* makeEncoder() const
.br
.fi
Return a QTextEncoder.
.PP
.nf
.br
    QCString fromUnicode(const QString& uc, int& lenInOut ) const
.br
.fi
Converts \fIlenInOut\fR characters (of type QChar) from the start of the string \fIuc\fR, returning a QCString result, and also returning the length of the result in \fIlenInOut\fR.
.PP
Again, these are mutually recursive so only one needs to be implemented, or both if greater efficiency is possible.
.PP
Finally, you must implement:
.PP
.nf
.br
    int heuristicContentMatch(const char* chars, int len) const
.br
.fi
Gives a value indicating how likely it is that \fIlen\fR characters from \fIchars\fR are in the encoding.
.PP
A good model for this function is the QWindowsLocalCodec::heuristicContentMatch function found in the Qt sources.
.PP
A QTextCodec subclass might have improved performance if you also re-implement:
.PP
.nf
.br
    bool canEncode( QChar ) const
.br
.fi
Test if a Unicode character can be encoded.
.PP
.nf
.br
    bool canEncode( const QString& ) const
.br
.fi
Test if a string of Unicode characters can be encoded.
.PP
.nf
.br
    int heuristicNameMatch(const char* hint) const
.br
.fi
Test if a possibly non-standard name is referring to the codec.
.PP
Codecs can also be created as plugins.
.PP
See also Internationalization with Qt.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QTextCodec::QTextCodec ()\fC [protected]\fR"
\fBWarning:\fR This function is \fInot\fR reentrant.</p>
.PP
Constructs a QTextCodec, and gives it the highest precedence. The QTextCodec should always be constructed on the heap (i.e. with \fCnew\fR). Qt takes ownership and will delete it when the application terminates.
.SH "QTextCodec::~QTextCodec ()\fC [virtual]\fR"
\fBWarning:\fR This function is \fInot\fR reentrant.</p>
.PP
Destroys the QTextCodec. Note that you should not delete codecs yourself: once created they become Qt's responsibility.
.SH "bool QTextCodec::canEncode ( QChar ch ) const\fC [virtual]\fR"
Returns TRUE if the Unicode character \fIch\fR can be fully encoded with this codec; otherwise returns FALSE. The default implementation tests if the result of toUnicode(fromUnicode(ch)) is the original \fIch\fR. Subclasses may be able to improve the efficiency.
.SH "bool QTextCodec::canEncode ( const QString & s ) const\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIs\fR contains the string being tested for encode-ability.
.SH "QTextCodec * QTextCodec::codecForCStrings ()\fC [static]\fR"
Returns the codec used by QString to convert to and from const char* and QCStrings. If this function returns 0 (the default), QString assumes Latin-1.
.PP
See also setCodecForCStrings().
.SH "QTextCodec * QTextCodec::codecForContent ( const char * chars, int len )\fC [static]\fR"
Searches all installed QTextCodec objects, returning the one which most recognizes the given content. May return 0.
.PP
Note that this is often a poor choice, since character encodings often use most of the available character sequences, and so only by linguistic analysis could a true match be made.
.PP
\fIchars\fR contains the string to check, and \fIlen\fR contains the number of characters in the string to use.
.PP
See also heuristicContentMatch().
.PP
Example: qwerty/qwerty.cpp.
.SH "QTextCodec * QTextCodec::codecForIndex ( int i )\fC [static]\fR"
Returns the QTextCodec \fIi\fR positions from the most recently inserted codec, or 0 if there is no such QTextCodec. Thus, codecForIndex(0) returns the most recently created QTextCodec.
.PP
Example: qwerty/qwerty.cpp.
.SH "QTextCodec * QTextCodec::codecForLocale ()\fC [static]\fR"
Returns a pointer to the codec most suitable for this locale.
.PP
Example: qwerty/qwerty.cpp.
.SH "QTextCodec * QTextCodec::codecForMib ( int mib )\fC [static]\fR"
Returns the QTextCodec which matches the MIBenum \fImib\fR.
.SH "QTextCodec * QTextCodec::codecForName ( const char * name, int accuracy = 0 )\fC [static]\fR"
Searches all installed QTextCodec objects and returns the one which best matches \fIname\fR; the match is case-insensitive. Returns 0 if no codec's heuristicNameMatch() reports a match better than \fIaccuracy\fR, or if \fIname\fR is a null string.
.PP
See also heuristicNameMatch().
.SH "QTextCodec * QTextCodec::codecForTr ()\fC [static]\fR"
Returns the codec used by QObject::tr() on its argument. If this function returns 0 (the default), tr() assumes Latin-1.
.PP
See also setCodecForTr().
.SH "void QTextCodec::deleteAllCodecs ()\fC [static]\fR"
Deletes all the created codecs.
.PP
\fBWarning:\fR Do not call this function.
.PP
QApplication calls this function just before exiting to delete any QTextCodec objects that may be lying around. Since various other classes hold pointers to QTextCodec objects, it is not safe to call this function earlier.
.PP
If you are using the utility classes (like QString) but not using QApplication, calling this function at the very end of your application may be helpful for chasing down memory leaks by eliminating any QTextCodec objects.
.SH "QCString QTextCodec::fromUnicode ( const QString & uc, int & lenInOut ) const\fC [virtual]\fR"
QTextCodec subclasses must reimplement either this function or makeEncoder(). It converts the first \fIlenInOut\fR characters of \fIuc\fR from Unicode to the encoding of the subclass. If \fIlenInOut\fR is negative or too large, the length of \fIuc\fR is used instead.
.PP
Converts \fIlenInOut\fR characters (not bytes) from \fIuc\fR, producing a QCString. \fIlenInOut\fR will be set to the length of the result (in bytes).
.PP
The default implementation makes an encoder with makeEncoder() and converts the input with that. Note that the default makeEncoder() implementation makes an encoder that simply calls this function, hence subclasses \fImust\fR reimplement one function or the other to avoid infinite recursion.
.PP
Reimplemented in QHebrewCodec.
.SH "QCString QTextCodec::fromUnicode ( const QString & uc ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIuc\fR is the unicode source string.
.SH "int QTextCodec::heuristicContentMatch ( const char * chars, int len ) const\fC [pure virtual]\fR"
QTextCodec subclasses must reimplement this function. It examines the first \fIlen\fR bytes of \fIchars\fR and returns a value indicating how likely it is that the string is a prefix of text encoded in the encoding of the subclass. A negative return value indicates that the text is detectably not in the encoding (e.g. it contains characters undefined in the encoding). A return value of 0 indicates that the text should be decoded with this codec rather than as ASCII, but there is no particular evidence. The value should range up to \fIlen\fR. Thus, most decoders will return -1, 0, or -\fIlen\fR.
.PP
The characters are not null terminated.
.PP
See also codecForContent().
.SH "int QTextCodec::heuristicNameMatch ( const char * hint ) const\fC [virtual]\fR"
Returns a value indicating how likely it is that this decoder is appropriate for decoding some format that has the given name. The name is compared with the \fIhint\fR.
.PP
A good match returns a positive number around the length of the string. A bad match is negative.
.PP
The default implementation calls simpleHeuristicNameMatch() with the name of the codec.
.SH "QTextCodec * QTextCodec::loadCharmap ( QIODevice * iod )\fC [static]\fR"
Reads a POSIX2 charmap definition from \fIiod\fR. The parser recognizes the following lines:
.PP
<font name="sans"> <code_set_name> \fIname\fR</br> <escape_char> \fIcharacter\fR</br> % alias \fIalias\fR</br> CHARMAP</br> <\fItoken\fR> /x\fIhexbyte\fR <U\fIunicode\fR> ...</br> <\fItoken\fR> /d\fIdecbyte\fR <U\fIunicode\fR> ...</br> <\fItoken\fR> /\fIoctbyte\fR <U\fIunicode\fR> ...</br> <\fItoken\fR> /\fIany\fR/\fIany\fR... <U\fIunicode\fR> ...</br> END CHARMAP</br> </font>
.PP
The resulting QTextCodec is returned (and also added to the global list of codecs). The name() of the result is taken from the code_set_name.
.PP
Note that a codec constructed in this way uses much more memory and is slower than a hand-written QTextCodec subclass, since tables in code are kept in memory shared by all Qt applications.
.PP
See also loadCharmapFile().
.PP
Example: qwerty/qwerty.cpp.
.SH "QTextCodec * QTextCodec::loadCharmapFile ( QString filename )\fC [static]\fR"
A convenience function for loadCharmap() that loads the charmap definition from the file \fIfilename\fR.
.SH "const char * QTextCodec::locale ()\fC [static]\fR"
Returns a string representing the current language and sublanguage, e.g. "pt" for Portuguese, or "pt_br" for Portuguese/Brazil.
.PP
Example: i18n/main.cpp.
.SH "QTextDecoder * QTextCodec::makeDecoder () const\fC [virtual]\fR"
Creates a QTextDecoder which stores enough state to decode chunks of char* data to create chunks of Unicode data. The default implementation creates a stateless decoder, which is only sufficient for the simplest encodings where each byte corresponds to exactly one Unicode character.
.PP
The caller is responsible for deleting the returned object.
.SH "QTextEncoder * QTextCodec::makeEncoder () const\fC [virtual]\fR"
Creates a QTextEncoder which stores enough state to encode chunks of Unicode data as char* data. The default implementation creates a stateless encoder, which is only sufficient for the simplest encodings where each Unicode character corresponds to exactly one character.
.PP
The caller is responsible for deleting the returned object.
.SH "int QTextCodec::mibEnum () const\fC [pure virtual]\fR"
Subclasses of QTextCodec must reimplement this function. It returns the MIBenum (see the IANA character-sets encoding file for more information). It is important that each QTextCodec subclass returns the correct unique value for this function.
.PP
Reimplemented in QEucJpCodec.
.SH "const char * QTextCodec::mimeName () const\fC [virtual]\fR"
Returns the preferred mime name of the encoding as defined in the IANA character-sets encoding file.
.PP
Reimplemented in QEucJpCodec, QEucKrCodec, QJisCodec, QHebrewCodec, and QSjisCodec.
.SH "const char * QTextCodec::name () const\fC [pure virtual]\fR"
QTextCodec subclasses must reimplement this function. It returns the name of the encoding supported by the subclass. When choosing a name for an encoding, consider these points:
.TP
On X11, heuristicNameMatch( const char * hint ) is used to test if a the QTextCodec can convert between Unicode and the encoding of a font with encoding \fIhint\fR, such as "iso8859-1" for Latin-1 fonts," koi8-r" for Russian KOI8 fonts. The default algorithm of heuristicNameMatch() uses name().
.TP
Some applications may use this function to present encodings to the end user.
.PP
Example: qwerty/qwerty.cpp.
.SH "void QTextCodec::setCodecForCStrings ( QTextCodec * c )\fC [static]\fR"
\fBWarning:\fR This function is \fInot\fR reentrant.</p>
.PP
Sets the codec used by QString to convert to and from const char* and QCStrings. If \fIc\fR is 0 (the default), QString assumes Latin-1.
.PP
\fBWarning:\fR Some codecs do not preserve the characters in the ascii range (0x00 to 0x7f). For example, the Japanese Shift-JIS encoding maps the backslash character (0x5a) to the Yen character. This leads to unexpected results when using the backslash character to escape characters in strings used in e.g. regular expressions. Use QString::fromLatin1() to preserve characters in the ascii range when needed.
.PP
See also codecForCStrings() and setCodecForTr().
.SH "void QTextCodec::setCodecForLocale ( QTextCodec * c )\fC [static]\fR"
Set the codec to \fIc\fR; this will be returned by codecForLocale(). This might be needed for some applications that want to use their own mechanism for setting the locale.
.PP
See also codecForLocale().
.SH "void QTextCodec::setCodecForTr ( QTextCodec * c )\fC [static]\fR"
\fBWarning:\fR This function is \fInot\fR reentrant.</p>
.PP
Sets the codec used by QObject::tr() on its argument to \fIc\fR. If \fIc\fR is 0 (the default), tr() assumes Latin-1.
.PP
If the literal quoted text in the program is not in the Latin-1 encoding, this function can be used to set the appropriate encoding. For example, software developed by Korean programmers might use eucKR for all the text in the program, in which case the main() function might look like this:
.PP
.nf
.br
    int main(int argc, char** argv)
.br
    {
.br
        QApplication app(argc, argv);
.br
        ... install any additional codecs ...
.br
        QTextCodec::setCodecForTr( QTextCodec::codecForName("eucKR") );
.br
        ...
.br
    }
.br
.fi
.PP
Note that this is not the way to select the encoding that the \fIuser\fR has chosen. For example, to convert an application containing literal English strings to Korean, all that is needed is for the English strings to be passed through tr() and for translation files to be loaded. For details of internationalization, see the Qt internationalization documentation.
.PP
See also codecForTr() and setCodecForCStrings().
.SH "int QTextCodec::simpleHeuristicNameMatch ( const char * name, const char * hint )\fC [static protected]\fR"
A simple utility function for heuristicNameMatch(): it does some very minor character-skipping so that almost-exact matches score high. \fIname\fR is the text we're matching and \fIhint\fR is used for the comparison.
.SH "QString QTextCodec::toUnicode ( const char * chars, int len ) const\fC [virtual]\fR"
QTextCodec subclasses must reimplement this function or makeDecoder(). It converts the first \fIlen\fR characters of \fIchars\fR to Unicode.
.PP
The default implementation makes a decoder with makeDecoder() and converts the input with that. Note that the default makeDecoder() implementation makes a decoder that simply calls this function, hence subclasses \fImust\fR reimplement one function or the other to avoid infinite recursion.
.SH "QString QTextCodec::toUnicode ( const QByteArray & a, int len ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR contains the source characters; \fIlen\fR contains the number of characters in \fIa\fR to use.
.SH "QString QTextCodec::toUnicode ( const QByteArray & a ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR contains the source characters.
.SH "QString QTextCodec::toUnicode ( const QCString & a, int len ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR contains the source characters; \fIlen\fR contains the number of characters in \fIa\fR to use.
.SH "QString QTextCodec::toUnicode ( const QCString & a ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIa\fR contains the source characters.
.SH "QString QTextCodec::toUnicode ( const char * chars ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
\fIchars\fR contains the source characters.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qtextcodec.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qtextcodec.3qt) and the Qt
version (3.3.8).
