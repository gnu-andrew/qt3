'\" t
.TH QPtrList 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QPtrList \- Template class that provides a list
.SH SYNOPSIS
\fC#include <qptrlist.h>\fR
.PP
Inherits QPtrCollection.
.PP
Inherited by QObjectList, QSortedList, and QStrList.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQPtrList\fR ()"
.br
.ti -1c
.BI "\fBQPtrList\fR ( const QPtrList<type> & list )"
.br
.ti -1c
.BI "\fB~QPtrList\fR ()"
.br
.ti -1c
.BI "QPtrList<type> & \fBoperator=\fR ( const QPtrList<type> & list )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QPtrList<type> & list ) const"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QPtrList<type> & list ) const"
.br
.ti -1c
.BI "virtual uint \fBcount\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "bool \fBinsert\fR ( uint index, const type * item )"
.br
.ti -1c
.BI "void \fBinSort\fR ( const type * item )"
.br
.ti -1c
.BI "void \fBprepend\fR ( const type * item )"
.br
.ti -1c
.BI "void \fBappend\fR ( const type * item )"
.br
.ti -1c
.BI "bool \fBremove\fR ( uint index )"
.br
.ti -1c
.BI "bool \fBremove\fR ()"
.br
.ti -1c
.BI "bool \fBremove\fR ( const type * item )"
.br
.ti -1c
.BI "bool \fBremoveRef\fR ( const type * item )"
.br
.ti -1c
.BI "void \fBremoveNode\fR ( QLNode * node )"
.br
.ti -1c
.BI "bool \fBremoveFirst\fR ()"
.br
.ti -1c
.BI "bool \fBremoveLast\fR ()"
.br
.ti -1c
.BI "type * \fBtake\fR ( uint index )"
.br
.ti -1c
.BI "type * \fBtake\fR ()"
.br
.ti -1c
.BI "type * \fBtakeNode\fR ( QLNode * node )"
.br
.ti -1c
.BI "virtual void \fBclear\fR ()"
.br
.ti -1c
.BI "void \fBsort\fR ()"
.br
.ti -1c
.BI "int \fBfind\fR ( const type * item )"
.br
.ti -1c
.BI "int \fBfindNext\fR ( const type * item )"
.br
.ti -1c
.BI "int \fBfindRef\fR ( const type * item )"
.br
.ti -1c
.BI "int \fBfindNextRef\fR ( const type * item )"
.br
.ti -1c
.BI "uint \fBcontains\fR ( const type * item ) const"
.br
.ti -1c
.BI "uint \fBcontainsRef\fR ( const type * item ) const"
.br
.ti -1c
.BI "bool \fBreplace\fR ( uint index, const type * item )"
.br
.ti -1c
.BI "type * \fBat\fR ( uint index )"
.br
.ti -1c
.BI "int \fBat\fR () const"
.br
.ti -1c
.BI "type * \fBcurrent\fR () const"
.br
.ti -1c
.BI "QLNode * \fBcurrentNode\fR () const"
.br
.ti -1c
.BI "type * \fBgetFirst\fR () const"
.br
.ti -1c
.BI "type * \fBgetLast\fR () const"
.br
.ti -1c
.BI "type * \fBfirst\fR ()"
.br
.ti -1c
.BI "type * \fBlast\fR ()"
.br
.ti -1c
.BI "type * \fBnext\fR ()"
.br
.ti -1c
.BI "type * \fBprev\fR ()"
.br
.ti -1c
.BI "void \fBtoVector\fR ( QGVector * vec ) const"
.br
.in -1c
.SS "Important Inherited Members"
.in +1c
.ti -1c
.BI "bool \fBautoDelete\fR () const"
.br
.ti -1c
.BI "void \fBsetAutoDelete\fR ( bool enable )"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual int \fBcompareItems\fR ( QPtrCollection::Item item1, QPtrCollection::Item item2 )"
.br
.ti -1c
.BI "virtual QDataStream & \fBread\fR ( QDataStream & s, QPtrCollection::Item & item )"
.br
.ti -1c
.BI "virtual QDataStream & \fBwrite\fR ( QDataStream & s, QPtrCollection::Item item ) const"
.br
.in -1c
.SH DESCRIPTION
The QPtrList class is a template class that provides a list.
.PP
QValueList is an STL-compatible alternative to this class.
.PP
Define a template instance QPtrList<X> to create a list that operates on pointers to X (X*).
.PP
The list class is indexable and has a current index and a current item. The first item corresponds to index position 0. The current index is -1 if the current item is 0.
.PP
Items are inserted with prepend(), insert() or append(). Items are removed with remove(), removeRef(), removeFirst() and removeLast(). You can search for an item using find(), findNext(), findRef() or findNextRef(). The list can be sorted with sort(). You can count the number of occurrences of an item with contains() or containsRef(). You can get a pointer to the current item with current(), to an item at a particular index position in the list with at() or to the first or last item with getFirst() and getLast(). You can also iterate over the list with first(), last(), next() and prev() (which all update current()). The list's deletion property is set with setAutoDelete().
.PP
Example:
.PP
.nf
.br
    class Employee
.br
    {
.br
    public:
.br
        Employee() : sn( 0 ) { }
.br
        Employee( const QString& forename, const QString& surname, int salary )
.br
            : fn( forename ), sn( surname ), sal( salary )
.br
        { }
.br
.br
        void setSalary( int salary ) { sal = salary; }
.br
.br
        QString forename() const { return fn; }
.br
        QString surname() const { return sn; }
.br
        int salary() const { return sal; }
.br
.br
    private:
.br
        QString fn;
.br
        QString sn;
.br
        int sal;
.br
    };
.br
.br
    QPtrList<Employee> list;
.br
    list.setAutoDelete( TRUE ); // the list owns the objects
.br
.br
    list.append( new Employee("John", "Doe", 50000) );
.br
    list.append( new Employee("Jane", "Williams", 80000) );
.br
    list.append( new Employee("Tom", "Jones", 60000) );
.br
.br
    Employee *employee;
.br
    for ( employee = list.first(); employee; employee = list.next() )
.br
        cout << employee->surname().latin1() << ", " <<
.br
                employee->forename().latin1() << " earns " <<
.br
                employee->salary() << endl;
.br
    cout << endl;
.br
.br
    // very inefficient for big lists
.br
    for ( uint i = 0; i < list.count(); ++i )
.br
        if ( list.at(i) )
.br
            cout << list.at( i )->surname().latin1() << endl;
.br
.fi
.PP
The output is
.PP
.nf
.br
    Doe, John earns 50000
.br
    Williams, Jane earns 80000
.br
    Jones, Tom earns 60000
.br
.br
    Doe
.br
    Williams
.br
    Jones
.br
.fi
.PP
QPtrList has several member functions for traversing the list, but using a QPtrListIterator can be more practical. Multiple list iterators may traverse the same list, independently of each other and of the current list item.
.PP
In the example above we make the call setAutoDelete(TRUE). Enabling auto-deletion tells the list to delete items that are removed. The default is to not delete items when they are removed but this would cause a memory leak in the example because there are no other references to the list items.
.PP
When inserting an item into a list only the pointer is copied, not the item itself, i.e. a shallow copy. It is possible to make the list copy all of the item's data (deep copy) when an item is inserted. insert(), inSort() and append() call the virtual function QPtrCollection::newItem() for the item to be inserted. Inherit a list and reimplement newItem() to have deep copies.
.PP
When removing an item from a list, the virtual function QPtrCollection::deleteItem() is called. QPtrList's default implementation is to delete the item if auto-deletion is enabled.
.PP
The virtual function compareItems() can be reimplemented to compare two list items. This function is called from all list functions that need to compare list items, for instance remove(const type*). If you only want to deal with pointers, there are functions that compare pointers instead, for instance removeRef(const type*). These functions are somewhat faster than those that call compareItems().
.PP
List items are stored as \fCvoid*\fR in an internal QLNode, which also holds pointers to the next and previous list items. The functions currentNode(), removeNode(), and takeNode() operate directly on the QLNode, but they should be used with care. The data component of the node is available through QLNode::getData().
.PP
The QStrList class defined in qstrlist.h is a list of \fCchar*\fR. It reimplements newItem(), deleteItem() and compareItems(). (But see QStringList for a list of Unicode QStrings.)
.PP
See also QPtrListIterator, Collection Classes, and Non-GUI Classes.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QPtrList::QPtrList ()"
Constructs an empty list.
.SH "QPtrList::QPtrList ( const QPtrList<type> & list )"
Constructs a copy of \fIlist\fR.
.PP
Each item in \fIlist\fR is appended to this list. Only the pointers are copied (shallow copy).
.SH "QPtrList::~QPtrList ()"
Removes all items from the list and destroys the list.
.PP
All list iterators that access this list will be reset.
.PP
See also setAutoDelete().
.SH "void QPtrList::append ( const type * item )"
Inserts the \fIitem\fR at the end of the list.
.PP
The inserted item becomes the current list item. This is equivalent to \fCinsert( count(), item )\fR.
.PP
\fIitem\fR must not be 0.
.PP
See also insert(), current(), and prepend().
.PP
Examples:
.)l customlayout/border.cpp, customlayout/card.cpp, customlayout/flow.cpp, grapher/grapher.cpp, listviews/listviews.cpp, listviews/listviews.h, and qwerty/qwerty.cpp.
.SH "type * QPtrList::at ( uint index )"
Returns a pointer to the item at position \fIindex\fR in the list, or 0 if the index is out of range.
.PP
Sets the current list item to this item if \fIindex\fR is valid. The valid range is \fC0..(count() - 1)\fR inclusive.
.PP
This function is very efficient. It starts scanning from the first item, last item, or current item, whichever is closest to \fIindex\fR.
.PP
See also current().
.PP
Examples:
.)l customlayout/border.cpp, customlayout/card.cpp, customlayout/flow.cpp, dirview/dirview.cpp, mdi/application.cpp, and qwerty/qwerty.cpp.
.SH "int QPtrList::at () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the index of the current list item. The returned value is -1 if the current item is 0.
.PP
See also current().
.SH "bool QPtrCollection::autoDelete () const"
Returns the setting of the auto-delete option. The default is FALSE.
.PP
See also setAutoDelete().
.SH "void QPtrList::clear ()\fC [virtual]\fR"
Removes all items from the list.
.PP
The removed items are deleted if auto-deletion is enabled.
.PP
All list iterators that access this list will be reset.
.PP
See also remove(), take(), and setAutoDelete().
.PP
Reimplemented from QPtrCollection.
.SH "int QPtrList::compareItems ( QPtrCollection::Item item1, QPtrCollection::Item item2 )\fC [virtual protected]\fR"
This virtual function compares two list items.
.PP
Returns:
.TP
zero if \fIitem1\fR == \fIitem2\fR
.TP
nonzero if \fIitem1\fR != \fIitem2\fR
.PP
This function returns \fIint\fR rather than \fIbool\fR so that reimplementations can return three values and use it to sort by:
.TP
0 if \fIitem1\fR == \fIitem2\fR
.TP
> 0 (positive integer) if \fIitem1\fR > \fIitem2\fR
.TP
< 0 (negative integer) if \fIitem1\fR < \fIitem2\fR
.PP
inSort() requires that compareItems() is implemented as described here.
.PP
This function should not modify the list because some const functions call compareItems().
.PP
The default implementation compares the pointers.
.SH "uint QPtrList::contains ( const type * item ) const"
Returns the number of occurrences of \fIitem\fR in the list.
.PP
The compareItems() function is called when looking for the \fIitem\fR in the list. If compareItems() is not reimplemented, it is more efficient to call containsRef().
.PP
This function does not affect the current list item.
.PP
See also containsRef() and compareItems().
.SH "uint QPtrList::containsRef ( const type * item ) const"
Returns the number of occurrences of \fIitem\fR in the list.
.PP
Calling this function is much faster than contains() because contains() compares \fIitem\fR with each list item using compareItems(), whereas his function only compares the pointers.
.PP
This function does not affect the current list item.
.PP
See also contains().
.SH "uint QPtrList::count () const\fC [virtual]\fR"
Returns the number of items in the list.
.PP
See also isEmpty().
.PP
Examples:
.)l customlayout/border.cpp, customlayout/card.cpp, customlayout/flow.cpp, dirview/dirview.cpp, grapher/grapher.cpp, mdi/application.cpp, and qwerty/qwerty.cpp.
.PP
Reimplemented from QPtrCollection.
.SH "type * QPtrList::current () const"
Returns a pointer to the current list item. The current item may be 0 (implies that the current index is -1).
.PP
See also at().
.SH "QLNode * QPtrList::currentNode () const"
Returns a pointer to the current list node.
.PP
The node can be kept and removed later using removeNode(). The advantage is that the item can be removed directly without searching the list.
.PP
\fBWarning:\fR Do not call this function unless you are an expert.
.PP
See also removeNode(), takeNode(), and current().
.SH "int QPtrList::find ( const type * item )"
Finds the first occurrence of \fIitem\fR in the list.
.PP
If the item is found, the list sets the current item to point to the found item and returns the index of this item. If the item is not found, the list sets the current item to 0, the current index to -1, and returns -1.
.PP
The compareItems() function is called when searching for the item in the list. If compareItems() is not reimplemented, it is more efficient to call findRef().
.PP
See also findNext(), findRef(), compareItems(), and current().
.SH "int QPtrList::findNext ( const type * item )"
Finds the next occurrence of \fIitem\fR in the list, starting from the current list item.
.PP
If the item is found, the list sets the current item to point to the found item and returns the index of this item. If the item is not found, the list sets the current item to 0, the current index to -1, and returns -1.
.PP
The compareItems() function is called when searching for the item in the list. If compareItems() is not reimplemented, it is more efficient to call findNextRef().
.PP
See also find(), findNextRef(), compareItems(), and current().
.SH "int QPtrList::findNextRef ( const type * item )"
Finds the next occurrence of \fIitem\fR in the list, starting from the current list item.
.PP
If the item is found, the list sets the current item to point to the found item and returns the index of this item. If the item is not found, the list sets the current item to 0, the current index to -1, and returns -1.
.PP
Calling this function is much faster than findNext() because findNext() compares \fIitem\fR with each list item using compareItems(), whereas this function only compares the pointers.
.PP
See also findRef(), findNext(), and current().
.SH "int QPtrList::findRef ( const type * item )"
Finds the first occurrence of \fIitem\fR in the list.
.PP
If the item is found, the list sets the current item to point to the found item and returns the index of this item. If the item is not found, the list sets the current item to 0, the current index to -1, and returns -1.
.PP
Calling this function is much faster than find() because find() compares \fIitem\fR with each list item using compareItems(), whereas this function only compares the pointers.
.PP
See also findNextRef(), find(), and current().
.SH "type * QPtrList::first ()"
Returns a pointer to the first item in the list and makes this the current list item; returns 0 if the list is empty.
.PP
See also getFirst(), last(), next(), prev(), and current().
.PP
Examples:
.)l grapher/grapher.cpp, listviews/listviews.h, and showimg/showimg.cpp.
.SH "type * QPtrList::getFirst () const"
Returns a pointer to the first item in the list, or 0 if the list is empty.
.PP
This function does not affect the current list item.
.PP
See also first() and getLast().
.SH "type * QPtrList::getLast () const"
Returns a pointer to the last item in the list, or 0 if the list is empty.
.PP
This function does not affect the current list item.
.PP
See also last() and getFirst().
.SH "void QPtrList::inSort ( const type * item )"
Inserts the \fIitem\fR at its sorted position in the list.
.PP
The sort order depends on the virtual compareItems() function. All items must be inserted with inSort() to maintain the sorting order.
.PP
The inserted item becomes the current list item.
.PP
\fIitem\fR must not be 0.
.PP
\fBWarning:\fR Using inSort() is slow. An alternative, especially if you have lots of items, is to simply append() or insert() them and then use sort(). inSort() takes up to O(n) compares. That means inserting n items in your list will need O(n^2) compares whereas sort() only needs O(n*log n) for the same task. So use inSort() only if you already have a presorted list and want to insert just a few additional items.
.PP
See also insert(), compareItems(), current(), and sort().
.SH "bool QPtrList::insert ( uint index, const type * item )"
Inserts the \fIitem\fR at position \fIindex\fR in the list.
.PP
Returns TRUE if successful, i.e. if \fIindex\fR is in range; otherwise returns FALSE. The valid range is 0 to count() (inclusively). The item is appended if \fIindex\fR == count().
.PP
The inserted item becomes the current list item.
.PP
\fIitem\fR must not be 0.
.PP
See also append(), current(), and replace().
.SH "bool QPtrList::isEmpty () const"
Returns TRUE if the list is empty; otherwise returns FALSE.
.PP
See also count().
.SH "type * QPtrList::last ()"
Returns a pointer to the last item in the list and makes this the current list item; returns 0 if the list is empty.
.PP
See also getLast(), first(), next(), prev(), and current().
.SH "type * QPtrList::next ()"
Returns a pointer to the item succeeding the current item. Returns 0 if the current item is 0 or equal to the last item.
.PP
Makes the succeeding item current. If the current item before this function call was the last item, the current item will be set to 0. If the current item was 0, this function does nothing.
.PP
See also first(), last(), prev(), and current().
.PP
Examples:
.)l grapher/grapher.cpp, listviews/listviews.h, and showimg/showimg.cpp.
.SH "bool QPtrList::operator!= ( const QPtrList<type> & list ) const"
Compares this list with \fIlist\fR. Returns TRUE if the lists contain different data; otherwise returns FALSE.
.SH "QPtrList<type> & QPtrList::operator= ( const QPtrList<type> & list )"
Assigns \fIlist\fR to this list and returns a reference to this list.
.PP
This list is first cleared and then each item in \fIlist\fR is appended to this list. Only the pointers are copied (shallow copy) unless newItem() has been reimplemented.
.SH "bool QPtrList::operator== ( const QPtrList<type> & list ) const"
Compares this list with \fIlist\fR. Returns TRUE if the lists contain the same data; otherwise returns FALSE.
.SH "void QPtrList::prepend ( const type * item )"
Inserts the \fIitem\fR at the start of the list.
.PP
The inserted item becomes the current list item. This is equivalent to \fCinsert( 0, item )\fR.
.PP
\fIitem\fR must not be 0.
.PP
See also append(), insert(), and current().
.SH "type * QPtrList::prev ()"
Returns a pointer to the item preceding the current item. Returns 0 if the current item is 0 or equal to the first item.
.PP
Makes the preceding item current. If the current item before this function call was the first item, the current item will be set to 0. If the current item was 0, this function does nothing.
.PP
See also first(), last(), next(), and current().
.SH "QDataStream & QPtrList::read ( QDataStream & s, QPtrCollection::Item & item )\fC [virtual protected]\fR"
Reads a list item from the stream \fIs\fR and returns a reference to the stream.
.PP
The default implementation sets \fIitem\fR to 0.
.PP
See also write().
.SH "bool QPtrList::remove ( uint index )"
Removes the item at position \fIindex\fR in the list.
.PP
Returns TRUE if successful, i.e. if \fIindex\fR is in range; otherwise returns FALSE. The valid range is \fC0..(count() - 1)\fR inclusive.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also take(), clear(), setAutoDelete(), current(), and removeRef().
.SH "bool QPtrList::remove ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes the current list item.
.PP
Returns TRUE if successful, i.e. if the current item isn't 0; otherwise returns FALSE.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also take(), clear(), setAutoDelete(), current(), and removeRef().
.SH "bool QPtrList::remove ( const type * item )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes the first occurrence of \fIitem\fR from the list.
.PP
Returns TRUE if successful, i.e. if \fIitem\fR is in the list; otherwise returns FALSE.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The compareItems() function is called when searching for the item in the list. If compareItems() is not reimplemented, it is more efficient to call removeRef().
.PP
If \fIitem\fR is NULL then the current item is removed from the list.
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also removeRef(), take(), clear(), setAutoDelete(), compareItems(), and current().
.SH "bool QPtrList::removeFirst ()"
Removes the first item from the list. Returns TRUE if successful, i.e. if the list isn't empty; otherwise returns FALSE.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The first item in the list becomes the new current list item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also removeLast(), setAutoDelete(), current(), and remove().
.SH "bool QPtrList::removeLast ()"
Removes the last item from the list. Returns TRUE if successful, i.e. if the list isn't empty; otherwise returns FALSE.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The last item in the list becomes the new current list item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also removeFirst(), setAutoDelete(), and current().
.SH "void QPtrList::removeNode ( QLNode * node )"
Removes the \fInode\fR from the list.
.PP
This node must exist in the list, otherwise the program may crash.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
The first item in the list will become the new current list item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the item succeeding this item or to the preceding item if the removed item was the last item.
.PP
\fBWarning:\fR Do not call this function unless you are an expert.
.PP
See also takeNode(), currentNode(), remove(), and removeRef().
.SH "bool QPtrList::removeRef ( const type * item )"
Removes the first occurrence of \fIitem\fR from the list.
.PP
Returns TRUE if successful, i.e. if \fIitem\fR is in the list; otherwise returns FALSE.
.PP
The removed item is deleted if auto-deletion is enabled.
.PP
Equivalent to:
.PP
.nf
.br
        if ( list.findRef( item ) != -1 )
.br
            list.remove();
.br
.fi
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the removed item will be set to point to the new current item.
.PP
See also remove(), clear(), setAutoDelete(), and current().
.SH "bool QPtrList::replace ( uint index, const type * item )"
Replaces the item at position \fIindex\fR with the new \fIitem\fR.
.PP
Returns TRUE if successful, i.e. \fIindex\fR is in the range 0 to count()-1.
.PP
See also append(), current(), and insert().
.SH "void QPtrCollection::setAutoDelete ( bool enable )"
Sets the collection to auto-delete its contents if \fIenable\fR is TRUE and to never delete them if \fIenable\fR is FALSE.
.PP
If auto-deleting is turned on, all the items in a collection are deleted when the collection itself is deleted. This is convenient if the collection has the only pointer to the items.
.PP
The default setting is FALSE, for safety. If you turn it on, be careful about copying the collection - you might find yourself with two collections deleting the same items.
.PP
Note that the auto-delete setting may also affect other functions in subclasses. For example, a subclass that has a remove() function will remove the item from its data structure, and if auto-delete is enabled, will also delete the item.
.PP
See also autoDelete().
.PP
Examples:
.)l grapher/grapher.cpp, scribble/scribble.cpp, and table/bigtable/main.cpp.
.SH "void QPtrList::sort ()"
Sorts the list by the result of the virtual compareItems() function.
.PP
The heap sort algorithm is used for sorting. It sorts n items with O(n*log n) comparisons. This is the asymptotic optimal solution of the sorting problem.
.PP
If the items in your list support operator<() and operator==(), you might be better off with QSortedList because it implements the compareItems() function for you using these two operators.
.PP
See also inSort().
.SH "type * QPtrList::take ( uint index )"
Takes the item at position \fIindex\fR out of the list without deleting it (even if auto-deletion is enabled).
.PP
Returns a pointer to the item taken out of the list, or 0 if the index is out of range. The valid range is \fC0..(count() - 1)\fR inclusive.
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the taken item will be set to point to the new current item.
.PP
See also remove(), clear(), and current().
.PP
Examples:
.)l customlayout/border.cpp, customlayout/card.cpp, and customlayout/flow.cpp.
.SH "type * QPtrList::take ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Takes the current item out of the list without deleting it (even if auto-deletion is enabled).
.PP
Returns a pointer to the item taken out of the list, or 0 if the current item is 0.
.PP
The item after the removed item becomes the new current list item if the removed item is not the last item in the list. If the last item is removed, the new last item becomes the current item. The current item is set to 0 if the list becomes empty.
.PP
All list iterators that refer to the taken item will be set to point to the new current item.
.PP
See also remove(), clear(), and current().
.SH "type * QPtrList::takeNode ( QLNode * node )"
Takes the \fInode\fR out of the list without deleting its item (even if auto-deletion is enabled). Returns a pointer to the item taken out of the list.
.PP
This node must exist in the list, otherwise the program may crash.
.PP
The first item in the list becomes the new current list item.
.PP
All list iterators that refer to the taken item will be set to point to the item succeeding this item or to the preceding item if the taken item was the last item.
.PP
\fBWarning:\fR Do not call this function unless you are an expert.
.PP
See also removeNode() and currentNode().
.SH "void QPtrList::toVector ( QGVector * vec ) const"
Stores all list items in the vector \fIvec\fR.
.PP
The vector must be of the same item type, otherwise the result will be undefined.
.SH "QDataStream & QPtrList::write ( QDataStream & s, QPtrCollection::Item item ) const\fC [virtual protected]\fR"
Writes a list item, \fIitem\fR to the stream \fIs\fR and returns a reference to the stream.
.PP
The default implementation does nothing.
.PP
See also read().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qptrlist.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qptrlist.3qt) and the Qt
version (3.3.8).
