'\" t
.TH QCString 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QCString \- Abstraction of the classic C zero-terminated char array (char *)
.SH SYNOPSIS
All the functions in this class are reentrant when Qt is built with thread support.</p>
.PP
\fC#include <qcstring.h>\fR
.PP
Inherits QByteArray.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQCString\fR ()"
.br
.ti -1c
.BI "\fBQCString\fR ( int size )"
.br
.ti -1c
.BI "\fBQCString\fR ( const QCString & s )"
.br
.ti -1c
.BI "\fBQCString\fR ( const char * str )"
.br
.ti -1c
.BI "\fBQCString\fR ( const char * str, uint maxsize )"
.br
.ti -1c
.BI "QCString & \fBoperator=\fR ( const QCString & s )"
.br
.ti -1c
.BI "QCString & \fBoperator=\fR ( const char * str )"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "uint \fBlength\fR () const"
.br
.ti -1c
.BI "bool \fBresize\fR ( uint len )"
.br
.ti -1c
.BI "bool \fBtruncate\fR ( uint pos )"
.br
.ti -1c
.BI "bool \fBfill\fR ( char c, int len = -1 )"
.br
.ti -1c
.BI "QCString \fBcopy\fR () const"
.br
.ti -1c
.BI "QCString & \fBsprintf\fR ( const char * format, ... )"
.br
.ti -1c
.BI "int \fBfind\fR ( char c, int index = 0, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( const char * str, int index = 0, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfind\fR ( const QRegExp & rx, int index = 0 ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( char c, int index = -1, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( const char * str, int index = -1, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBfindRev\fR ( const QRegExp & rx, int index = -1 ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( char c, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( const char * str, bool cs = TRUE ) const"
.br
.ti -1c
.BI "int \fBcontains\fR ( const QRegExp & rx ) const"
.br
.ti -1c
.BI "QCString \fBleft\fR ( uint len ) const"
.br
.ti -1c
.BI "QCString \fBright\fR ( uint len ) const"
.br
.ti -1c
.BI "QCString \fBmid\fR ( uint index, uint len = 0xffffffff ) const"
.br
.ti -1c
.BI "QCString \fBleftJustify\fR ( uint width, char fill = ' ', bool truncate = FALSE ) const"
.br
.ti -1c
.BI "QCString \fBrightJustify\fR ( uint width, char fill = ' ', bool truncate = FALSE ) const"
.br
.ti -1c
.BI "QCString \fBlower\fR () const"
.br
.ti -1c
.BI "QCString \fBupper\fR () const"
.br
.ti -1c
.BI "QCString \fBstripWhiteSpace\fR () const"
.br
.ti -1c
.BI "QCString \fBsimplifyWhiteSpace\fR () const"
.br
.ti -1c
.BI "QCString & \fBinsert\fR ( uint index, const char * s )"
.br
.ti -1c
.BI "QCString & \fBinsert\fR ( uint index, char c )"
.br
.ti -1c
.BI "QCString & \fBappend\fR ( const char * str )"
.br
.ti -1c
.BI "QCString & \fBprepend\fR ( const char * s )"
.br
.ti -1c
.BI "QCString & \fBremove\fR ( uint index, uint len )"
.br
.ti -1c
.BI "QCString & \fBreplace\fR ( uint index, uint len, const char * str )"
.br
.ti -1c
.BI "QCString & \fBreplace\fR ( const QRegExp & rx, const char * str )"
.br
.ti -1c
.BI "QCString & \fBreplace\fR ( char c, const char * after )"
.br
.ti -1c
.BI "QCString & \fBreplace\fR ( const char * before, const char * after )"
.br
.ti -1c
.BI "QCString & \fBreplace\fR ( char c1, char c2 )"
.br
.ti -1c
.BI "short \fBtoShort\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "ushort \fBtoUShort\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "int \fBtoInt\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "uint \fBtoUInt\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "long \fBtoLong\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "ulong \fBtoULong\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "float \fBtoFloat\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "double \fBtoDouble\fR ( bool * ok = 0 ) const"
.br
.ti -1c
.BI "QCString & \fBsetStr\fR ( const char * str )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( short n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( ushort n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( int n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( uint n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( long n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( ulong n )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( float n, char f = 'g', int prec = 6 )"
.br
.ti -1c
.BI "QCString & \fBsetNum\fR ( double n, char f = 'g', int prec = 6 )"
.br
.ti -1c
.BI "bool \fBsetExpand\fR ( uint index, char c )"
.br
.ti -1c
.BI "\fBoperator const char *\fR () const"
.br
.ti -1c
.BI "QCString & \fBoperator+=\fR ( const char * str )"
.br
.ti -1c
.BI "QCString & \fBoperator+=\fR ( char c )"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "void * \fBqmemmove\fR ( void * dst, const void * src, uint len )"
.br
.ti -1c
.BI "char * \fBqstrdup\fR ( const char * src )"
.br
.ti -1c
.BI "char * \fBqstrcpy\fR ( char * dst, const char * src )"
.br
.ti -1c
.BI "char * \fBqstrncpy\fR ( char * dst, const char * src, uint len )"
.br
.ti -1c
.BI "uint \fBqstrlen\fR ( const char * str )"
.br
.ti -1c
.BI "int \fBqstrcmp\fR ( const char * str1, const char * str2 )"
.br
.ti -1c
.BI "int \fBqstrncmp\fR ( const char * str1, const char * str2, uint len )"
.br
.ti -1c
.BI "int \fBqstricmp\fR ( const char * str1, const char * str2 )"
.br
.ti -1c
.BI "int \fBqstrnicmp\fR ( const char * str1, const char * str2, uint len )"
.br
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QCString & str )"
.br
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QCString & str )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QCString & s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QCString & s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator<\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator<\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator<=\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator<=\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator>\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator>\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "bool \fBoperator>=\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "bool \fBoperator>=\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "const QCString \fBoperator+\fR ( const QCString & s1, const QCString & s2 )"
.br
.ti -1c
.BI "const QCString \fBoperator+\fR ( const QCString & s1, const char * s2 )"
.br
.ti -1c
.BI "const QCString \fBoperator+\fR ( const char * s1, const QCString & s2 )"
.br
.ti -1c
.BI "const QCString \fBoperator+\fR ( const QCString & s, char c )"
.br
.ti -1c
.BI "const QCString \fBoperator+\fR ( char c, const QCString & s )"
.br
.in -1c
.SH DESCRIPTION
The QCString class provides an abstraction of the classic C zero-terminated char array (char *).
.PP
QCString inherits QByteArray, which is defined as QMemArray<char>. Since QCString is a QMemArray, it uses explicit sharing with a reference count.
.PP
QCString tries to behave like a more convenient \fCconst char *\fR. The price of doing this is that some algorithms will perform badly. For example, append() is O(length()) since it scans for a null terminator. Although you might use QCString for text that is never exposed to the user, for most purposes, and especially for user-visible text, you should use QString. QString provides implicit sharing, Unicode and other internationalization support, and is well optimized.
.PP
Note that for the QCString methods that take a \fCconst char *\fR parameter the \fCconst char *\fR must either be 0 (null) or not-null and '&#92;0' (NUL byte) terminated; otherwise the results are undefined.
.PP
A QCString that has not been assigned to anything is \fInull\fR, i.e. both the length and the data pointer is 0. A QCString that references the empty string ("", a single '&#92;0' char) is \fIempty\fR. Both null and empty QCStrings are legal parameters to the methods. Assigning \fCconst char *\fR 0 to QCString produces a null QCString.
.PP
The length() function returns the length of the string; resize() resizes the string and truncate() truncates the string. A string can be filled with a character using fill(). Strings can be left or right padded with characters using leftJustify() and rightJustify(). Characters, strings and regular expressions can be searched for using find() and findRev(), and counted using contains().
.PP
Strings and characters can be inserted with insert() and appended with append(). A string can be prepended with prepend(). Characters can be removed from the string with remove() and replaced with replace().
.PP
Portions of a string can be extracted using left(), right() and mid(). Whitespace can be removed using stripWhiteSpace() and simplifyWhiteSpace(). Strings can be converted to uppercase or lowercase with upper() and lower() respectively.
.PP
Strings that contain numbers can be converted to numbers with toShort(), toInt(), toLong(), toULong(), toFloat() and toDouble(). Numbers can be converted to strings with setNum().
.PP
Many operators are overloaded to work with QCStrings. QCString also supports some more obscure functions, e.g. sprintf(), setStr() and setExpand().
.PP
<blockquote><p align="center">\fB Note on Character Comparisons \fR
.PP
In QCString the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions which support a case insensitive option or which compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If \fC$LC_CTYPE\fR is set, most Unix systems do "the right thing".) Functions that this affects include contains(), find(), findRev(), operator<(), operator<=(), operator>(), operator>=(), lower() and upper().
.PP
This issue does not apply to QStrings since they represent characters using Unicode. </blockquote>
.PP
Performance note: The QCString methods for QRegExp searching are implemented by converting the QCString to a QString and performing the search on that. This implies a deep copy of the QCString data. If you are going to perform many QRegExp searches on a large QCString, you will get better performance by converting the QCString to a QString yourself, and then searching in the QString.
.PP
See also Collection Classes, Implicitly and Explicitly Shared Classes, Text Related Classes, and Non-GUI Classes.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QCString::QCString ()"
Constructs a null string.
.PP
See also isNull().
.SH "QCString::QCString ( int size )"
Constructs a string with room for \fIsize\fR characters, including the '&#92;0'-terminator. Makes a null string if \fIsize\fR == 0.
.PP
If \fIsize\fR > 0, then the first and last characters in the string are initialized to '&#92;0'. All other characters are uninitialized.
.PP
See also resize() and isNull().
.SH "QCString::QCString ( const QCString & s )"
Constructs a shallow copy \fIs\fR.
.PP
See also assign().
.SH "QCString::QCString ( const char * str )"
Constructs a string that is a deep copy of \fIstr\fR.
.PP
If \fIstr\fR is 0 a null string is created.
.PP
See also isNull().
.SH "QCString::QCString ( const char * str, uint maxsize )"
Constructs a string that is a deep copy of \fIstr\fR. The copy will be at most \fImaxsize\fR bytes long including the '&#92;0'-terminator.
.PP
Example:
.PP
.nf
.br
    QCString str( "helloworld", 6 ); // assigns "hello" to str
.br
.fi
.PP
If \fIstr\fR contains a 0 byte within the first \fImaxsize\fR bytes, the resulting QCString will be terminated by this 0. If \fIstr\fR is 0 a null string is created.
.PP
See also isNull().
.SH "QCString & QCString::append ( const char * str )"
Appends string \fIstr\fR to the string and returns a reference to the string. Equivalent to operator+=().
.SH "int QCString::contains ( char c, bool cs = TRUE ) const"
Returns the number of times the character \fIc\fR occurs in the string.
.PP
The match is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR if FALSE.
.PP
See also Note on character comparisons.
.SH "int QCString::contains ( const char * str, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the number of times \fIstr\fR occurs in the string.
.PP
The match is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR if FALSE.
.PP
This function counts overlapping substrings, for example, "banana" contains two occurrences of "ana".
.PP
See also findRev() and Note on character comparisons.
.SH "int QCString::contains ( const QRegExp & rx ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Counts the number of overlapping occurrences of \fIrx\fR in the string.
.PP
Example:
.PP
.nf
.br
    QString s = "banana and panama";
.br
    QRegExp r = QRegExp( "a[nm]a", TRUE, FALSE );
.br
    s.contains( r ); // 4 matches
.br
.fi
.PP
See also find() and findRev().
.PP
\fBWarning:\fR If you want to apply this function repeatedly to the same string it is more efficient to convert the string to a QString and apply the function to that.
.SH "QCString QCString::copy () const"
Returns a deep copy of this string.
.PP
See also detach().
.SH "bool QCString::fill ( char c, int len = -1 )"
Fills the string with \fIlen\fR bytes of character \fIc\fR, followed by a '&#92;0'-terminator.
.PP
If \fIlen\fR is negative, then the current string length is used.
.PP
Returns FALSE is \fIlen\fR is nonnegative and there is not enough memory to resize the string; otherwise returns TRUE.
.SH "int QCString::find ( char c, int index = 0, bool cs = TRUE ) const"
Finds the first occurrence of the character \fIc\fR, starting at position \fIindex\fR.
.PP
The search is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR is FALSE.
.PP
Returns the position of \fIc\fR, or -1 if \fIc\fR could not be found.
.PP
See also Note on character comparisons.
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "int QCString::find ( const char * str, int index = 0, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the string \fIstr\fR, starting at position \fIindex\fR.
.PP
The search is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR is FALSE.
.PP
Returns the position of \fIstr\fR, or -1 if \fIstr\fR could not be found.
.PP
See also Note on character comparisons.
.SH "int QCString::find ( const QRegExp & rx, int index = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the regular expression \fIrx\fR, starting at position \fIindex\fR.
.PP
Returns the position of the next match, or -1 if \fIrx\fR was not found.
.PP
\fBWarning:\fR If you want to apply this function repeatedly to the same string it is more efficient to convert the string to a QString and apply the function to that.
.SH "int QCString::findRev ( char c, int index = -1, bool cs = TRUE ) const"
Finds the first occurrence of the character \fIc\fR, starting at position \fIindex\fR and searching backwards.
.PP
The search is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR is FALSE.
.PP
Returns the position of \fIc\fR, or -1 if \fIc\fR could not be found.
.PP
See also Note on character comparisons.
.SH "int QCString::findRev ( const char * str, int index = -1, bool cs = TRUE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the string \fIstr\fR, starting at position \fIindex\fR and searching backwards.
.PP
The search is case sensitive if \fIcs\fR is TRUE, or case insensitive if \fIcs\fR is FALSE.
.PP
Returns the position of \fIstr\fR, or -1 if \fIstr\fR could not be found.
.PP
See also Note on character comparisons.
.SH "int QCString::findRev ( const QRegExp & rx, int index = -1 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of the regular expression \fIrx\fR, starting at position \fIindex\fR and searching backwards.
.PP
Returns the position of the next match (backwards), or -1 if \fIrx\fR was not found.
.PP
\fBWarning:\fR If you want to apply this function repeatedly to the same string it is more efficient to convert the string to a QString and apply the function to that.
.SH "QCString & QCString::insert ( uint index, char c )"
Inserts character \fIc\fR into the string at position \fIindex\fR and returns a reference to the string.
.PP
If \fIindex\fR is beyond the end of the string, the string is padded with spaces (ASCII 32) to length \fIindex\fR and then \fIc\fR is appended.
.PP
Example:
.PP
.nf
.br
    QCString s = "Yes";
.br
    s.insert( 3, '!');   // s == "Yes!"
.br
.fi
.PP
See also remove() and replace().
.SH "QCString & QCString::insert ( uint index, const char * s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts string \fIs\fR into the string at position \fIindex\fR.
.PP
If \fIindex\fR is beyond the end of the string, the string is padded with spaces (ASCII 32) to length \fIindex\fR and then \fIs\fR is appended.
.PP
.nf
.br
    QCString s = "I like fish";
.br
    s.insert( 2, "don't ");     // s == "I don't like fish"
.br
.br
    s = "x";                    // index 01234
.br
    s.insert( 3, "yz" );        // s == "x  yz"
.br
.fi
.SH "bool QCString::isEmpty () const"
Returns TRUE if the string is empty, i.e. if length() == 0; otherwise returns FALSE. An empty string is not always a null string.
.PP
See example in isNull().
.PP
See also isNull(), length(), and size().
.SH "bool QCString::isNull () const"
Returns TRUE if the string is null, i.e. if data() == 0; otherwise returns FALSE. A null string is also an empty string.
.PP
Example:
.PP
.nf
.br
    QCString a;         // a.data() == 0,  a.size() == 0, a.length() == 0
.br
    QCString b == "";   // b.data() == "", b.size() == 1, b.length() == 0
.br
    a.isNull();         // TRUE  because a.data() == 0
.br
    a.isEmpty();        // TRUE  because a.length() == 0
.br
    b.isNull();         // FALSE because b.data() == ""
.br
    b.isEmpty();        // TRUE  because b.length() == 0
.br
.fi
.PP
See also isEmpty(), length(), and size().
.SH "QCString QCString::left ( uint len ) const"
Returns a substring that contains the \fIlen\fR leftmost characters of the string.
.PP
The whole string is returned if \fIlen\fR exceeds the length of the string.
.PP
Example:
.PP
.nf
.br
    QCString s = "Pineapple";
.br
    QCString t = s.left( 4 );  // t == "Pine"
.br
.fi
.PP
See also right() and mid().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString QCString::leftJustify ( uint width, char fill = ' ', bool truncate = FALSE ) const"
Returns a string of length \fIwidth\fR (plus one for the terminating '&#92;0') that contains this string padded with the \fIfill\fR character.
.PP
If the length of the string exceeds \fIwidth\fR and \fItruncate\fR is FALSE (the default), then the returned string is a copy of the string. If the length of the string exceeds \fIwidth\fR and \fItruncate\fR is TRUE, then the returned string is a left(\fIwidth\fR).
.PP
Example:
.PP
.nf
.br
    QCString s("apple");
.br
    QCString t = s.leftJustify(8, '.');  // t == "apple..."
.br
.fi
.PP
See also rightJustify().
.SH "uint QCString::length () const"
Returns the length of the string, excluding the '&#92;0'-terminator. Equivalent to calling \fCstrlen(data())\fR.
.PP
Null strings and empty strings have zero length.
.PP
See also size(), isNull(), and isEmpty().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString QCString::lower () const"
Returns a new string that is a copy of this string converted to lower case.
.PP
Example:
.PP
.nf
.br
    QCString s("Credit");
.br
    QCString t = s.lower();  // t == "credit"
.br
.fi
.PP
See also upper() and Note on character comparisons.
.SH "QCString QCString::mid ( uint index, uint len = 0xffffffff ) const"
Returns a substring that contains at most \fIlen\fR characters from this string, starting at position \fIindex\fR.
.PP
Returns a null string if the string is empty or if \fIindex\fR is out of range. Returns the whole string from \fIindex\fR if \fIindex+len\fR exceeds the length of the string.
.PP
Example:
.PP
.nf
.br
    QCString s = "Two pineapples";
.br
    QCString t = s.mid( 4, 3 );     // t == "pin"
.br
.fi
.PP
See also left() and right().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString::operator const char * () const"
Returns the string data.
.SH "QCString & QCString::operator+= ( const char * str )"
Appends string \fIstr\fR to the string and returns a reference to the string.
.SH "QCString & QCString::operator+= ( char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends character \fIc\fR to the string and returns a reference to the string.
.SH "QCString & QCString::operator= ( const QCString & s )"
Assigns a shallow copy of \fIs\fR to this string and returns a reference to this string.
.SH "QCString & QCString::operator= ( const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns a deep copy of \fIstr\fR to this string and returns a reference to this string.
.PP
If \fIstr\fR is 0 a null string is created.
.PP
See also isNull().
.SH "QCString & QCString::prepend ( const char * s )"
Prepend \fIs\fR to the string. Equivalent to insert(0, s).
.PP
See also insert().
.SH "QCString & QCString::remove ( uint index, uint len )"
Removes \fIlen\fR characters from the string, starting at position \fIindex\fR, and returns a reference to the string.
.PP
If \fIindex\fR is out of range, nothing happens. If \fIindex\fR is valid, but \fIindex\fR + \fIlen\fR is larger than the length of the string, the string is truncated at position \fIindex\fR.
.PP
.nf
.br
    QCString s = "Montreal";
.br
    s.remove( 1, 4 );         // s == "Meal"
.br
.fi
.PP
See also insert() and replace().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString & QCString::replace ( uint index, uint len, const char * str )"
Replaces \fIlen\fR characters from the string, starting at position \fIindex\fR, with \fIstr\fR, and returns a reference to the string.
.PP
If \fIindex\fR is out of range, nothing is removed and \fIstr\fR is appended at the end of the string. If \fIindex\fR is valid, but \fIindex\fR + \fIlen\fR is larger than the length of the string, \fIstr\fR replaces the rest of the string from position \fIindex\fR.
.PP
.nf
.br
    QCString s = "Say yes!";
.br
    s.replace( 4, 3, "NO" );  // s == "Say NO!"
.br
.fi
.PP
See also insert() and remove().
.SH "QCString & QCString::replace ( const QRegExp & rx, const char * str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of \fIrx\fR in the string with \fIstr\fR. Returns a reference to the string.
.PP
Example:
.PP
.nf
.br
    QString s = "banana";
.br
    s.replace( QRegExp("a.*a"), "" );     // becomes "b"
.br
.br
    s = "banana";
.br
    s.replace( QRegExp("^[bn]a"), "X" );  // becomes "Xnana"
.br
.br
    s = "banana";
.br
    s.replace( QRegExp("^[bn]a"), "" );   // becomes "nana"
.br
.fi
.PP
\fBWarning:\fR If you want to apply this function repeatedly to the same string it is more efficient to convert the string to a QString and apply the function to that.
.SH "QCString & QCString::replace ( char c, const char * after )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the character \fIc\fR in the string with \fIafter\fR. Returns a reference to the string.
.PP
Example:
.PP
.nf
.br
    QCString s = "a,b,c";
.br
    s.replace( ',', " or " );
.br
    // s == "a or b or c"
.br
.fi
.SH "QCString & QCString::replace ( const char * before, const char * after )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of the string \fIbefore\fR in the string with the string \fIafter\fR. Returns a reference to the string.
.PP
Example:
.PP
.nf
.br
    QCString s = "Greek is Greek";
.br
    s.replace( "Greek", "English" );
.br
    // s == "English is English"
.br
.fi
.SH "QCString & QCString::replace ( char c1, char c2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Replaces every occurrence of \fIc1\fR with the char \fIc2\fR. Returns a reference to the string.
.SH "bool QCString::resize ( uint len )"
Extends or shrinks the string to \fIlen\fR bytes, including the '&#92;0'-terminator.
.PP
A '&#92;0'-terminator is set at position \fClen - 1\fR unless \fClen == 0\fR.
.PP
Example:
.PP
.nf
.br
    QCString s = "resize this string";
.br
    s.resize( 7 );                      // s == "resize"
.br
.fi
.PP
See also truncate().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString QCString::right ( uint len ) const"
Returns a substring that contains the \fIlen\fR rightmost characters of the string.
.PP
The whole string is returned if \fIlen\fR exceeds the length of the string.
.PP
Example:
.PP
.nf
.br
    QCString s = "Pineapple";
.br
    QCString t = s.right( 5 );  // t == "apple"
.br
.fi
.PP
See also left() and mid().
.PP
Example: network/networkprotocol/nntp.cpp.
.SH "QCString QCString::rightJustify ( uint width, char fill = ' ', bool truncate = FALSE ) const"
Returns a string of length \fIwidth\fR (plus one for the terminating '&#92;0') that contains zero or more of the \fIfill\fR character followed by this string.
.PP
If the length of the string exceeds \fIwidth\fR and \fItruncate\fR is FALSE (the default), then the returned string is a copy of the string. If the length of the string exceeds \fIwidth\fR and \fItruncate\fR is TRUE, then the returned string is a left(\fIwidth\fR).
.PP
Example:
.PP
.nf
.br
    QCString s("pie");
.br
    QCString t = s.rightJustify(8, '.');  // t == ".....pie"
.br
.fi
.PP
See also leftJustify().
.SH "bool QCString::setExpand ( uint index, char c )"
Sets the character at position \fIindex\fR to \fIc\fR and expands the string if necessary, padding with spaces.
.PP
Returns FALSE if \fIindex\fR was out of range and the string could not be expanded; otherwise returns TRUE.
.SH "QCString & QCString::setNum ( double n, char f = 'g', int prec = 6 )"
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.PP
The format of the string representation is specified by the format character \fIf\fR, and the precision (number of digits after the decimal point) is specified with \fIprec\fR.
.PP
The valid formats for \fIf\fR are 'e', 'E', 'f', 'g' and 'G'. The formats are the same as for sprintf(); they are explained in QString::arg().
.SH "QCString & QCString::setNum ( short n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( ushort n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( int n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( uint n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( long n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( ulong n )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the string to the string representation of the number \fIn\fR and returns a reference to the string.
.SH "QCString & QCString::setNum ( float n, char f = 'g', int prec = 6 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QCString & QCString::setStr ( const char * str )"
Makes a deep copy of \fIstr\fR. Returns a reference to the string.
.SH "QCString QCString::simplifyWhiteSpace () const"
Returns a new string that has white space removed from the start and the end, plus any sequence of internal white space replaced with a single space (ASCII 32).
.PP
White space means the decimal ASCII codes 9, 10, 11, 12, 13 and 32.
.PP
.nf
.br
    QCString s = "  lots\\t of\\nwhite    space ";
.br
    QCString t = s.simplifyWhiteSpace(); // t == "lots of white space"
.br
.fi
.PP
See also stripWhiteSpace().
.SH "QCString & QCString::sprintf ( const char * format, ... )"
Implemented as a call to the native vsprintf() (see the manual for your C library).
.PP
If the string is shorter than 256 characters, this sprintf() calls resize(256) to decrease the chance of memory corruption. The string is resized back to its actual length before sprintf() returns.
.PP
Example:
.PP
.nf
.br
    QCString s;
.br
    s.sprintf( "%d - %s", 1, "first" );         // result < 256 chars
.br
.br
    QCString big( 25000 );                      // very long string
.br
    big.sprintf( "%d - %s", 2, longString );    // result < 25000 chars
.br
.fi
.PP
\fBWarning:\fR All vsprintf() implementations will write past the end of the target string (*this) if the \fIformat\fR specification and arguments happen to be longer than the target string, and some will also fail if the target string is longer than some arbitrary implementation limit.
.PP
Giving user-supplied arguments to sprintf() is risky: Sooner or later someone will paste a huge line into your application.
.SH "QCString QCString::stripWhiteSpace () const"
Returns a new string that has white space removed from the start and the end.
.PP
White space means the decimal ASCII codes 9, 10, 11, 12, 13 and 32.
.PP
Example:
.PP
.nf
.br
    QCString s = " space ";
.br
    QCString t = s.stripWhiteSpace();           // t == "space"
.br
.fi
.PP
See also simplifyWhiteSpace().
.SH "double QCString::toDouble ( bool * ok = 0 ) const"
Returns the string converted to a \fCdouble\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "float QCString::toFloat ( bool * ok = 0 ) const"
Returns the string converted to a \fCfloat\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "int QCString::toInt ( bool * ok = 0 ) const"
Returns the string converted to a \fCint\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "long QCString::toLong ( bool * ok = 0 ) const"
Returns the string converted to a \fClong\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "short QCString::toShort ( bool * ok = 0 ) const"
Returns the string converted to a \fCshort\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, is out of range, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "uint QCString::toUInt ( bool * ok = 0 ) const"
Returns the string converted to an \fCunsigned int\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "ulong QCString::toULong ( bool * ok = 0 ) const"
Returns the string converted to an \fCunsigned long\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "ushort QCString::toUShort ( bool * ok = 0 ) const"
Returns the string converted to an \fCunsigned short\fR value.
.PP
If \fIok\fR is not 0: \fI*ok\fR is set to FALSE if the string is not a number, is out of range, or if it has trailing garbage; otherwise \fI*ok\fR is set to TRUE.
.SH "bool QCString::truncate ( uint pos )"
Truncates the string at position \fIpos\fR.
.PP
Equivalent to calling \fCresize(pos+1)\fR.
.PP
Example:
.PP
.nf
.br
    QCString s = "truncate this string";
.br
    s.truncate( 5 );                      // s == "trunc"
.br
.fi
.PP
See also resize().
.SH "QCString QCString::upper () const"
Returns a new string that is a copy of this string converted to upper case.
.PP
Example:
.PP
.nf
.br
    QCString s( "Debit" );
.br
    QCString t = s.upper();  // t == "DEBIT"
.br
.fi
.PP
See also lower() and Note on character comparisons.
.SH RELATED FUNCTION DOCUMENTATION
.SH "bool operator!= ( const QCString & s1, const QCString & s2 )"
Returns TRUE if \fIs1\fR and \fIs2\fR are different; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) != 0.
.SH "bool operator!= ( const QCString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR and \fIs2\fR are different; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) != 0.
.SH "bool operator!= ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR and \fIs2\fR are different; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) != 0.
.SH "const QCString operator+ ( const QCString & s1, const QCString & s2 )"
Returns a string which consists of the concatenation of \fIs1\fR and \fIs2\fR.
.SH "const QCString operator+ ( const QCString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which consists of the concatenation of \fIs1\fR and \fIs2\fR.
.SH "const QCString operator+ ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which consists of the concatenation of \fIs1\fR and \fIs2\fR.
.SH "const QCString operator+ ( const QCString & s, char c )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which consists of the concatenation of \fIs\fR and \fIc\fR.
.SH "const QCString operator+ ( char c, const QCString & s )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a string which consists of the concatenation of \fIc\fR and \fIs\fR.
.SH "bool operator< ( const QCString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is less than \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) < 0.
.PP
See also Note on character comparisons.
.SH "bool operator< ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is less than \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) < 0.
.PP
See also Note on character comparisons.
.SH "QDataStream & operator<< ( QDataStream & s, const QCString & str )"
Writes string \fIstr\fR to the stream \fIs\fR.
.PP
See also Format of the QDataStream operators.
.SH "bool operator<= ( const QCString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is less than or equal to \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) <= 0.
.PP
See also Note on character comparisons.
.SH "bool operator<= ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is less than or equal to \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) <= 0.
.PP
See also Note on character comparisons.
.SH "bool operator== ( const QCString & s1, const QCString & s2 )"
Returns TRUE if \fIs1\fR and \fIs2\fR are equal; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) == 0.
.SH "bool operator== ( const QCString & s1, const char * s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR and \fIs2\fR are equal; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) == 0.
.SH "bool operator== ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR and \fIs2\fR are equal; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) == 0.
.SH "bool operator> ( const QCString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is greater than \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) > 0.
.PP
See also Note on character comparisons.
.SH "bool operator> ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is greater than \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) > 0.
.PP
See also Note on character comparisons.
.SH "bool operator>= ( const QCString & s1, const char * s2 )"
Returns TRUE if \fIs1\fR is greater than or equal to \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) >= 0.
.PP
See also Note on character comparisons.
.SH "bool operator>= ( const char * s1, const QCString & s2 )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if \fIs1\fR is greater than or equal to \fIs2\fR; otherwise returns FALSE.
.PP
Equivalent to qstrcmp(\fIs1\fR, \fIs2\fR) >= 0.
.PP
See also Note on character comparisons.
.SH "QDataStream & operator>> ( QDataStream & s, QCString & str )"
Reads a string into \fIstr\fR from the stream \fIs\fR.
.PP
See also Format of the QDataStream operators.
.SH "void * qmemmove ( void * dst, const void * src, uint len )"
This function is normally part of the C library. Qt implements memmove() for platforms that do not provide it.
.PP
memmove() copies \fIlen\fR bytes from \fIsrc\fR into \fIdst\fR. The data is copied correctly even if \fIsrc\fR and \fIdst\fR overlap.
.SH "int qstrcmp ( const char * str1, const char * str2 )"
A safe strcmp() function.
.PP
Compares \fIstr1\fR and \fIstr2\fR. Returns a negative value if \fIstr1\fR is less than \fIstr2\fR, 0 if \fIstr1\fR is equal to \fIstr2\fR or a positive value if \fIstr1\fR is greater than \fIstr2\fR.
.PP
Special case I: Returns 0 if \fIstr1\fR and \fIstr2\fR are both 0.
.PP
Special case II: Returns a random nonzero value if \fIstr1\fR is 0 or \fIstr2\fR is 0 (but not both).
.PP
See also qstrncmp(), qstricmp(), qstrnicmp(), and Note on character comparisons.
.SH "char * qstrcpy ( char * dst, const char * src )"
A safe strcpy() function.
.PP
Copies all characters up to and including the '&#92;0' from \fIsrc\fR into \fIdst\fR and returns a pointer to \fIdst\fR.
.SH "char * qstrdup ( const char * src )"
Returns a duplicate string.
.PP
Allocates space for a copy of \fIsrc\fR, copies it, and returns a pointer to the copy. If \fIsrc\fR is 0, it immediately returns 0.
.PP
The returned string must be deleted using \fCdelete[]\fR.
.SH "int qstricmp ( const char * str1, const char * str2 )"
A safe stricmp() function.
.PP
Compares \fIstr1\fR and \fIstr2\fR ignoring the case.
.PP
Returns a negative value if \fIstr1\fR is less than \fIstr2\fR, 0 if \fIstr1\fR is equal to \fIstr2\fR or a positive value if \fIstr1\fR is greater than \fIstr2\fR.
.PP
Special case I: Returns 0 if \fIstr1\fR and \fIstr2\fR are both 0.
.PP
Special case II: Returns a random nonzero value if \fIstr1\fR is 0 or \fIstr2\fR is 0 (but not both).
.PP
See also qstrcmp(), qstrncmp(), qstrnicmp(), and Note on character comparisons.
.SH "uint qstrlen ( const char * str )"
A safe strlen function.
.PP
Returns the number of characters that precede the terminating '&#92;0'. or 0 if \fIstr\fR is 0.
.SH "int qstrncmp ( const char * str1, const char * str2, uint len )"
A safe strncmp() function.
.PP
Compares at most \fIlen\fR bytes of \fIstr1\fR and \fIstr2\fR.
.PP
Returns a negative value if \fIstr1\fR is less than \fIstr2\fR, 0 if \fIstr1\fR is equal to \fIstr2\fR or a positive value if \fIstr1\fR is greater than \fIstr2\fR.
.PP
Special case I: Returns 0 if \fIstr1\fR and \fIstr2\fR are both 0.
.PP
Special case II: Returns a random nonzero value if \fIstr1\fR is 0 or \fIstr2\fR is 0 (but not both).
.PP
See also qstrcmp(), qstricmp(), qstrnicmp(), and Note on character comparisons.
.SH "char * qstrncpy ( char * dst, const char * src, uint len )"
A safe strncpy() function.
.PP
Copies at most \fIlen\fR bytes from \fIsrc\fR (stopping at \fIlen\fR or the terminating '&#92;0' whichever comes first) into \fIdst\fR and returns a pointer to \fIdst\fR. Guarantees that \fIdst\fR is '&#92;0'-terminated. If \fIsrc\fR or \fIdst\fR is 0, returns 0 immediately.
.PP
See also qstrcpy().
.SH "int qstrnicmp ( const char * str1, const char * str2, uint len )"
A safe strnicmp() function.
.PP
Compares at most \fIlen\fR bytes of \fIstr1\fR and \fIstr2\fR ignoring the case.
.PP
Returns a negative value if \fIstr1\fR is less than \fIstr2\fR, 0 if \fIstr1\fR is equal to \fIstr2\fR or a positive value if \fIstr1\fR is greater than \fIstr2\fR.
.PP
Special case I: Returns 0 if \fIstr1\fR and \fIstr2\fR are both 0.
.PP
Special case II: Returns a random nonzero value if \fIstr1\fR is 0 or \fIstr2\fR is 0 (but not both).
.PP
See also qstrcmp(), qstrncmp(), qstricmp(), and Note on character comparisons.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qcstring.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qcstring.3qt) and the Qt
version (3.3.8).
