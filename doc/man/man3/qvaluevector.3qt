'\" t
.TH QValueVector 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QValueVector \- Value-based template class that provides a dynamic array
.SH SYNOPSIS
All the functions in this class are reentrant when Qt is built with thread support.</p>
.PP
\fC#include <qvaluevector.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "typedef T \fBvalue_type\fR"
.br
.ti -1c
.BI "typedef value_type * \fBpointer\fR"
.br
.ti -1c
.BI "typedef const value_type * \fBconst_pointer\fR"
.br
.ti -1c
.BI "typedef value_type * \fBiterator\fR"
.br
.ti -1c
.BI "typedef const value_type * \fBconst_iterator\fR"
.br
.ti -1c
.BI "typedef value_type & \fBreference\fR"
.br
.ti -1c
.BI "typedef const value_type & \fBconst_reference\fR"
.br
.ti -1c
.BI "typedef size_t \fBsize_type\fR"
.br
.ti -1c
.BI "typedef ptrdiff_t \fBdifference_type\fR"
.br
.ti -1c
.BI "\fBQValueVector\fR ()"
.br
.ti -1c
.BI "\fBQValueVector\fR ( const QValueVector<T> & v )"
.br
.ti -1c
.BI "\fBQValueVector\fR ( size_type n, const T & val = T ( ) )"
.br
.ti -1c
.BI "\fBQValueVector\fR ( std::vector<T> & v )"
.br
.ti -1c
.BI "\fBQValueVector\fR ( const std::vector<T> & v )"
.br
.ti -1c
.BI "\fB~QValueVector\fR ()"
.br
.ti -1c
.BI "QValueVector<T> & \fBoperator=\fR ( const QValueVector<T> & v )"
.br
.ti -1c
.BI "QValueVector<T> & \fBoperator=\fR ( const std::vector<T> & v )"
.br
.ti -1c
.BI "size_type \fBsize\fR () const"
.br
.ti -1c
.BI "bool \fBempty\fR () const"
.br
.ti -1c
.BI "size_type \fBcapacity\fR () const"
.br
.ti -1c
.BI "iterator \fBbegin\fR ()"
.br
.ti -1c
.BI "const_iterator \fBbegin\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstBegin\fR () const"
.br
.ti -1c
.BI "iterator \fBend\fR ()"
.br
.ti -1c
.BI "const_iterator \fBend\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstEnd\fR () const"
.br
.ti -1c
.BI "reference \fBat\fR ( size_type i, bool * ok = 0 )"
.br
.ti -1c
.BI "const_reference \fBat\fR ( size_type i, bool * ok = 0 ) const"
.br
.ti -1c
.BI "reference \fBoperator[]\fR ( size_type i )"
.br
.ti -1c
.BI "const_reference \fBoperator[]\fR ( size_type i ) const"
.br
.ti -1c
.BI "reference \fBfront\fR ()"
.br
.ti -1c
.BI "const_reference \fBfront\fR () const"
.br
.ti -1c
.BI "reference \fBback\fR ()"
.br
.ti -1c
.BI "const_reference \fBback\fR () const"
.br
.ti -1c
.BI "void \fBpush_back\fR ( const T & x )"
.br
.ti -1c
.BI "void \fBpop_back\fR ()"
.br
.ti -1c
.BI "iterator \fBinsert\fR ( iterator pos, const T & x )"
.br
.ti -1c
.BI "iterator \fBinsert\fR ( iterator pos, size_type n, const T & x )"
.br
.ti -1c
.BI "void \fBreserve\fR ( size_type n )"
.br
.ti -1c
.BI "void \fBresize\fR ( size_type n, const T & val = T ( ) )"
.br
.ti -1c
.BI "void \fBclear\fR ()"
.br
.ti -1c
.BI "iterator \fBerase\fR ( iterator pos )"
.br
.ti -1c
.BI "iterator \fBerase\fR ( iterator first, iterator last )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QValueVector<T> & x )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QValueVector<T> & x ) const"
.br
.ti -1c
.BI "typedef T \fBValueType\fR"
.br
.ti -1c
.BI "typedef ValueType * \fBIterator\fR"
.br
.ti -1c
.BI "typedef const ValueType * \fBConstIterator\fR"
.br
.ti -1c
.BI "size_type \fBcount\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "reference \fBfirst\fR ()"
.br
.ti -1c
.BI "const_reference \fBfirst\fR () const"
.br
.ti -1c
.BI "reference \fBlast\fR ()"
.br
.ti -1c
.BI "const_reference \fBlast\fR () const"
.br
.ti -1c
.BI "void \fBappend\fR ( const T & x )"
.br
.in -1c
.SH DESCRIPTION
The QValueVector class is a value-based template class that provides a dynamic array.
.PP
QValueVector is a Qt implementation of an STL-like vector container. It can be used in your application if the standard \fCvector\fR is not available for your target platforms. QValueVector is part of the Qt Template Library.
.PP
QValueVector<T> defines a template instance to create a vector of values that all have the class T. QValueVector does not store pointers to the members of the vector; it holds a copy of every member. QValueVector is said to be value based; in contrast, QPtrList and QDict are pointer based.
.PP
QValueVector contains and manages a collection of objects of type T and provides random access iterators that allow the contained objects to be addressed. QValueVector owns the contained elements. For more relaxed ownership semantics, see QPtrCollection and friends, which are pointer-based containers.
.PP
QValueVector provides good performance if you append or remove elements from the end of the vector. If you insert or remove elements from anywhere but the end, performance is very bad. The reason for this is that elements must to be copied into new positions.
.PP
Some classes cannot be used within a QValueVector: for example, all classes derived from QObject and thus all classes that implement widgets. Only values can be used in a QValueVector. To qualify as a value the class must provide:
.TP
a copy constructor;
.TP
an assignment operator;
.TP
a default constructor, i.e., a constructor that does not take any arguments.
.PP
Note that C++ defaults to field-by-field assignment operators and copy constructors if no explicit version is supplied. In many cases this is sufficient.
.PP
QValueVector uses an STL-like syntax to manipulate and address the objects it contains. See this document for more information.
.PP
Example:
.PP
.nf
.br
    #include <qvaluevector.h>
.br
    #include <qstring.h>
.br
    #include <stdio.h>
.br
.br
    class Employee
.br
    {
.br
    public:
.br
        Employee(): s(0) {}
.br
        Employee( const QString& name, int salary )
.br
            : n( name ), s( salary )
.br
        { }
.br
.br
        QString name()   const          { return n; }
.br
        int     salary() const          { return s; }
.br
        void    setSalary( int salary ) { s = salary; }
.br
    private:
.br
        QString n;
.br
        int     s;
.br
    };
.br
.br
    int main()
.br
    {
.br
        typedef QValueVector<Employee> EmployeeVector;
.br
        EmployeeVector vec( 3 );  // vector of 3 Employees
.br
.br
        vec[0] = Employee( "Bill", 50000 );
.br
        vec[1] = Employee( "Steve", 80000 );
.br
        vec[2] = Employee( "Ron", 60000 );
.br
.br
        Employee joe( "Joe", 50000 );
.br
        vec.push_back( joe );  // vector expands to accommodate 4 Employees
.br
        joe.setSalary( 70000 );
.br
.br
.br
        EmployeeVector::iterator it;
.br
        for( it = vec.begin(); it != vec.end(); ++it )
.br
            printf( "%s earns %d\\n", (*it).name().latin1(), (*it).salary() );
.br
.br
        return 0;
.br
    }
.br
.fi
.PP
Program output:
.PP
.nf
.br
        Bill earns 50000
.br
        Steve earns 80000
.br
        Ron earns 60000
.br
        Joe earns 50000
.br
.fi
.PP
As you can see, the most recent change to Joe's salary did not affect the value in the vector because the vector created a copy of Joe's entry.
.PP
Many Qt functions return const value vectors; to iterate over these you should make a copy and iterate over the copy.
.PP
There are several ways to find items in the vector. The begin() and end() functions return iterators to the beginning and end of the vector. The advantage of getting an iterator is that you can move forward or backward from this position by incrementing/decrementing the iterator. The iterator returned by end() points to the element which is one past the last element in the container. The past-the-end iterator is still associated with the vector it belongs to, however it is \fInot\fR dereferenceable; operator*() will not return a well-defined value. If the vector is empty(), the iterator returned by begin() will equal the iterator returned by end().
.PP
The fastest way to access an element of a vector is by using operator[]. This function provides random access and will return a reference to the element located at the specified index. Thus, you can access every element directly, in constant time, providing you know the location of the element. It is undefined to access an element that does not exist (your application will probably crash). For example:
.PP
.nf
.br
    QValueVector<int> vec1;  // an empty vector
.br
    vec1[10] = 4;  // WARNING: undefined, probably a crash
.br
.br
    QValueVector<QString> vec2(25); // initialize with 25 elements
.br
    vec2[10] = "Dave";  // OK
.br
.fi
.PP
Whenever inserting, removing or referencing elements in a vector, always make sure you are referring to valid positions. For example:
.PP
.nf
.br
    void func( QValueVector<int>& vec )
.br
    {
.br
        if ( vec.size() > 10 ) {
.br
            vec[9] = 99; // OK
.br
        }
.br
    };
.br
.fi
.PP
The iterators provided by vector are random access iterators, therefore you can use them with many generic algorithms, for example, algorithms provided by the STL or the QTL.
.PP
Another way to find an element in the vector is by using the std::find() or qFind() algorithms. For example:
.PP
.nf
.br
    QValueVector<int> vec;
.br
    ...
.br
    QValueVector<int>::const_iterator it = qFind( vec.begin(), vec.end(), 3 );
.br
    if ( it != vector.end() )
.br
        // 'it' points to the found element
.br
.fi
.PP
It is safe to have multiple iterators on the vector at the same time. Since QValueVector manages memory dynamically, all iterators can become invalid if a memory reallocation occurs. For example, if some member of the vector is removed, iterators that point to the removed element and to all following elements become invalidated. Inserting into the middle of the vector will invalidate all iterators. For convenience, the function back() returns a reference to the last element in the vector, and front() returns a reference to the first element. If the vector is empty(), both back() and front() have undefined behavior (your application will crash or do unpredictable things). Use back() and front() with caution, for example:
.PP
.nf
.br
    QValueVector<int> vec( 3 );
.br
    vec.push_back( 1 );
.br
    vec.push_back( 2 );
.br
    vec.push_back( 3 );
.br
    ...
.br
    if ( !vec.empty() ) {
.br
        // OK: modify the first element
.br
        int& i = vec.front();
.br
        i = 18;
.br
    }
.br
    ...
.br
    QValueVector<double> dvec;
.br
    double d = dvec.back(); // undefined behavior
.br
.fi
.PP
Because QValueVector manages memory dynamically, it is recommended that you contruct a vector with an initial size. Inserting and removing elements happens fastest when:
.TP
Inserting or removing elements happens at the end() of the vector;
.TP
The vector does not need to allocate additional memory.
.PP
By creating a QValueVector with a sufficiently large initial size, there will be less memory allocations. Do not use an initial size that is too big, since it will still take time to construct all the empty entries, and the extra space will be wasted if it is never used.
.PP
Because QValueVector is value-based there is no need to be careful about deleting elements in the vector. The vector holds its own copies and will free them if the corresponding member or the vector itself is deleted. You can force the vector to free all of its items with clear().
.PP
QValueVector is shared implicitly, which means it can be copied in constant time. If multiple QValueVector instances share the same data and one needs to modify its contents, this modifying instance makes a copy and modifies its private copy; it thus does not affect the other instances. This is often called "copy on write". If a QValueVector is being used in a multi-threaded program, you must protect all access to the vector. See QMutex.
.PP
There are several ways to insert elements into the vector. The push_back() function insert elements into the end of the vector, and is usually fastest. The insert() function can be used to add elements at specific positions within the vector.
.PP
Items can be also be removed from the vector in several ways. There are several variants of the erase() function which removes a specific element, or range of elements, from the vector.
.PP
Vectors can be also sorted with various STL algorithms , or it can be sorted using the Qt Template Library. For example with qHeapSort():
.PP
Example:
.PP
.nf
.br
    QValueVector<int> v( 4 );
.br
    v.push_back( 5 );
.br
    v.push_back( 8 );
.br
    v.push_back( 3 );
.br
    v.push_back( 4 );
.br
    qHeapSort( v );
.br
.fi
.PP
QValueVector stores its elements in contiguous memory. This means that you can use a QValueVector in any situation that requires an array.
.PP
See also Qt Template Library Classes, Implicitly and Explicitly Shared Classes, and Non-GUI Classes.
.SS "Member Type Documentation"
.SH "QValueVector::ConstIterator"
The vector's const iterator type.
.SH "QValueVector::Iterator"
The vector's iterator type.
.SH "QValueVector::ValueType"
The type of the object stored in the vector.
.SH "QValueVector::const_iterator"
The vector's const iterator type.
.SH "QValueVector::const_pointer"
The const pointer to T type.
.SH "QValueVector::const_reference"
The const reference to T type.
.SH "QValueVector::difference_type"
A signed integral type used to represent the distance between two iterators.
.SH "QValueVector::iterator"
The vector's iterator type.
.SH "QValueVector::pointer"
The pointer to T type.
.SH "QValueVector::reference"
The reference to T type.
.SH "QValueVector::size_type"
An unsigned integral type, used to represent various sizes.
.SH "QValueVector::value_type"
The type of the object stored in the vector.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QValueVector::QValueVector ()"
Constructs an empty vector without any elements. To create a vector which reserves an initial amount of space for elements, use \fCQValueVector(size_type n)\fR.
.SH "QValueVector::QValueVector ( const QValueVector<T> & v )"
Constructs a copy of \fIv\fR.
.PP
This operation costs O(1) time because QValueVector is implicitly shared.
.PP
The first modification to the vector does takes O(n) time, because the elements must be copied.
.SH "QValueVector::QValueVector ( size_type n, const T & val = T ( ) )"
Constructs a vector with an initial size of \fIn\fR elements. Each element is initialized with the value of \fIval\fR.
.SH "QValueVector::QValueVector ( std::vector<T> & v )"
Constructs a copy of \fIv\fR.
.SH "QValueVector::QValueVector ( const std::vector<T> & v )"
This operation costs O(n) time because \fIv\fR is copied.
.SH "QValueVector::~QValueVector ()"
Destroys the vector, destroying all elements and freeing the allocated memory. References to the values in the vector and all iterators of this vector become invalidated. Note that it is impossible for an iterator to check whether or not it is valid: QValueVector is tuned for performance, not for error checking.
.SH "void QValueVector::append ( const T & x )"
Appends a copy of \fIx\fR to the end of the vector.
.PP
See also push_back() and insert().
.SH "reference QValueVector::at ( size_type i, bool * ok = 0 )"
Returns a reference to the element with index \fIi\fR. If \fIok\fR is non-null, and the index \fIi\fR is out of range, *\fIok\fR is set to FALSE and the returned reference is undefined. If the index \fIi\fR is within the range of the vector, and \fIok\fR is non-null, *\fIok\fR is set to TRUE and the returned reference is well defined.
.SH "const_reference QValueVector::at ( size_type i, bool * ok = 0 ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const reference to the element with index \fIi\fR. If \fIok\fR is non-null, and the index \fIi\fR is out of range, *\fIok\fR is set to FALSE and the returned reference is undefined. If the index \fIi\fR is within the range of the vector, and \fIok\fR is non-null, *\fIok\fR is set to TRUE and the returned reference is well defined.
.SH "reference QValueVector::back ()"
Returns a reference to the last element in the vector. If there is no last element, this function has undefined behavior.
.PP
See also empty() and front().
.SH "const_reference QValueVector::back () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const reference to the last element in the vector. If there is no last element, this function has undefined behavior.
.PP
See also empty() and front().
.SH "iterator QValueVector::begin ()"
Returns an iterator pointing to the beginning of the vector. If the vector is empty(), the returned iterator will equal end().
.SH "const_iterator QValueVector::begin () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const iterator pointing to the beginning of the vector. If the vector is empty(), the returned iterator will equal end().
.SH "size_type QValueVector::capacity () const"
Returns the maximum number of elements that can be stored in the vector without forcing memory reallocation. If memory reallocation takes place, some or all iterators may become invalidated.
.SH "void QValueVector::clear ()"
Removes all the elements from the vector.
.SH "const_iterator QValueVector::constBegin () const"
Returns a const iterator pointing to the beginning of the vector. If the vector is empty(), the returned iterator will equal end().
.PP
See also constEnd().
.SH "const_iterator QValueVector::constEnd () const"
Returns a const iterator pointing behind the last element of the vector.
.PP
See also constBegin().
.SH "size_type QValueVector::count () const"
Returns the number of items in the vector.
.PP
See also isEmpty().
.SH "bool QValueVector::empty () const"
Returns TRUE if the vector is empty; otherwise returns FALSE. Equivalent to size()==0, only faster.
.PP
This function is provided for STL compatibility. It is equivalent to isEmpty().
.PP
See also size().
.SH "iterator QValueVector::end ()"
Returns an iterator pointing behind the last element of the vector.
.SH "const_iterator QValueVector::end () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const iterator pointing behind the last element of the vector.
.SH "iterator QValueVector::erase ( iterator pos )"
Removes the element at position \fIpos\fR and returns the position of the next element.
.SH "iterator QValueVector::erase ( iterator first, iterator last )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes all elements from \fIfirst\fR up to but not including \fIlast\fR and returns the position of the next element.
.SH "reference QValueVector::first ()"
Returns a reference to the first item in the vector. If there is no first item, this function has undefined behavior.
.PP
See also empty() and last().
.SH "const_reference QValueVector::first () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "reference QValueVector::front ()"
Returns a reference to the first element in the vector. If there is no first element, this function has undefined behavior.
.PP
See also empty() and back().
.SH "const_reference QValueVector::front () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const reference to the first element in the vector. If there is no first element, this function has undefined behavior.
.PP
See also empty() and back().
.SH "iterator QValueVector::insert ( iterator pos, const T & x )"
Inserts a copy of \fIx\fR at the position immediately before \fIpos\fR.
.PP
See also push_back().
.SH "iterator QValueVector::insert ( iterator pos, size_type n, const T & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIn\fR copies of \fIx\fR immediately before position x.
.PP
See also push_back().
.SH "bool QValueVector::isEmpty () const"
Returns TRUE if the vector is empty; returns FALSE otherwise.
.PP
See also count().
.SH "reference QValueVector::last ()"
Returns a reference to the last item in the vector. If there is no last item, this function has undefined behavior.
.PP
See also empty() and first().
.SH "const_reference QValueVector::last () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "QValueVector<T> & QValueVector::operator= ( const QValueVector<T> & v )"
Assigns \fIv\fR to this vector and returns a reference to this vector.
.PP
All iterators of the current vector become invalidated by this operation. The cost of such an assignment is O(1) since QValueVector is implicitly shared.
.SH "QValueVector<T> & QValueVector::operator= ( const std::vector<T> & v )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns \fIv\fR to this vector and returns a reference to this vector.
.PP
All iterators of the current vector become invalidated by this operation. The cost of this assignment is O(n) since \fIv\fR is copied.
.SH "bool QValueVector::operator== ( const QValueVector<T> & x ) const"
Returns TRUE if each element in this vector equals each corresponding element in \fIx\fR; otherwise returns FALSE.
.SH "bool QValueVector::operator== ( const QValueVector<T> & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if each element in this vector equals each corresponding element in \fIx\fR; otherwise returns FALSE.
.SH "reference QValueVector::operator[] ( size_type i )"
Returns a reference to the element at index \fIi\fR. If \fIi\fR is out of range, this function has undefined behavior.
.PP
See also at().
.SH "const_reference QValueVector::operator[] ( size_type i ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a const reference to the element at index \fIi\fR. If \fIi\fR is out of range, this function has undefined behavior.
.PP
See also at().
.SH "void QValueVector::pop_back ()"
Removes the last item from the vector.
.PP
This function is provided for STL compatibility.
.SH "void QValueVector::push_back ( const T & x )"
Appends a copy of \fIx\fR to the end of the vector. This is the fastest way to add new elements.
.PP
This function is provided for STL compatibility. It is equivalent to append().
.PP
See also insert().
.SH "void QValueVector::reserve ( size_type n )"
Increases the vector's capacity. If \fIn\fR is less than or equal to capacity(), nothing happens. Otherwise, additional memory is allocated so that capacity() will be increased to a value greater than or equal to \fIn\fR. All iterators will then become invalidated. Note that the vector's size() and the values of existing elements remain unchanged.
.SH "void QValueVector::resize ( size_type n, const T & val = T ( ) )"
Changes the size of the vector to \fIn\fR. If \fIn\fR is greater than the current size(), elements are added to the end and initialized with the value of \fIval\fR. If \fIn\fR is less than size(), elements are removed from the end. If \fIn\fR is equal to size() nothing happens.
.SH "size_type QValueVector::size () const"
Returns the number of elements in the vector.
.PP
This function is provided for STL compatibility. It is equivalent to count().
.PP
See also empty().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qvaluevector.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qvaluevector.3qt) and the Qt
version (3.3.8).
