'\" t
.TH QWidget 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QWidget \- The base class of all user interface objects
.SH SYNOPSIS
\fC#include <qwidget.h>\fR
.PP
Inherits QObject and QPaintDevice.
.PP
Inherited by QAxWidget, QButton, QFrame, QDialog, QComboBox, QDataBrowser, QDataView, QDateTimeEditBase, QDateTimeEdit, QDesktopWidget, QDial, QDockArea, QGLWidget, QHeader, QMainWindow, QMotifWidget, QNPWidget, QScrollBar, QSizeGrip, QSlider, QSpinBox, QSplashScreen, QStatusBar, QTabBar, QTabWidget, QWorkspace, and QXtWidget.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "explicit \fBQWidget\fR ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )"
.br
.ti -1c
.BI "\fB~QWidget\fR ()"
.br
.ti -1c
.BI "WId \fBwinId\fR () const"
.br
.ti -1c
.BI "QStyle & \fBstyle\fR () const"
.br
.ti -1c
.BI "void \fBsetStyle\fR ( QStyle * style )"
.br
.ti -1c
.BI "QStyle * \fBsetStyle\fR ( const QString & style )"
.br
.ti -1c
.BI "bool \fBisTopLevel\fR () const"
.br
.ti -1c
.BI "bool \fBisDialog\fR () const"
.br
.ti -1c
.BI "bool \fBisPopup\fR () const"
.br
.ti -1c
.BI "bool \fBisDesktop\fR () const"
.br
.ti -1c
.BI "bool \fBisModal\fR () const"
.br
.ti -1c
.BI "bool \fBisEnabled\fR () const"
.br
.ti -1c
.BI "bool \fBisEnabledTo\fR ( QWidget * ancestor ) const"
.br
.ti -1c
.BI "bool isEnabledToTLW () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QRect \fBframeGeometry\fR () const"
.br
.ti -1c
.BI "const QRect & \fBgeometry\fR () const"
.br
.ti -1c
.BI "int \fBx\fR () const"
.br
.ti -1c
.BI "int \fBy\fR () const"
.br
.ti -1c
.BI "QPoint \fBpos\fR () const"
.br
.ti -1c
.BI "QSize \fBframeSize\fR () const"
.br
.ti -1c
.BI "QSize \fBsize\fR () const"
.br
.ti -1c
.BI "int \fBwidth\fR () const"
.br
.ti -1c
.BI "int \fBheight\fR () const"
.br
.ti -1c
.BI "QRect \fBrect\fR () const"
.br
.ti -1c
.BI "QRect \fBchildrenRect\fR () const"
.br
.ti -1c
.BI "QRegion \fBchildrenRegion\fR () const"
.br
.ti -1c
.BI "QSize \fBminimumSize\fR () const"
.br
.ti -1c
.BI "QSize \fBmaximumSize\fR () const"
.br
.ti -1c
.BI "int \fBminimumWidth\fR () const"
.br
.ti -1c
.BI "int \fBminimumHeight\fR () const"
.br
.ti -1c
.BI "int \fBmaximumWidth\fR () const"
.br
.ti -1c
.BI "int \fBmaximumHeight\fR () const"
.br
.ti -1c
.BI "void \fBsetMinimumSize\fR ( const QSize & )"
.br
.ti -1c
.BI "virtual void \fBsetMinimumSize\fR ( int minw, int minh )"
.br
.ti -1c
.BI "void \fBsetMaximumSize\fR ( const QSize & )"
.br
.ti -1c
.BI "virtual void \fBsetMaximumSize\fR ( int maxw, int maxh )"
.br
.ti -1c
.BI "void \fBsetMinimumWidth\fR ( int minw )"
.br
.ti -1c
.BI "void \fBsetMinimumHeight\fR ( int minh )"
.br
.ti -1c
.BI "void \fBsetMaximumWidth\fR ( int maxw )"
.br
.ti -1c
.BI "void \fBsetMaximumHeight\fR ( int maxh )"
.br
.ti -1c
.BI "QSize \fBsizeIncrement\fR () const"
.br
.ti -1c
.BI "void \fBsetSizeIncrement\fR ( const QSize & )"
.br
.ti -1c
.BI "virtual void \fBsetSizeIncrement\fR ( int w, int h )"
.br
.ti -1c
.BI "QSize \fBbaseSize\fR () const"
.br
.ti -1c
.BI "void \fBsetBaseSize\fR ( const QSize & )"
.br
.ti -1c
.BI "void \fBsetBaseSize\fR ( int basew, int baseh )"
.br
.ti -1c
.BI "void \fBsetFixedSize\fR ( const QSize & s )"
.br
.ti -1c
.BI "void \fBsetFixedSize\fR ( int w, int h )"
.br
.ti -1c
.BI "void \fBsetFixedWidth\fR ( int w )"
.br
.ti -1c
.BI "void \fBsetFixedHeight\fR ( int h )"
.br
.ti -1c
.BI "QPoint \fBmapToGlobal\fR ( const QPoint & pos ) const"
.br
.ti -1c
.BI "QPoint \fBmapFromGlobal\fR ( const QPoint & pos ) const"
.br
.ti -1c
.BI "QPoint \fBmapToParent\fR ( const QPoint & pos ) const"
.br
.ti -1c
.BI "QPoint \fBmapFromParent\fR ( const QPoint & pos ) const"
.br
.ti -1c
.BI "QPoint \fBmapTo\fR ( QWidget * parent, const QPoint & pos ) const"
.br
.ti -1c
.BI "QPoint \fBmapFrom\fR ( QWidget * parent, const QPoint & pos ) const"
.br
.ti -1c
.BI "QWidget * \fBtopLevelWidget\fR () const"
.br
.ti -1c
.BI "BackgroundMode \fBbackgroundMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundMode\fR ( BackgroundMode )"
.br
.ti -1c
.BI "void \fBsetBackgroundMode\fR ( BackgroundMode m, BackgroundMode visual )"
.br
.ti -1c
.BI "const QColor & \fBforegroundColor\fR () const"
.br
.ti -1c
.BI "const QColor & \fBeraseColor\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetEraseColor\fR ( const QColor & color )"
.br
.ti -1c
.BI "const QPixmap * \fBerasePixmap\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetErasePixmap\fR ( const QPixmap & pixmap )"
.br
.ti -1c
.BI "const QColorGroup & \fBcolorGroup\fR () const"
.br
.ti -1c
.BI "const QPalette & \fBpalette\fR () const"
.br
.ti -1c
.BI "bool \fBownPalette\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetPalette\fR ( const QPalette & )"
.br
.ti -1c
.BI "void \fBunsetPalette\fR ()"
.br
.ti -1c
.BI "const QColor & \fBpaletteForegroundColor\fR () const"
.br
.ti -1c
.BI "void \fBsetPaletteForegroundColor\fR ( const QColor & )"
.br
.ti -1c
.BI "const QColor & \fBpaletteBackgroundColor\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetPaletteBackgroundColor\fR ( const QColor & )"
.br
.ti -1c
.BI "const QPixmap * \fBpaletteBackgroundPixmap\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetPaletteBackgroundPixmap\fR ( const QPixmap & )"
.br
.ti -1c
.BI "const QBrush & \fBbackgroundBrush\fR () const"
.br
.ti -1c
.BI "QFont \fBfont\fR () const"
.br
.ti -1c
.BI "bool \fBownFont\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFont\fR ( const QFont & )"
.br
.ti -1c
.BI "void \fBunsetFont\fR ()"
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR () const"
.br
.ti -1c
.BI "QFontInfo \fBfontInfo\fR () const"
.br
.ti -1c
.BI "const QCursor & \fBcursor\fR () const"
.br
.ti -1c
.BI "bool \fBownCursor\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCursor\fR ( const QCursor & )"
.br
.ti -1c
.BI "virtual void \fBunsetCursor\fR ()"
.br
.ti -1c
.BI "QString \fBcaption\fR () const"
.br
.ti -1c
.BI "const QPixmap * \fBicon\fR () const"
.br
.ti -1c
.BI "QString \fBiconText\fR () const"
.br
.ti -1c
.BI "bool \fBhasMouseTracking\fR () const"
.br
.ti -1c
.BI "bool \fBhasMouse\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMask\fR ( const QBitmap & bitmap )"
.br
.ti -1c
.BI "virtual void \fBsetMask\fR ( const QRegion & region )"
.br
.ti -1c
.BI "void \fBclearMask\fR ()"
.br
.ti -1c
.BI "const QColor & backgroundColor () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void setBackgroundColor ( const QColor & c )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "const QPixmap * backgroundPixmap () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void setBackgroundPixmap ( const QPixmap & pm )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "enum \fBFocusPolicy\fR { NoFocus = 0, TabFocus = 0x1, ClickFocus = 0x2, StrongFocus = TabFocus | ClickFocus | 0x8, WheelFocus = StrongFocus | 0x4 }"
.br
.ti -1c
.BI "bool \fBisActiveWindow\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetActiveWindow\fR ()"
.br
.ti -1c
.BI "bool \fBisFocusEnabled\fR () const"
.br
.ti -1c
.BI "FocusPolicy \fBfocusPolicy\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFocusPolicy\fR ( FocusPolicy )"
.br
.ti -1c
.BI "bool \fBhasFocus\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFocusProxy\fR ( QWidget * w )"
.br
.ti -1c
.BI "QWidget * \fBfocusProxy\fR () const"
.br
.ti -1c
.BI "void \fBsetInputMethodEnabled\fR ( bool b )"
.br
.ti -1c
.BI "bool \fBisInputMethodEnabled\fR () const"
.br
.ti -1c
.BI "void \fBgrabMouse\fR ()"
.br
.ti -1c
.BI "void \fBgrabMouse\fR ( const QCursor & cursor )"
.br
.ti -1c
.BI "void \fBreleaseMouse\fR ()"
.br
.ti -1c
.BI "void \fBgrabKeyboard\fR ()"
.br
.ti -1c
.BI "void \fBreleaseKeyboard\fR ()"
.br
.ti -1c
.BI "bool \fBisUpdatesEnabled\fR () const"
.br
.ti -1c
.BI "virtual bool \fBclose\fR ( bool alsoDelete )"
.br
.ti -1c
.BI "bool \fBisVisible\fR () const"
.br
.ti -1c
.BI "bool \fBisVisibleTo\fR ( QWidget * ancestor ) const"
.br
.ti -1c
.BI "bool isVisibleToTLW () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "QRect visibleRect () const  \fI(obsolete)\fR"
.br
.ti -1c
.BI "bool \fBisHidden\fR () const"
.br
.ti -1c
.BI "bool \fBisShown\fR () const"
.br
.ti -1c
.BI "bool \fBisMinimized\fR () const"
.br
.ti -1c
.BI "bool \fBisMaximized\fR () const"
.br
.ti -1c
.BI "bool \fBisFullScreen\fR () const"
.br
.ti -1c
.BI "uint \fBwindowState\fR () const"
.br
.ti -1c
.BI "void \fBsetWindowState\fR ( uint windowState )"
.br
.ti -1c
.BI "virtual QSize \fBsizeHint\fR () const"
.br
.ti -1c
.BI "virtual QSize \fBminimumSizeHint\fR () const"
.br
.ti -1c
.BI "virtual QSizePolicy \fBsizePolicy\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetSizePolicy\fR ( QSizePolicy )"
.br
.ti -1c
.BI "void \fBsetSizePolicy\fR ( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE )"
.br
.ti -1c
.BI "virtual int \fBheightForWidth\fR ( int w ) const"
.br
.ti -1c
.BI "QRegion \fBclipRegion\fR () const"
.br
.ti -1c
.BI "QLayout * \fBlayout\fR () const"
.br
.ti -1c
.BI "void \fBupdateGeometry\fR ()"
.br
.ti -1c
.BI "virtual void \fBreparent\fR ( QWidget * parent, WFlags f, const QPoint & p, bool showIt = FALSE )"
.br
.ti -1c
.BI "void \fBreparent\fR ( QWidget * parent, const QPoint & p, bool showIt = FALSE )"
.br
.ti -1c
.BI "void recreate ( QWidget * parent, WFlags f, const QPoint & p, bool showIt = FALSE )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBerase\fR ()"
.br
.ti -1c
.BI "void \fBerase\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBerase\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBerase\fR ( const QRegion & reg )"
.br
.ti -1c
.BI "void \fBscroll\fR ( int dx, int dy )"
.br
.ti -1c
.BI "void \fBscroll\fR ( int dx, int dy, const QRect & r )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( int x, int y, const QString & str )"
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QPoint & pos, const QString & str )"
.br
.ti -1c
.BI "QWidget * \fBfocusWidget\fR () const"
.br
.ti -1c
.BI "QRect \fBmicroFocusHint\fR () const"
.br
.ti -1c
.BI "bool \fBacceptDrops\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAcceptDrops\fR ( bool on )"
.br
.ti -1c
.BI "virtual void \fBsetAutoMask\fR ( bool )"
.br
.ti -1c
.BI "bool \fBautoMask\fR () const"
.br
.ti -1c
.BI "enum \fBBackgroundOrigin\fR { WidgetOrigin, ParentOrigin, WindowOrigin, AncestorOrigin }"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundOrigin\fR ( BackgroundOrigin )"
.br
.ti -1c
.BI "BackgroundOrigin \fBbackgroundOrigin\fR () const"
.br
.ti -1c
.BI "virtual bool \fBcustomWhatsThis\fR () const"
.br
.ti -1c
.BI "QWidget * \fBparentWidget\fR ( bool sameWindow = FALSE ) const"
.br
.ti -1c
.BI "WFlags \fBtestWFlags\fR ( WFlags f ) const"
.br
.ti -1c
.BI "QWidget * \fBchildAt\fR ( int x, int y, bool includeThis = FALSE ) const"
.br
.ti -1c
.BI "QWidget * \fBchildAt\fR ( const QPoint & p, bool includeThis = FALSE ) const"
.br
.ti -1c
.BI "void \fBsetWindowOpacity\fR ( double level )"
.br
.ti -1c
.BI "double \fBwindowOpacity\fR () const"
.br
.ti -1c
.BI "void setPalette ( const QPalette & p, bool )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void setFont ( const QFont & f, bool )  \fI(obsolete)\fR"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBsetEnabled\fR ( bool )"
.br
.ti -1c
.BI "void \fBsetDisabled\fR ( bool disable )"
.br
.ti -1c
.BI "virtual void \fBsetCaption\fR ( const QString & )"
.br
.ti -1c
.BI "virtual void \fBsetIcon\fR ( const QPixmap & )"
.br
.ti -1c
.BI "virtual void \fBsetIconText\fR ( const QString & )"
.br
.ti -1c
.BI "virtual void \fBsetMouseTracking\fR ( bool enable )"
.br
.ti -1c
.BI "virtual void \fBsetFocus\fR ()"
.br
.ti -1c
.BI "void \fBclearFocus\fR ()"
.br
.ti -1c
.BI "virtual void \fBsetUpdatesEnabled\fR ( bool enable )"
.br
.ti -1c
.BI "void \fBupdate\fR ()"
.br
.ti -1c
.BI "void \fBupdate\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBupdate\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBrepaint\fR ()"
.br
.ti -1c
.BI "void \fBrepaint\fR ( bool erase )"
.br
.ti -1c
.BI "void \fBrepaint\fR ( int x, int y, int w, int h, bool erase = TRUE )"
.br
.ti -1c
.BI "void \fBrepaint\fR ( const QRect & r, bool erase = TRUE )"
.br
.ti -1c
.BI "void \fBrepaint\fR ( const QRegion & reg, bool erase = TRUE )"
.br
.ti -1c
.BI "virtual void \fBshow\fR ()"
.br
.ti -1c
.BI "virtual void \fBhide\fR ()"
.br
.ti -1c
.BI "void \fBsetShown\fR ( bool show )"
.br
.ti -1c
.BI "void \fBsetHidden\fR ( bool hide )"
.br
.ti -1c
.BI "void iconify ()  \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void \fBshowMinimized\fR ()"
.br
.ti -1c
.BI "virtual void \fBshowMaximized\fR ()"
.br
.ti -1c
.BI "void \fBshowFullScreen\fR ()"
.br
.ti -1c
.BI "virtual void \fBshowNormal\fR ()"
.br
.ti -1c
.BI "virtual void \fBpolish\fR ()"
.br
.ti -1c
.BI "void \fBconstPolish\fR () const"
.br
.ti -1c
.BI "bool \fBclose\fR ()"
.br
.ti -1c
.BI "void \fBraise\fR ()"
.br
.ti -1c
.BI "void \fBlower\fR ()"
.br
.ti -1c
.BI "void \fBstackUnder\fR ( QWidget * w )"
.br
.ti -1c
.BI "virtual void \fBmove\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBmove\fR ( const QPoint & )"
.br
.ti -1c
.BI "virtual void \fBresize\fR ( int w, int h )"
.br
.ti -1c
.BI "void \fBresize\fR ( const QSize & )"
.br
.ti -1c
.BI "virtual void \fBsetGeometry\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "virtual void \fBsetGeometry\fR ( const QRect & )"
.br
.ti -1c
.BI "virtual void \fBadjustSize\fR ()"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "void \fBsetTabOrder\fR ( QWidget * first, QWidget * second )"
.br
.ti -1c
.BI "QWidget * \fBmouseGrabber\fR ()"
.br
.ti -1c
.BI "QWidget * \fBkeyboardGrabber\fR ()"
.br
.ti -1c
.BI "QWidget * \fBfind\fR ( WId id )"
.br
.in -1c
.SS "Properties"
.in +1c
.ti -1c
.BI "bool \fBacceptDrops\fR - whether drop events are enabled for this widget"
.br
.ti -1c
.BI "bool \fBautoMask\fR - whether the auto mask feature is enabled for the widget"
.br
.ti -1c
.BI "QBrush \fBbackgroundBrush\fR - the widget's background brush  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "BackgroundMode \fBbackgroundMode\fR - the color role used for painting the background of the widget"
.br
.ti -1c
.BI "BackgroundOrigin \fBbackgroundOrigin\fR - the origin of the widget's background"
.br
.ti -1c
.BI "QSize \fBbaseSize\fR - the base size of the widget"
.br
.ti -1c
.BI "QString \fBcaption\fR - the window caption (title)"
.br
.ti -1c
.BI "QRect \fBchildrenRect\fR - the bounding rectangle of the widget's children  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QRegion \fBchildrenRegion\fR - the combined region occupied by the widget's children  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QColorGroup \fBcolorGroup\fR - the current color group of the widget palette  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QCursor \fBcursor\fR - the cursor shape for this widget"
.br
.ti -1c
.BI "bool \fBcustomWhatsThis\fR - whether the widget wants to handle What's This help manually  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBenabled\fR - whether the widget is enabled"
.br
.ti -1c
.BI "bool \fBfocus\fR - whether this widget (or its focus " "proxy" ") has the keyboard input focus  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBfocusEnabled\fR - whether the widget accepts keyboard focus  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "FocusPolicy \fBfocusPolicy\fR - the way the widget accepts keyboard focus"
.br
.ti -1c
.BI "QFont \fBfont\fR - the font currently set for the widget"
.br
.ti -1c
.BI "QRect \fBframeGeometry\fR - geometry of the widget relative to its parent including any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QSize \fBframeSize\fR - the size of the widget including any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBfullScreen\fR - whether the widget is full screen  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QRect \fBgeometry\fR - the geometry of the widget relative to its parent and excluding the window frame"
.br
.ti -1c
.BI "int \fBheight\fR - the height of the widget excluding any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBhidden\fR - whether the widget is explicitly hidden"
.br
.ti -1c
.BI "QPixmap \fBicon\fR - the widget's icon"
.br
.ti -1c
.BI "QString \fBiconText\fR - the widget's icon text"
.br
.ti -1c
.BI "bool \fBinputMethodEnabled\fR - enables or disables the use of input methods for this widget"
.br
.ti -1c
.BI "bool \fBisActiveWindow\fR - whether this widget is the active window  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBisDesktop\fR - whether the widget is a desktop " "widget" ", i.e. represents the desktop  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBisDialog\fR - whether the widget is a dialog widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBisModal\fR - whether the widget is a modal widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBisPopup\fR - whether the widget is a popup widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBisTopLevel\fR - whether the widget is a top-level widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBmaximized\fR - whether this widget is maximized  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBmaximumHeight\fR - the widget's maximum height"
.br
.ti -1c
.BI "QSize \fBmaximumSize\fR - the widget's maximum size"
.br
.ti -1c
.BI "int \fBmaximumWidth\fR - the widget's maximum width"
.br
.ti -1c
.BI "QRect \fBmicroFocusHint\fR - the currently set micro focus hint for this widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBminimized\fR - whether this widget is minimized (iconified)  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBminimumHeight\fR - the widget's minimum height"
.br
.ti -1c
.BI "QSize \fBminimumSize\fR - the widget's minimum size"
.br
.ti -1c
.BI "QSize \fBminimumSizeHint\fR - the recommended minimum size for the widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBminimumWidth\fR - the widget's minimum width"
.br
.ti -1c
.BI "bool \fBmouseTracking\fR - whether mouse tracking is enabled for the widget"
.br
.ti -1c
.BI "bool \fBownCursor\fR - whether the widget uses its own cursor  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBownFont\fR - whether the widget uses its own font  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBownPalette\fR - whether the widget uses its own palette  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QPalette \fBpalette\fR - the widget's palette"
.br
.ti -1c
.BI "QColor \fBpaletteBackgroundColor\fR - the background color of the widget"
.br
.ti -1c
.BI "QPixmap \fBpaletteBackgroundPixmap\fR - the background pixmap of the widget"
.br
.ti -1c
.BI "QColor \fBpaletteForegroundColor\fR - the foreground color of the widget"
.br
.ti -1c
.BI "QPoint \fBpos\fR - the position of the widget within its parent widget"
.br
.ti -1c
.BI "QRect \fBrect\fR - the internal geometry of the widget excluding any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBshown\fR - whether the widget is shown"
.br
.ti -1c
.BI "QSize \fBsize\fR - the size of the widget excluding any window frame"
.br
.ti -1c
.BI "QSize \fBsizeHint\fR - the recommended size for the widget  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QSize \fBsizeIncrement\fR - the size increment of the widget"
.br
.ti -1c
.BI "QSizePolicy \fBsizePolicy\fR - the default layout behavior of the widget"
.br
.ti -1c
.BI "bool \fBunderMouse\fR - whether the widget is under the mouse cursor  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBupdatesEnabled\fR - whether updates are enabled"
.br
.ti -1c
.BI "bool \fBvisible\fR - whether the widget is visible  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "QRect visibleRect - the visible rectangle  \fI(read " "only" ")\fR  \fI(obsolete)\fR"
.br
.ti -1c
.BI "int \fBwidth\fR - the width of the widget excluding any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "double \fBwindowOpacity\fR - the level of opacity for the window"
.br
.ti -1c
.BI "int \fBx\fR - the x coordinate of the widget relative to its parent including any window frame  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBy\fR - the y coordinate of the widget relative to its parent and including any window frame  \fI(read " "only" ")\fR"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual bool \fBevent\fR ( QEvent * e )"
.br
.ti -1c
.BI "virtual void \fBmousePressEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBmouseReleaseEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBmouseDoubleClickEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBmouseMoveEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBwheelEvent\fR ( QWheelEvent * e )"
.br
.ti -1c
.BI "virtual void \fBkeyPressEvent\fR ( QKeyEvent * e )"
.br
.ti -1c
.BI "virtual void \fBkeyReleaseEvent\fR ( QKeyEvent * e )"
.br
.ti -1c
.BI "virtual void \fBfocusInEvent\fR ( QFocusEvent * )"
.br
.ti -1c
.BI "virtual void \fBfocusOutEvent\fR ( QFocusEvent * )"
.br
.ti -1c
.BI "virtual void \fBenterEvent\fR ( QEvent * )"
.br
.ti -1c
.BI "virtual void \fBleaveEvent\fR ( QEvent * )"
.br
.ti -1c
.BI "virtual void \fBpaintEvent\fR ( QPaintEvent * )"
.br
.ti -1c
.BI "virtual void \fBmoveEvent\fR ( QMoveEvent * )"
.br
.ti -1c
.BI "virtual void \fBresizeEvent\fR ( QResizeEvent * )"
.br
.ti -1c
.BI "virtual void \fBcloseEvent\fR ( QCloseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontextMenuEvent\fR ( QContextMenuEvent * e )"
.br
.ti -1c
.BI "virtual void \fBimStartEvent\fR ( QIMEvent * e )"
.br
.ti -1c
.BI "virtual void \fBimComposeEvent\fR ( QIMEvent * e )"
.br
.ti -1c
.BI "virtual void \fBimEndEvent\fR ( QIMEvent * e )"
.br
.ti -1c
.BI "virtual void \fBtabletEvent\fR ( QTabletEvent * e )"
.br
.ti -1c
.BI "virtual void \fBdragEnterEvent\fR ( QDragEnterEvent * )"
.br
.ti -1c
.BI "virtual void \fBdragMoveEvent\fR ( QDragMoveEvent * )"
.br
.ti -1c
.BI "virtual void \fBdragLeaveEvent\fR ( QDragLeaveEvent * )"
.br
.ti -1c
.BI "virtual void \fBdropEvent\fR ( QDropEvent * )"
.br
.ti -1c
.BI "virtual void \fBshowEvent\fR ( QShowEvent * )"
.br
.ti -1c
.BI "virtual void \fBhideEvent\fR ( QHideEvent * )"
.br
.ti -1c
.BI "virtual bool \fBmacEvent\fR ( MSG * )"
.br
.ti -1c
.BI "virtual bool \fBwinEvent\fR ( MSG * )"
.br
.ti -1c
.BI "virtual bool \fBx11Event\fR ( XEvent * )"
.br
.ti -1c
.BI "virtual bool \fBqwsEvent\fR ( QWSEvent * )"
.br
.ti -1c
.BI "virtual void \fBupdateMask\fR ()"
.br
.ti -1c
.BI "virtual void \fBstyleChange\fR ( QStyle & oldStyle )"
.br
.ti -1c
.BI "virtual void \fBenabledChange\fR ( bool oldEnabled )"
.br
.ti -1c
.BI "virtual void \fBpaletteChange\fR ( const QPalette & oldPalette )"
.br
.ti -1c
.BI "virtual void \fBfontChange\fR ( const QFont & oldFont )"
.br
.ti -1c
.BI "virtual void \fBwindowActivationChange\fR ( bool oldActive )"
.br
.ti -1c
.BI "virtual int \fBmetric\fR ( int m ) const"
.br
.ti -1c
.BI "void \fBresetInputContext\fR ()"
.br
.ti -1c
.BI "virtual void \fBcreate\fR ( WId window = 0, bool initializeWindow = TRUE, bool destroyOldWindow = TRUE )"
.br
.ti -1c
.BI "virtual void \fBdestroy\fR ( bool destroyWindow = TRUE, bool destroySubWindows = TRUE )"
.br
.ti -1c
.BI "WFlags \fBgetWFlags\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetWFlags\fR ( WFlags f )"
.br
.ti -1c
.BI "void \fBclearWFlags\fR ( WFlags f )"
.br
.ti -1c
.BI "virtual bool \fBfocusNextPrevChild\fR ( bool next )"
.br
.ti -1c
.BI "QFocusData * \fBfocusData\fR ()"
.br
.ti -1c
.BI "virtual void \fBsetKeyCompression\fR ( bool compress )"
.br
.ti -1c
.BI "virtual void \fBsetMicroFocusHint\fR ( int x, int y, int width, int height, bool text = TRUE, QFont * f = 0 )"
.br
.in -1c
.SH DESCRIPTION
The QWidget class is the base class of all user interface objects.
.PP
The widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.
.PP
A widget that isn't embedded in a parent widget is called a top-level widget. Usually, top-level widgets are windows with a frame and a title bar (although it is also possible to create top-level widgets without such decoration if suitable widget flags are used). In Qt, QMainWindow and the various subclasses of QDialog are the most common top-level windows.
.PP
A widget without a parent widget is always a top-level widget.
.PP
Non-top-level widgets are child widgets. These are child windows in their parent widgets. You cannot usually distinguish a child widget from its parent visually. Most other widgets in Qt are useful only as child widgets. (It is possible to make, say, a button into a top-level widget, but most people prefer to put their buttons inside other widgets, e.g. QDialog.)
.PP
If you want to use a QWidget to hold child widgets you will probably want to add a layout to the parent QWidget. (See Layouts.)
.PP
QWidget has many member functions, but some of them have little direct functionality: for example, QWidget has a font property, but never uses this itself. There are many subclasses which provide real functionality, such as QPushButton, QListBox and QTabDialog, etc.
.SH "Groups of functions:"
<center>.nf
.TS
l - l. Context Functions Window functions show(), hide(), raise(), lower(), close(). Top level windows caption(), setCaption(), icon(), setIcon(), iconText(), setIconText(), isActiveWindow(), setActiveWindow(), showMinimized(). showMaximized(), showFullScreen(), showNormal(). Window contents update(), repaint(), erase(), scroll(), updateMask(). Geometry pos(), size(), rect(), x(), y(), width(), height(), sizePolicy(), setSizePolicy(), sizeHint(), updateGeometry(), layout(), move(), resize(), setGeometry(), frameGeometry(), geometry(), childrenRect(), adjustSize(), mapFromGlobal(), mapFromParent() mapToGlobal(), mapToParent(), maximumSize(), minimumSize(), sizeIncrement(), setMaximumSize(), setMinimumSize(), setSizeIncrement(), setBaseSize(), setFixedSize() Mode isVisible(), isVisibleTo(), isMinimized(), isDesktop(), isEnabled(), isEnabledTo(), isModal(), isPopup(), isTopLevel(), setEnabled(), hasMouseTracking(), setMouseTracking(), isUpdatesEnabled(), setUpdatesEnabled(), clipRegion(). Look and feel style(), setStyle(), cursor(), setCursor() font(), setFont(), palette(), setPalette(), backgroundMode(), setBackgroundMode(), colorGroup(), fontMetrics(), fontInfo(). Keyboard focus
.br
functions isFocusEnabled(), setFocusPolicy(), focusPolicy(), hasFocus(), setFocus(), clearFocus(), setTabOrder(), setFocusProxy(). Mouse and
.br
keyboard grabbing grabMouse(), releaseMouse(), grabKeyboard(), releaseKeyboard(), mouseGrabber(), keyboardGrabber(). Event handlers event(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), keyPressEvent(), keyReleaseEvent(), focusInEvent(), focusOutEvent(), wheelEvent(), enterEvent(), leaveEvent(), paintEvent(), moveEvent(), resizeEvent(), closeEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), childEvent(), showEvent(), hideEvent(), customEvent(). Change handlers enabledChange(), fontChange(), paletteChange(), styleChange(), windowActivationChange(). System functions parentWidget(), topLevelWidget(), reparent(), polish(), winId(), find(), metric(). What's this help customWhatsThis() Internal kernel
.br
functions
.TE
.fi
</center>
.PP
Every widget's constructor accepts two or three standard arguments: <ol type=1>
.IP 1
\fCQWidget *parent = 0\fR is the parent of the new widget. If it is 0 (the default), the new widget will be a top-level window. If not, it will be a child of \fIparent\fR, and be constrained by \fIparent\fR's geometry (unless you specify WType_TopLevel as widget flag).
.IP 2
\fCconst char *name = 0\fR is the widget name of the new widget. You can access it using name(). The widget name is little used by programmers but is quite useful with GUI builders such as \fIQt Designer\fR (you can name a widget in \fIQt Designer\fR, and connect() to it using the name in your code). The dumpObjectTree() debugging function also uses it.
.IP 3
\fCWFlags f = 0\fR (where available) sets the widget flags; the default is suitable for almost all widgets, but to get, for example, a top-level widget without a window system frame, you must use special flags.
.PP
The tictac/tictac.cpp example program is good example of a simple widget. It contains a few event handlers (as all widgets must), a few custom routines that are specific to it (as all useful widgets do), and has a few children and connections. Everything it does is done in response to an event: this is by far the most common way to design GUI applications.
.PP
You will need to supply the content for your widgets yourself, but here is a brief run-down of the events, starting with the most common ones:
.IP
.TP
paintEvent() - called whenever the widget needs to be repainted. Every widget which displays output must implement it, and it is wise \fInot\fR to paint on the screen outside paintEvent().
.IP
.TP
resizeEvent() - called when the widget has been resized.
.IP
.TP
mousePressEvent() - called when a mouse button is pressed. There are six mouse-related events, but the mouse press and mouse release events are by far the most important. A widget receives mouse press events when the mouse is inside it, or when it has grabbed the mouse using grabMouse().
.IP
.TP
mouseReleaseEvent() - called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside \fIyour\fR widget, then drags the mouse to somewhere else, then releases, \fIyour\fR widget receives the release event. There is one exception: if a popup menu appears while the mouse button is held down, this popup immediately steals the mouse events.
.IP
.TP
mouseDoubleClickEvent() - not quite as obvious as it might seem. If the user double-clicks, the widget receives a mouse press event (perhaps a mouse move event or two if they don't hold the mouse quite steady), a mouse release event and finally this event. It is \fInot possible\fR to distinguish a click from a double click until you've seen whether the second click arrives. (This is one reason why most GUI books recommend that double clicks be an extension of single clicks, rather than trigger a different action.)
.IP
.PP
If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's hasMouse() function inside the parent widget's mousePressEvent().
.PP
Widgets that accept keyboard input need to reimplement a few more event handlers:
.IP
.TP
keyPressEvent() - called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. Note that the Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
.IP
.TP
focusInEvent() - called when the widget gains keyboard focus (assuming you have called setFocusPolicy()). Well written widgets indicate that they own the keyboard focus in a clear but discreet way.
.IP
.TP
focusOutEvent() - called when the widget loses keyboard focus.
.IP
.PP
Some widgets will also need to reimplement some of the less common event handlers:
.IP
.TP
mouseMoveEvent() - called whenever the mouse moves while a button is held down. This is useful for, for example, dragging. If you call setMouseTracking(TRUE), you get mouse move events even when no buttons are held down. (Note that applications which make use of mouse tracking are often not very useful on low-bandwidth X connections.) (See also the drag and drop information.)
.IP
.TP
keyReleaseEvent() - called whenever a key is released, and also while it is held down if the key is auto-repeating. In that case the widget receives a key release event and immediately a key press event for every repeat. Note that the Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
.IP
.TP
wheelEvent() -- called whenever the user turns the mouse wheel while the widget has the focus.
.IP
.TP
enterEvent() - called when the mouse enters the widget's screen space. (This excludes screen space owned by any children of the widget.)
.IP
.TP
leaveEvent() - called when the mouse leaves the widget's screen space.
.IP
.TP
moveEvent() - called when the widget has been moved relative to its parent.
.IP
.TP
closeEvent() - called when the user closes the widget (or when close() is called).
.IP
.PP
There are also some rather obscure events. They are listed in qevent.h and you need to reimplement event() to handle them. The default implementation of event() handles Tab and Shift+Tab (to move the keyboard focus), and passes on most other events to one of the more specialized handlers above.
.PP
When implementing a widget, there are a few more things to consider.
.IP
.TP
In the constructor, be sure to set up your member variables early on, before there's any chance that you might receive an event.
.IP
.TP
It is almost always useful to reimplement sizeHint() and to set the correct size policy with setSizePolicy(), so users of your class can set up layout management more easily. A size policy lets you supply good defaults for the layout management handling, so that other widgets can contain and manage yours easily. sizeHint() indicates a "good" size for the widget.
.IP
.TP
If your widget is a top-level window, setCaption() and setIcon() set the title bar and icon respectively.
.IP
.PP
See also QEvent, QPainter, QGridLayout, QBoxLayout, and Abstract Widget Classes.
.SS "Member Type Documentation"
.SH "QWidget::BackgroundOrigin"
This enum defines the origin used to draw a widget's background pixmap.
.PP
The pixmap is drawn using the:
.TP
\fCQWidget::WidgetOrigin\fR - widget's coordinate system.
.TP
\fCQWidget::ParentOrigin\fR - parent's coordinate system.
.TP
\fCQWidget::WindowOrigin\fR - top-level window's coordinate system.
.TP
\fCQWidget::AncestorOrigin\fR - same origin as the parent uses.
.SH "QWidget::FocusPolicy"
This enum type defines the various policies a widget can have with respect to acquiring keyboard focus.
.TP
\fCQWidget::TabFocus\fR - the widget accepts focus by tabbing.
.TP
\fCQWidget::ClickFocus\fR - the widget accepts focus by clicking.
.TP
\fCQWidget::StrongFocus\fR - the widget accepts focus by both tabbing and clicking. On Mac OS X this will also be indicate that the widget accepts tab focus when in 'Text/List focus mode'.
.TP
\fCQWidget::WheelFocus\fR - like StrongFocus plus the widget accepts focus by using the mouse wheel.
.TP
\fCQWidget::NoFocus\fR - the widget does not accept focus.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.SH "explicit QWidget::QWidget ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )"
Constructs a widget which is a child of \fIparent\fR, with the name \fIname\fR and widget flags set to \fIf\fR.
.PP
If \fIparent\fR is 0, the new widget becomes a top-level window. If \fIparent\fR is another widget, this widget becomes a child window inside \fIparent\fR. The new widget is deleted when its \fIparent\fR is deleted.
.PP
The \fIname\fR is sent to the QObject constructor.
.PP
The widget flags argument, \fIf\fR, is normally 0, but it can be set to customize the window frame of a top-level widget (i.e. \fIparent\fR must be 0). To customize the frame, set the WStyle_Customize flag OR'ed with any of the Qt::WidgetFlags.
.PP
If you add a child widget to an already visible widget you must explicitly show the child to make it visible.
.PP
Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.
.PP
Example:
.PP
.nf
.br
    QLabel *splashScreen = new QLabel( 0, "mySplashScreen",
.br
                                WStyle_Customize | WStyle_Splash );
.br
.fi
.SH "QWidget::~QWidget ()"
Destroys the widget.
.PP
All this widget's children are deleted first. The application exits if this widget is the main widget.
.SH "bool QWidget::acceptDrops () const"
Returns TRUE if drop events are enabled for this widget; otherwise returns FALSE. See the "acceptDrops" property for details.
.SH "void QWidget::adjustSize ()\fC [virtual slot]\fR"
Adjusts the size of the widget to fit the contents.
.PP
Uses sizeHint() if valid (i.e if the size hint's width and height are >= 0), otherwise sets the size to the children rectangle (the union of all child widget geometries).
.PP
See also sizeHint and childrenRect.
.PP
Example: xform/xform.cpp.
.PP
Reimplemented in QMessageBox.
.SH "bool QWidget::autoMask () const"
Returns TRUE if the auto mask feature is enabled for the widget; otherwise returns FALSE. See the "autoMask" property for details.
.SH "const QBrush & QWidget::backgroundBrush () const"
Returns the widget's background brush. See the "backgroundBrush" property for details.
.SH "const QColor & QWidget::backgroundColor () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code. Use paletteBackgroundColor() or eraseColor() instead.
.SH "BackgroundMode QWidget::backgroundMode () const"
Returns the color role used for painting the background of the widget. See the "backgroundMode" property for details.
.SH "BackgroundOrigin QWidget::backgroundOrigin () const"
Returns the origin of the widget's background. See the "backgroundOrigin" property for details.
.SH "const QPixmap * QWidget::backgroundPixmap () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code. Use paletteBackgroundPixmap() or erasePixmap() instead.
.PP
Examples:
.)l themes/metal.cpp and themes/wood.cpp.
.SH "QSize QWidget::baseSize () const"
Returns the base size of the widget. See the "baseSize" property for details.
.SH "QString QWidget::caption () const"
Returns the window caption (title). See the "caption" property for details.
.SH "QWidget * QWidget::childAt ( int x, int y, bool includeThis = FALSE ) const"
Returns the visible child widget at pixel position \fI(x, y)\fR in the widget's own coordinate system.
.PP
If \fIincludeThis\fR is TRUE, and there is no child visible at \fI(x, y)\fR, the widget itself is returned.
.SH "QWidget * QWidget::childAt ( const QPoint & p, bool includeThis = FALSE ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the visible child widget at point \fIp\fR in the widget's own coordinate system.
.PP
If \fIincludeThis\fR is TRUE, and there is no child visible at \fIp\fR, the widget itself is returned.
.SH "QRect QWidget::childrenRect () const"
Returns the bounding rectangle of the widget's children. See the "childrenRect" property for details.
.SH "QRegion QWidget::childrenRegion () const"
Returns the combined region occupied by the widget's children. See the "childrenRegion" property for details.
.SH "void QWidget::clearFocus ()\fC [slot]\fR"
Takes keyboard input focus from the widget.
.PP
If the widget has active focus, a focus out event is sent to this widget to tell it that it is about to lose the focus.
.PP
This widget must enable focus setting in order to get the keyboard input focus, i.e. it must call setFocusPolicy().
.PP
See also focus, setFocus(), focusInEvent(), focusOutEvent(), focusPolicy, and QApplication::focusWidget().
.SH "void QWidget::clearMask ()"
Removes any mask set by setMask().
.PP
See also setMask().
.SH "void QWidget::clearWFlags ( WFlags f )\fC [protected]\fR"
Clears the widget flags \fIf\fR.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), getWFlags(), and setWFlags().
.SH "QRegion QWidget::clipRegion () const"
Returns the unobscured region where paint events can occur.
.PP
For visible widgets, this is an approximation of the area not covered by other widgets; otherwise, this is an empty region.
.PP
The repaint() function calls this function if necessary, so in general you do not need to call it.
.SH "bool QWidget::close ()\fC [slot]\fR"
Closes this widget. Returns TRUE if the widget was closed; otherwise returns FALSE.
.PP
First it sends the widget a QCloseEvent. The widget is hidden if it accepts the close event. The default implementation of QWidget::closeEvent() accepts the close event.
.PP
The QApplication::lastWindowClosed() signal is emitted when the last visible top level widget is closed.
.PP
Examples:
.)l dialog/mainwindow.cpp, mdi/application.cpp, popup/popup.cpp, and toplevel/options.ui.h.
.SH "bool QWidget::close ( bool alsoDelete )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Closes this widget. Returns TRUE if the widget was closed; otherwise returns FALSE.
.PP
If \fIalsoDelete\fR is TRUE or the widget has the WDestructiveClose widget flag, the widget is also deleted. The widget can prevent itself from being closed by rejecting the QCloseEvent it gets. A close events is delivered to the widget no matter if the widget is visible or not.
.PP
The QApplication::lastWindowClosed() signal is emitted when the last visible top level widget is closed.
.PP
Note that closing the QApplication::mainWidget() terminates the application.
.PP
See also closeEvent(), QCloseEvent, hide(), QApplication::quit(), QApplication::setMainWidget(), and QApplication::lastWindowClosed().
.SH "void QWidget::closeEvent ( QCloseEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive widget close events.
.PP
The default implementation calls e->accept(), which hides this widget. See the QCloseEvent documentation for more details.
.PP
See also event(), hide(), close(), and QCloseEvent.
.PP
Examples:
.)l action/application.cpp, application/application.cpp, chart/chartform.cpp, i18n/mywidget.cpp, mdi/application.cpp, popup/popup.cpp, and qwerty/qwerty.cpp.
.SH "const QColorGroup & QWidget::colorGroup () const"
Returns the current color group of the widget palette. See the "colorGroup" property for details.
.SH "void QWidget::constPolish () const\fC [slot]\fR"
Ensures that the widget is properly initialized by calling polish().
.PP
Call constPolish() from functions like sizeHint() that depends on the widget being initialized, and that may be called before show().
.PP
\fBWarning:\fR Do not call constPolish() on a widget from inside that widget's constructor.
.PP
See also polish().
.SH "void QWidget::contextMenuEvent ( QContextMenuEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive widget context menu events.
.PP
The default implementation calls e->ignore(), which rejects the context event. See the QContextMenuEvent documentation for more details.
.PP
See also event() and QContextMenuEvent.
.PP
Example: menu/menu.cpp.
.SH "void QWidget::create ( WId window = 0, bool initializeWindow = TRUE, bool destroyOldWindow = TRUE )\fC [virtual protected]\fR"
Creates a new widget window if \fIwindow\fR is 0, otherwise sets the widget's window to \fIwindow\fR.
.PP
Initializes the window (sets the geometry etc.) if \fIinitializeWindow\fR is TRUE. If \fIinitializeWindow\fR is FALSE, no initialization is performed. This parameter only makes sense if \fIwindow\fR is a valid window.
.PP
Destroys the old window if \fIdestroyOldWindow\fR is TRUE. If \fIdestroyOldWindow\fR is FALSE, you are responsible for destroying the window yourself (using platform native code).
.PP
The QWidget constructor calls create(0,TRUE,TRUE) to create a window for this widget.
.SH "const QCursor & QWidget::cursor () const"
Returns the cursor shape for this widget. See the "cursor" property for details.
.SH "bool QWidget::customWhatsThis () const\fC [virtual]\fR"
Returns TRUE if the widget wants to handle What's This help manually; otherwise returns FALSE. See the "customWhatsThis" property for details.
.SH "void QWidget::destroy ( bool destroyWindow = TRUE, bool destroySubWindows = TRUE )\fC [virtual protected]\fR"
Frees up window system resources. Destroys the widget window if \fIdestroyWindow\fR is TRUE.
.PP
destroy() calls itself recursively for all the child widgets, passing \fIdestroySubWindows\fR for the \fIdestroyWindow\fR parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.
.PP
This function is usually called from the QWidget destructor.
.SH "void QWidget::dragEnterEvent ( QDragEnterEvent * )\fC [virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse enters this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag, and QDragEnterEvent.
.PP
Example: iconview/simple_dd/main.cpp.
.SH "void QWidget::dragLeaveEvent ( QDragLeaveEvent * )\fC [virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse leaves this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag, and QDragLeaveEvent.
.SH "void QWidget::dragMoveEvent ( QDragMoveEvent * )\fC [virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse enters this widget, and whenever it moves within the widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag, and QDragMoveEvent.
.SH "void QWidget::drawText ( int x, int y, const QString & str )"
Draws the string \fIstr\fR at position \fI(x, y)\fR.
.PP
The \fIy\fR position is the base line position of the text. The text is drawn using the default font and the default foreground color.
.PP
This function is provided for convenience. You will generally get more flexible results and often higher speed by using a a painter instead.
.PP
See also font, foregroundColor(), and QPainter::drawText().
.SH "void QWidget::drawText ( const QPoint & pos, const QString & str )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Draws the string \fIstr\fR at position \fIpos\fR.
.SH "void QWidget::dropEvent ( QDropEvent * )\fC [virtual protected]\fR"
This event handler is called when the drag is dropped on this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag, and QDropEvent.
.PP
Example: iconview/simple_dd/main.cpp.
.SH "void QWidget::enabledChange ( bool oldEnabled )\fC [virtual protected]\fR"
This virtual function is called from setEnabled(). \fIoldEnabled\fR is the previous setting; you can get the new setting from isEnabled().
.PP
Reimplement this function if your widget needs to know when it becomes enabled or disabled. You will almost certainly need to update the widget using update().
.PP
The default implementation repaints the visible part of the widget.
.PP
See also enabled, enabled, repaint(), update(), and clipRegion().
.SH "void QWidget::enterEvent ( QEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget enter events.
.PP
An event is sent to the widget when the mouse cursor enters the widget.
.PP
See also leaveEvent(), mouseMoveEvent(), and event().
.SH "void QWidget::erase ( int x, int y, int w, int h )"
Erases the specified area \fI(x, y, w, h)\fR in the widget without generating a paint event.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
Child widgets are not affected.
.PP
See also repaint().
.SH "void QWidget::erase ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This version erases the entire widget.
.SH "void QWidget::erase ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Erases the specified area \fIr\fR in the widget without generating a paint event.
.SH "void QWidget::erase ( const QRegion & reg )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Erases the area defined by \fIreg\fR, without generating a paint event.
.PP
Child widgets are not affected.
.SH "const QColor & QWidget::eraseColor () const"
Returns the erase color of the widget.
.PP
See also setEraseColor(), setErasePixmap(), and backgroundColor().
.SH "const QPixmap * QWidget::erasePixmap () const"
Returns the widget's erase pixmap.
.PP
See also setErasePixmap() and eraseColor().
.SH "bool QWidget::event ( QEvent * e )\fC [virtual protected]\fR"
This is the main event handler; it handles event \fIe\fR. You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.
.PP
The main event handler first passes an event through all event filters that have been installed. If none of the filters intercept the event, it calls one of the specialized event handlers.
.PP
Key press and release events are treated differently from other events. event() checks for Tab and Shift+Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or Shift+Tab), event() calls keyPressEvent().
.PP
This function returns TRUE if it is able to pass the event over to someone (i.e. someone wanted the event); otherwise returns FALSE.
.PP
See also closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(), keyPressEvent(), keyReleaseEvent(), leaveEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(), mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(), QObject::event(), and QObject::timerEvent().
.PP
Reimplemented from QObject.
.SH "QWidget * QWidget::find ( WId id )\fC [static]\fR"
Returns a pointer to the widget with window identifer/handle \fIid\fR.
.PP
The window identifier type depends on the underlying window system, see qwindowdefs.h for the actual definition. If there is no widget with this identifier, 0 is returned.
.SH "QFocusData * QWidget::focusData ()\fC [protected]\fR"
Returns the focus data for this widget's top-level widget.
.PP
Focus data always belongs to the top-level widget. The focus data list contains all the widgets in this top-level widget that can accept focus, in tab order. An iterator points to the current focus widget (focusWidget() returns a pointer to this widget).
.PP
This information is useful for implementing advanced versions of focusNextPrevChild().
.SH "void QWidget::focusInEvent ( QFocusEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget.
.PP
A widget normally must setFocusPolicy() to something other than NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
.PP
The default implementation updates the widget (except for toplevel widgets that do not specify a focusPolicy() ). It also calls setMicroFocusHint(), hinting any system-specific input tools about the focus of the user's attention.
.PP
See also focusOutEvent(), focusPolicy, keyPressEvent(), keyReleaseEvent(), event(), and QFocusEvent.
.SH "bool QWidget::focusNextPrevChild ( bool next )\fC [virtual protected]\fR"
Finds a new widget to give the keyboard focus to, as appropriate for Tab and Shift+Tab, and returns TRUE if is can find a new widget and FALSE if it can't,
.PP
If \fInext\fR is TRUE, this function searches "forwards", if \fInext\fR is FALSE, it searches "backwards".
.PP
Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its "current active link" forwards or backwards, and call QWidget::focusNextPrevChild() only when it reaches the last or first link on the "page".
.PP
Child widgets call focusNextPrevChild() on their parent widgets, but only the top-level widget decides where to redirect focus. By overriding this method for an object, you thus gain control of focus traversal for all child widgets.
.PP
\fBWarning:\fR QScrollView uses it own logic for this function, which does the right thing in most cases. But if you are using a QScrollView and want complete control of the focus chain you'll need to override QScrollView::focusNextPrevChild() and your top-level widgets' focusNextPrevChild() functions.
.PP
See also focusData().
.SH "void QWidget::focusOutEvent ( QFocusEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget.
.PP
A widget normally must setFocusPolicy() to something other than NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
.PP
The default implementation updates the widget (except for toplevel widgets that do not specify a focusPolicy() ). It also calls setMicroFocusHint(), hinting any system-specific input tools about the focus of the user's attention.
.PP
See also focusInEvent(), focusPolicy, keyPressEvent(), keyReleaseEvent(), event(), and QFocusEvent.
.PP
Example: qmag/qmag.cpp.
.SH "FocusPolicy QWidget::focusPolicy () const"
Returns the way the widget accepts keyboard focus. See the "focusPolicy" property for details.
.SH "QWidget * QWidget::focusProxy () const"
Returns the focus proxy, or 0 if there is no focus proxy.
.PP
See also setFocusProxy().
.SH "QWidget * QWidget::focusWidget () const"
Returns the focus widget in this widget's window. This is not the same as QApplication::focusWidget(), which returns the focus widget in the currently active window.
.SH "QFont QWidget::font () const"
Returns the font currently set for the widget. See the "font" property for details.
.SH "void QWidget::fontChange ( const QFont & oldFont )\fC [virtual protected]\fR"
This virtual function is called from setFont(). \fIoldFont\fR is the previous font; you can get the new font from font().
.PP
Reimplement this function if your widget needs to know when its font changes. You will almost certainly need to update the widget using update().
.PP
The default implementation updates the widget including its geometry.
.PP
See also font, font, update(), and updateGeometry().
.SH "QFontInfo QWidget::fontInfo () const"
Returns the font info for the widget's current font. Equivalent to QFontInto(widget->font()).
.PP
See also font, fontMetrics(), and font.
.SH "QFontMetrics QWidget::fontMetrics () const"
Returns the font metrics for the widget's current font. Equivalent to QFontMetrics(widget->font()).
.PP
See also font, fontInfo(), and font.
.PP
Examples:
.)l drawdemo/drawdemo.cpp and qmag/qmag.cpp.
.SH "const QColor & QWidget::foregroundColor () const"
Same as paletteForegroundColor()
.SH "QRect QWidget::frameGeometry () const"
Returns geometry of the widget relative to its parent including any window frame. See the "frameGeometry" property for details.
.SH "QSize QWidget::frameSize () const"
Returns the size of the widget including any window frame. See the "frameSize" property for details.
.SH "const QRect & QWidget::geometry () const"
Returns the geometry of the widget relative to its parent and excluding the window frame. See the "geometry" property for details.
.SH "WFlags QWidget::getWFlags () const\fC [protected]\fR"
Returns the widget flags for this this widget.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), setWFlags(), and clearWFlags().
.SH "void QWidget::grabKeyboard ()"
Grabs the keyboard input.
.PP
This widget reveives all keyboard events until releaseKeyboard() is called; other widgets get no keyboard events at all. Mouse events are not affected. Use grabMouse() if you want to grab that.
.PP
The focus widget is not affected, except that it doesn't receive any keyboard events. setFocus() moves the focus as usual, but the new focus widget receives keyboard events only after releaseKeyboard() is called.
.PP
If a different widget is currently grabbing keyboard input, that widget's grab is released first.
.PP
See also releaseKeyboard(), grabMouse(), releaseMouse(), and focusWidget().
.SH "void QWidget::grabMouse ()"
Grabs the mouse input.
.PP
This widget receives all mouse events until releaseMouse() is called; other widgets get no mouse events at all. Keyboard events are not affected. Use grabKeyboard() if you want to grab that.
.PP
\fBWarning:\fR Bugs in mouse-grabbing applications very often lock the terminal. Use this function with extreme caution, and consider using the \fC-nograb\fR command line option while debugging.
.PP
It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.
.PP
Note that only visible widgets can grab mouse input. If isVisible() returns FALSE for a widget, that widget cannot call grabMouse().
.PP
See also releaseMouse(), grabKeyboard(), releaseKeyboard(), grabKeyboard(), and focusWidget().
.SH "void QWidget::grabMouse ( const QCursor & cursor )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Grabs the mouse input and changes the cursor shape.
.PP
The cursor will assume shape \fIcursor\fR (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until releaseMouse() is called().
.PP
\fBWarning:\fR Grabbing the mouse might lock the terminal.
.PP
See also releaseMouse(), grabKeyboard(), releaseKeyboard(), and cursor.
.SH "bool QWidget::hasFocus () const"
Returns TRUE if this widget (or its focus proxy) has the keyboard input focus; otherwise returns FALSE. See the "focus" property for details.
.SH "bool QWidget::hasMouse () const"
Returns TRUE if the widget is under the mouse cursor; otherwise returns FALSE. See the "underMouse" property for details.
.SH "bool QWidget::hasMouseTracking () const"
Returns TRUE if mouse tracking is enabled for the widget; otherwise returns FALSE. See the "mouseTracking" property for details.
.SH "int QWidget::height () const"
Returns the height of the widget excluding any window frame. See the "height" property for details.
.SH "int QWidget::heightForWidth ( int w ) const\fC [virtual]\fR"
Returns the preferred height for this widget, given the width \fIw\fR. The default implementation returns 0, indicating that the preferred height does not depend on the width.
.PP
\fBWarning:\fR Does not look at the widget's layout.
.PP
Reimplemented in QMenuBar and QTextEdit.
.SH "void QWidget::hide ()\fC [virtual slot]\fR"
Hides the widget.
.PP
You almost never have to reimplement this function. If you need to do something after a widget is hidden, use hideEvent() instead.
.PP
See also hideEvent(), hidden, show(), showMinimized(), visible, and close().
.PP
Examples:
.)l mdi/application.cpp, popup/popup.cpp, progress/progress.cpp, scrollview/scrollview.cpp, webbrowser/mainwindow.ui.h, and xform/xform.cpp.
.PP
Reimplemented in QMenuBar.
.SH "void QWidget::hideEvent ( QHideEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget hide events.
.PP
Hide events are sent to widgets immediately after they have been hidden.
.PP
See also event() and QHideEvent.
.PP
Reimplemented in QScrollBar.
.SH "const QPixmap * QWidget::icon () const"
Returns the widget's icon. See the "icon" property for details.
.SH "QString QWidget::iconText () const"
Returns the widget's icon text. See the "iconText" property for details.
.SH "void QWidget::iconify ()\fC [slot]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.SH "void QWidget::imComposeEvent ( QIMEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the user has entered some text using an Input Method.
.PP
The default implementation calls e->ignore(), which rejects the Input Method event. See the QIMEvent documentation for more details.
.PP
See also event() and QIMEvent.
.SH "void QWidget::imEndEvent ( QIMEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the user has finished inputting text via an Input Method.
.PP
The default implementation calls e->ignore(), which rejects the Input Method event. See the QIMEvent documentation for more details.
.PP
See also event() and QIMEvent.
.SH "void QWidget::imStartEvent ( QIMEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the user begins entering text using an Input Method.
.PP
The default implementation calls e->ignore(), which rejects the Input Method event. See the QIMEvent documentation for more details.
.PP
See also event() and QIMEvent.
.SH "bool QWidget::isActiveWindow () const"
Returns TRUE if this widget is the active window; otherwise returns FALSE. See the "isActiveWindow" property for details.
.SH "bool QWidget::isDesktop () const"
Returns TRUE if the widget is a desktop widget, i.e. represents the desktop; otherwise returns FALSE. See the "isDesktop" property for details.
.SH "bool QWidget::isDialog () const"
Returns TRUE if the widget is a dialog widget; otherwise returns FALSE. See the "isDialog" property for details.
.SH "bool QWidget::isEnabled () const"
Returns TRUE if the widget is enabled; otherwise returns FALSE. See the "enabled" property for details.
.SH "bool QWidget::isEnabledTo ( QWidget * ancestor ) const"
Returns TRUE if this widget would become enabled if \fIancestor\fR is enabled; otherwise returns FALSE.
.PP
This is the case if neither the widget itself nor every parent up to but excluding \fIancestor\fR has been explicitly disabled.
.PP
isEnabledTo(0) is equivalent to isEnabled().
.PP
See also enabled and enabled.
.SH "bool QWidget::isEnabledToTLW () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This function is deprecated. It is equivalent to isEnabled()
.SH "bool QWidget::isFocusEnabled () const"
Returns TRUE if the widget accepts keyboard focus; otherwise returns FALSE. See the "focusEnabled" property for details.
.SH "bool QWidget::isFullScreen () const"
Returns TRUE if the widget is full screen; otherwise returns FALSE. See the "fullScreen" property for details.
.SH "bool QWidget::isHidden () const"
Returns TRUE if the widget is explicitly hidden; otherwise returns FALSE. See the "hidden" property for details.
.SH "bool QWidget::isInputMethodEnabled () const"
Returns enables or disables the use of input methods for this widget. See the "inputMethodEnabled" property for details.
.SH "bool QWidget::isMaximized () const"
Returns TRUE if this widget is maximized; otherwise returns FALSE. See the "maximized" property for details.
.SH "bool QWidget::isMinimized () const"
Returns TRUE if this widget is minimized (iconified); otherwise returns FALSE. See the "minimized" property for details.
.SH "bool QWidget::isModal () const"
Returns TRUE if the widget is a modal widget; otherwise returns FALSE. See the "isModal" property for details.
.SH "bool QWidget::isPopup () const"
Returns TRUE if the widget is a popup widget; otherwise returns FALSE. See the "isPopup" property for details.
.SH "bool QWidget::isShown () const"
Returns TRUE if the widget is shown; otherwise returns FALSE. See the "shown" property for details.
.SH "bool QWidget::isTopLevel () const"
Returns TRUE if the widget is a top-level widget; otherwise returns FALSE. See the "isTopLevel" property for details.
.SH "bool QWidget::isUpdatesEnabled () const"
Returns TRUE if updates are enabled; otherwise returns FALSE. See the "updatesEnabled" property for details.
.SH "bool QWidget::isVisible () const"
Returns TRUE if the widget is visible; otherwise returns FALSE. See the "visible" property for details.
.SH "bool QWidget::isVisibleTo ( QWidget * ancestor ) const"
Returns TRUE if this widget would become visible if \fIancestor\fR is shown; otherwise returns FALSE.
.PP
The TRUE case occurs if neither the widget itself nor any parent up to but excluding \fIancestor\fR has been explicitly hidden.
.PP
This function will still return TRUE if the widget is obscured by other windows on the screen, but could be physically visible if it or they were to be moved.
.PP
isVisibleTo(0) is identical to isVisible().
.PP
See also show(), hide(), and visible.
.SH "bool QWidget::isVisibleToTLW () const"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This function is deprecated. It is equivalent to isVisible()
.SH "void QWidget::keyPressEvent ( QKeyEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive key press events for the widget.
.PP
A widget must call setFocusPolicy() to accept focus initially and have focus in order to receive a key press event.
.PP
If you reimplement this handler, it is very important that you explicitly ignore the event if you do not understand it, so that the widget's parent can interpret it; otherwise, the event will be implicitly accepted. Although top-level widgets are able to choose whether to accept or ignore unknown events because they have no parent widgets that could otherwise handle them, it is good practice to explicitly ignore events to make widgets as reusable as possible.
.PP
The default implementation closes popup widgets if the user presses \fBEsc\fR. Otherwise the event is ignored.
.PP
See also keyReleaseEvent(), QKeyEvent::ignore(), focusPolicy, focusInEvent(), focusOutEvent(), event(), and QKeyEvent.
.PP
Example: picture/picture.cpp.
.PP
Reimplemented in QLineEdit and QTextEdit.
.SH "void QWidget::keyReleaseEvent ( QKeyEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive key release events for the widget.
.PP
A widget must accept focus initially and have focus in order to receive a key release event.
.PP
If you reimplement this handler, it is very important that you ignore() the release if you do not understand it, so that the widget's parent can interpret it.
.PP
The default implementation ignores the event.
.PP
See also keyPressEvent(), QKeyEvent::ignore(), focusPolicy, focusInEvent(), focusOutEvent(), event(), and QKeyEvent.
.SH "QWidget * QWidget::keyboardGrabber ()\fC [static]\fR"
Returns the widget that is currently grabbing the keyboard input.
.PP
If no widget in this application is currently grabbing the keyboard, 0 is returned.
.PP
See also grabMouse() and mouseGrabber().
.SH "QLayout * QWidget::layout () const"
Returns the layout engine that manages the geometry of this widget's children.
.PP
If the widget does not have a layout, layout() returns 0.
.PP
See also sizePolicy.
.PP
Examples:
.)l chart/optionsform.cpp and fonts/simple-qfont-demo/viewer.cpp.
.SH "void QWidget::leaveEvent ( QEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget leave events.
.PP
A leave event is sent to the widget when the mouse cursor leaves the widget.
.PP
See also enterEvent(), mouseMoveEvent(), and event().
.SH "void QWidget::lower ()\fC [slot]\fR"
Lowers the widget to the bottom of the parent widget's stack.
.PP
After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.
.PP
See also raise() and stackUnder().
.SH "bool QWidget::macEvent ( MSG * )\fC [virtual protected]\fR"
This special event handler can be reimplemented in a subclass to receive native Macintosh events.
.PP
In your reimplementation of this function, if you want to stop the event being handled by Qt, return TRUE. If you return FALSE, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.
.PP
\fBWarning:\fR This function is not portable.
.PP
See also QApplication::macEventFilter().
.SH "QPoint QWidget::mapFrom ( QWidget * parent, const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR from the coordinate system of \fIparent\fR to this widget's coordinate system. The \fIparent\fR must not be 0 and must be a parent of the calling widget.
.PP
See also mapTo(), mapFromParent(), mapFromGlobal(), and underMouse.
.SH "QPoint QWidget::mapFromGlobal ( const QPoint & pos ) const"
Translates the global screen coordinate \fIpos\fR to widget coordinates.
.PP
See also mapToGlobal(), mapFrom(), and mapFromParent().
.SH "QPoint QWidget::mapFromParent ( const QPoint & pos ) const"
Translates the parent widget coordinate \fIpos\fR to widget coordinates.
.PP
Same as mapFromGlobal() if the widget has no parent.
.PP
See also mapToParent(), mapFrom(), mapFromGlobal(), and underMouse.
.SH "QPoint QWidget::mapTo ( QWidget * parent, const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to the coordinate system of \fIparent\fR. The \fIparent\fR must not be 0 and must be a parent of the calling widget.
.PP
See also mapFrom(), mapToParent(), mapToGlobal(), and underMouse.
.SH "QPoint QWidget::mapToGlobal ( const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to global screen coordinates. For example, \fCmapToGlobal(QPoint(0,0))\fR would give the global coordinates of the top-left pixel of the widget.
.PP
See also mapFromGlobal(), mapTo(), and mapToParent().
.PP
Example: scribble/scribble.cpp.
.SH "QPoint QWidget::mapToParent ( const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to a coordinate in the parent widget.
.PP
Same as mapToGlobal() if the widget has no parent.
.PP
See also mapFromParent(), mapTo(), mapToGlobal(), and underMouse.
.SH "int QWidget::maximumHeight () const"
Returns the widget's maximum height. See the "maximumHeight" property for details.
.SH "QSize QWidget::maximumSize () const"
Returns the widget's maximum size. See the "maximumSize" property for details.
.SH "int QWidget::maximumWidth () const"
Returns the widget's maximum width. See the "maximumWidth" property for details.
.SH "int QWidget::metric ( int m ) const\fC [virtual protected]\fR"
Internal implementation of the virtual QPaintDevice::metric() function.
.PP
Use the QPaintDeviceMetrics class instead.
.PP
\fIm\fR is the metric to get.
.SH "QRect QWidget::microFocusHint () const"
Returns the currently set micro focus hint for this widget. See the "microFocusHint" property for details.
.SH "int QWidget::minimumHeight () const"
Returns the widget's minimum height. See the "minimumHeight" property for details.
.SH "QSize QWidget::minimumSize () const"
Returns the widget's minimum size. See the "minimumSize" property for details.
.SH "QSize QWidget::minimumSizeHint () const\fC [virtual]\fR"
Returns the recommended minimum size for the widget. See the "minimumSizeHint" property for details.
.PP
Reimplemented in QLineEdit.
.SH "int QWidget::minimumWidth () const"
Returns the widget's minimum width. See the "minimumWidth" property for details.
.SH "void QWidget::mouseDoubleClickEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive mouse double click events for the widget.
.PP
The default implementation generates a normal mouse press event.
.PP
Note that the widgets gets a mousePressEvent() and a mouseReleaseEvent() before the mouseDoubleClickEvent().
.PP
See also mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), event(), and QMouseEvent.
.SH "QWidget * QWidget::mouseGrabber ()\fC [static]\fR"
Returns the widget that is currently grabbing the mouse input.
.PP
If no widget in this application is currently grabbing the mouse, 0 is returned.
.PP
See also grabMouse() and keyboardGrabber().
.SH "void QWidget::mouseMoveEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive mouse move events for the widget.
.PP
If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.
.PP
QMouseEvent::pos() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user's hand shakes. This is a feature of the underlying window system, not Qt.
.PP
See also mouseTracking, mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), event(), and QMouseEvent.
.PP
Examples:
.)l aclock/aclock.cpp, drawlines/connect.cpp, iconview/simple_dd/main.cpp, life/life.cpp, popup/popup.cpp, qmag/qmag.cpp, and scribble/scribble.cpp.
.PP
Reimplemented in QSizeGrip.
.SH "void QWidget::mousePressEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive mouse press events for the widget.
.PP
If you create new widgets in the mousePressEvent() the mouseReleaseEvent() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.
.PP
The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.
.PP
See also mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), event(), and QMouseEvent.
.PP
Examples:
.)l biff/biff.cpp, drawlines/connect.cpp, iconview/simple_dd/main.cpp, life/life.cpp, qmag/qmag.cpp, scribble/scribble.cpp, and tooltip/tooltip.cpp.
.PP
Reimplemented in QSizeGrip.
.SH "void QWidget::mouseReleaseEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive mouse release events for the widget.
.PP
See also mouseDoubleClickEvent(), mouseMoveEvent(), event(), and QMouseEvent.
.PP
Examples:
.)l drawlines/connect.cpp, hello/hello.cpp, popup/popup.cpp, qmag/qmag.cpp, scribble/scribble.cpp, showimg/showimg.cpp, and t14/cannon.cpp.
.SH "void QWidget::move ( const QPoint & )\fC [slot]\fR"
Sets the position of the widget within its parent widget. See the "pos" property for details.
.SH "void QWidget::move ( int x, int y )\fC [virtual slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This corresponds to move( QPoint(\fIx\fR, \fIy\fR) ).
.SH "void QWidget::moveEvent ( QMoveEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget move events. When the widget receives this event, it is already at the new position.
.PP
The old position is accessible through QMoveEvent::oldPos().
.PP
See also resizeEvent(), event(), pos, and QMoveEvent.
.SH "bool QWidget::ownCursor () const"
Returns TRUE if the widget uses its own cursor; otherwise returns FALSE. See the "ownCursor" property for details.
.SH "bool QWidget::ownFont () const"
Returns TRUE if the widget uses its own font; otherwise returns FALSE. See the "ownFont" property for details.
.SH "bool QWidget::ownPalette () const"
Returns TRUE if the widget uses its own palette; otherwise returns FALSE. See the "ownPalette" property for details.
.SH "void QWidget::paintEvent ( QPaintEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive paint events.
.PP
A paint event is a request to repaint all or part of the widget. It can happen as a result of repaint() or update(), or because the widget was obscured and has now been uncovered, or for many other reasons.
.PP
Many widgets can simply repaint their entire surface when asked to, but some slow widgets need to optimize by painting only the requested region: QPaintEvent::region(). This speed optimization does not change the result, as painting is clipped to that region during event processing. QListView and QCanvas do this, for example.
.PP
Qt also tries to speed up painting by merging multiple paint events into one. When update() is called several times or the window system sends several paint events, Qt merges these events into one event with a larger region (see QRegion::unite()). repaint() does not permit this optimization, so we suggest using update() when possible.
.PP
When the paint event occurs, the update region has normally been erased, so that you're painting on the widget's background. There are a couple of exceptions and QPaintEvent::erased() tells you whether the widget has been erased or not.
.PP
The background can be set using setBackgroundMode(), setPaletteBackgroundColor() or setBackgroundPixmap(). The documentation for setBackgroundMode() elaborates on the background; we recommend reading it.
.PP
See also event(), repaint(), update(), QPainter, QPixmap, and QPaintEvent.
.PP
Examples:
.)l drawlines/connect.cpp, forever/forever.cpp, qmag/qmag.cpp, scribble/scribble.cpp, splitter/splitter.cpp, t8/cannon.cpp, and t9/cannon.cpp.
.PP
Reimplemented in QButton, QFrame, QGLWidget, QSizeGrip, QStatusBar, and QTabBar.
.SH "const QPalette & QWidget::palette () const"
Returns the widget's palette. See the "palette" property for details.
.SH "const QColor & QWidget::paletteBackgroundColor () const"
Returns the background color of the widget. See the "paletteBackgroundColor" property for details.
.SH "const QPixmap * QWidget::paletteBackgroundPixmap () const"
Returns the background pixmap of the widget. See the "paletteBackgroundPixmap" property for details.
.SH "void QWidget::paletteChange ( const QPalette & oldPalette )\fC [virtual protected]\fR"
This virtual function is called from setPalette(). \fIoldPalette\fR is the previous palette; you can get the new palette from palette().
.PP
Reimplement this function if your widget needs to know when its palette changes.
.PP
See also palette and palette.
.SH "const QColor & QWidget::paletteForegroundColor () const"
Returns the foreground color of the widget. See the "paletteForegroundColor" property for details.
.SH "QWidget * QWidget::parentWidget ( bool sameWindow = FALSE ) const"
Returns the parent of this widget, or 0 if it does not have any parent widget. If \fIsameWindow\fR is TRUE and the widget is top level returns 0; otherwise returns the widget's parent.
.PP
Example: mdi/application.cpp.
.SH "void QWidget::polish ()\fC [virtual slot]\fR"
Delayed initialization of a widget.
.PP
This function will be called \fIafter\fR a widget has been fully created and \fIbefore\fR it is shown the very first time.
.PP
Polishing is useful for final initialization which depends on having an instantiated widget. This is something a constructor cannot guarantee since the initialization of the subclasses might not be finished.
.PP
After this function, the widget has a proper font and palette and QApplication::polish() has been called.
.PP
Remember to call QWidget's implementation first when reimplementing this function to ensure that your program does not end up in infinite recursion.
.PP
See also constPolish() and QApplication::polish().
.PP
Example: menu/menu.cpp.
.SH "QPoint QWidget::pos () const"
Returns the position of the widget within its parent widget. See the "pos" property for details.
.SH "bool QWidget::qwsEvent ( QWSEvent * )\fC [virtual protected]\fR"
This special event handler can be reimplemented in a subclass to receive native Qt/Embedded events.
.PP
In your reimplementation of this function, if you want to stop the event being handled by Qt, return TRUE. If you return FALSE, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.
.PP
\fBWarning:\fR This function is not portable.
.PP
See also QApplication::qwsEventFilter().
.SH "void QWidget::raise ()\fC [slot]\fR"
Raises this widget to the top of the parent widget's stack.
.PP
After this call the widget will be visually in front of any overlapping sibling widgets.
.PP
See also lower() and stackUnder().
.PP
Example: showimg/showimg.cpp.
.SH "void QWidget::recreate ( QWidget * parent, WFlags f, const QPoint & p, bool showIt = FALSE )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
This method is provided to aid porting from Qt 1.0 to 2.0. It has been renamed reparent() in Qt 2.0.
.SH "QRect QWidget::rect () const"
Returns the internal geometry of the widget excluding any window frame. See the "rect" property for details.
.SH "void QWidget::releaseKeyboard ()"
Releases the keyboard grab.
.PP
See also grabKeyboard(), grabMouse(), and releaseMouse().
.SH "void QWidget::releaseMouse ()"
Releases the mouse grab.
.PP
See also grabMouse(), grabKeyboard(), and releaseKeyboard().
.SH "void QWidget::repaint ( int x, int y, int w, int h, bool erase = TRUE )\fC [slot]\fR"
Repaints the widget directly by calling paintEvent() immediately, unless updates are disabled or the widget is hidden.
.PP
If \fIerase\fR is TRUE, Qt erases the area \fI(x, y, w, h)\fR before the paintEvent() call.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR, and if \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances update() is better, as it permits Qt to optimize for speed and minimize flicker.
.PP
\fBWarning:\fR If you call repaint() in a function which may itself be called from paintEvent(), you may get infinite recursion. The update() function never causes recursion.
.PP
See also update(), paintEvent(), updatesEnabled, and erase().
.PP
Example: qwerty/qwerty.cpp.
.SH "void QWidget::repaint ()\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This version erases and repaints the entire widget.
.SH "void QWidget::repaint ( bool erase )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This version repaints the entire widget.
.SH "void QWidget::repaint ( const QRect & r, bool erase = TRUE )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Repaints the widget directly by calling paintEvent() directly, unless updates are disabled or the widget is hidden.
.PP
Erases the widget region \fIr\fR if \fIerase\fR is TRUE.
.SH "void QWidget::repaint ( const QRegion & reg, bool erase = TRUE )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Repaints the widget directly by calling paintEvent() directly, unless updates are disabled or the widget is hidden.
.PP
Erases the widget region \fIreg\fR if \fIerase\fR is TRUE.
.PP
Only use repaint if your widget needs to be repainted immediately, for example when doing some animation. In all other cases, use update(). Calling update() many times in a row will generate a single paint event.
.PP
\fBWarning:\fR If you call repaint() in a function which may itself be called from paintEvent(), you may get infinite recursion. The update() function never causes recursion.
.PP
See also update(), paintEvent(), updatesEnabled, and erase().
.SH "void QWidget::reparent ( QWidget * parent, WFlags f, const QPoint & p, bool showIt = FALSE )\fC [virtual]\fR"
Reparents the widget. The widget gets a new \fIparent\fR, new widget flags (\fIf\fR, but as usual, use 0) at a new position in its new parent (\fIp\fR).
.PP
If \fIshowIt\fR is TRUE, show() is called once the widget has been reparented.
.PP
If the new parent widget is in a different top-level widget, the reparented widget and its children are appended to the end of the tab chain of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, reparent() calls clearFocus() for that widget.
.PP
If the new parent widget is in the same top-level widget as the old parent, reparent doesn't change the tab order or keyboard focus.
.PP
\fBWarning:\fR It is extremely unlikely that you will ever need this function. If you have a widget that changes its content dynamically, it is far easier to use QWidgetStack or QWizard.
.PP
See also getWFlags().
.PP
Example: toplevel/options.ui.h.
.SH "void QWidget::reparent ( QWidget * parent, const QPoint & p, bool showIt = FALSE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
A convenience version of reparent that does not take widget flags as argument.
.PP
Calls reparent(\fIparent\fR, getWFlags() & ~WType_Mask, \fIp\fR, \fIshowIt\fR).
.SH "void QWidget::resetInputContext ()\fC [protected]\fR"
This function is called when the user finishes input composition, e.g. changes focus to another widget, moves the cursor, etc.
.SH "void QWidget::resize ( const QSize & )\fC [slot]\fR"
Sets the size of the widget excluding any window frame. See the "size" property for details.
.SH "void QWidget::resize ( int w, int h )\fC [virtual slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This corresponds to resize( QSize(\fIw\fR, \fIh\fR) ).
.SH "void QWidget::resizeEvent ( QResizeEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget resize events. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through QResizeEvent::oldSize().
.PP
The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.
.PP
Widgets that have been created with the WNoAutoErase flag will not be erased. Nevertheless, they will receive a paint event for their entire area afterwards. Again, no drawing needs to be done inside this handler.
.PP
The default implementation calls updateMask() if the widget has automatic masking enabled.
.PP
See also moveEvent(), event(), size, QResizeEvent, and paintEvent().
.PP
Examples:
.)l drawdemo/drawdemo.cpp, menu/menu.cpp, qmag/qmag.cpp, scribble/scribble.cpp, showimg/showimg.cpp, tooltip/tooltip.cpp, and xform/xform.cpp.
.PP
Reimplemented in QFrame and QGLWidget.
.SH "void QWidget::scroll ( int dx, int dy )"
Scrolls the widget including its children \fIdx\fR pixels to the right and \fIdy\fR downwards. Both \fIdx\fR and \fIdy\fR may be negative.
.PP
After scrolling, scroll() sends a paint event for the the part that is read but not written. For example, when scrolling 10 pixels rightwards, the leftmost ten pixels of the widget need repainting. The paint event may be delivered immediately or later, depending on some heuristics (note that you might have to force processing of paint events using QApplication::sendPostedEvents() when using scroll() and move() in combination).
.PP
See also QScrollView, erase(), and bitBlt().
.SH "void QWidget::scroll ( int dx, int dy, const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This version only scrolls \fIr\fR and does not move the children of the widget.
.PP
If \fIr\fR is empty or invalid, the result is undefined.
.PP
See also QScrollView, erase(), and bitBlt().
.SH "void QWidget::setAcceptDrops ( bool on )\fC [virtual]\fR"
Sets whether drop events are enabled for this widget to \fIon\fR. See the "acceptDrops" property for details.
.SH "void QWidget::setActiveWindow ()\fC [virtual]\fR"
Sets the top-level widget containing this widget to be the active window.
.PP
An active window is a visible top-level window that has the keyboard input focus.
.PP
This function performs the same operation as clicking the mouse on the title bar of a top-level window. On X11, the result depends on the Window Manager. If you want to ensure that the window is stacked on top as well you should also call raise(). Note that the window must be visible, otherwise setActiveWindow() has no effect.
.PP
On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will flash the task bar entry blue to indicate that the window has done something. This is because Microsoft do not allow an application to interrupt what the user is currently doing in another application.
.PP
See also isActiveWindow, topLevelWidget(), and show().
.PP
Reimplemented in QXtWidget.
.SH "void QWidget::setAutoMask ( bool )\fC [virtual]\fR"
Sets whether the auto mask feature is enabled for the widget. See the "autoMask" property for details.
.SH "void QWidget::setBackgroundColor ( const QColor & c )\fC [virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code. Use setPaletteBackgroundColor() or setEraseColor() instead.
.PP
Examples:
.)l customlayout/main.cpp, desktop/desktop.cpp, hello/main.cpp, movies/main.cpp, and splitter/splitter.cpp.
.SH "void QWidget::setBackgroundMode ( BackgroundMode )\fC [virtual]\fR"
Sets the color role used for painting the background of the widget. See the "backgroundMode" property for details.
.SH "void QWidget::setBackgroundMode ( BackgroundMode m, BackgroundMode visual )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the widget's own background mode to \fIm\fR and the visual background mode to \fIvisual\fR. The visual background mode is used with the designable properties \fCbackgroundColor\fR, \fCforegroundColor\fR and \fCbackgroundPixmap\fR.
.PP
For complex controls, the logical background mode sometimes differs from a widget's own background mode. A spinbox for example has PaletteBackground as background mode (typically dark gray), while it's embedded lineedit control uses PaletteBase (typically white). Since the lineedit covers most of the visual area of a spinbox, it defines PaletteBase to be its \fIvisual\fR background mode. Changing the \fCbackgroundColor\fR property thus changes the lineedit control's background, which is exactly what the user expects in \fIQt Designer\fR.
.SH "void QWidget::setBackgroundOrigin ( BackgroundOrigin )\fC [virtual]\fR"
Sets the origin of the widget's background. See the "backgroundOrigin" property for details.
.SH "void QWidget::setBackgroundPixmap ( const QPixmap & pm )\fC [virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code. Use setPaletteBackgroundPixmap() or setErasePixmap() instead.
.PP
Example: desktop/desktop.cpp.
.SH "void QWidget::setBaseSize ( const QSize & )"
Sets the base size of the widget. See the "baseSize" property for details.
.SH "void QWidget::setBaseSize ( int basew, int baseh )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This corresponds to setBaseSize( QSize(\fIbasew\fR, \fIbaseh\fR) ). Sets the widgets base size to width \fIbasew\fR and height \fIbaseh\fR.
.SH "void QWidget::setCaption ( const QString & )\fC [virtual slot]\fR"
Sets the window caption (title). See the "caption" property for details.
.SH "void QWidget::setCursor ( const QCursor & )\fC [virtual]\fR"
Sets the cursor shape for this widget. See the "cursor" property for details.
.SH "void QWidget::setDisabled ( bool disable )\fC [slot]\fR"
Disables widget input events if \fIdisable\fR is TRUE; otherwise enables input events.
.PP
See the enabled documentation for more information.
.PP
See also isEnabledTo(), QKeyEvent, QMouseEvent, and enabledChange().
.SH "void QWidget::setEnabled ( bool )\fC [virtual slot]\fR"
Sets whether the widget is enabled. See the "enabled" property for details.
.SH "void QWidget::setEraseColor ( const QColor & color )\fC [virtual]\fR"
Sets the erase color of the widget to \fIcolor\fR.
.PP
The erase color is the color the widget is to be cleared to before paintEvent() is called. If there is an erase pixmap (set using setErasePixmap()), then this property has an indeterminate value.
.PP
See also erasePixmap(), backgroundColor(), backgroundMode, and palette.
.SH "void QWidget::setErasePixmap ( const QPixmap & pixmap )\fC [virtual]\fR"
Sets the widget's erase pixmap to \fIpixmap\fR.
.PP
This pixmap is used to clear the widget before paintEvent() is called.
.SH "void QWidget::setFixedHeight ( int h )"
Sets both the minimum and maximum heights of the widget to \fIh\fR without changing the widths. Provided for convenience.
.PP
See also sizeHint, minimumSize, maximumSize, and setFixedSize().
.PP
Examples:
.)l fonts/simple-qfont-demo/viewer.cpp, layout/layout.cpp, qdir/qdir.cpp, and showimg/showimg.cpp.
.SH "void QWidget::setFixedSize ( const QSize & s )"
Sets both the minimum and maximum sizes of the widget to \fIs\fR, thereby preventing it from ever growing or shrinking.
.PP
See also maximumSize and minimumSize.
.SH "void QWidget::setFixedSize ( int w, int h )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the width of the widget to \fIw\fR and the height to \fIh\fR.
.SH "void QWidget::setFixedWidth ( int w )"
Sets both the minimum and maximum width of the widget to \fIw\fR without changing the heights. Provided for convenience.
.PP
See also sizeHint, minimumSize, maximumSize, and setFixedSize().
.PP
Examples:
.)l progressbar/progressbar.cpp and qdir/qdir.cpp.
.SH "void QWidget::setFocus ()\fC [virtual slot]\fR"
Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the active window.
.PP
First, a focus out event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then a focus in event is sent to this widget to tell it that it just received the focus. (Nothing happens if the focus in and focus out widgets are the same.)
.PP
setFocus() gives focus to a widget regardless of its focus policy, but does not clear any keyboard grab (see grabKeyboard()).
.PP
Be aware that if the widget is hidden, it will not accept focus.
.PP
\fBWarning:\fR If you call setFocus() in a function which may itself be called from focusOutEvent() or focusInEvent(), you may get an infinite recursion.
.PP
See also focus, clearFocus(), focusInEvent(), focusOutEvent(), focusPolicy, QApplication::focusWidget(), grabKeyboard(), and grabMouse().
.PP
Examples:
.)l addressbook/centralwidget.cpp, lineedits/lineedits.cpp, mdi/application.cpp, popup/popup.cpp, rot13/rot13.cpp, t8/main.cpp, and wizard/wizard.cpp.
.SH "void QWidget::setFocusPolicy ( FocusPolicy )\fC [virtual]\fR"
Sets the way the widget accepts keyboard focus. See the "focusPolicy" property for details.
.SH "void QWidget::setFocusProxy ( QWidget * w )\fC [virtual]\fR"
Sets the widget's focus proxy to widget \fIw\fR. If \fIw\fR is 0, the function resets this widget to have no focus proxy.
.PP
Some widgets, such as QComboBox, can "have focus", but create a child widget to actually handle the focus. QComboBox, for example, creates a QLineEdit which handles the focus.
.PP
setFocusProxy() sets the widget which will actually get focus when" this widget" gets it. If there is a focus proxy, focusPolicy(), setFocusPolicy(), setFocus() and hasFocus() all operate on the focus proxy.
.PP
See also focusProxy().
.SH "void QWidget::setFont ( const QFont & )\fC [virtual]\fR"
Sets the font currently set for the widget. See the "font" property for details.
.PP
Reimplemented in QComboBox, QLabel, and QTabDialog.
.SH "void QWidget::setFont ( const QFont & f, bool )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Use setFont(const QFont& font) instead.
.SH "void QWidget::setGeometry ( const QRect & )\fC [virtual slot]\fR"
Sets the geometry of the widget relative to its parent and excluding the window frame. See the "geometry" property for details.
.SH "void QWidget::setGeometry ( int x, int y, int w, int h )\fC [virtual slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This corresponds to setGeometry( QRect(\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) ).
.SH "void QWidget::setHidden ( bool hide )\fC [slot]\fR"
Sets whether the widget is explicitly hidden to \fIhide\fR. See the "hidden" property for details.
.SH "void QWidget::setIcon ( const QPixmap & )\fC [virtual slot]\fR"
Sets the widget's icon. See the "icon" property for details.
.SH "void QWidget::setIconText ( const QString & )\fC [virtual slot]\fR"
Sets the widget's icon text. See the "iconText" property for details.
.SH "void QWidget::setInputMethodEnabled ( bool b )"
Sets enables or disables the use of input methods for this widget to \fIb\fR. See the "inputMethodEnabled" property for details.
.SH "void QWidget::setKeyCompression ( bool compress )\fC [virtual protected]\fR"
Enables key event compression, if \fIcompress\fR is TRUE, and disables it if \fIcompress\fR is FALSE.
.PP
Key compression is off by default (except for QLineEdit and QTextEdit), so widgets receive one key press event for each key press (or more, since autorepeat is usually on). If you turn it on and your program doesn't keep up with key input, Qt may try to compress key events so that more than one character can be processed in each event.
.PP
For example, a word processor widget might receive 2, 3 or more characters in each QKeyEvent::text(), if the layout recalculation takes too long for the CPU.
.PP
If a widget supports multiple character unicode input, it is always safe to turn the compression on.
.PP
Qt performs key event compression only for printable characters. Modifier keys, cursor movement keys, function keys and miscellaneous action keys (e.g. Escape, Enter, Backspace, PrintScreen) will stop key event compression, even if there are more compressible key events available.
.PP
Not all platforms support this compression, in which case turning it on will have no effect.
.PP
See also QKeyEvent::text().
.SH "void QWidget::setMask ( const QBitmap & bitmap )\fC [virtual]\fR"
Causes only the pixels of the widget for which \fIbitmap\fR has a corresponding 1 bit to be visible. Use Qt::color0 to draw transparent regions and Qt::color1 to draw opaque regions of the bitmap.
.PP
If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
.PP
Note that this effect can be slow if the region is particularly complex.
.PP
See \fCexamples/tux\fR for an example of masking for transparency.
.PP
See also clearMask().
.SH "void QWidget::setMask ( const QRegion & region )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Causes only the parts of the widget which overlap \fIregion\fR to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
.PP
Note that this effect can be slow if the region is particularly complex.
.PP
See also clearMask().
.SH "void QWidget::setMaximumHeight ( int maxh )"
Sets the widget's maximum height to \fImaxh\fR. See the "maximumHeight" property for details.
.SH "void QWidget::setMaximumSize ( const QSize & )"
Sets the widget's maximum size. See the "maximumSize" property for details.
.SH "void QWidget::setMaximumSize ( int maxw, int maxh )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function corresponds to setMaximumSize( QSize(\fImaxw\fR, \fImaxh\fR) ). Sets the maximum width to \fImaxw\fR and the maximum height to \fImaxh\fR.
.SH "void QWidget::setMaximumWidth ( int maxw )"
Sets the widget's maximum width to \fImaxw\fR. See the "maximumWidth" property for details.
.SH "void QWidget::setMicroFocusHint ( int x, int y, int width, int height, bool text = TRUE, QFont * f = 0 )\fC [virtual protected]\fR"
When a widget gets focus, it should call setMicroFocusHint() with some appropriate position and size, \fIx\fR, \fIy\fR, \fIwidth\fR and \fIheight\fR. This has no \fIvisual\fR effect, it just provides hints to any system-specific input handling tools.
.PP
The \fItext\fR argument should be TRUE if this is a position for text input.
.PP
In the Windows version of Qt, this method sets the system caret, which is used for user Accessibility focus handling. If \fItext\fR is TRUE, it also sets the IME composition window in Far East Asian language input systems.
.PP
In the X11 version of Qt, if \fItext\fR is TRUE, this method sets the XIM "spot" point for complex language input handling.
.PP
The font \fIf\fR is a rendering hint to the currently active input method. If \fIf\fR is 0 the widget's font is used.
.PP
See also microFocusHint.
.SH "void QWidget::setMinimumHeight ( int minh )"
Sets the widget's minimum height to \fIminh\fR. See the "minimumHeight" property for details.
.SH "void QWidget::setMinimumSize ( const QSize & )"
Sets the widget's minimum size. See the "minimumSize" property for details.
.SH "void QWidget::setMinimumSize ( int minw, int minh )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
This function corresponds to setMinimumSize( QSize(minw, minh) ). Sets the minimum width to \fIminw\fR and the minimum height to \fIminh\fR.
.SH "void QWidget::setMinimumWidth ( int minw )"
Sets the widget's minimum width to \fIminw\fR. See the "minimumWidth" property for details.
.SH "void QWidget::setMouseTracking ( bool enable )\fC [virtual slot]\fR"
Sets whether mouse tracking is enabled for the widget to \fIenable\fR. See the "mouseTracking" property for details.
.SH "void QWidget::setPalette ( const QPalette & )\fC [virtual]\fR"
Sets the widget's palette. See the "palette" property for details.
.PP
Reimplemented in QComboBox, QScrollBar, and QSlider.
.SH "void QWidget::setPalette ( const QPalette & p, bool )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Use setPalette( const QPalette& p ) instead.
.SH "void QWidget::setPaletteBackgroundColor ( const QColor & )\fC [virtual]\fR"
Sets the background color of the widget. See the "paletteBackgroundColor" property for details.
.SH "void QWidget::setPaletteBackgroundPixmap ( const QPixmap & )\fC [virtual]\fR"
Sets the background pixmap of the widget. See the "paletteBackgroundPixmap" property for details.
.SH "void QWidget::setPaletteForegroundColor ( const QColor & )"
Sets the foreground color of the widget. See the "paletteForegroundColor" property for details.
.SH "void QWidget::setShown ( bool show )\fC [slot]\fR"
Sets whether the widget is shown to \fIshow\fR. See the "shown" property for details.
.SH "void QWidget::setSizeIncrement ( const QSize & )"
Sets the size increment of the widget. See the "sizeIncrement" property for details.
.SH "void QWidget::setSizeIncrement ( int w, int h )\fC [virtual]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the x (width) size increment to \fIw\fR and the y (height) size increment to \fIh\fR.
.SH "void QWidget::setSizePolicy ( QSizePolicy )\fC [virtual]\fR"
Sets the default layout behavior of the widget. See the "sizePolicy" property for details.
.SH "void QWidget::setSizePolicy ( QSizePolicy::SizeType hor, QSizePolicy::SizeType ver, bool hfw = FALSE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the size policy of the widget to \fIhor\fR, \fIver\fR and \fIhfw\fR (height for width).
.PP
See also QSizePolicy::QSizePolicy().
.SH "void QWidget::setStyle ( QStyle * style )"
Sets the widget's GUI style to \fIstyle\fR. Ownership of the style object is not transferred.
.PP
If no style is set, the widget uses the application's style, QApplication::style() instead.
.PP
Setting a widget's style has no effect on existing or future child widgets.
.PP
\fBWarning:\fR This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should avoid it and use one consistent GUI style instead.
.PP
See also style(), QStyle, QApplication::style(), and QApplication::setStyle().
.PP
Examples:
.)l grapher/grapher.cpp and progressbar/progressbar.cpp.
.SH "QStyle * QWidget::setStyle ( const QString & style )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Sets the widget's GUI style to \fIstyle\fR using the QStyleFactory.
.SH "void QWidget::setTabOrder ( QWidget * first, QWidget * second )\fC [static]\fR"
Moves the \fIsecond\fR widget around the ring of focus widgets so that keyboard focus moves from the \fIfirst\fR widget to the \fIsecond\fR widget when the Tab key is pressed.
.PP
Note that since the tab order of the \fIsecond\fR widget is changed, you should order a chain like this:
.PP
.nf
.br
        setTabOrder( a, b ); // a to b
.br
        setTabOrder( b, c ); // a to b to c
.br
        setTabOrder( c, d ); // a to b to c to d
.br
.fi
.PP
\fInot\fR like this:
.PP
.nf
.br
        setTabOrder( c, d ); // c to d   WRONG
.br
        setTabOrder( a, b ); // a to b AND c to d
.br
        setTabOrder( b, c ); // a to b to c, but not c to d
.br
.fi
.PP
If \fIfirst\fR or \fIsecond\fR has a focus proxy, setTabOrder() correctly substitutes the proxy.
.PP
See also focusPolicy and setFocusProxy().
.PP
Example: customlayout/main.cpp.
.SH "void QWidget::setUpdatesEnabled ( bool enable )\fC [virtual slot]\fR"
Sets whether updates are enabled to \fIenable\fR. See the "updatesEnabled" property for details.
.SH "void QWidget::setWFlags ( WFlags f )\fC [virtual protected]\fR"
Sets the widget flags \fIf\fR.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), getWFlags(), and clearWFlags().
.SH "void QWidget::setWindowOpacity ( double level )"
Sets the level of opacity for the window to \fIlevel\fR. See the "windowOpacity" property for details.
.SH "void QWidget::setWindowState ( uint windowState )"
Sets the window state to \fIwindowState\fR. The window state is a OR'ed combination of Qt::WindowState: WindowMinimized, WindowMaximized, WindowFullScreen and WindowActive.
.PP
If the window is not visible (i.e. isVisible() returns FALSE), the window state will take effect when show() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and mormal mode, use the following code:
.PP
.nf
.br
        w->setWindowState(w->windowState() ^ WindowFullScreen);
.br
.fi
.PP
In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:
.PP
.nf
.br
        w->setWindowState(w->windowState() & ~WindowMinimized | WindowActive);
.br
.fi
.PP
Note: On some window systems WindowActive is not immediate, and may be ignored in certain cases.
.PP
See also Qt::WindowState and windowState().
.SH "void QWidget::show ()\fC [virtual slot]\fR"
Shows the widget and its child widgets.
.PP
If its size or position has changed, Qt guarantees that a widget gets move and resize events just before it is shown.
.PP
You almost never have to reimplement this function. If you need to change some settings before a widget is shown, use showEvent() instead. If you need to do some delayed initialization use polish().
.PP
See also showEvent(), hide(), showMinimized(), showMaximized(), showNormal(), visible, and polish().
.PP
Examples:
.)l aclock/main.cpp, life/main.cpp, popup/popup.cpp, t1/main.cpp, t3/main.cpp, t4/main.cpp, and toplevel/options.ui.h.
.PP
Reimplemented in QDialog and QMenuBar.
.SH "void QWidget::showEvent ( QShowEvent * )\fC [virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget show events.
.PP
Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of top-level widgets are delivered afterwards.
.PP
See also event() and QShowEvent.
.PP
Example: qdir/qdir.cpp.
.SH "void QWidget::showFullScreen ()\fC [slot]\fR"
Shows the widget in full-screen mode.
.PP
Calling this function only affects top-level widgets.
.PP
To return from full-screen mode, call showNormal().
.PP
Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not understand the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.
.PP
An alternative would be to bypass the window manager entirely and create a window with the WX11BypassWM flag. This has other severe problems though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.
.PP
X11 window managers that follow modern post-ICCCM specifications support full-screen mode properly.
.PP
See also showNormal(), showMaximized(), show(), hide(), and visible.
.SH "void QWidget::showMaximized ()\fC [virtual slot]\fR"
Shows the widget maximized.
.PP
Calling this function only affects top-level widgets.
.PP
On X11, this function may not work properly with certain window managers. See the Window Geometry documentation for an explanation.
.PP
See also setWindowState(), showNormal(), showMinimized(), show(), hide(), and visible.
.PP
Examples:
.)l canvas/main.cpp, helpviewer/main.cpp, mdi/application.cpp, qwerty/main.cpp, qwerty/qwerty.cpp, and scribble/main.cpp.
.SH "void QWidget::showMinimized ()\fC [virtual slot]\fR"
Shows the widget minimized, as an icon.
.PP
Calling this function only affects top-level widgets.
.PP
See also showNormal(), showMaximized(), show(), hide(), visible, and minimized.
.SH "void QWidget::showNormal ()\fC [virtual slot]\fR"
Restores the widget after it has been maximized or minimized.
.PP
Calling this function only affects top-level widgets.
.PP
See also setWindowState(), showMinimized(), showMaximized(), show(), hide(), and visible.
.PP
Example: mdi/application.cpp.
.SH "QSize QWidget::size () const"
Returns the size of the widget excluding any window frame. See the "size" property for details.
.SH "QSize QWidget::sizeHint () const\fC [virtual]\fR"
Returns the recommended size for the widget. See the "sizeHint" property for details.
.PP
Reimplemented in QSizeGrip.
.SH "QSize QWidget::sizeIncrement () const"
Returns the size increment of the widget. See the "sizeIncrement" property for details.
.SH "QSizePolicy QWidget::sizePolicy () const\fC [virtual]\fR"
Returns the default layout behavior of the widget. See the "sizePolicy" property for details.
.SH "void QWidget::stackUnder ( QWidget * w )\fC [slot]\fR"
Places the widget under \fIw\fR in the parent widget's stack.
.PP
To make this work, the widget itself and \fIw\fR must be siblings.
.PP
See also raise() and lower().
.SH "QStyle & QWidget::style () const"
Returns the GUI style for this widget
.PP
See also QWidget::setStyle(), QApplication::setStyle(), and QApplication::style().
.SH "void QWidget::styleChange ( QStyle & oldStyle )\fC [virtual protected]\fR"
This virtual function is called when the style of the widgets changes. \fIoldStyle\fR is the previous GUI style; you can get the new style from style().
.PP
Reimplement this function if your widget needs to know when its GUI style changes. You will almost certainly need to update the widget using update().
.PP
The default implementation updates the widget including its geometry.
.PP
See also QApplication::setStyle(), style(), update(), and updateGeometry().
.SH "void QWidget::tabletEvent ( QTabletEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive tablet events for the widget.
.PP
If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.
.PP
The default implementation ignores the event.
.PP
See also QTabletEvent::ignore(), QTabletEvent::accept(), event(), and QTabletEvent.
.SH "WFlags QWidget::testWFlags ( WFlags f ) const"
Returns the bitwise AND of the widget flags and \fIf\fR.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
If you want to test for the presence of multiple flags (or composite flags such as WStyle_Splash), test the return value for equality against the argument. For example:
.PP
.nf
.br
    int flags = WStyle_Tool | WStyle_NoBorder;
.br
    if ( testWFlags(flags) )
.br
        ... // WStyle_Tool or WStyle_NoBorder or both are set
.br
    if ( testWFlags(flags) == flags )
.br
        ... // both WStyle_Tool and WStyle_NoBorder are set
.br
.fi
.PP
See also getWFlags(), setWFlags(), and clearWFlags().
.SH "QWidget * QWidget::topLevelWidget () const"
Returns the top-level widget for this widget, i.e. the next ancestor widget that has (or could have) a window-system frame.
.PP
If the widget is a top-level, the widget itself is returned.
.PP
Typical usage is changing the window caption:
.PP
.nf
.br
        aWidget->topLevelWidget()->setCaption( "New Caption" );
.br
.fi
.PP
See also isTopLevel.
.SH "void QWidget::unsetCursor ()\fC [virtual]\fR"
Resets the cursor shape for this widget. See the "cursor" property for details.
.SH "void QWidget::unsetFont ()"
Resets the font currently set for the widget. See the "font" property for details.
.SH "void QWidget::unsetPalette ()"
Resets the widget's palette. See the "palette" property for details.
.SH "void QWidget::update ()\fC [slot]\fR"
Updates the widget unless updates are disabled or the widget is hidden.
.PP
This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to repaint() does.
.PP
Calling update() several times normally results in just one paintEvent() call.
.PP
Qt normally erases the widget's area before the paintEvent() call. If the WRepaintNoErase widget flag is set, the widget is responsible for painting all its pixels itself.
.PP
See also repaint(), paintEvent(), updatesEnabled, erase(), and setWFlags().
.PP
Examples:
.)l desktop/desktop.cpp and scrollview/scrollview.cpp.
.SH "void QWidget::update ( int x, int y, int w, int h )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Updates a rectangle (\fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR) inside the widget unless updates are disabled or the widget is hidden.
.PP
This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker and a call to repaint() does.
.PP
Calling update() several times normally results in just one paintEvent() call.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
Qt normally erases the specified area before the paintEvent() call. If the WRepaintNoErase widget flag is set, the widget is responsible for painting all its pixels itself.
.PP
See also repaint(), paintEvent(), updatesEnabled, and erase().
.SH "void QWidget::update ( const QRect & r )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Updates a rectangle \fIr\fR inside the widget unless updates are disabled or the widget is hidden.
.PP
This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker and a call to repaint() does.
.PP
Calling update() several times normally results in just one paintEvent() call.
.SH "void QWidget::updateGeometry ()"
Notifies the layout system that this widget has changed and may need to change geometry.
.PP
Call this function if the sizeHint() or sizePolicy() have changed.
.PP
For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.
.SH "void QWidget::updateMask ()\fC [virtual protected]\fR"
This function can be reimplemented in a subclass to support transparent widgets. It should be called whenever a widget changes state in a way that means that the shape mask must be recalculated.
.PP
See also autoMask, setMask(), and clearMask().
.SH "QRect QWidget::visibleRect () const"
Returns the visible rectangle. See the "visibleRect" property for details.
.SH "void QWidget::wheelEvent ( QWheelEvent * e )\fC [virtual protected]\fR"
This event handler, for event \fIe\fR, can be reimplemented in a subclass to receive wheel events for the widget.
.PP
If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.
.PP
The default implementation ignores the event.
.PP
See also QWheelEvent::ignore(), QWheelEvent::accept(), event(), and QWheelEvent.
.SH "int QWidget::width () const"
Returns the width of the widget excluding any window frame. See the "width" property for details.
.SH "bool QWidget::winEvent ( MSG * )\fC [virtual protected]\fR"
This special event handler can be reimplemented in a subclass to receive native Windows events.
.PP
In your reimplementation of this function, if you want to stop the event being handled by Qt, return TRUE. If you return FALSE, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.
.PP
\fBWarning:\fR This function is not portable.
.PP
See also QApplication::winEventFilter().
.SH "WId QWidget::winId () const"
Returns the window system identifier of the widget.
.PP
Portable in principle, but if you use it you are probably about to do something non-portable. Be careful.
.PP
See also find().
.SH "void QWidget::windowActivationChange ( bool oldActive )\fC [virtual protected]\fR"
This virtual function is called for a widget when its window is activated or deactivated by the window system. \fIoldActive\fR is the previous state; you can get the new setting from isActiveWindow().
.PP
Reimplement this function if your widget needs to know when its window becomes activated or deactivated.
.PP
The default implementation updates the visible part of the widget if the inactive and the active colorgroup are different for colors other than the highlight and link colors.
.PP
See also setActiveWindow(), isActiveWindow, update(), and palette.
.SH "double QWidget::windowOpacity () const"
Returns the level of opacity for the window. See the "windowOpacity" property for details.
.SH "uint QWidget::windowState () const"
Returns the current window state. The window state is a OR'ed combination of Qt::WindowState: WindowMinimized, WindowMaximized, WindowFullScreen and WindowActive.
.PP
See also Qt::WindowState and setWindowState().
.SH "int QWidget::x () const"
Returns the x coordinate of the widget relative to its parent including any window frame. See the "x" property for details.
.SH "bool QWidget::x11Event ( XEvent * )\fC [virtual protected]\fR"
This special event handler can be reimplemented in a subclass to receive native X11 events.
.PP
In your reimplementation of this function, if you want to stop the event being handled by Qt, return TRUE. If you return FALSE, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.
.PP
\fBWarning:\fR This function is not portable.
.PP
See also QApplication::x11EventFilter().
.PP
Reimplemented in QXtWidget.
.SH "int QWidget::y () const"
Returns the y coordinate of the widget relative to its parent and including any window frame. See the "y" property for details.
.SS "Property Documentation"
.SH "bool acceptDrops"
This property holds whether drop events are enabled for this widget.
.PP
Setting this property to TRUE announces to the system that this widget \fImay\fR be able to accept drop events.
.PP
If the widget is the desktop (QWidget::isDesktop()), this may fail if another application is using the desktop; you can call acceptDrops() to test if this occurs.
.PP
\fBWarning:\fR Do not modify this property in a Drag&Drop event handler.
.PP
Set this property's value with setAcceptDrops() and get this property's value with acceptDrops().
.SH "bool autoMask"
This property holds whether the auto mask feature is enabled for the widget.
.PP
Transparent widgets use a mask to define their visible region. QWidget has some built-in support to make the task of recalculating the mask easier. When setting auto mask to TRUE, updateMask() will be called whenever the widget is resized or changes its focus state. Note that you must reimplement updateMask() (which should include a call to setMask()) or nothing will happen.
.PP
Note: when you re-implement resizeEvent(), focusInEvent() or focusOutEvent() in your custom widgets and still want to ensure that the auto mask calculation works, you should add:
.PP
.nf
.br
        if ( autoMask() )
.br
            updateMask();
.br
.fi
.PP
at the end of your event handlers. This is true for all member functions that change the appearance of the widget in a way that requires a recalculation of the mask.
.PP
While being a technically appealing concept, masks have a big drawback: when using complex masks that cannot be expressed easily with relatively simple regions, they can be very slow on some window systems. The classic example is a transparent label. The complex shape of its contents makes it necessary to represent its mask by a bitmap, which consumes both memory and time. If all you want is to blend the background of several neighboring widgets together seamlessly, you will probably want to use setBackgroundOrigin() rather than a mask.
.PP
See also updateMask(), setMask(), clearMask(), and backgroundOrigin.
.PP
Set this property's value with setAutoMask() and get this property's value with autoMask().
.SH "QBrush backgroundBrush"
This property holds the widget's background brush.
.PP
The background brush depends on a widget's palette and its background mode.
.PP
See also backgroundColor(), backgroundPixmap(), eraseColor(), palette, and QApplication::setPalette().
.PP
Get this property's value with backgroundBrush().
.SH "BackgroundMode backgroundMode"
This property holds the color role used for painting the background of the widget.
.PP
setPaletteBackgroundColor() reads this property to determine which entry of the palette to set.
.PP
For most widgets the default suffices (PaletteBackground, typically gray), but some need to use PaletteBase (the background color for text output, typically white) or another role.
.PP
QListBox, which is "sunken" and uses the base color to contrast with its environment, does this in its constructor:
.PP
.nf
.br
    setBackgroundMode( PaletteBase );
.br
.fi
.PP
You will never need to set the background mode of a built-in widget in Qt, but you might consider setting it in your custom widgets, so that setPaletteBackgroundColor() works as expected.
.PP
Note that two of the BackgroundMode values make no sense for setBackgroundMode(), namely FixedPixmap and FixedColor. You must call setBackgroundPixmap() and setPaletteBackgroundColor() instead.
.PP
Set this property's value with setBackgroundMode() and get this property's value with backgroundMode().
.SH "BackgroundOrigin backgroundOrigin"
This property holds the origin of the widget's background.
.PP
The origin is either WidgetOrigin (the default), ParentOrigin, WindowOrigin or AncestorOrigin.
.PP
This only makes a difference if the widget has a background pixmap, in which case positioning matters. Using WindowOrigin for several neighboring widgets makes the background blend together seamlessly. AncestorOrigin allows blending backgrounds seamlessly when an ancestor of the widget has an origin other than WindowOrigin.
.PP
See also backgroundPixmap() and backgroundMode.
.PP
Set this property's value with setBackgroundOrigin() and get this property's value with backgroundOrigin().
.SH "QSize baseSize"
This property holds the base size of the widget.
.PP
The base size is used to calculate a proper widget size if the widget defines sizeIncrement().
.PP
See also sizeIncrement.
.PP
Set this property's value with setBaseSize() and get this property's value with baseSize().
.SH "QString caption"
This property holds the window caption (title).
.PP
This property only makes sense for top-level widgets. If no caption has been set, the caption is QString::null.
.PP
See also icon and iconText.
.PP
Set this property's value with setCaption() and get this property's value with caption().
.SH "QRect childrenRect"
This property holds the bounding rectangle of the widget's children.
.PP
Hidden children are excluded.
.PP
See also childrenRegion and geometry.
.PP
Get this property's value with childrenRect().
.SH "QRegion childrenRegion"
This property holds the combined region occupied by the widget's children.
.PP
Hidden children are excluded.
.PP
See also childrenRect and geometry.
.PP
Get this property's value with childrenRegion().
.SH "QColorGroup colorGroup"
This property holds the current color group of the widget palette.
.PP
The color group is determined by the state of the widget. A disabled widget has the QPalette::disabled() color group, a widget with keyboard focus has the QPalette::active() color group, and an inactive widget has the QPalette::inactive() color group.
.PP
See also palette.
.PP
Get this property's value with colorGroup().
.SH "QCursor cursor"
This property holds the cursor shape for this widget.
.PP
The mouse cursor will assume this shape when it's over this widget. See the list of predefined cursor objects for a range of useful shapes.
.PP
An editor widget might use an I-beam cursor:
.PP
.nf
.br
        setCursor( IbeamCursor );
.br
.fi
.PP
If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used. The function unsetCursor() has no effect on top-level widgets.
.PP
See also QApplication::setOverrideCursor().
.PP
Set this property's value with setCursor(), get this property's value with cursor(), and reset this property's value with unsetCursor().
.SH "bool customWhatsThis"
This property holds whether the widget wants to handle What's This help manually.
.PP
The default implementation of customWhatsThis() returns FALSE, which means the widget will not receive any events in Whats This mode.
.PP
The widget may leave What's This mode by calling QWhatsThis::leaveWhatsThisMode(), with or without actually displaying any help text.
.PP
You can also reimplement customWhatsThis() if your widget is a" passive interactor" supposed to work under all circumstances. Simply don't call QWhatsThis::leaveWhatsThisMode() in that case.
.PP
See also QWhatsThis::inWhatsThisMode() and QWhatsThis::leaveWhatsThisMode().
.PP
Get this property's value with customWhatsThis().
.SH "bool enabled"
This property holds whether the widget is enabled.
.PP
An enabled widget receives keyboard and mouse events; a disabled widget does not. In fact, an enabled widget only receives keyboard events when it is in focus.
.PP
Some widgets display themselves differently when they are disabled. For example a button might draw its label grayed out. If your widget needs to know when it becomes enabled or disabled, you can reimplement the enabledChange() function.
.PP
Disabling a widget implicitly disables all its children. Enabling respectively enables all child widgets unless they have been explicitly disabled.
.PP
See also enabled, isEnabledTo(), QKeyEvent, QMouseEvent, and enabledChange().
.PP
Set this property's value with setEnabled() and get this property's value with isEnabled().
.SH "bool focus"
This property holds whether this widget (or its focus proxy) has the keyboard input focus.
.PP
Effectively equivalent to \fCqApp->focusWidget() == this\fR.
.PP
See also setFocus(), clearFocus(), focusPolicy, and QApplication::focusWidget().
.PP
Get this property's value with hasFocus().
.SH "bool focusEnabled"
This property holds whether the widget accepts keyboard focus.
.PP
Keyboard focus is initially disabled (i.e. focusPolicy() == QWidget::NoFocus).
.PP
You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the QLineEdit constructor calls setFocusPolicy(QWidget::StrongFocus).
.PP
See also focusPolicy, focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), and enabled.
.PP
Get this property's value with isFocusEnabled().
.SH "FocusPolicy focusPolicy"
This property holds the way the widget accepts keyboard focus.
.PP
The policy is QWidget::TabFocus if the widget accepts keyboard focus by tabbing, QWidget::ClickFocus if the widget accepts focus by clicking, QWidget::StrongFocus if it accepts both, and QWidget::NoFocus (the default) if it does not accept focus at all.
.PP
You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the QLineEdit constructor calls setFocusPolicy(QWidget::StrongFocus).
.PP
See also focusEnabled, focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), and enabled.
.PP
Set this property's value with setFocusPolicy() and get this property's value with focusPolicy().
.SH "QFont font"
This property holds the font currently set for the widget.
.PP
The fontInfo() function reports the actual font that is being used by the widget.
.PP
As long as no special font has been set, or after unsetFont() is called, this is either a special font for the widget class, the parent's font or (if this widget is a top level widget), the default application font.
.PP
This code fragment sets a 12 point helvetica bold font:
.PP
.nf
.br
    QFont f( "Helvetica", 12, QFont::Bold );
.br
    setFont( f );
.br
.fi
.PP
In addition to setting the font, setFont() informs all children about the change.
.PP
See also fontChange(), fontInfo(), fontMetrics(), and ownFont.
.PP
Set this property's value with setFont(), get this property's value with font(), and reset this property's value with unsetFont().
.SH "QRect frameGeometry"
This property holds geometry of the widget relative to its parent including any window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also geometry, x, y, and pos.
.PP
Get this property's value with frameGeometry().
.SH "QSize frameSize"
This property holds the size of the widget including any window frame.
.PP
Get this property's value with frameSize().
.SH "bool fullScreen"
This property holds whether the widget is full screen.
.PP
Get this property's value with isFullScreen().
.PP
See also windowState(), minimized, and maximized.
.SH "QRect geometry"
This property holds the geometry of the widget relative to its parent and excluding the window frame.
.PP
When changing the geometry, the widget, if visible, receives a move event (moveEvent()) and/or a resize event (resizeEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.
.PP
The size component is adjusted if it lies outside the range defined by minimumSize() and maximumSize().
.PP
setGeometry() is virtual, and all other overloaded setGeometry() implementations in Qt call it.
.PP
\fBWarning:\fR Calling setGeometry() inside resizeEvent() or moveEvent() can lead to infinite recursion.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also frameGeometry, rect, pos, size, moveEvent(), resizeEvent(), minimumSize, and maximumSize.
.PP
Set this property's value with setGeometry() and get this property's value with geometry().
.SH "int height"
This property holds the height of the widget excluding any window frame.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also geometry, width, and size.
.PP
Get this property's value with height().
.SH "bool hidden"
This property holds whether the widget is explicitly hidden.
.PP
If FALSE, the widget is visible or would become visible if all its ancestors became visible.
.PP
See also hide(), show(), visible, isVisibleTo(), and shown.
.PP
Set this property's value with setHidden() and get this property's value with isHidden().
.SH "QPixmap icon"
This property holds the widget's icon.
.PP
This property only makes sense for top-level widgets. If no icon has been set, icon() returns 0.
.PP
See also iconText, caption, and Setting the Application Icon.
.PP
Set this property's value with setIcon() and get this property's value with icon().
.SH "QString iconText"
This property holds the widget's icon text.
.PP
This property only makes sense for top-level widgets. If no icon text has been set, this functions returns QString::null.
.PP
See also icon and caption.
.PP
Set this property's value with setIconText() and get this property's value with iconText().
.SH "bool inputMethodEnabled"
This property holds enables or disables the use of input methods for this widget.
.PP
Most Widgets (as eg. buttons) that do not handle text input should have the input method disabled if they have focus. This is the default.
.PP
If a widget handles text input it should set this property to TRUE.
.PP
Set this property's value with setInputMethodEnabled() and get this property's value with isInputMethodEnabled().
.SH "bool isActiveWindow"
This property holds whether this widget is the active window.
.PP
The active window is the window that contains the widget that has keyboard focus.
.PP
When popup windows are visible, this property is TRUE for both the active window \fIand\fR for the popup.
.PP
See also setActiveWindow() and QApplication::activeWindow().
.PP
Get this property's value with isActiveWindow().
.SH "bool isDesktop"
This property holds whether the widget is a desktop widget, i.e. represents the desktop.
.PP
A desktop widget is also a top-level widget.
.PP
See also isTopLevel and QApplication::desktop().
.PP
Get this property's value with isDesktop().
.SH "bool isDialog"
This property holds whether the widget is a dialog widget.
.PP
A dialog widget is a secondary top-level widget, i.e. a top-level widget with a parent.
.PP
See also isTopLevel and QDialog.
.PP
Get this property's value with isDialog().
.SH "bool isModal"
This property holds whether the widget is a modal widget.
.PP
This property only makes sense for top-level widgets. A modal widget prevents widgets in all other top-level widgets from getting any input.
.PP
See also isTopLevel, isDialog, and QDialog.
.PP
Get this property's value with isModal().
.SH "bool isPopup"
This property holds whether the widget is a popup widget.
.PP
A popup widget is created by specifying the widget flag WType_Popup to the widget constructor. A popup widget is also a top-level widget.
.PP
See also isTopLevel.
.PP
Get this property's value with isPopup().
.SH "bool isTopLevel"
This property holds whether the widget is a top-level widget.
.PP
A top-level widget is a widget which usually has a frame and a caption (title). Popup and desktop widgets are also top-level widgets.
.PP
A top-level widget can have a parent widget. It will then be grouped with its parent and deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.
.PP
QDialog and QMainWindow widgets are by default top-level, even if a parent widget is specified in the constructor. This behavior is specified by the WType_TopLevel widget flag.
.PP
See also topLevelWidget(), isDialog, isModal, isPopup, isDesktop, and parentWidget().
.PP
Get this property's value with isTopLevel().
.SH "bool maximized"
This property holds whether this widget is maximized.
.PP
This property is only relevant for top-level widgets.
.PP
Note that due to limitations in some window-systems, this does not always report the expected results (e.g. if the user on X11 maximizes the window via the window manager, Qt has no way of distinguishing this from any other resize). This is expected to improve as window manager protocols evolve.
.PP
See also windowState(), showMaximized(), visible, show(), hide(), showNormal(), and minimized.
.PP
Get this property's value with isMaximized().
.SH "int maximumHeight"
This property holds the widget's maximum height.
.PP
This property corresponds to maximumSize().height().
.PP
See also maximumSize and maximumWidth.
.PP
Set this property's value with setMaximumHeight() and get this property's value with maximumHeight().
.SH "QSize maximumSize"
This property holds the widget's maximum size.
.PP
The widget cannot be resized to a larger size than the maximum widget size.
.PP
See also maximumWidth, maximumHeight, maximumSize, minimumSize, and sizeIncrement.
.PP
Set this property's value with setMaximumSize() and get this property's value with maximumSize().
.SH "int maximumWidth"
This property holds the widget's maximum width.
.PP
This property corresponds to maximumSize().width().
.PP
See also maximumSize and maximumHeight.
.PP
Set this property's value with setMaximumWidth() and get this property's value with maximumWidth().
.SH "QRect microFocusHint"
This property holds the currently set micro focus hint for this widget.
.PP
See the documentation of setMicroFocusHint() for more information.
.PP
Get this property's value with microFocusHint().
.SH "bool minimized"
This property holds whether this widget is minimized (iconified).
.PP
This property is only relevant for top-level widgets.
.PP
See also showMinimized(), visible, show(), hide(), showNormal(), and maximized.
.PP
Get this property's value with isMinimized().
.SH "int minimumHeight"
This property holds the widget's minimum height.
.PP
This property corresponds to minimumSize().height().
.PP
See also minimumSize and minimumWidth.
.PP
Set this property's value with setMinimumHeight() and get this property's value with minimumHeight().
.SH "QSize minimumSize"
This property holds the widget's minimum size.
.PP
The widget cannot be resized to a smaller size than the minimum widget size. The widget's size is forced to the minimum size if the current size is smaller.
.PP
If you use a layout inside the widget, the minimum size will be set by the layout and not by setMinimumSize(), unless you set the layout's resize mode to QLayout::FreeResize.
.PP
See also minimumWidth, minimumHeight, maximumSize, sizeIncrement, and QLayout::resizeMode.
.PP
Set this property's value with setMinimumSize() and get this property's value with minimumSize().
.SH "QSize minimumSizeHint"
This property holds the recommended minimum size for the widget.
.PP
If the value of this property is an invalid size, no minimum size is recommended.
.PP
The default implementation of minimumSizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's minimum size otherwise. Most built-in widgets reimplement minimumSizeHint().
.PP
QLayout will never resize a widget to a size smaller than minimumSizeHint.
.PP
See also QSize::isValid(), size, minimumSize, and sizePolicy.
.PP
Get this property's value with minimumSizeHint().
.SH "int minimumWidth"
This property holds the widget's minimum width.
.PP
This property corresponds to minimumSize().width().
.PP
See also minimumSize and minimumHeight.
.PP
Set this property's value with setMinimumWidth() and get this property's value with minimumWidth().
.SH "bool mouseTracking"
This property holds whether mouse tracking is enabled for the widget.
.PP
If mouse tracking is disabled (the default), the widget only receives mouse move events when at least one mouse button is pressed while the mouse is being moved.
.PP
If mouse tracking is enabled, the widget receives mouse move events even if no buttons are pressed.
.PP
See also mouseMoveEvent() and QApplication::setGlobalMouseTracking().
.PP
Set this property's value with setMouseTracking() and get this property's value with hasMouseTracking().
.SH "bool ownCursor"
This property holds whether the widget uses its own cursor.
.PP
If FALSE, the widget uses its parent widget's cursor.
.PP
See also cursor.
.PP
Get this property's value with ownCursor().
.SH "bool ownFont"
This property holds whether the widget uses its own font.
.PP
If FALSE, the widget uses its parent widget's font.
.PP
See also font.
.PP
Get this property's value with ownFont().
.SH "bool ownPalette"
This property holds whether the widget uses its own palette.
.PP
If FALSE, the widget uses its parent widget's palette.
.PP
See also palette.
.PP
Get this property's value with ownPalette().
.SH "QPalette palette"
This property holds the widget's palette.
.PP
As long as no special palette has been set, or after unsetPalette() has been called, this is either a special palette for the widget class, the parent's palette or (if this widget is a top level widget), the default application palette.
.PP
Instead of defining an entirely new palette, you can also use the paletteBackgroundColor, paletteBackgroundPixmap and paletteForegroundColor convenience properties to change a widget's background and foreground appearance only.
.PP
See also ownPalette, colorGroup, and QApplication::palette().
.PP
Set this property's value with setPalette(), get this property's value with palette(), and reset this property's value with unsetPalette().
.SH "QColor paletteBackgroundColor"
This property holds the background color of the widget.
.PP
The palette background color is usually set implicitly by setBackgroundMode(), although it can also be set explicitly by setPaletteBackgroundColor(). setPaletteBackgroundColor() is a convenience function that creates and sets a modified QPalette with setPalette(). The palette is modified according to the widget's background mode. For example, if the background mode is PaletteButton the color used for the palette's QColorGroup::Button color entry is set.
.PP
If there is a background pixmap (set using setPaletteBackgroundPixmap()), then the return value of this function is indeterminate.
.PP
See also paletteBackgroundPixmap, paletteForegroundColor, palette, and colorGroup.
.PP
Set this property's value with setPaletteBackgroundColor(), get this property's value with paletteBackgroundColor(), and reset this property's value with unsetPalette().
.SH "QPixmap paletteBackgroundPixmap"
This property holds the background pixmap of the widget.
.PP
The palette background pixmap is usually set implicitly by setBackgroundMode(), although it can also be set explicitly by setPaletteBackgroundPixmap(). setPaletteBackgroundPixmap() is a convenience function that creates and sets a modified QPalette with setPalette(). The palette is modified according to the widget's background mode. For example, if the background mode is PaletteButton the pixmap used for the palette's QColorGroup::Button color entry is set.
.PP
If there is a plain background color (set using setPaletteBackgroundColor()), then this function returns 0.
.PP
See also paletteBackgroundColor, paletteForegroundColor, palette, and colorGroup.
.PP
Set this property's value with setPaletteBackgroundPixmap(), get this property's value with paletteBackgroundPixmap(), and reset this property's value with unsetPalette().
.SH "QColor paletteForegroundColor"
This property holds the foreground color of the widget.
.PP
setPaletteForegroundColor() is a convenience function that creates and sets a modified QPalette with setPalette(). The palette is modified according to the widget's \fIbackground mode\fR. For example, if the background mode is PaletteButton the palette entry QColorGroup::ButtonText is set to color.
.PP
See also palette, QApplication::setPalette(), backgroundMode, foregroundColor(), backgroundMode, and setEraseColor().
.PP
Set this property's value with setPaletteForegroundColor(), get this property's value with paletteForegroundColor(), and reset this property's value with unsetPalette().
.SH "QPoint pos"
This property holds the position of the widget within its parent widget.
.PP
If the widget is a top-level widget, the position is that of the widget on the desktop, including its frame.
.PP
When changing the position, the widget, if visible, receives a move event (moveEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.
.PP
move() is virtual, and all other overloaded move() implementations in Qt call it.
.PP
\fBWarning:\fR Calling move() or setGeometry() inside moveEvent() can lead to infinite recursion.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also frameGeometry, size, x, and y.
.PP
Set this property's value with move() and get this property's value with pos().
.SH "QRect rect"
This property holds the internal geometry of the widget excluding any window frame.
.PP
The rect property equals QRect(0, 0, width(), height()).
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also size.
.PP
Get this property's value with rect().
.SH "bool shown"
This property holds whether the widget is shown.
.PP
If TRUE, the widget is visible or would become visible if all its ancestors became visible.
.PP
See also hide(), show(), visible, isVisibleTo(), and hidden.
.PP
Set this property's value with setShown() and get this property's value with isShown().
.SH "QSize size"
This property holds the size of the widget excluding any window frame.
.PP
When resizing, the widget, if visible, receives a resize event (resizeEvent()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.
.PP
The size is adjusted if it lies outside the range defined by minimumSize() and maximumSize(). Furthermore, the size is always at least QSize(1, 1). For toplevel widgets, the minimum size might be larger, depending on the window manager.
.PP
If you want a top-level window to have a fixed size, call setResizeMode( QLayout::FreeResize ) on its layout.
.PP
resize() is virtual, and all other overloaded resize() implementations in Qt call it.
.PP
\fBWarning:\fR Calling resize() or setGeometry() inside resizeEvent() can lead to infinite recursion.
.PP
See also pos, geometry, minimumSize, maximumSize, and resizeEvent().
.PP
Set this property's value with resize() and get this property's value with size().
.SH "QSize sizeHint"
This property holds the recommended size for the widget.
.PP
If the value of this property is an invalid size, no size is recommended.
.PP
The default implementation of sizeHint() returns an invalid size if there is no layout for this widget, and returns the layout's preferred size otherwise.
.PP
See also QSize::isValid(), minimumSizeHint, sizePolicy, minimumSize, and updateGeometry().
.PP
Get this property's value with sizeHint().
.SH "QSize sizeIncrement"
This property holds the size increment of the widget.
.PP
When the user resizes the window, the size will move in steps of sizeIncrement().width() pixels horizontally and sizeIncrement.height() pixels vertically, with baseSize() as the basis. Preferred widget sizes are for non-negative integers \fIi\fR and \fIj\fR:
.PP
.nf
.br
        width = baseSize().width() + i * sizeIncrement().width();
.br
        height = baseSize().height() + j * sizeIncrement().height();
.br
.fi
.PP
Note that while you can set the size increment for all widgets, it only affects top-level widgets.
.PP
\fBWarning:\fR The size increment has no effect under Windows, and may be disregarded by the window manager on X.
.PP
See also size, minimumSize, and maximumSize.
.PP
Set this property's value with setSizeIncrement() and get this property's value with sizeIncrement().
.SH "QSizePolicy sizePolicy"
This property holds the default layout behavior of the widget.
.PP
If there is a QLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such QLayout, the result of this function is used.
.PP
The default policy is Preferred/Preferred, which means that the widget can be freely resized, but prefers to be the size sizeHint() returns. Button-like widgets set the size policy to specify that they may stretch horizontally, but are fixed vertically. The same applies to lineedit controls (such as QLineEdit, QSpinBox or an editable QComboBox) and other horizontally orientated widgets (such as QProgressBar). QToolButton's are normally square, so they allow growth in both directions. Widgets that support different directions (such as QSlider, QScrollBar or QHeader) specify stretching in the respective direction only. Widgets that can provide scrollbars (usually subclasses of QScrollView) tend to specify that they can use additional space, and that they can make do with less than sizeHint().
.PP
See also sizeHint, QLayout, QSizePolicy, and updateGeometry().
.PP
Set this property's value with setSizePolicy() and get this property's value with sizePolicy().
.SH "bool underMouse"
This property holds whether the widget is under the mouse cursor.
.PP
This value is not updated properly during drag and drop operations.
.PP
See also QEvent::Enter and QEvent::Leave.
.PP
Get this property's value with hasMouse().
.SH "bool updatesEnabled"
This property holds whether updates are enabled.
.PP
Calling update() and repaint() has no effect if updates are disabled. Paint events from the window system are processed normally even if updates are disabled.
.PP
setUpdatesEnabled() is normally used to disable updates for a short period of time, for instance to avoid screen flicker during large changes.
.PP
Example:
.PP
.nf
.br
        setUpdatesEnabled( FALSE );
.br
        bigVisualChanges();
.br
        setUpdatesEnabled( TRUE );
.br
        repaint();
.br
.fi
.PP
See also update(), repaint(), and paintEvent().
.PP
Set this property's value with setUpdatesEnabled() and get this property's value with isUpdatesEnabled().
.SH "bool visible"
This property holds whether the widget is visible.
.PP
Calling show() sets the widget to visible status if all its parent widgets up to the top-level widget are visible. If an ancestor is not visible, the widget won't become visible until all its ancestors are shown.
.PP
Calling hide() hides a widget explicitly. An explicitly hidden widget will never become visible, even if all its ancestors become visible, unless you show it.
.PP
A widget receives show and hide events when its visibility status changes. Between a hide and a show event, there is no need to waste CPU cycles preparing or displaying information to the user. A video application, for example, might simply stop generating new frames.
.PP
A widget that happens to be obscured by other windows on the screen is considered to be visible. The same applies to iconified top-level widgets and windows that exist on another virtual desktop (on platforms that support this concept). A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again.
.PP
See also show(), hide(), hidden, isVisibleTo(), minimized, showEvent(), and hideEvent().
.PP
Get this property's value with isVisible().
.SH "QRect visibleRect"
This property holds the visible rectangle.
.PP
\fBThis property is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
No longer necessary, you can simply call repaint(). If you do not need the rectangle for repaint(), use clipRegion() instead.
.PP
Get this property's value with visibleRect().
.SH "int width"
This property holds the width of the widget excluding any window frame.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also geometry, height, and size.
.PP
Get this property's value with width().
.SH "double windowOpacity"
This property holds the level of opacity for the window.
.PP
The valid range of opacity is from 1.0 (completely opaque) to 0.0 (completely transparent).
.PP
By default the value of this property is 1.0.
.PP
This feature is only present on Mac OS X and Windows 2000 and up.
.PP
\fBWarning:\fR Changing this property from opaque to transparent might issue a paint event that needs to be processed before the window is displayed correctly. This affects mainly the use of QPixmap::grabWindow(). Also note that semi-transparent windows update and resize significantely slower than opaque windows.
.PP
Set this property's value with setWindowOpacity() and get this property's value with windowOpacity().
.SH "int x"
This property holds the x coordinate of the widget relative to its parent including any window frame.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also frameGeometry, y, and pos.
.PP
Get this property's value with x().
.SH "int y"
This property holds the y coordinate of the widget relative to its parent and including any window frame.
.PP
See the Window Geometry documentation for an overview of top-level widget geometry.
.PP
See also frameGeometry, x, and pos.
.PP
Get this property's value with y().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qwidget.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qwidget.3qt) and the Qt
version (3.3.8).
