'\" t
.TH QValueList 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QValueList \- Value-based template class that provides lists
.SH SYNOPSIS
All the functions in this class are reentrant when Qt is built with thread support.</p>
.PP
\fC#include <qvaluelist.h>\fR
.PP
Inherited by QCanvasItemList, QStringList, and QValueStack.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "typedef QValueListIterator<T> \fBiterator\fR"
.br
.ti -1c
.BI "typedef QValueListConstIterator<T> \fBconst_iterator\fR"
.br
.ti -1c
.BI "typedef T \fBvalue_type\fR"
.br
.ti -1c
.BI "typedef value_type * \fBpointer\fR"
.br
.ti -1c
.BI "typedef const value_type * \fBconst_pointer\fR"
.br
.ti -1c
.BI "typedef value_type & \fBreference\fR"
.br
.ti -1c
.BI "typedef const value_type & \fBconst_reference\fR"
.br
.ti -1c
.BI "typedef size_t \fBsize_type\fR"
.br
.ti -1c
.BI "\fBQValueList\fR ()"
.br
.ti -1c
.BI "\fBQValueList\fR ( const QValueList<T> & l )"
.br
.ti -1c
.BI "\fBQValueList\fR ( const std::list<T> & l )"
.br
.ti -1c
.BI "\fB~QValueList\fR ()"
.br
.ti -1c
.BI "QValueList<T> & \fBoperator=\fR ( const QValueList<T> & l )"
.br
.ti -1c
.BI "QValueList<T> & \fBoperator=\fR ( const std::list<T> & l )"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const std::list<T> & l ) const"
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QValueList<T> & l ) const"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QValueList<T> & l ) const"
.br
.ti -1c
.BI "iterator \fBbegin\fR ()"
.br
.ti -1c
.BI "const_iterator \fBbegin\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstBegin\fR () const"
.br
.ti -1c
.BI "iterator \fBend\fR ()"
.br
.ti -1c
.BI "const_iterator \fBend\fR () const"
.br
.ti -1c
.BI "const_iterator \fBconstEnd\fR () const"
.br
.ti -1c
.BI "iterator \fBinsert\fR ( iterator it, const T & x )"
.br
.ti -1c
.BI "uint \fBremove\fR ( const T & x )"
.br
.ti -1c
.BI "void \fBclear\fR ()"
.br
.ti -1c
.BI "QValueList<T> & \fBoperator<<\fR ( const T & x )"
.br
.ti -1c
.BI "size_type \fBsize\fR () const"
.br
.ti -1c
.BI "bool \fBempty\fR () const"
.br
.ti -1c
.BI "void \fBpush_front\fR ( const T & x )"
.br
.ti -1c
.BI "void \fBpush_back\fR ( const T & x )"
.br
.ti -1c
.BI "iterator \fBerase\fR ( iterator it )"
.br
.ti -1c
.BI "iterator \fBerase\fR ( iterator first, iterator last )"
.br
.ti -1c
.BI "reference \fBfront\fR ()"
.br
.ti -1c
.BI "const_reference \fBfront\fR () const"
.br
.ti -1c
.BI "reference \fBback\fR ()"
.br
.ti -1c
.BI "const_reference \fBback\fR () const"
.br
.ti -1c
.BI "void \fBpop_front\fR ()"
.br
.ti -1c
.BI "void \fBpop_back\fR ()"
.br
.ti -1c
.BI "void \fBinsert\fR ( iterator pos, size_type n, const T & x )"
.br
.ti -1c
.BI "QValueList<T> \fBoperator+\fR ( const QValueList<T> & l ) const"
.br
.ti -1c
.BI "QValueList<T> & \fBoperator+=\fR ( const QValueList<T> & l )"
.br
.ti -1c
.BI "iterator \fBfromLast\fR ()"
.br
.ti -1c
.BI "const_iterator \fBfromLast\fR () const"
.br
.ti -1c
.BI "bool \fBisEmpty\fR () const"
.br
.ti -1c
.BI "iterator \fBappend\fR ( const T & x )"
.br
.ti -1c
.BI "iterator \fBprepend\fR ( const T & x )"
.br
.ti -1c
.BI "iterator \fBremove\fR ( iterator it )"
.br
.ti -1c
.BI "T & \fBfirst\fR ()"
.br
.ti -1c
.BI "const T & \fBfirst\fR () const"
.br
.ti -1c
.BI "T & \fBlast\fR ()"
.br
.ti -1c
.BI "const T & \fBlast\fR () const"
.br
.ti -1c
.BI "T & \fBoperator[]\fR ( size_type i )"
.br
.ti -1c
.BI "const T & \fBoperator[]\fR ( size_type i ) const"
.br
.ti -1c
.BI "iterator \fBat\fR ( size_type i )"
.br
.ti -1c
.BI "const_iterator \fBat\fR ( size_type i ) const"
.br
.ti -1c
.BI "iterator \fBfind\fR ( const T & x )"
.br
.ti -1c
.BI "const_iterator \fBfind\fR ( const T & x ) const"
.br
.ti -1c
.BI "iterator \fBfind\fR ( iterator it, const T & x )"
.br
.ti -1c
.BI "const_iterator \fBfind\fR ( const_iterator it, const T & x ) const"
.br
.ti -1c
.BI "int \fBfindIndex\fR ( const T & x ) const"
.br
.ti -1c
.BI "size_type \fBcontains\fR ( const T & x ) const"
.br
.ti -1c
.BI "size_type \fBcount\fR () const"
.br
.ti -1c
.BI "QValueList<T> & \fBoperator+=\fR ( const T & x )"
.br
.ti -1c
.BI "typedef QValueListIterator<T> \fBIterator\fR"
.br
.ti -1c
.BI "typedef QValueListConstIterator<T> \fBConstIterator\fR"
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
.in +1c
.ti -1c
.BI "QDataStream & \fBoperator>>\fR ( QDataStream & s, QValueList<T> & l )"
.br
.ti -1c
.BI "QDataStream & \fBoperator<<\fR ( QDataStream & s, const QValueList<T> & l )"
.br
.in -1c
.SH DESCRIPTION
The QValueList class is a value-based template class that provides lists.
.PP
QValueList is a Qt implementation of an STL-like list container. It can be used in your application if the standard \fClist\fR is not available for your target platform(s). QValueList is part of the Qt Template Library.
.PP
QValueList<T> defines a template instance to create a list of values that all have the class T. Note that QValueList does not store pointers to the members of the list; it holds a copy of every member. This is why these kinds of classes are called "value based"; QPtrList and QDict are "pointer based".
.PP
QValueList contains and manages a collection of objects of type T and provides iterators that allow the contained objects to be addressed. QValueList owns the contained items. For more relaxed ownership semantics, see QPtrCollection and friends which are pointer-based containers.
.PP
Some classes cannot be used within a QValueList, for example, all classes derived from QObject and thus all classes that implement widgets. Only values can be used in a QValueList. To qualify as a value the class must provide:
.TP
a copy constructor;
.TP
an assignment operator;
.TP
a default constructor, i.e. a constructor that does not take any arguments.
.PP
Note that C++ defaults to field-by-field assignment operators and copy constructors if no explicit version is supplied. In many cases this is sufficient.
.PP
In addition, some compilers (e.g. Sun CC) might require that the class provides an equality operator (operator==()).
.PP
QValueList's function naming is consistent with the other Qt classes (e.g. count(), isEmpty()). QValueList also provides extra functions for compatibility with STL algorithms, such as size() and empty(). Programmers already familiar with the STL \fClist\fR may prefer to use the STL-compatible functions.
.PP
Example:
.PP
.nf
.br
    class Employee
.br
    {
.br
    public:
.br
        Employee(): sn(0) {}
.br
        Employee( const QString& forename, const QString& surname, int salary )
.br
            : fn(forename), sn(surname), sal(salary)
.br
        {}
.br
.br
        QString forename() const { return fn; }
.br
        QString surname() const { return sn; }
.br
        int salary() const { return sal; }
.br
        void setSalary( int salary ) { sal = salary; }
.br
.br
    private:
.br
        QString fn;
.br
        QString sn;
.br
        int sal;
.br
    };
.br
.br
    typedef QValueList<Employee> EmployeeList;
.br
    EmployeeList list;
.br
.br
    list.append( Employee("John", "Doe", 50000) );
.br
    list.append( Employee("Jane", "Williams", 80000) );
.br
    list.append( Employee("Tom", "Jones", 60000) );
.br
.br
    Employee mary( "Mary", "Hawthorne", 90000 );
.br
    list.append( mary );
.br
    mary.setSalary( 100000 );
.br
.br
    EmployeeList::iterator it;
.br
    for ( it = list.begin(); it != list.end(); ++it )
.br
        cout << (*it).surname().latin1() << ", " <<
.br
                (*it).forename().latin1() << " earns " <<
.br
                (*it).salary() << endl;
.br
.br
    // Output:
.br
    // Doe, John earns 50000
.br
    // Williams, Jane earns 80000
.br
    // Hawthorne, Mary earns 90000
.br
    // Jones, Tom earns 60000
.br
.fi
.PP
Notice that the latest changes to Mary's salary did not affect the value in the list because the list created a copy of Mary's entry.
.PP
There are several ways to find items in the list. The begin() and end() functions return iterators to the beginning and end of the list. The advantage of getting an iterator is that you can move forward or backward from this position by incrementing/decrementing the iterator. The iterator returned by end() points to the item which is one \fIpast\fR the last item in the container. The past-the-end iterator is still associated with the list it belongs to, however it is \fInot\fR dereferenceable; operator*() will not return a well-defined value. If the list is empty(), the iterator returned by begin() will equal the iterator returned by end().
.PP
Another way to find an item in the list is by using the qFind() algorithm. For example:
.PP
.nf
.br
    QValueList<int> list;
.br
    ...
.br
    QValueList<int>::iterator it = qFind( list.begin(), list.end(), 3 );
.br
    if ( it != list.end() )
.br
        // it points to the found item
.br
.fi
.PP
It is safe to have multiple iterators a the list at the same time. If some member of the list is removed, only iterators pointing to the removed member become invalid. Inserting into the list does not invalidate any iterator. For convenience, the function last() returns a reference to the last item in the list, and first() returns a reference to the the first item. If the list is empty(), both last() and first() have undefined behavior (your application will crash or do unpredictable things). Use last() and first() with caution, for example:
.PP
.nf
.br
    QValueList<int> list;
.br
    list.append( 1 );
.br
    list.append( 2 );
.br
    list.append( 3 );
.br
    ...
.br
    if ( !list.empty() ) {
.br
        // OK, modify the first item
.br
        int& i = list.first();
.br
        i = 18;
.br
    }
.br
    ...
.br
    QValueList<double> dlist;
.br
    double d = dlist.last(); // undefined
.br
.fi
.PP
Because QValueList is value-based there is no need to be careful about deleting items in the list. The list holds its own copies and will free them if the corresponding member or the list itself is deleted. You can force the list to free all of its items with clear().
.PP
QValueList is shared implicitly, which means it can be copied in constant time, i.e. O(1). If multiple QValueList instances share the same data and one needs to modify its contents, this modifying instance makes a copy and modifies its private copy; therefore it does not affect the other instances; this takes O(n) time. This is often called "copy on write". If a QValueList is being used in a multi-threaded program, you must protect all access to the list. See QMutex.
.PP
There are several ways to insert items into the list. The prepend() and append() functions insert items at the beginning and the end of the list respectively. The insert() function comes in several flavors and can be used to add one or more items at specific positions within the list.
.PP
Items can also be removed from the list in several ways. There are several variants of the remove() function, which removes a specific item from the list. The remove() function will find and remove items according to a specific item value.
.PP
Lists can also be sorted using the Qt Template Library. For example with qHeapSort():
.PP
Example:
.PP
.nf
.br
    QValueList<int> list;
.br
    list.append( 5 );
.br
    list.append( 8 );
.br
    list.append( 3 );
.br
    list.append( 4 );
.br
    qHeapSort( list );
.br
.fi
.PP
See also QValueListIterator, Qt Template Library Classes, Implicitly and Explicitly Shared Classes, and Non-GUI Classes.
.SS "Member Type Documentation"
.SH "QValueList::ConstIterator"
This iterator is an instantiation of QValueListConstIterator for the same type as this QValueList. In other words, if you instantiate QValueList<int>, ConstIterator is a QValueListConstIterator<int>. Several member function use it, such as QValueList::begin(), which returns an iterator pointing to the first item in the list.
.PP
Functionally, this is almost the same as Iterator. The only difference is you cannot use ConstIterator for non-const operations, and that the compiler can often generate better code if you use ConstIterator.
.PP
See also QValueListIterator and Iterator.
.SH "QValueList::Iterator"
This iterator is an instantiation of QValueListIterator for the same type as this QValueList. In other words, if you instantiate QValueList<int>, Iterator is a QValueListIterator<int>. Several member function use it, such as QValueList::begin(), which returns an iterator pointing to the first item in the list.
.PP
Functionally, this is almost the same as ConstIterator. The only difference is that you cannot use ConstIterator for non-const operations, and that the compiler can often generate better code if you use ConstIterator.
.PP
See also QValueListIterator and ConstIterator.
.SH "QValueList::const_iterator"
The list's const iterator type, QValueListConstIterator.
.SH "QValueList::const_pointer"
The const pointer to T type.
.SH "QValueList::const_reference"
The const reference to T type.
.SH "QValueList::iterator"
The list's iterator type, QValueListIterator.
.SH "QValueList::pointer"
The pointer to T type.
.SH "QValueList::reference"
The reference to T type.
.SH "QValueList::size_type"
An unsigned integral type, used to represent various sizes.
.SH "QValueList::value_type"
The type of the object stored in the list, T.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QValueList::QValueList ()"
Constructs an empty list.
.SH "QValueList::QValueList ( const QValueList<T> & l )"
Constructs a copy of \fIl\fR.
.PP
This operation takes O(1) time because QValueList is implicitly shared.
.PP
The first modification to a list will take O(n) time.
.SH "QValueList::QValueList ( const std::list<T> & l )"
Contructs a copy of \fIl\fR.
.PP
This constructor is provided for compatibility with STL containers.
.SH "QValueList::~QValueList ()"
Destroys the list. References to the values in the list and all iterators of this list become invalidated. Note that it is impossible for an iterator to check whether or not it is valid: QValueList is highly tuned for performance, not for error checking.
.SH "iterator QValueList::append ( const T & x )"
Inserts \fIx\fR at the end of the list.
.PP
See also insert() and prepend().
.PP
Examples:
.)l checklists/checklists.cpp and fonts/simple-qfont-demo/viewer.cpp.
.SH "const_iterator QValueList::at ( size_type i ) const"
Returns an iterator pointing to the item at position \fIi\fR in the list, or an undefined value if the index is out of range.
.PP
\fBWarning:\fR This function uses a linear search and can be extremely slow for large lists. QValueList is not optimized for random item access. If you need random access use a different container, such as QValueVector.
.SH "iterator QValueList::at ( size_type i )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator pointing to the item at position \fIi\fR in the list, or an undefined value if the index is out of range.
.SH "reference QValueList::back ()"
Returns a reference to the last item. If the list contains no last item (i.e. empty() returns TRUE), the return value is undefined.
.PP
This function is provided for STL compatibility. It is equivalent to last().
.PP
See also front().
.SH "const_reference QValueList::back () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "const_iterator QValueList::begin () const"
Returns an iterator pointing to the first item in the list. This iterator equals end() if the list is empty.
.PP
See also first(), end(), and constBegin().
.PP
Examples:
.)l canvas/canvas.cpp, chart/canvasview.cpp, chart/element.cpp, checklists/checklists.cpp, sql/overview/insert/main.cpp, table/statistics/statistics.cpp, and themes/themes.cpp.
.SH "iterator QValueList::begin ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator pointing to the first item in the list. This iterator equals end() if the list is empty.
.PP
See also first() and end().
.SH "void QValueList::clear ()"
Removes all items from the list.
.PP
See also remove().
.SH "const_iterator QValueList::constBegin () const"
Returns an iterator pointing to the first item in the list. This iterator equals constEnd() if the list is empty.
.PP
See also begin().
.SH "const_iterator QValueList::constEnd () const"
Returns an iterator pointing \fIpast\fR the last item in the list. This iterator equals constBegin() if the list is empty.
.PP
See also end().
.SH "size_type QValueList::contains ( const T & x ) const"
Returns the number of occurrences of the value \fIx\fR in the list.
.SH "size_type QValueList::count () const"
Returns the number of items in the list.
.PP
See also isEmpty().
.PP
Examples:
.)l chart/element.cpp, fileiconview/qfileiconview.cpp, and table/statistics/statistics.cpp.
.SH "bool QValueList::empty () const"
Returns TRUE if the list contains no items; otherwise returns FALSE.
.PP
See also size().
.SH "iterator QValueList::end ()"
Returns an iterator pointing \fIpast\fR the last item in the list. This iterator equals begin() if the list is empty.
.PP
See also last(), begin(), and constEnd().
.PP
Examples:
.)l canvas/canvas.cpp, chart/canvasview.cpp, chart/element.cpp, checklists/checklists.cpp, sql/overview/insert/main.cpp, table/statistics/statistics.cpp, and themes/themes.cpp.
.SH "const_iterator QValueList::end () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator pointing \fIpast\fR the last item in the list. This iterator equals begin() if the list is empty.
.PP
See also last() and begin().
.SH "iterator QValueList::erase ( iterator it )"
Removes the item pointed to by \fIit\fR from the list. No iterators other than \fIit\fR or other iterators pointing at the same item as \fIit\fR are invalidated. Returns an iterator to the next item after \fIit\fR, or end() if there is no such item.
.PP
This function is provided for STL compatibility. It is equivalent to remove().
.SH "iterator QValueList::erase ( iterator first, iterator last )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Deletes all items from \fIfirst\fR to \fIlast\fR (not including \fIlast\fR). No iterators are invalidated, except those pointing to the removed items themselves. Returns \fIlast\fR.
.SH "iterator QValueList::find ( const T & x )"
Returns an iterator pointing to the first occurrence of \fIx\fR in the list.
.PP
Returns end() is no item matched.
.SH "const_iterator QValueList::find ( const T & x ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator pointing to the first occurrence of \fIx\fR in the list.
.PP
Returns end() if no item matched.
.SH "iterator QValueList::find ( iterator it, const T & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of \fIx\fR in the list starting at the position given by \fIit\fR.
.PP
Returns end() if no item matched.
.SH "const_iterator QValueList::find ( const_iterator it, const T & x ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Finds the first occurrence of \fIx\fR in the list starting at the position given by \fIit\fR.
.PP
Returns end() if no item matched.
.SH "int QValueList::findIndex ( const T & x ) const"
Returns the index of the first occurrence of the value \fIx\fR. Returns -1 if no item matched.
.SH "T & QValueList::first ()"
Returns a reference to the first item. If the list contains no first item (i.e. isEmpty() returns TRUE), the return value is undefined.
.PP
See also last().
.PP
Example: network/mail/smtp.cpp.
.SH "const T & QValueList::first () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "const_iterator QValueList::fromLast () const"
Returns an iterator to the last item in the list, or end() if there is no last item.
.PP
Use the end() function instead. For example:
.PP
.nf
.br
    QValueList<int> l;
.br
    ...
.br
    QValueList<int>::iterator it = l.end();
.br
    --it;
.br
    if ( it != end() )
.br
        // ...
.br
.fi
.SH "iterator QValueList::fromLast ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns an iterator to the last item in the list, or end() if there is no last item.
.PP
Use the end() function instead. For example:
.PP
.nf
.br
    QValueList<int> l;
.br
    ...
.br
    QValueList<int>::iterator it = l.end();
.br
    --it;
.br
    if ( it != end() )
.br
        // ...
.br
.fi
.SH "reference QValueList::front ()"
Returns a reference to the first item. If the list contains no first item (i.e. empty() returns TRUE), the return value is undefined.
.PP
This function is provided for STL compatibility. It is equivalent to first().
.PP
See also back().
.SH "const_reference QValueList::front () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "iterator QValueList::insert ( iterator it, const T & x )"
Inserts the value \fIx\fR in front of the item pointed to by the iterator, \fIit\fR.
.PP
Returns an iterator pointing at the inserted item.
.PP
See also append() and prepend().
.PP
Example: themes/themes.cpp.
.SH "void QValueList::insert ( iterator pos, size_type n, const T & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Inserts \fIn\fR copies of \fIx\fR before position \fIpos\fR.
.SH "bool QValueList::isEmpty () const"
Returns TRUE if the list contains no items; otherwise returns FALSE.
.PP
See also count().
.PP
Examples:
.)l fonts/simple-qfont-demo/viewer.cpp and network/mail/smtp.cpp.
.SH "T & QValueList::last ()"
Returns a reference to the last item. If the list contains no last item (i.e. empty() returns TRUE), the return value is undefined.
.SH "const T & QValueList::last () const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "bool QValueList::operator!= ( const QValueList<T> & l ) const"
Compares both lists.
.PP
Returns TRUE if this list and \fIl\fR are unequal; otherwise returns FALSE.
.SH "QValueList<T> QValueList::operator+ ( const QValueList<T> & l ) const"
Creates a new list and fills it with the items of this list. Then the items of \fIl\fR are appended. Returns the new list.
.SH "QValueList<T> & QValueList::operator+= ( const QValueList<T> & l )"
Appends the items of \fIl\fR to this list. Returns a reference to this list.
.SH "QValueList<T> & QValueList::operator+= ( const T & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Appends the value \fIx\fR to the list. Returns a reference to the list.
.SH "QValueList<T> & QValueList::operator<< ( const T & x )"
Adds the value \fIx\fR to the end of the list.
.PP
Returns a reference to the list.
.SH "QValueList<T> & QValueList::operator= ( const QValueList<T> & l )"
Assigns \fIl\fR to this list and returns a reference to this list.
.PP
All iterators of the current list become invalidated by this operation. The cost of such an assignment is O(1) since QValueList is implicitly shared.
.SH "QValueList<T> & QValueList::operator= ( const std::list<T> & l )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Assigns the contents of \fIl\fR to the list.
.PP
All iterators of the current list become invalidated by this operation.
.SH "bool QValueList::operator== ( const QValueList<T> & l ) const"
Compares both lists.
.PP
Returns TRUE if this list and \fIl\fR are equal; otherwise returns FALSE.
.SH "bool QValueList::operator== ( const std::list<T> & l ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns TRUE if this list and \fIl\fR are equal; otherwise returns FALSE.
.PP
This operator is provided for compatibility with STL containers.
.SH "const T & QValueList::operator[] ( size_type i ) const"
Returns a const reference to the item with index \fIi\fR in the list. It is up to you to check whether this item really exists. You can do that easily with the count() function. However this operator does not check whether \fIi\fR is in range and will deliver undefined results if it does not exist.
.PP
\fBWarning:\fR This function uses a linear search and can be extremely slow for large lists. QValueList is not optimized for random item access. If you need random access use a different container, such as QValueVector.
.SH "T & QValueList::operator[] ( size_type i )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns a non-const reference to the item with index \fIi\fR.
.SH "void QValueList::pop_back ()"
Removes the last item. If there is no last item, this operation is undefined.
.PP
This function is provided for STL compatibility.
.SH "void QValueList::pop_front ()"
Removes the first item. If there is no first item, this operation is undefined.
.PP
This function is provided for STL compatibility.
.SH "iterator QValueList::prepend ( const T & x )"
Inserts \fIx\fR at the beginning of the list.
.PP
See also insert() and append().
.SH "void QValueList::push_back ( const T & x )"
Inserts \fIx\fR at the end of the list.
.PP
This function is provided for STL compatibility. It is equivalent to append().
.SH "void QValueList::push_front ( const T & x )"
Inserts \fIx\fR at the beginning of the list.
.PP
This function is provided for STL compatibility. It is equivalent to prepend().
.PP
Example: toplevel/options.ui.h.
.SH "iterator QValueList::remove ( iterator it )"
Removes the item pointed to by \fIit\fR from the list. No iterators other than \fIit\fR or other iterators pointing at the same item as \fIit\fR are invalidated. Returns an iterator to the next item after \fIit\fR, or end() if there is no such item.
.PP
See also clear().
.SH "uint QValueList::remove ( const T & x )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Removes all items that have value \fIx\fR and returns the number of removed items.
.SH "size_type QValueList::size () const"
Returns the number of items in the list.
.PP
This function is provided for STL compatibility. It is equivalent to count().
.PP
See also empty().
.SH RELATED FUNCTION DOCUMENTATION
.SH "QDataStream & operator<< ( QDataStream & s, const QValueList<T> & l )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Writes a list, \fIl\fR, to the stream \fIs\fR. The type T stored in the list must implement the streaming operator.
.SH "QDataStream & operator>> ( QDataStream & s, QValueList<T> & l )"
Reads a list, \fIl\fR, from the stream \fIs\fR. The type T stored in the
list must implement the streaming operator.

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qvaluelist.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qvaluelist.3qt) and the Qt
version (3.3.8).
