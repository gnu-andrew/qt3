'\" t
.TH QScrollView 3qt "2 February 2007" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2007 Trolltech ASA.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QScrollView \- Scrolling area with on-demand scroll bars
.SH SYNOPSIS
\fC#include <qscrollview.h>\fR
.PP
Inherits QFrame.
.PP
Inherited by QCanvasView, QTable, QGridView, QIconView, QListBox, QListView, and QTextEdit.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQScrollView\fR ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )"
.br
.ti -1c
.BI "\fB~QScrollView\fR ()"
.br
.ti -1c
.BI "enum \fBResizePolicy\fR { Default, Manual, AutoOne, AutoOneFit }"
.br
.ti -1c
.BI "virtual void \fBsetResizePolicy\fR ( ResizePolicy )"
.br
.ti -1c
.BI "ResizePolicy \fBresizePolicy\fR () const"
.br
.ti -1c
.BI "void \fBremoveChild\fR ( QWidget * child )"
.br
.ti -1c
.BI "virtual void \fBaddChild\fR ( QWidget * child, int x = 0, int y = 0 )"
.br
.ti -1c
.BI "virtual void \fBmoveChild\fR ( QWidget * child, int x, int y )"
.br
.ti -1c
.BI "int \fBchildX\fR ( QWidget * child )"
.br
.ti -1c
.BI "int \fBchildY\fR ( QWidget * child )"
.br
.ti -1c
.BI "bool childIsVisible ( QWidget * child )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "void showChild ( QWidget * child, bool y = TRUE )  \fI(obsolete)\fR"
.br
.ti -1c
.BI "enum \fBScrollBarMode\fR { Auto, AlwaysOff, AlwaysOn }"
.br
.ti -1c
.BI "ScrollBarMode \fBvScrollBarMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetVScrollBarMode\fR ( ScrollBarMode )"
.br
.ti -1c
.BI "ScrollBarMode \fBhScrollBarMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetHScrollBarMode\fR ( ScrollBarMode )"
.br
.ti -1c
.BI "QWidget * \fBcornerWidget\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCornerWidget\fR ( QWidget * corner )"
.br
.ti -1c
.BI "QScrollBar * \fBhorizontalScrollBar\fR () const"
.br
.ti -1c
.BI "QScrollBar * \fBverticalScrollBar\fR () const"
.br
.ti -1c
.BI "QWidget * \fBviewport\fR () const"
.br
.ti -1c
.BI "QWidget * \fBclipper\fR () const"
.br
.ti -1c
.BI "int \fBvisibleWidth\fR () const"
.br
.ti -1c
.BI "int \fBvisibleHeight\fR () const"
.br
.ti -1c
.BI "int \fBcontentsWidth\fR () const"
.br
.ti -1c
.BI "int \fBcontentsHeight\fR () const"
.br
.ti -1c
.BI "int \fBcontentsX\fR () const"
.br
.ti -1c
.BI "int \fBcontentsY\fR () const"
.br
.ti -1c
.BI "void \fBupdateContents\fR ( int x, int y, int w, int h )"
.br
.ti -1c
.BI "void \fBupdateContents\fR ( const QRect & r )"
.br
.ti -1c
.BI "void \fBupdateContents\fR ()"
.br
.ti -1c
.BI "void \fBrepaintContents\fR ( int x, int y, int w, int h, bool erase = TRUE )"
.br
.ti -1c
.BI "void \fBrepaintContents\fR ( const QRect & r, bool erase = TRUE )"
.br
.ti -1c
.BI "void \fBrepaintContents\fR ( bool erase = TRUE )"
.br
.ti -1c
.BI "void \fBcontentsToViewport\fR ( int x, int y, int & vx, int & vy ) const"
.br
.ti -1c
.BI "void \fBviewportToContents\fR ( int vx, int vy, int & x, int & y ) const"
.br
.ti -1c
.BI "QPoint \fBcontentsToViewport\fR ( const QPoint & p ) const"
.br
.ti -1c
.BI "QPoint \fBviewportToContents\fR ( const QPoint & vp ) const"
.br
.ti -1c
.BI "void \fBenableClipper\fR ( bool y )"
.br
.ti -1c
.BI "void \fBsetStaticBackground\fR ( bool y )"
.br
.ti -1c
.BI "bool \fBhasStaticBackground\fR () const"
.br
.ti -1c
.BI "QSize \fBviewportSize\fR ( int x, int y ) const"
.br
.ti -1c
.BI "bool \fBisHorizontalSliderPressed\fR ()"
.br
.ti -1c
.BI "bool \fBisVerticalSliderPressed\fR ()"
.br
.ti -1c
.BI "virtual void \fBsetDragAutoScroll\fR ( bool b )"
.br
.ti -1c
.BI "bool \fBdragAutoScroll\fR () const"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBresizeContents\fR ( int w, int h )"
.br
.ti -1c
.BI "void \fBscrollBy\fR ( int dx, int dy )"
.br
.ti -1c
.BI "virtual void \fBsetContentsPos\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBensureVisible\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBensureVisible\fR ( int x, int y, int xmargin, int ymargin )"
.br
.ti -1c
.BI "void \fBcenter\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBcenter\fR ( int x, int y, float xmargin, float ymargin )"
.br
.ti -1c
.BI "void \fBupdateScrollBars\fR ()"
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBcontentsMoving\fR ( int x, int y )"
.br
.ti -1c
.BI "void \fBhorizontalSliderPressed\fR ()"
.br
.ti -1c
.BI "void \fBhorizontalSliderReleased\fR ()"
.br
.ti -1c
.BI "void \fBverticalSliderPressed\fR ()"
.br
.ti -1c
.BI "void \fBverticalSliderReleased\fR ()"
.br
.in -1c
.SS "Properties"
.in +1c
.ti -1c
.BI "int \fBcontentsHeight\fR - the height of the contents area  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBcontentsWidth\fR - the width of the contents area  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBcontentsX\fR - the X coordinate of the contents that are at the left edge of the viewport  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBcontentsY\fR - the Y coordinate of the contents that are at the top edge of the viewport  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "bool \fBdragAutoScroll\fR - whether autoscrolling in drag move events is enabled"
.br
.ti -1c
.BI "ScrollBarMode \fBhScrollBarMode\fR - the mode for the horizontal scroll bar"
.br
.ti -1c
.BI "ResizePolicy \fBresizePolicy\fR - the resize policy"
.br
.ti -1c
.BI "ScrollBarMode \fBvScrollBarMode\fR - the mode for the vertical scroll bar"
.br
.ti -1c
.BI "int \fBvisibleHeight\fR - the vertical amount of the content that is visible  \fI(read " "only" ")\fR"
.br
.ti -1c
.BI "int \fBvisibleWidth\fR - the horizontal amount of the content that is visible  \fI(read " "only" ")\fR"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual void \fBdrawContents\fR ( QPainter * p, int clipx, int clipy, int clipw, int cliph )"
.br
.ti -1c
.BI "virtual void \fBdrawContentsOffset\fR ( QPainter * p, int offsetx, int offsety, int clipx, int clipy, int clipw, int cliph )"
.br
.ti -1c
.BI "virtual void \fBcontentsMousePressEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsMouseReleaseEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsMouseDoubleClickEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsMouseMoveEvent\fR ( QMouseEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragEnterEvent\fR ( QDragEnterEvent * )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragMoveEvent\fR ( QDragMoveEvent * )"
.br
.ti -1c
.BI "virtual void \fBcontentsDragLeaveEvent\fR ( QDragLeaveEvent * )"
.br
.ti -1c
.BI "virtual void \fBcontentsDropEvent\fR ( QDropEvent * )"
.br
.ti -1c
.BI "virtual void \fBcontentsWheelEvent\fR ( QWheelEvent * e )"
.br
.ti -1c
.BI "virtual void \fBcontentsContextMenuEvent\fR ( QContextMenuEvent * e )"
.br
.ti -1c
.BI "virtual void \fBviewportPaintEvent\fR ( QPaintEvent * pe )"
.br
.ti -1c
.BI "virtual void \fBviewportResizeEvent\fR ( QResizeEvent * )"
.br
.ti -1c
.BI "virtual void \fBsetMargins\fR ( int left, int top, int right, int bottom )"
.br
.ti -1c
.BI "int \fBleftMargin\fR () const"
.br
.ti -1c
.BI "int \fBtopMargin\fR () const"
.br
.ti -1c
.BI "int \fBrightMargin\fR () const"
.br
.ti -1c
.BI "int \fBbottomMargin\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetHBarGeometry\fR ( QScrollBar & hbar, int x, int y, int w, int h )"
.br
.ti -1c
.BI "virtual void \fBsetVBarGeometry\fR ( QScrollBar & vbar, int x, int y, int w, int h )"
.br
.ti -1c
.BI "virtual bool \fBeventFilter\fR ( QObject * obj, QEvent * e )"
.br
.in -1c
.SH DESCRIPTION
The QScrollView widget provides a scrolling area with on-demand scroll bars.
.PP
The QScrollView is a large canvas - potentially larger than the coordinate system normally supported by the underlying window system. This is important because it is quite easy to go beyond these limitations (e.g. many web pages are more than 32000 pixels high). Additionally, the QScrollView can have QWidgets positioned on it that scroll around with the drawn content. These sub-widgets can also have positions outside the normal coordinate range (but they are still limited in size).
.PP
To provide content for the widget, inherit from QScrollView, reimplement drawContents() and use resizeContents() to set the size of the viewed area. Use addChild() and moveChild() to position widgets on the view.
.PP
To use QScrollView effectively it is important to understand its widget structure in the three styles of use: a single large child widget, a large panning area with some widgets and a large panning area with many widgets.
.SH "Using One Big Widget"
<center>
.ce 1
.B "[Image Omitted]"
.PP
</center>
.PP
The first, simplest usage of QScrollView (depicted above), is appropriate for scrolling areas that are never more than about 4000 pixels in either dimension (this is about the maximum reliable size on X11 servers). In this usage, you just make one large child in the QScrollView. The child should be a child of the viewport() of the scrollview and be added with addChild():
.PP
.nf
.br
        QScrollView* sv = new QScrollView(...);
.br
        QVBox* big_box = new QVBox(sv->viewport());
.br
        sv->addChild(big_box);
.br
.fi
You can go on to add arbitrary child widgets to the single child in the scrollview as you would with any widget:
.PP
.nf
.br
        QLabel* child1 = new QLabel("CHILD", big_box);
.br
        QLabel* child2 = new QLabel("CHILD", big_box);
.br
        QLabel* child3 = new QLabel("CHILD", big_box);
.br
        ...
.br
.fi
.PP
Here the QScrollView has four children: the viewport(), the verticalScrollBar(), the horizontalScrollBar() and a small cornerWidget(). The viewport() has one child: the big QVBox. The QVBox has the three QLabel objects as child widgets. When the view is scrolled, the QVBox is moved; its children move with it as child widgets normally do.
.SH "Using a Very Big View with Some Widgets"
<center>
.ce 1
.B "[Image Omitted]"
.PP
</center>
.PP
The second usage of QScrollView (depicted above) is appropriate when few, if any, widgets are on a very large scrolling area that is potentially larger than 4000 pixels in either dimension. In this usage you call resizeContents() to set the size of the area and reimplement drawContents() to paint the contents. You may also add some widgets by making them children of the viewport() and adding them with addChild() (this is the same as the process for the single large widget in the previous example):
.PP
.nf
.br
        QScrollView* sv = new QScrollView(...);
.br
        QLabel* child1 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child1);
.br
        QLabel* child2 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child2);
.br
        QLabel* child3 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child3);
.br
.fi
Here, the QScrollView has the same four children: the viewport(), the verticalScrollBar(), the horizontalScrollBar() and a small cornerWidget(). The viewport() has the three QLabel objects as child widgets. When the view is scrolled, the scrollview moves the child widgets individually.
.SH "Using a Very Big View with Many Widgets"
<center>
.ce 1
.B "[Image Omitted]"
.PP
</center>
.PP
The final usage of QScrollView (depicted above) is appropriate when many widgets are on a very large scrolling area that is potentially larger than 4000 pixels in either dimension. In this usage you call resizeContents() to set the size of the area and reimplement drawContents() to paint the contents. You then call enableClipper(TRUE) and add widgets, again by making them children of the viewport(), and adding them with addChild():
.PP
.nf
.br
        QScrollView* sv = new QScrollView(...);
.br
        sv->enableClipper(TRUE);
.br
        QLabel* child1 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child1);
.br
        QLabel* child2 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child2);
.br
        QLabel* child3 = new QLabel("CHILD", sv->viewport());
.br
        sv->addChild(child3);
.br
.fi
.PP
Here, the QScrollView has four children: the clipper() (not the viewport() this time), the verticalScrollBar(), the horizontalScrollBar() and a small cornerWidget(). The clipper() has one child: the viewport(). The viewport() has the same three labels as child widgets. When the view is scrolled the viewport() is moved; its children move with it as child widgets normally do.
.SH "Details Relevant for All Views"
Normally you will use the first or third method if you want any child widgets in the view.
.PP
Note that the widget you see in the scrolled area is the viewport() widget, not the QScrollView itself. So to turn mouse tracking on, for example, use viewport()->setMouseTracking(TRUE).
.PP
To enable drag-and-drop, you would setAcceptDrops(TRUE) on the QScrollView (because drag-and-drop events propagate to the parent). But to work out the logical position in the view, you would need to map the drop co-ordinate from being relative to the QScrollView to being relative to the contents; use the function viewportToContents() for this.
.PP
To handle mouse events on the scrolling area, subclass scrollview as you would subclass other widgets, but rather than reimplementing mousePressEvent(), reimplement contentsMousePressEvent() instead. The contents specific event handlers provide translated events in the coordinate system of the scrollview. If you reimplement mousePressEvent(), you'll get called only when part of the QScrollView is clicked: and the only such part is the "corner" (if you don't set a cornerWidget()) and the frame; everything else is covered up by the viewport, clipper or scroll bars.
.PP
When you construct a QScrollView, some of the widget flags apply to the viewport() instead of being sent to the QWidget constructor for the QScrollView. This applies to WNoAutoErase, WStaticContents, and WPaintClever. See Qt::WidgetFlags for documentation about these flags. Here are some examples:
.IP
.TP
An image-manipulation widget would use \fCWNoAutoErase|WStaticContents\fR because the widget draws all pixels itself, and when its size increases, it only needs a paint event for the new part because the old part remains unchanged.
.IP
.TP
A scrolling game widget in which the background scrolls as the characters move might use WNoAutoErase (in addition to WStaticContents) so that the window system background does not flash in and out during scrolling.
.IP
.TP
A word processing widget might use WNoAutoErase and repaint itself line by line to get a less-flickery resizing. If the widget is in a mode in which no text justification can take place, it might use WStaticContents too, so that it would only get a repaint for the newly visible parts.
.IP
.PP
Child widgets may be moved using addChild() or moveChild(). Use childX() and childY() to get the position of a child widget.
.PP
A widget may be placed in the corner between the vertical and horizontal scrollbars with setCornerWidget(). You can get access to the scrollbars using horizontalScrollBar() and verticalScrollBar(), and to the viewport with viewport(). The scroll view can be scrolled using scrollBy(), ensureVisible(), setContentsPos() or center().
.PP
The visible area is given by visibleWidth() and visibleHeight(), and the contents area by contentsWidth() and contentsHeight(). The contents may be repainted using one of the repaintContents() or updateContents() functions.
.PP
Coordinate conversion is provided by contentsToViewport() and viewportToContents().
.PP
The contentsMoving() signal is emitted just before the contents are moved to a new position.
.PP
\fBWarning:\fR QScrollView currently does not erase the background when resized, i.e. you must always clear the background manually in scrollview subclasses. This will change in a future version of Qt and we recommend specifying the WNoAutoErase flag explicitly.
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
See also Abstract Widget Classes.
.SS "Member Type Documentation"
.SH "QScrollView::ResizePolicy"
This enum type is used to control a QScrollView's reaction to resize events.
.TP
\fCQScrollView::Default\fR - the QScrollView selects one of the other settings automatically when it has to. In this version of Qt, QScrollView changes to Manual if you resize the contents with resizeContents() and to AutoOne if a child is added.
.TP
\fCQScrollView::Manual\fR - the contents stays the size set by resizeContents().
.TP
\fCQScrollView::AutoOne\fR - if there is only one child widget the contents stays the size of that widget. Otherwise the behavior is undefined.
.TP
\fCQScrollView::AutoOneFit\fR - if there is only one child widget the contents stays the size of that widget's sizeHint(). If the scrollview is resized larger than the child's sizeHint(), the child will be resized to fit. If there is more than one child, the behavior is undefined.
.SH "QScrollView::ScrollBarMode"
This enum type describes the various modes of QScrollView's scroll bars.
.TP
\fCQScrollView::Auto\fR - QScrollView shows a scroll bar when the content is too large to fit and not otherwise. This is the default.
.TP
\fCQScrollView::AlwaysOff\fR - QScrollView never shows a scroll bar.
.TP
\fCQScrollView::AlwaysOn\fR - QScrollView always shows a scroll bar.
.PP
(The modes for the horizontal and vertical scroll bars are independent.)
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QScrollView::QScrollView ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )"
Constructs a QScrollView called \fIname\fR with parent \fIparent\fR and widget flags \fIf\fR.
.PP
The widget flags WStaticContents, WNoAutoErase and WPaintClever are propagated to the viewport() widget. The other widget flags are propagated to the parent constructor as usual.
.SH "QScrollView::~QScrollView ()"
Destroys the QScrollView. Any children added with addChild() will be deleted.
.SH "void QScrollView::addChild ( QWidget * child, int x = 0, int y = 0 )\fC [virtual]\fR"
Inserts the widget, \fIchild\fR, into the scrolled area positioned at (\fIx\fR, \fIy\fR). The position defaults to (0, 0). If the child is already in the view, it is just moved.
.PP
You may want to call enableClipper(TRUE) if you add a large number of widgets.
.PP
Example: scrollview/scrollview.cpp.
.SH "int QScrollView::bottomMargin () const\fC [protected]\fR"
Returns the bottom margin.
.PP
See also setMargins().
.SH "void QScrollView::center ( int x, int y )\fC [slot]\fR"
Scrolls the content so that the point \fI(x, y)\fR is in the center of visible area.
.PP
Example: scrollview/scrollview.cpp.
.SH "void QScrollView::center ( int x, int y, float xmargin, float ymargin )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Scrolls the content so that the point \fI(x, y)\fR is visible with the \fIxmargin\fR and \fIymargin\fR margins (as fractions of visible the area).
.PP
For example:
.TP
Margin 0.0 allows (x, y) to be on the edge of the visible area.
.TP
Margin 0.5 ensures that (x, y) is in middle 50% of the visible area.
.TP
Margin 1.0 ensures that (x, y) is in the center of the the visible area.
.SH "bool QScrollView::childIsVisible ( QWidget * child )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Returns TRUE if \fIchild\fR is visible. This is equivalent to child->isVisible().
.SH "int QScrollView::childX ( QWidget * child )"
Returns the X position of the given \fIchild\fR widget. Use this rather than QWidget::x() for widgets added to the view.
.PP
This function returns 0 if \fIchild\fR has not been added to the view.
.SH "int QScrollView::childY ( QWidget * child )"
Returns the Y position of the given \fIchild\fR widget. Use this rather than QWidget::y() for widgets added to the view.
.PP
This function returns 0 if \fIchild\fR has not been added to the view.
.SH "QWidget * QScrollView::clipper () const"
Returns the clipper widget. Contents in the scrollview are ultimately clipped to be inside the clipper widget.
.PP
You should not need to use this function.
.PP
See also visibleWidth and visibleHeight.
.SH "void QScrollView::contentsContextMenuEvent ( QContextMenuEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a contextMenuEvent() in \fIe\fR: the mouse position is translated to be a point on the contents.
.PP
Example: chart/canvasview.cpp.
.SH "void QScrollView::contentsDragEnterEvent ( QDragEnterEvent * )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragEnterEvent(): the drag position is translated to be a point on the contents.
.PP
Reimplemented in QTable.
.SH "void QScrollView::contentsDragLeaveEvent ( QDragLeaveEvent * )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragLeaveEvent(): the drag position is translated to be a point on the contents.
.PP
Reimplemented in QTable.
.SH "void QScrollView::contentsDragMoveEvent ( QDragMoveEvent * )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragMoveEvent(): the drag position is translated to be a point on the contents.
.PP
Reimplemented in QTable.
.SH "void QScrollView::contentsDropEvent ( QDropEvent * )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dropEvent(): the drop position is translated to be a point on the contents.
.PP
Reimplemented in QTable.
.SH "int QScrollView::contentsHeight () const"
Returns the height of the contents area. See the "contentsHeight" property for details.
.SH "void QScrollView::contentsMouseDoubleClickEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseDoubleClickEvent(): the click position in \fIe\fR is translated to be a point on the contents.
.PP
The default implementation generates a normal mouse press event.
.PP
Reimplemented in QListView.
.SH "void QScrollView::contentsMouseMoveEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseMoveEvent(): the mouse position in \fIe\fR is translated to be a point on the contents.
.PP
Examples:
.)l canvas/canvas.cpp and chart/canvasview.cpp.
.PP
Reimplemented in QListView.
.SH "void QScrollView::contentsMousePressEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mousePressEvent(): the press position in \fIe\fR is translated to be a point on the contents.
.PP
Examples:
.)l canvas/canvas.cpp and chart/canvasview.cpp.
.PP
Reimplemented in QListView.
.SH "void QScrollView::contentsMouseReleaseEvent ( QMouseEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseReleaseEvent(): the release position in \fIe\fR is translated to be a point on the contents.
.PP
Reimplemented in QListView.
.SH "void QScrollView::contentsMoving ( int x, int y )\fC [signal]\fR"
This signal is emitted just before the contents are moved to position \fI(x, y)\fR.
.PP
See also contentsX and contentsY.
.SH "void QScrollView::contentsToViewport ( int x, int y, int & vx, int & vy ) const"
Translates a point (\fIx\fR, \fIy\fR) in the contents to a point (\fIvx\fR, \fIvy\fR) on the viewport() widget.
.SH "QPoint QScrollView::contentsToViewport ( const QPoint & p ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point \fIp\fR translated to a point on the viewport() widget.
.SH "void QScrollView::contentsWheelEvent ( QWheelEvent * e )\fC [virtual protected]\fR"
This event handler is called whenever the QScrollView receives a wheelEvent() in \fIe\fR: the mouse position is translated to be a point on the contents.
.SH "int QScrollView::contentsWidth () const"
Returns the width of the contents area. See the "contentsWidth" property for details.
.SH "int QScrollView::contentsX () const"
Returns the X coordinate of the contents that are at the left edge of the viewport. See the "contentsX" property for details.
.SH "int QScrollView::contentsY () const"
Returns the Y coordinate of the contents that are at the top edge of the viewport. See the "contentsY" property for details.
.SH "QWidget * QScrollView::cornerWidget () const"
Returns the widget in the corner between the two scroll bars.
.PP
By default, no corner widget is present.
.PP
Example: scrollview/scrollview.cpp.
.SH "bool QScrollView::dragAutoScroll () const"
Returns TRUE if autoscrolling in drag move events is enabled; otherwise returns FALSE. See the "dragAutoScroll" property for details.
.SH "void QScrollView::drawContents ( QPainter * p, int clipx, int clipy, int clipw, int cliph )\fC [virtual protected]\fR"
Reimplement this function if you are viewing a drawing area rather than a widget.
.PP
The function should draw the rectangle (\fIclipx\fR, \fIclipy\fR, \fIclipw\fR, \fIcliph\fR) of the contents using painter \fIp\fR. The clip rectangle is in the scrollview's coordinates.
.PP
For example:
.PP
.nf
.br
    {
.br
        // Fill a 40000 by 50000 rectangle at (100000,150000)
.br
.br
        // Calculate the coordinates...
.br
        int x1 = 100000, y1 = 150000;
.br
        int x2 = x1+40000-1, y2 = y1+50000-1;
.br
.br
        // Clip the coordinates so X/Windows will not have problems...
.br
        if (x1 < clipx) x1=clipx;
.br
        if (y1 < clipy) y1=clipy;
.br
        if (x2 > clipx+clipw-1) x2=clipx+clipw-1;
.br
        if (y2 > clipy+cliph-1) y2=clipy+cliph-1;
.br
.br
        // Paint using the small coordinates...
.br
        if ( x2 >= x1 && y2 >= y1 )
.br
            p->fillRect(x1, y1, x2-x1+1, y2-y1+1, red);
.br
    }
.br
.fi
.PP
The clip rectangle and translation of the painter \fIp\fR is already set appropriately.
.PP
Example: qdir/qdir.cpp.
.PP
Reimplemented in QCanvasView and QTable.
.SH "void QScrollView::drawContentsOffset ( QPainter * p, int offsetx, int offsety, int clipx, int clipy, int clipw, int cliph )\fC [virtual protected]\fR"
For backward-compatibility only. It is easier to use drawContents(QPainter*,int,int,int,int).
.PP
The default implementation translates the painter appropriately and calls drawContents(QPainter*,int,int,int,int). See drawContents() for an explanation of the parameters \fIp\fR, \fIoffsetx\fR, \fIoffsety\fR, \fIclipx\fR, \fIclipy\fR, \fIclipw\fR and \fIcliph\fR.
.PP
Reimplemented in QListView.
.SH "void QScrollView::enableClipper ( bool y )"
When a large numbers of child widgets are in a scrollview, especially if they are close together, the scrolling performance can suffer greatly. If \fIy\fR is TRUE the scrollview will use an extra widget to group child widgets.
.PP
Note that you may only call enableClipper() prior to adding widgets.
.PP
For a full discussion, see this class's detailed description.
.PP
Example: scrollview/scrollview.cpp.
.SH "void QScrollView::ensureVisible ( int x, int y )\fC [slot]\fR"
Scrolls the content so that the point \fI(x, y)\fR is visible with at least 50-pixel margins (if possible, otherwise centered).
.SH "void QScrollView::ensureVisible ( int x, int y, int xmargin, int ymargin )\fC [slot]\fR"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Scrolls the content so that the point \fI(x, y)\fR is visible with at least the \fIxmargin\fR and \fIymargin\fR margins (if possible, otherwise centered).
.SH "bool QScrollView::eventFilter ( QObject * obj, QEvent * e )\fC [virtual protected]\fR"
This event filter ensures the scroll bars are updated when a single contents widget is resized, shown, hidden or destroyed; it passes mouse events to the QScrollView. The event is in \fIe\fR and the object is in \fIobj\fR.
.PP
Reimplemented from QObject.
.PP
Reimplemented in QListView.
.SH "ScrollBarMode QScrollView::hScrollBarMode () const"
Returns the mode for the horizontal scroll bar. See the "hScrollBarMode" property for details.
.SH "bool QScrollView::hasStaticBackground () const"
Returns TRUE if QScrollView uses a static background; otherwise returns FALSE.
.PP
See also setStaticBackground().
.SH "QScrollBar * QScrollView::horizontalScrollBar () const"
Returns the component horizontal scroll bar. It is made available to allow accelerators, autoscrolling, etc.
.PP
It should not be used for other purposes.
.PP
This function never returns 0.
.SH "void QScrollView::horizontalSliderPressed ()\fC [signal]\fR"
This signal is emitted whenever the user presses the horizontal slider.
.SH "void QScrollView::horizontalSliderReleased ()\fC [signal]\fR"
This signal is emitted whenever the user releases the horizontal slider.
.SH "bool QScrollView::isHorizontalSliderPressed ()"
Returns TRUE if horizontal slider is pressed by user; otherwise returns FALSE.
.SH "bool QScrollView::isVerticalSliderPressed ()"
Returns TRUE if vertical slider is pressed by user; otherwise returns FALSE.
.SH "int QScrollView::leftMargin () const\fC [protected]\fR"
Returns the left margin.
.PP
See also setMargins().
.SH "void QScrollView::moveChild ( QWidget * child, int x, int y )\fC [virtual]\fR"
Repositions the \fIchild\fR widget to (\fIx\fR, \fIy\fR). This function is the same as addChild().
.SH "void QScrollView::removeChild ( QWidget * child )"
Removes the \fIchild\fR widget from the scrolled area. Note that this happens automatically if the \fIchild\fR is deleted.
.SH "void QScrollView::repaintContents ( int x, int y, int w, int h, bool erase = TRUE )"
Calls repaint() on a rectangle defined by \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR, translated appropriately. If the rectangle is not visible, nothing is repainted. If \fIerase\fR is TRUE the background is cleared using the background color.
.PP
See also updateContents().
.SH "void QScrollView::repaintContents ( const QRect & r, bool erase = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Repaints the contents of rectangle \fIr\fR. If \fIerase\fR is TRUE the background is cleared using the background color.
.SH "void QScrollView::repaintContents ( bool erase = TRUE )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Repaints the contents. If \fIerase\fR is TRUE the background is cleared using the background color.
.SH "void QScrollView::resizeContents ( int w, int h )\fC [virtual slot]\fR"
Sets the size of the contents area to \fIw\fR pixels wide and \fIh\fR pixels high and updates the viewport accordingly.
.SH "ResizePolicy QScrollView::resizePolicy () const"
Returns the resize policy. See the "resizePolicy" property for details.
.SH "int QScrollView::rightMargin () const\fC [protected]\fR"
Returns the right margin.
.PP
See also setMargins().
.SH "void QScrollView::scrollBy ( int dx, int dy )\fC [slot]\fR"
Scrolls the content by \fIdx\fR to the left and \fIdy\fR upwards.
.SH "void QScrollView::setContentsPos ( int x, int y )\fC [virtual slot]\fR"
Scrolls the content so that the point \fI(x, y)\fR is in the top-left corner.
.PP
Example: process/process.cpp.
.SH "void QScrollView::setCornerWidget ( QWidget * corner )\fC [virtual]\fR"
Sets the widget in the \fIcorner\fR between the two scroll bars.
.PP
You will probably also want to set at least one of the scroll bar modes to AlwaysOn.
.PP
Passing 0 shows no widget in the corner.
.PP
Any previous \fIcorner\fR widget is hidden.
.PP
You may call setCornerWidget() with the same widget at different times.
.PP
All widgets set here will be deleted by the QScrollView when it is destroyed unless you separately reparent the widget after setting some other corner widget (or 0).
.PP
Any \fInewly\fR set widget should have no current parent.
.PP
By default, no corner widget is present.
.PP
See also vScrollBarMode and hScrollBarMode.
.PP
Example: scrollview/scrollview.cpp.
.SH "void QScrollView::setDragAutoScroll ( bool b )\fC [virtual]\fR"
Sets whether autoscrolling in drag move events is enabled to \fIb\fR. See the "dragAutoScroll" property for details.
.SH "void QScrollView::setHBarGeometry ( QScrollBar & hbar, int x, int y, int w, int h )\fC [virtual protected]\fR"
Called when the horizontal scroll bar geometry changes. This is provided as a protected function so that subclasses can do interesting things such as providing extra buttons in some of the space normally used by the scroll bars.
.PP
The default implementation simply gives all the space to \fIhbar\fR. The new geometry is given by \fIx\fR, \fIy\fR, \fIw\fR and \fIh\fR.
.PP
See also setVBarGeometry().
.SH "void QScrollView::setHScrollBarMode ( ScrollBarMode )\fC [virtual]\fR"
Sets the mode for the horizontal scroll bar. See the "hScrollBarMode" property for details.
.SH "void QScrollView::setMargins ( int left, int top, int right, int bottom )\fC [virtual protected]\fR"
Sets the margins around the scrolling area to \fIleft\fR, \fItop\fR, \fIright\fR and \fIbottom\fR. This is useful for applications such as spreadsheets with "locked" rows and columns. The marginal space is \fIinside\fR the frameRect() and is left blank; reimplement drawFrame() or put widgets in the unused area.
.PP
By default all margins are zero.
.PP
See also frameChanged().
.SH "void QScrollView::setResizePolicy ( ResizePolicy )\fC [virtual]\fR"
Sets the resize policy. See the "resizePolicy" property for details.
.SH "void QScrollView::setStaticBackground ( bool y )"
Sets the scrollview to have a static background if \fIy\fR is TRUE, or a scrolling background if \fIy\fR is FALSE. By default, the background is scrolling.
.PP
Be aware that this mode is quite slow, as a full repaint of the visible area has to be triggered on every contents move.
.PP
See also hasStaticBackground().
.SH "void QScrollView::setVBarGeometry ( QScrollBar & vbar, int x, int y, int w, int h )\fC [virtual protected]\fR"
Called when the vertical scroll bar geometry changes. This is provided as a protected function so that subclasses can do interesting things such as providing extra buttons in some of the space normally used by the scroll bars.
.PP
The default implementation simply gives all the space to \fIvbar\fR. The new geometry is given by \fIx\fR, \fIy\fR, \fIw\fR and \fIh\fR.
.PP
See also setHBarGeometry().
.SH "void QScrollView::setVScrollBarMode ( ScrollBarMode )\fC [virtual]\fR"
Sets the mode for the vertical scroll bar. See the "vScrollBarMode" property for details.
.SH "void QScrollView::showChild ( QWidget * child, bool y = TRUE )"
\fBThis function is obsolete.\fR It is provided to keep old source working. We strongly advise against using it in new code.
.PP
Sets the visibility of \fIchild\fR. Equivalent to QWidget::show() or QWidget::hide().
.SH "int QScrollView::topMargin () const\fC [protected]\fR"
Returns the top margin.
.PP
See also setMargins().
.SH "void QScrollView::updateContents ( int x, int y, int w, int h )"
Calls update() on a rectangle defined by \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR, translated appropriately. If the rectangle is not visible, nothing is repainted.
.PP
See also repaintContents().
.SH "void QScrollView::updateContents ( const QRect & r )"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Updates the contents in rectangle \fIr\fR
.SH "void QScrollView::updateContents ()"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.SH "void QScrollView::updateScrollBars ()\fC [slot]\fR"
Updates scroll bars: all possibilities are considered. You should never need to call this in your code.
.SH "ScrollBarMode QScrollView::vScrollBarMode () const"
Returns the mode for the vertical scroll bar. See the "vScrollBarMode" property for details.
.SH "QScrollBar * QScrollView::verticalScrollBar () const"
Returns the component vertical scroll bar. It is made available to allow accelerators, autoscrolling, etc.
.PP
It should not be used for other purposes.
.PP
This function never returns 0.
.SH "void QScrollView::verticalSliderPressed ()\fC [signal]\fR"
This signal is emitted whenever the user presses the vertical slider.
.SH "void QScrollView::verticalSliderReleased ()\fC [signal]\fR"
This signal is emitted whenever the user releases the vertical slider.
.SH "QWidget * QScrollView::viewport () const"
Returns the viewport widget of the scrollview. This is the widget containing the contents widget or which is the drawing area.
.PP
Examples:
.)l helpsystem/tooltip.cpp and scrollview/scrollview.cpp.
.SH "void QScrollView::viewportPaintEvent ( QPaintEvent * pe )\fC [virtual protected]\fR"
This is a low-level painting routine that draws the viewport contents. Reimplement this if drawContents() is too high-level (for example, if you don't want to open a QPainter on the viewport). The paint event is passed in \fIpe\fR.
.SH "void QScrollView::viewportResizeEvent ( QResizeEvent * )\fC [virtual protected]\fR"
To provide simple processing of events on the contents, this function receives all resize events sent to the viewport.
.PP
See also QWidget::resizeEvent().
.PP
Example: chart/canvasview.cpp.
.SH "QSize QScrollView::viewportSize ( int x, int y ) const"
Returns the viewport size for size (\fIx\fR, \fIy\fR).
.PP
The viewport size depends on \fI(x, y)\fR (the size of the contents), the size of this widget and the modes of the horizontal and vertical scroll bars.
.PP
This function permits widgets that can trade vertical and horizontal space for each other to control scroll bar appearance better. For example, a word processor or web browser can control the width of the right margin accurately, whether or not there needs to be a vertical scroll bar.
.SH "void QScrollView::viewportToContents ( int vx, int vy, int & x, int & y ) const"
Translates a point (\fIvx\fR, \fIvy\fR) on the viewport() widget to a point (\fIx\fR, \fIy\fR) in the contents.
.SH "QPoint QScrollView::viewportToContents ( const QPoint & vp ) const"
This is an overloaded member function, provided for convenience. It behaves essentially like the above function.
.PP
Returns the point on the viewport \fIvp\fR translated to a point in the contents.
.SH "int QScrollView::visibleHeight () const"
Returns the vertical amount of the content that is visible. See the "visibleHeight" property for details.
.SH "int QScrollView::visibleWidth () const"
Returns the horizontal amount of the content that is visible. See the "visibleWidth" property for details.
.SS "Property Documentation"
.SH "int contentsHeight"
This property holds the height of the contents area.
.PP
Get this property's value with contentsHeight().
.SH "int contentsWidth"
This property holds the width of the contents area.
.PP
Get this property's value with contentsWidth().
.SH "int contentsX"
This property holds the X coordinate of the contents that are at the left edge of the viewport.
.PP
Get this property's value with contentsX().
.SH "int contentsY"
This property holds the Y coordinate of the contents that are at the top edge of the viewport.
.PP
Get this property's value with contentsY().
.SH "bool dragAutoScroll"
This property holds whether autoscrolling in drag move events is enabled.
.PP
If this property is set to TRUE (the default), the QScrollView automatically scrolls the contents in drag move events if the user moves the cursor close to a border of the view. Of course this works only if the viewport accepts drops. Specifying FALSE disables this autoscroll feature.
.PP
\fBWarning:\fR Enabling this property might not be enough to effectively turn on autoscrolling. If you put a custom widget in the QScrollView, you might need to call QDragEvent::ignore() on the event in the dragEnterEvent() and dragMoveEvent() reimplementations.
.PP
Set this property's value with setDragAutoScroll() and get this property's value with dragAutoScroll().
.SH "ScrollBarMode hScrollBarMode"
This property holds the mode for the horizontal scroll bar.
.PP
The default mode is QScrollView::Auto.
.PP
See also vScrollBarMode.
.PP
Set this property's value with setHScrollBarMode() and get this property's value with hScrollBarMode().
.SH "ResizePolicy resizePolicy"
This property holds the resize policy.
.PP
The default is Default.
.PP
See also ResizePolicy.
.PP
Set this property's value with setResizePolicy() and get this property's value with resizePolicy().
.SH "ScrollBarMode vScrollBarMode"
This property holds the mode for the vertical scroll bar.
.PP
The default mode is QScrollView::Auto.
.PP
See also hScrollBarMode.
.PP
Set this property's value with setVScrollBarMode() and get this property's value with vScrollBarMode().
.SH "int visibleHeight"
This property holds the vertical amount of the content that is visible.
.PP
Get this property's value with visibleHeight().
.SH "int visibleWidth"
This property holds the horizontal amount of the content that is visible.
.PP
Get this property's value with visibleWidth().

.SH "SEE ALSO"
.BR http://doc.trolltech.com/qscrollview.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2007 Trolltech ASA, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports help us to help you. Thank you.
.P
The definitive Qt documentation is provided in HTML format; it is
located at $QTDIR/doc/html and can be read using Qt Assistant or with
a web browser. This man page is provided as a convenience for those
users who prefer man pages, although this format is not officially
supported by Trolltech. 
.P
If you find errors in this manual page, please report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qscrollview.3qt) and the Qt
version (3.3.8).
